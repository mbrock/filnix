diff --git a/.bundle/gems/racc-1.7.3/ext/racc/cparse/cparse.c b/.bundle/gems/racc-1.7.3/ext/racc/cparse/cparse.c
index 7d9319be2234..3f64925d325d 100644
--- a/.bundle/gems/racc-1.7.3/ext/racc/cparse/cparse.c
+++ b/.bundle/gems/racc-1.7.3/ext/racc/cparse/cparse.c
@@ -645,7 +645,7 @@ parse_main(struct cparse_params *v, VALUE tok, VALUE val, int resume)
     /* shift/reduce error token */
     if (act > 0 && act < v->shift_n) {
         D_puts("e shift");
-        SHIFT(v, act, ERROR_TOKEN, val);
+        SHIFT(v, act, (VALUE)ERROR_TOKEN, val);
     }
     else if (act < 0 && act > -(v->reduce_n)) {
         D_puts("e reduce");
diff --git a/array.c b/array.c
index e1b855356849..274672131984 100644
--- a/array.c
+++ b/array.c
@@ -1854,10 +1854,10 @@ rb_ary_aref1(VALUE ary, VALUE arg)
         return rb_ary_entry(ary, FIX2LONG(arg));
     }
     /* check if idx is Range or ArithmeticSequence */
-    switch (rb_arithmetic_sequence_beg_len_step(arg, &beg, &len, &step, RARRAY_LEN(ary), 0)) {
-      case Qfalse:
+    switch ((uintptr_t)rb_arithmetic_sequence_beg_len_step(arg, &beg, &len, &step, RARRAY_LEN(ary), 0)) {
+      case (uintptr_t)Qfalse:
         break;
-      case Qnil:
+      case (uintptr_t)Qnil:
         return Qnil;
       default:
         return rb_ary_subseq_step(ary, beg, len, step);
@@ -4190,11 +4190,11 @@ rb_ary_slice_bang(int argc, VALUE *argv, VALUE ary)
     }
 
     if (!FIXNUM_P(arg1)) {
-        switch (rb_range_beg_len(arg1, &pos, &len, RARRAY_LEN(ary), 0)) {
-          case Qtrue:
+        switch ((uintptr_t)rb_range_beg_len(arg1, &pos, &len, RARRAY_LEN(ary), 0)) {
+          case (uintptr_t)Qtrue:
             /* valid range */
             return ary_slice_bang_by_rb_ary_splice(ary, pos, len);
-          case Qnil:
+          case (uintptr_t)Qnil:
             /* invalid range */
             return Qnil;
           default:
@@ -6613,7 +6613,7 @@ ary_sample(rb_execution_context_t *ec, VALUE ary, VALUE randgen, VALUE nv, VALUE
         RARRAY_PTR_USE(result, ptr_result, {
             for (i=0; i<n; i++) {
                 long r = RAND_UPTO(len-i) + i;
-                ptr_result[i] = r;
+                ptr_result[i] = (VALUE)r;
                 if (r > max_idx) max_idx = r;
             }
             len = RARRAY_LEN(ary);
@@ -6621,7 +6621,7 @@ ary_sample(rb_execution_context_t *ec, VALUE ary, VALUE randgen, VALUE nv, VALUE
             else if (n > len) n = len;
             RARRAY_PTR_USE(ary, ptr_ary, {
                 for (i=0; i<n; i++) {
-                    long j2 = j = ptr_result[i];
+                    long j2 = j = (long)ptr_result[i];
                     long i2 = i;
                     st_data_t value;
                     if (st_lookup(memo, (st_data_t)i, &value)) i2 = (long)value;
diff --git a/bignum.c b/bignum.c
index bc48697bf4ad..30c8750042ed 100644
--- a/bignum.c
+++ b/bignum.c
@@ -3216,11 +3216,11 @@ VALUE
 rb_int2big(intptr_t n)
 {
     long neg = 0;
-    VALUE u;
+    uintptr_t u;
     VALUE big;
 
     if (n < 0) {
-        u = 1 + (VALUE)(-(n + 1)); /* u = -n avoiding overflow */
+        u = 1 + (uintptr_t)(-(n + 1)); /* u = -n avoiding overflow */
         neg = 1;
     }
     else {
diff --git a/class.c b/class.c
index b2a219100cc8..c8eb7c2f9fb3 100644
--- a/class.c
+++ b/class.c
@@ -227,7 +227,7 @@ rb_class_detach_module_subclasses(VALUE klass)
  * \note this function is not Class#allocate.
  */
 static VALUE
-class_alloc(VALUE flags, VALUE klass)
+class_alloc(uintptr_t flags, VALUE klass)
 {
     size_t alloc_size = sizeof(struct RClass) + sizeof(rb_classext_t);
 
@@ -474,7 +474,7 @@ copy_tables(VALUE clone, VALUE orig)
     rb_id_table_free(RCLASS_M_TBL(clone));
     RCLASS_M_TBL(clone) = 0;
     if (!RB_TYPE_P(clone, T_ICLASS)) {
-        st_data_t id;
+        ID id;
 
         rb_iv_tbl_copy(clone, orig);
         CONST_ID(id, "__tmp_classpath__");
@@ -1784,7 +1784,7 @@ method_entry_i(ID key, VALUE value, void *data)
         if (!me) return ID_TABLE_CONTINUE;
         if (!arg->recur && me->owner != owner) return ID_TABLE_CONTINUE;
     }
-    if (!st_is_member(arg->list, key)) {
+    if (!st_is_member(arg->list, (st_data_t)key)) {
         if (UNDEFINED_METHOD_ENTRY_P(me)) {
             type = METHOD_VISI_UNDEF; /* none */
         }
@@ -1792,7 +1792,7 @@ method_entry_i(ID key, VALUE value, void *data)
             type = METHOD_ENTRY_VISI(me);
             RUBY_ASSERT(type != METHOD_VISI_UNDEF);
         }
-        st_add_direct(arg->list, key, (st_data_t)type);
+        st_add_direct(arg->list, (st_data_t)key, (st_data_t)type);
     }
     return ID_TABLE_CONTINUE;
 }
@@ -2188,10 +2188,10 @@ rb_undef_methods_from(VALUE klass, VALUE super)
 static inline VALUE
 special_singleton_class_of(VALUE obj)
 {
-    switch (obj) {
-      case Qnil:   return rb_cNilClass;
-      case Qfalse: return rb_cFalseClass;
-      case Qtrue:  return rb_cTrueClass;
+    switch ((uintptr_t)obj) {
+      case (uintptr_t)Qnil:   return rb_cNilClass;
+      case (uintptr_t)Qfalse: return rb_cFalseClass;
+      case (uintptr_t)Qtrue:  return rb_cTrueClass;
       default:     return Qnil;
     }
 }
diff --git a/compile.c b/compile.c
index 504afbc59224..63da697d8e21 100644
--- a/compile.c
+++ b/compile.c
@@ -40,6 +40,7 @@
 #include "vm_callinfo.h"
 #include "vm_debug.h"
 #include "yjit.h"
+#include <stdfil.h>
 
 #include "builtin.h"
 #include "insns.inc"
@@ -48,8 +49,8 @@
 #undef RUBY_UNTYPED_DATA_WARNING
 #define RUBY_UNTYPED_DATA_WARNING 0
 
-#define FIXNUM_INC(n, i) ((n)+(INT2FIX(i)&~FIXNUM_FLAG))
-#define FIXNUM_OR(n, i) ((n)|INT2FIX(i))
+#define FIXNUM_INC(n, i) ((VALUE)((n)+((uintptr_t)INT2FIX(i)&~FIXNUM_FLAG)))
+#define FIXNUM_OR(n, i) ((VALUE)((n)|(uintptr_t)INT2FIX(i)))
 
 typedef struct iseq_link_element {
     enum {
@@ -308,8 +309,8 @@ static void iseq_add_setlocal(rb_iseq_t *iseq, LINK_ANCHOR *const seq, const NOD
     ((label) ? (LABEL_REF(label), (label)->unremovable=1) : 0)
 #define ADD_CATCH_ENTRY(type, ls, le, iseqv, lc) do {				\
     VALUE _e = rb_ary_new3(5, (type),						\
-                           (VALUE)(ls) | 1, (VALUE)(le) | 1,			\
-                           (VALUE)(iseqv), (VALUE)(lc) | 1);			\
+                           zorptr((ls), 1), zorptr((le), 1),            \
+                           (VALUE)(iseqv), zorptr((lc), 1));           \
     LABEL_UNREMOVABLE(ls);							\
     LABEL_REF(le);								\
     LABEL_REF(lc);								\
@@ -622,7 +623,7 @@ decl_branch_base(rb_iseq_t *iseq, const NODE *node, const char *type)
      */
 
     VALUE structure = RARRAY_AREF(ISEQ_BRANCH_COVERAGE(iseq), 0);
-    VALUE key = (VALUE)node | 1; // FIXNUM for hash key
+    VALUE key = zorptr(node, 1); // FIXNUM for hash key
     VALUE branch_base = rb_hash_aref(structure, key);
     VALUE branches;
 
@@ -844,7 +845,7 @@ rb_iseq_compile_callback(rb_iseq_t *iseq, const struct rb_iseq_new_with_callback
     ADD_INSN(ret, &dummy_line_node, leave);
 
     CHECK(iseq_setup_insn(iseq, ret));
-    return iseq_setup(iseq, ret);
+    return (VALUE)iseq_setup(iseq, ret);
 }
 
 VALUE
@@ -964,7 +965,7 @@ rb_iseq_compile_node(rb_iseq_t *iseq, const NODE *node)
     }
 #endif
     CHECK(iseq_setup_insn(iseq, ret));
-    return iseq_setup(iseq, ret);
+    return (VALUE)iseq_setup(iseq, ret);
 }
 
 static VALUE rb_translate_prism(pm_parser_t *parser, rb_iseq_t *iseq, pm_scope_node_t *scope_node, LINK_ANCHOR *const ret);
@@ -978,7 +979,7 @@ rb_iseq_compile_prism_node(rb_iseq_t * iseq, pm_scope_node_t *scope_node, pm_par
     CHECK(rb_translate_prism(parser, iseq, scope_node, ret));
 
     CHECK(iseq_setup_insn(iseq, ret));
-    return iseq_setup(iseq, ret);
+    return (VALUE)iseq_setup(iseq, ret);
 }
 
 static int
@@ -1022,7 +1023,7 @@ rb_iseq_original_iseq(const rb_iseq_t *iseq) /* cold path */
             const void *addr = (const void *)original_code[i];
             const int insn = rb_vm_insn_addr2insn(addr);
 
-            original_code[i] = insn;
+            original_code[i] = (VALUE)insn;
             i += insn_len(insn);
         }
     }
@@ -1376,7 +1377,7 @@ new_adjust_body(rb_iseq_t *iseq, LABEL *label, int line)
 static void
 iseq_insn_each_markable_object(INSN *insn, void (*func)(VALUE, VALUE), VALUE data)
 {
-    const char *types = insn_op_types(insn->insn_id);
+    const char *types = insn_op_types((uintptr_t)insn->insn_id);
     for (int j = 0; types[j]; j++) {
         char type = types[j];
         switch (type) {
@@ -1578,11 +1579,11 @@ iseq_insert_nop_between_end_and_cont(rb_iseq_t *iseq)
     const VALUE *tptr = RARRAY_CONST_PTR(catch_table_ary);
     for (i = 0; i < tlen; i++) {
         const VALUE *ptr = RARRAY_CONST_PTR(tptr[i]);
-        LINK_ELEMENT *end = (LINK_ELEMENT *)(ptr[2] & ~1);
-        LINK_ELEMENT *cont = (LINK_ELEMENT *)(ptr[4] & ~1);
+        LINK_ELEMENT *end = (LINK_ELEMENT *)zandptr(ptr[2], ~1);
+        LINK_ELEMENT *cont = (LINK_ELEMENT *)zandptr(ptr[4], ~1);
         LINK_ELEMENT *e;
 
-        enum rb_catch_type ct = (enum rb_catch_type)(ptr[0] & 0xffff);
+        enum rb_catch_type ct = (enum rb_catch_type)((uintptr_t)ptr[0] & 0xffff);
 
         if (ct != CATCH_TYPE_BREAK
             && ct != CATCH_TYPE_NEXT
@@ -2012,7 +2013,7 @@ iseq_set_arguments(rb_iseq_t *iseq, LINK_ANCHOR *const optargs, const NODE *cons
 
             while (node) {
                 label = NEW_LABEL(nd_line(RNODE(node)));
-                rb_ary_push(labels, (VALUE)label | 1);
+                rb_ary_push(labels, zorptr(label, 1));
                 ADD_LABEL(optargs, label);
                 NO_CHECK(COMPILE_POPPED(optargs, "optarg", node->nd_body));
                 node = node->nd_next;
@@ -2021,14 +2022,14 @@ iseq_set_arguments(rb_iseq_t *iseq, LINK_ANCHOR *const optargs, const NODE *cons
 
             /* last label */
             label = NEW_LABEL(nd_line(node_args));
-            rb_ary_push(labels, (VALUE)label | 1);
+            rb_ary_push(labels, zorptr(label, 1));
             ADD_LABEL(optargs, label);
 
             opt_table = ALLOC_N(VALUE, i+1);
 
             MEMCPY(opt_table, RARRAY_CONST_PTR(labels), VALUE, i+1);
             for (j = 0; j < i+1; j++) {
-                opt_table[j] &= ~1;
+                opt_table[j] = zandptr(opt_table[j], ~1);
             }
             rb_ary_clear(labels);
 
@@ -2208,7 +2209,7 @@ static int
 cdhash_set_label_i(VALUE key, VALUE val, VALUE ptr)
 {
     struct cdhash_set_label_struct *data = (struct cdhash_set_label_struct *)ptr;
-    LABEL *lobj = (LABEL *)(val & ~1);
+    LABEL *lobj = (LABEL *)zandptr(val, ~1);
     rb_hash_aset(data->hash, key, INT2FIX(lobj->position - (data->pos+data->len)));
     return ST_CONTINUE;
 }
@@ -2556,7 +2557,7 @@ iseq_set_sequence(rb_iseq_t *iseq, LINK_ANCHOR *const anchor)
                 /* fprintf(stderr, "insn: %-16s, sp: %d\n", insn_name(iobj->insn_id), sp); */
                 operands = iobj->operands;
                 insn = iobj->insn_id;
-                generated_iseq[code_index] = insn;
+                generated_iseq[code_index] = (VALUE)insn;
                 types = insn_op_types(insn);
                 len = insn_len(insn);
 
@@ -2569,7 +2570,7 @@ iseq_set_sequence(rb_iseq_t *iseq, LINK_ANCHOR *const anchor)
                         {
                             /* label(destination position) */
                             LABEL *lobj = (LABEL *)operands[j];
-                            generated_iseq[code_index + 1 + j] = lobj->position - (code_index + len);
+                            generated_iseq[code_index + 1 + j] = (VALUE)(lobj->position - (code_index + len));
                             break;
                         }
                       case TS_CDHASH:
@@ -2591,7 +2592,7 @@ iseq_set_sequence(rb_iseq_t *iseq, LINK_ANCHOR *const anchor)
                         }
                       case TS_LINDEX:
                       case TS_NUM:	/* ulong */
-                        generated_iseq[code_index + 1 + j] = FIX2INT(operands[j]);
+                        generated_iseq[code_index + 1 + j] = (VALUE)FIX2INT(operands[j]);
                         break;
                       case TS_ISEQ:	/* iseq */
                       case TS_VALUE:	/* VALUE */
@@ -2664,7 +2665,7 @@ iseq_set_sequence(rb_iseq_t *iseq, LINK_ANCHOR *const anchor)
                             break;
                         }
                       case TS_ID: /* ID */
-                        generated_iseq[code_index + 1 + j] = SYM2ID(operands[j]);
+                        generated_iseq[code_index + 1 + j] = (VALUE)SYM2ID(operands[j]);
                         break;
                       case TS_FUNCPTR:
                         generated_iseq[code_index + 1 + j] = operands[j];
@@ -2715,11 +2716,11 @@ iseq_set_sequence(rb_iseq_t *iseq, LINK_ANCHOR *const anchor)
                         if (add_adjust_info(insns_info, positions, insns_info_index, code_index, adjust)) insns_info_index++;
                     }
                     if (diff > 1) {
-                        generated_iseq[code_index++] = BIN(adjuststack);
-                        generated_iseq[code_index++] = orig_sp - sp;
+                        generated_iseq[code_index++] = (VALUE)BIN(adjuststack);
+                        generated_iseq[code_index++] = (VALUE)(orig_sp - sp);
                     }
                     else if (diff == 1) {
-                        generated_iseq[code_index++] = BIN(pop);
+                        generated_iseq[code_index++] = (VALUE)BIN(pop);
                     }
                     else if (diff < 0) {
                         int label_no = adjust->label ? adjust->label->label_no : -1;
@@ -2808,15 +2809,15 @@ iseq_set_exception_table(rb_iseq_t *iseq)
         for (i = 0; i < table->size; i++) {
             ptr = RARRAY_CONST_PTR(tptr[i]);
             entry = UNALIGNED_MEMBER_PTR(table, entries[i]);
-            entry->type = (enum rb_catch_type)(ptr[0] & 0xffff);
-            entry->start = label_get_position((LABEL *)(ptr[1] & ~1));
-            entry->end = label_get_position((LABEL *)(ptr[2] & ~1));
+            entry->type = (enum rb_catch_type)((uintptr_t)ptr[0] & 0xffff);
+            entry->start = label_get_position((LABEL *)zandptr(ptr[1], ~1));
+            entry->end = label_get_position((LABEL *)zandptr(ptr[2], ~1));
             entry->iseq = (rb_iseq_t *)ptr[3];
             RB_OBJ_WRITTEN(iseq, Qundef, entry->iseq);
 
             /* stack depth */
             if (ptr[4]) {
-                LABEL *lobj = (LABEL *)(ptr[4] & ~1);
+                LABEL *lobj = (LABEL *)zandptr(ptr[4], ~1);
                 entry->cont = label_get_position(lobj);
                 entry->sp = label_get_sp(lobj);
 
@@ -2857,7 +2858,7 @@ iseq_set_optargs_table(rb_iseq_t *iseq)
 
     if (ISEQ_BODY(iseq)->param.flags.has_opt) {
         for (i = 0; i < ISEQ_BODY(iseq)->param.opt_num + 1; i++) {
-            opt_table[i] = label_get_position((LABEL *)opt_table[i]);
+            opt_table[i] = (VALUE)label_get_position((LABEL *)opt_table[i]);
         }
     }
     return COMPILE_OK;
@@ -2999,7 +3000,7 @@ remove_unreachable_chunk(rb_iseq_t *iseq, LINK_ELEMENT *i)
     do {
         if (IS_INSN(i)) {
             struct rb_iseq_constant_body *body = ISEQ_BODY(iseq);
-            VALUE insn = INSN_OF(i);
+            uintptr_t insn = INSN_OF(i);
             int pos, len = insn_len(insn);
             for (pos = 0; pos < len; ++pos) {
                 switch (insn_op_types(insn)[pos]) {
@@ -3020,11 +3021,11 @@ remove_unreachable_chunk(rb_iseq_t *iseq, LINK_ELEMENT *i)
 static int
 iseq_pop_newarray(rb_iseq_t *iseq, INSN *iobj)
 {
-    switch (OPERAND_AT(iobj, 0)) {
-      case INT2FIX(0): /* empty array */
+    switch ((uintptr_t)OPERAND_AT(iobj, 0)) {
+      case (uintptr_t)INT2FIX(0): /* empty array */
         ELEM_REMOVE(&iobj->link);
         return TRUE;
-      case INT2FIX(1): /* single element array */
+      case (uintptr_t)INT2FIX(1): /* single element array */
         ELEM_REMOVE(&iobj->link);
         return FALSE;
       default:
@@ -5074,7 +5075,7 @@ when_vals(rb_iseq_t *iseq, LINK_ANCHOR *const cond_seq, const NODE *vals,
             only_special_literals = 0;
         }
         else if (NIL_P(rb_hash_lookup(literals, lit))) {
-            rb_hash_aset(literals, lit, (VALUE)(l1) | 1);
+            rb_hash_aset(literals, lit, zorptr(l1, 1));
         }
 
         if (nd_type_p(val, NODE_STR)) {
@@ -5409,9 +5410,9 @@ compile_massign_opt(rb_iseq_t *iseq, LINK_ANCHOR *const ret,
     int i; \
     if (memindex == memsize) return 0; \
     for (i=0; i<memindex; i++) { \
-        if (mem[i] == (v)) return 0; \
+        if (mem[i] == (VALUE)(v)) return 0; \
     } \
-    mem[memindex++] = (v); \
+    mem[memindex++] = (VALUE)(v); \
 }
 
     if (rhsn == 0 || !nd_type_p(rhsn, NODE_LIST)) {
@@ -6146,7 +6147,7 @@ setup_args_core(rb_iseq_t *iseq, LINK_ANCHOR *const args, const NODE *argn,
         return argc;
       }
       default: {
-        UNKNOWN_NODE("setup_arg", argn, Qnil);
+        UNKNOWN_NODE("setup_arg", argn, 0);
       }
     }
 }
@@ -7682,7 +7683,7 @@ compile_loop(rb_iseq_t *iseq, LINK_ANCHOR *const ret, const NODE *const node, in
     ADD_LABEL(ret, end_label);
     ADD_ADJUST_RESTORE(ret, adjust_label);
 
-    if (UNDEF_P(RNODE_WHILE(node)->nd_state)) {
+    if (UNDEF_P((VALUE)RNODE_WHILE(node)->nd_state)) {
         /* ADD_INSN(ret, line_node, putundef); */
         COMPILE_ERROR(ERROR_ARGS "unsupported: putundef");
         return COMPILE_NG;
@@ -10642,7 +10643,7 @@ dump_disasm_list_with_cursor(const LINK_ELEMENT *link, const LINK_ELEMENT *curr,
             }
           default:
             /* ignore */
-            rb_raise(rb_eSyntaxError, "dump_disasm_list error: %ld\n", FIX2LONG(link->type));
+            rb_raise(rb_eSyntaxError, "dump_disasm_list error: %d\n", link->type);
         }
         link = link->next;
     }
@@ -10651,7 +10652,7 @@ dump_disasm_list_with_cursor(const LINK_ELEMENT *link, const LINK_ELEMENT *curr,
 }
 
 int
-rb_insn_len(VALUE insn)
+rb_insn_len(uintptr_t insn)
 {
     return insn_len(insn);
 }
@@ -10691,7 +10692,7 @@ register_label(rb_iseq_t *iseq, struct st_table *labels_table, VALUE obj)
     return label;
 }
 
-static VALUE
+static uintptr_t
 get_exception_sym2type(VALUE sym)
 {
     static VALUE symRescue, symEnsure, symRetry;
@@ -10724,7 +10725,8 @@ iseq_build_from_ary_exception(rb_iseq_t *iseq, struct st_table *labels_table,
 
     for (i=0; i<RARRAY_LEN(exception); i++) {
         const rb_iseq_t *eiseq;
-        VALUE v, type;
+        VALUE v;
+        uintptr_t type;
         LABEL *lstart, *lend, *lcont;
         unsigned int sp;
 
@@ -10769,7 +10771,7 @@ insn_make_insn_table(void)
     table = st_init_numtable_with_size(VM_INSTRUCTION_SIZE);
 
     for (i=0; i<VM_INSTRUCTION_SIZE; i++) {
-        st_insert(table, ID2SYM(rb_intern_const(insn_name(i))), i);
+        st_insert(table, ID2SYM(rb_intern_const(insn_name(i))), (st_data_t)i);
     }
 
     return table;
@@ -10900,12 +10902,12 @@ iseq_build_from_ary_body(rb_iseq_t *iseq, LINK_ANCHOR *const anchor,
             if (st_lookup(insn_table, (st_data_t)insn, &insn_id) == 0) {
                 /* TODO: exception */
                 COMPILE_ERROR(iseq, line_no,
-                              "unknown instruction: %+"PRIsVALUE, insn);
+                              "unknown instruction: %"PRIsVALUE, insn);
                 ret = COMPILE_NG;
                 break;
             }
 
-            if (argc != insn_len((VALUE)insn_id)-1) {
+            if (argc != insn_len((uintptr_t)insn_id)-1) {
                 COMPILE_ERROR(iseq, line_no,
                               "operand size mismatch");
                 ret = COMPILE_NG;
@@ -10923,7 +10925,7 @@ iseq_build_from_ary_body(rb_iseq_t *iseq, LINK_ANCHOR *const anchor,
 
                 for (j=0; j<argc; j++) {
                     VALUE op = rb_ary_entry(obj, j+1);
-                    switch (insn_op_type((VALUE)insn_id, j)) {
+                    switch (insn_op_type((uintptr_t)insn_id, j)) {
                       case TS_OFFSET: {
                         LABEL *label = register_label(iseq, labels_table, op);
                         argv[j] = (VALUE)label;
@@ -11003,7 +11005,7 @@ iseq_build_from_ary_body(rb_iseq_t *iseq, LINK_ANCHOR *const anchor,
                                 VALUE sym = RARRAY_AREF(op, i+1);
                                 LABEL *label =
                                   register_label(iseq, labels_table, sym);
-                                rb_hash_aset(map, key, (VALUE)label | 1);
+                                rb_hash_aset(map, key, zorptr(label, 1));
                             }
                             RB_GC_GUARD(op);
                             argv[j] = map;
@@ -11021,7 +11023,7 @@ iseq_build_from_ary_body(rb_iseq_t *iseq, LINK_ANCHOR *const anchor,
                         }
                         break;
                       default:
-                        rb_raise(rb_eSyntaxError, "unknown operand: %c", insn_op_type((VALUE)insn_id, j));
+                        rb_raise(rb_eSyntaxError, "unknown operand: %c", insn_op_type((uintptr_t)insn_id, j));
                     }
                 }
             }
@@ -11589,7 +11591,7 @@ ibf_dump_object_table_new(void)
 static VALUE
 ibf_dump_object(struct ibf_dump *dump, VALUE obj)
 {
-    return ibf_table_find_or_insert(dump->current_buffer->obj_table, (st_data_t)obj);
+    return (VALUE)ibf_table_find_or_insert(dump->current_buffer->obj_table, (st_data_t)obj);
 }
 
 static VALUE
@@ -11607,7 +11609,7 @@ ibf_load_id(const struct ibf_load *load, const ID id_index)
     if (id_index == 0) {
         return 0;
     }
-    VALUE sym = ibf_load_object(load, id_index);
+    VALUE sym = ibf_load_object(load, (VALUE)id_index);
     return rb_sym2id(sym);
 }
 
@@ -11644,10 +11646,10 @@ ibf_load_byte(const struct ibf_load *load, ibf_offset_t *offset)
  * 0x01000000_00000000 - 0xffffffff_ffffffff: 9byte | 0000 0000 | XXXX XXXX | XXXX XXXX | XXXX XXXX | XXXX XXXX | XXXX XXXX | XXXX XXXX | XXXX XXXX | XXXX XXXX |
  */
 static void
-ibf_dump_write_small_value(struct ibf_dump *dump, VALUE x)
+ibf_dump_write_small_value(struct ibf_dump *dump, VALUE x_value)
 {
     if (sizeof(VALUE) > 8 || CHAR_BIT != 8) {
-        ibf_dump_write(dump, &x, sizeof(VALUE));
+        ibf_dump_write(dump, &x_value, sizeof(VALUE));
         return;
     }
 
@@ -11656,6 +11658,8 @@ ibf_dump_write_small_value(struct ibf_dump *dump, VALUE x)
     unsigned char bytes[max_byte_length];
     ibf_offset_t n;
 
+    uintptr_t x = (uintptr_t)x_value;
+
     for (n = 0; n < sizeof(VALUE) && (x >> (7 - n)); n++, x >>= 8) {
         bytes[max_byte_length - 1 - n] = (unsigned char)x;
     }
@@ -11689,7 +11693,7 @@ ibf_load_small_value(const struct ibf_load *load, ibf_offset_t *offset)
     ibf_offset_t n =
         c & 1 ? 1 :
         c == 0 ? 9 : ntz_int32(c) + 1;
-    VALUE x = (VALUE)c >> n;
+    uintptr_t x = (uintptr_t)c >> n;
 
     if (*offset + n > load->current_buffer->size) {
         rb_raise(rb_eRuntimeError, "invalid byte sequence");
@@ -11698,11 +11702,11 @@ ibf_load_small_value(const struct ibf_load *load, ibf_offset_t *offset)
     ibf_offset_t i;
     for (i = 1; i < n; i++) {
         x <<= 8;
-        x |= (VALUE)buffer[*offset + i];
+        x |= (uintptr_t)buffer[*offset + i];
     }
 
     *offset += n;
-    return x;
+    return (VALUE)x;
 }
 
 static void
@@ -11752,11 +11756,11 @@ ibf_dump_code(struct ibf_dump *dump, const rb_iseq_t *iseq)
 
     for (code_index=0; code_index<iseq_size;) {
         const VALUE insn = orig_code[code_index++];
-        const char *types = insn_op_types(insn);
+        const char *types = insn_op_types((uintptr_t)insn);
         int op_index;
 
         /* opcode */
-        if (insn >= 0x100) { rb_raise(rb_eRuntimeError, "invalid instruction"); }
+        if (insn >= (VALUE)0x100) { rb_raise(rb_eRuntimeError, "invalid instruction"); }
         ibf_dump_write_small_value(dump, insn);
 
         /* operands */
@@ -11784,7 +11788,7 @@ ibf_dump_code(struct ibf_dump *dump, const rb_iseq_t *iseq)
               case TS_ICVARC:
                 {
                     union iseq_inline_storage_entry *is = (union iseq_inline_storage_entry *)op;
-                    wv = is - ISEQ_IS_ENTRY_START(body, types[op_index]);
+                    wv = (VALUE)(is - ISEQ_IS_ENTRY_START(body, types[op_index]));
                 }
                 break;
               case TS_CALLDATA:
@@ -11843,7 +11847,7 @@ ibf_load_code(const struct ibf_load *load, rb_iseq_t *iseq, ibf_offset_t bytecod
     for (code_index=0; code_index<iseq_size;) {
         /* opcode */
         const VALUE insn = code[code_index] = ibf_load_small_value(load, &reading_pos);
-        const char *types = insn_op_types(insn);
+        const char *types = insn_op_types((uintptr_t)insn);
         int op_index;
 
         code_index++;
@@ -11940,7 +11944,7 @@ ibf_load_code(const struct ibf_load *load, rb_iseq_t *iseq, ibf_offset_t bytecod
               case TS_ID:
                 {
                     VALUE op = ibf_load_small_value(load, &reading_pos);
-                    code[code_index] = ibf_load_id(load, (ID)(VALUE)op);
+                    code[code_index] = (VALUE)ibf_load_id(load, (ID)(VALUE)op);
                 }
                 break;
               case TS_FUNCPTR:
@@ -11954,7 +11958,7 @@ ibf_load_code(const struct ibf_load *load, rb_iseq_t *iseq, ibf_offset_t bytecod
                 continue;
             }
         }
-        if (insn_len(insn) != op_index+1) {
+        if (insn_len((uintptr_t)insn) != op_index+1) {
             rb_raise(rb_eRuntimeError, "operand size mismatch");
         }
     }
@@ -12065,11 +12069,11 @@ ibf_dump_insns_info_body(struct ibf_dump *dump, const rb_iseq_t *iseq)
 
     unsigned int i;
     for (i = 0; i < ISEQ_BODY(iseq)->insns_info.size; i++) {
-        ibf_dump_write_small_value(dump, entries[i].line_no);
+        ibf_dump_write_small_value(dump, (VALUE)entries[i].line_no);
 #ifdef USE_ISEQ_NODE_ID
-        ibf_dump_write_small_value(dump, entries[i].node_id);
+        ibf_dump_write_small_value(dump, (VALUE)entries[i].node_id);
 #endif
-        ibf_dump_write_small_value(dump, entries[i].events);
+        ibf_dump_write_small_value(dump, (VALUE)entries[i].events);
     }
 
     return offset;
@@ -12101,7 +12105,7 @@ ibf_dump_insns_info_positions(struct ibf_dump *dump, const unsigned int *positio
     unsigned int last = 0;
     unsigned int i;
     for (i = 0; i < size; i++) {
-        ibf_dump_write_small_value(dump, positions[i] - last);
+        ibf_dump_write_small_value(dump, (VALUE)(positions[i] - last));
         last = positions[i];
     }
 
@@ -12133,7 +12137,7 @@ ibf_dump_local_table(struct ibf_dump *dump, const rb_iseq_t *iseq)
     int i;
 
     for (i=0; i<size; i++) {
-        table[i] = ibf_dump_id(dump, body->local_table[i]);
+        table[i] = (ID)ibf_dump_id(dump, body->local_table[i]);
     }
 
     IBF_W_ALIGN(ID);
@@ -12173,12 +12177,12 @@ ibf_dump_catch_table(struct ibf_dump *dump, const rb_iseq_t *iseq)
         const ibf_offset_t offset = ibf_dump_pos(dump);
 
         for (i=0; i<table->size; i++) {
-            ibf_dump_write_small_value(dump, iseq_indices[i]);
-            ibf_dump_write_small_value(dump, table->entries[i].type);
-            ibf_dump_write_small_value(dump, table->entries[i].start);
-            ibf_dump_write_small_value(dump, table->entries[i].end);
-            ibf_dump_write_small_value(dump, table->entries[i].cont);
-            ibf_dump_write_small_value(dump, table->entries[i].sp);
+            ibf_dump_write_small_value(dump, (VALUE)iseq_indices[i]);
+            ibf_dump_write_small_value(dump, (VALUE)table->entries[i].type);
+            ibf_dump_write_small_value(dump, (VALUE)table->entries[i].start);
+            ibf_dump_write_small_value(dump, (VALUE)table->entries[i].end);
+            ibf_dump_write_small_value(dump, (VALUE)table->entries[i].cont);
+            ibf_dump_write_small_value(dump, (VALUE)table->entries[i].sp);
         }
         return offset;
     }
@@ -12230,13 +12234,13 @@ ibf_dump_ci_entries(struct ibf_dump *dump, const rb_iseq_t *iseq)
         const struct rb_callinfo *ci = cds[i].ci;
         if (ci != NULL) {
             ibf_dump_write_small_value(dump, ibf_dump_id(dump, vm_ci_mid(ci)));
-            ibf_dump_write_small_value(dump, vm_ci_flag(ci));
-            ibf_dump_write_small_value(dump, vm_ci_argc(ci));
+            ibf_dump_write_small_value(dump, (VALUE)vm_ci_flag(ci));
+            ibf_dump_write_small_value(dump, (VALUE)vm_ci_argc(ci));
 
             const struct rb_callinfo_kwarg *kwarg = vm_ci_kwarg(ci);
             if (kwarg) {
                 int len = kwarg->keyword_len;
-                ibf_dump_write_small_value(dump, len);
+                ibf_dump_write_small_value(dump, (VALUE)len);
                 for (int j=0; j<len; j++) {
                     VALUE keyword = ibf_dump_object(dump, kwarg->keywords[j]);
                     ibf_dump_write_small_value(dump, keyword);
@@ -12306,9 +12310,9 @@ ibf_dump_outer_variables(struct ibf_dump *dump, const rb_iseq_t *iseq)
         ruby_qsort(ovlist->pairs, size, sizeof(struct outer_variable_pair), outer_variable_cmp, NULL);
         for (size_t i = 0; i < size; ++i) {
             ID id = ovlist->pairs[i].id;
-            ID val = ovlist->pairs[i].val;
+            ID val = (ID)ovlist->pairs[i].val;
             ibf_dump_write_small_value(dump, ibf_dump_id(dump, id));
-            ibf_dump_write_small_value(dump, val);
+            ibf_dump_write_small_value(dump, (VALUE)val);
         }
     }
 
@@ -12332,7 +12336,7 @@ ibf_load_ci_entries(const struct ibf_load *load,
     for (i = 0; i < ci_size; i++) {
         VALUE mid_index = ibf_load_small_value(load, &reading_pos);
         if (mid_index != (VALUE)-1) {
-            ID mid = ibf_load_id(load, mid_index);
+            ID mid = ibf_load_id(load, (ID)mid_index);
             unsigned int flag = (unsigned int)ibf_load_small_value(load, &reading_pos);
             unsigned int argc = (unsigned int)ibf_load_small_value(load, &reading_pos);
 
@@ -12453,49 +12457,49 @@ ibf_dump_iseq_each(struct ibf_dump *dump, const rb_iseq_t *iseq)
 #  define IBF_BODY_OFFSET(x) (body_offset - (x))
 #endif
 
-    ibf_dump_write_small_value(dump, body->type);
-    ibf_dump_write_small_value(dump, body->iseq_size);
-    ibf_dump_write_small_value(dump, IBF_BODY_OFFSET(bytecode_offset));
-    ibf_dump_write_small_value(dump, bytecode_size);
-    ibf_dump_write_small_value(dump, param_flags);
-    ibf_dump_write_small_value(dump, body->param.size);
-    ibf_dump_write_small_value(dump, body->param.lead_num);
-    ibf_dump_write_small_value(dump, body->param.opt_num);
-    ibf_dump_write_small_value(dump, body->param.rest_start);
-    ibf_dump_write_small_value(dump, body->param.post_start);
-    ibf_dump_write_small_value(dump, body->param.post_num);
-    ibf_dump_write_small_value(dump, body->param.block_start);
-    ibf_dump_write_small_value(dump, IBF_BODY_OFFSET(param_opt_table_offset));
-    ibf_dump_write_small_value(dump, param_keyword_offset);
-    ibf_dump_write_small_value(dump, location_pathobj_index);
-    ibf_dump_write_small_value(dump, location_base_label_index);
-    ibf_dump_write_small_value(dump, location_label_index);
-    ibf_dump_write_small_value(dump, body->location.first_lineno);
-    ibf_dump_write_small_value(dump, body->location.node_id);
-    ibf_dump_write_small_value(dump, body->location.code_location.beg_pos.lineno);
-    ibf_dump_write_small_value(dump, body->location.code_location.beg_pos.column);
-    ibf_dump_write_small_value(dump, body->location.code_location.end_pos.lineno);
-    ibf_dump_write_small_value(dump, body->location.code_location.end_pos.column);
-    ibf_dump_write_small_value(dump, IBF_BODY_OFFSET(insns_info_body_offset));
-    ibf_dump_write_small_value(dump, IBF_BODY_OFFSET(insns_info_positions_offset));
-    ibf_dump_write_small_value(dump, body->insns_info.size);
-    ibf_dump_write_small_value(dump, IBF_BODY_OFFSET(local_table_offset));
-    ibf_dump_write_small_value(dump, catch_table_size);
-    ibf_dump_write_small_value(dump, IBF_BODY_OFFSET(catch_table_offset));
-    ibf_dump_write_small_value(dump, parent_iseq_index);
-    ibf_dump_write_small_value(dump, local_iseq_index);
-    ibf_dump_write_small_value(dump, mandatory_only_iseq_index);
-    ibf_dump_write_small_value(dump, IBF_BODY_OFFSET(ci_entries_offset));
-    ibf_dump_write_small_value(dump, IBF_BODY_OFFSET(outer_variables_offset));
-    ibf_dump_write_small_value(dump, body->variable.flip_count);
-    ibf_dump_write_small_value(dump, body->local_table_size);
-    ibf_dump_write_small_value(dump, body->ivc_size);
-    ibf_dump_write_small_value(dump, body->icvarc_size);
-    ibf_dump_write_small_value(dump, body->ise_size);
-    ibf_dump_write_small_value(dump, body->ic_size);
-    ibf_dump_write_small_value(dump, body->ci_size);
-    ibf_dump_write_small_value(dump, body->stack_max);
-    ibf_dump_write_small_value(dump, body->builtin_attrs);
+    ibf_dump_write_small_value(dump, (VALUE)body->type);
+    ibf_dump_write_small_value(dump, (VALUE)body->iseq_size);
+    ibf_dump_write_small_value(dump, (VALUE)IBF_BODY_OFFSET(bytecode_offset));
+    ibf_dump_write_small_value(dump, (VALUE)bytecode_size);
+    ibf_dump_write_small_value(dump, (VALUE)param_flags);
+    ibf_dump_write_small_value(dump, (VALUE)body->param.size);
+    ibf_dump_write_small_value(dump, (VALUE)body->param.lead_num);
+    ibf_dump_write_small_value(dump, (VALUE)body->param.opt_num);
+    ibf_dump_write_small_value(dump, (VALUE)body->param.rest_start);
+    ibf_dump_write_small_value(dump, (VALUE)body->param.post_start);
+    ibf_dump_write_small_value(dump, (VALUE)body->param.post_num);
+    ibf_dump_write_small_value(dump, (VALUE)body->param.block_start);
+    ibf_dump_write_small_value(dump, (VALUE)IBF_BODY_OFFSET(param_opt_table_offset));
+    ibf_dump_write_small_value(dump, (VALUE)param_keyword_offset);
+    ibf_dump_write_small_value(dump, (VALUE)location_pathobj_index);
+    ibf_dump_write_small_value(dump, (VALUE)location_base_label_index);
+    ibf_dump_write_small_value(dump, (VALUE)location_label_index);
+    ibf_dump_write_small_value(dump, (VALUE)body->location.first_lineno);
+    ibf_dump_write_small_value(dump, (VALUE)body->location.node_id);
+    ibf_dump_write_small_value(dump, (VALUE)body->location.code_location.beg_pos.lineno);
+    ibf_dump_write_small_value(dump, (VALUE)body->location.code_location.beg_pos.column);
+    ibf_dump_write_small_value(dump, (VALUE)body->location.code_location.end_pos.lineno);
+    ibf_dump_write_small_value(dump, (VALUE)body->location.code_location.end_pos.column);
+    ibf_dump_write_small_value(dump, (VALUE)IBF_BODY_OFFSET(insns_info_body_offset));
+    ibf_dump_write_small_value(dump, (VALUE)IBF_BODY_OFFSET(insns_info_positions_offset));
+    ibf_dump_write_small_value(dump, (VALUE)body->insns_info.size);
+    ibf_dump_write_small_value(dump, (VALUE)IBF_BODY_OFFSET(local_table_offset));
+    ibf_dump_write_small_value(dump, (VALUE)catch_table_size);
+    ibf_dump_write_small_value(dump, (VALUE)IBF_BODY_OFFSET(catch_table_offset));
+    ibf_dump_write_small_value(dump, (VALUE)parent_iseq_index);
+    ibf_dump_write_small_value(dump, (VALUE)local_iseq_index);
+    ibf_dump_write_small_value(dump, (VALUE)mandatory_only_iseq_index);
+    ibf_dump_write_small_value(dump, (VALUE)IBF_BODY_OFFSET(ci_entries_offset));
+    ibf_dump_write_small_value(dump, (VALUE)IBF_BODY_OFFSET(outer_variables_offset));
+    ibf_dump_write_small_value(dump, (VALUE)body->variable.flip_count);
+    ibf_dump_write_small_value(dump, (VALUE)body->local_table_size);
+    ibf_dump_write_small_value(dump, (VALUE)body->ivc_size);
+    ibf_dump_write_small_value(dump, (VALUE)body->icvarc_size);
+    ibf_dump_write_small_value(dump, (VALUE)body->ise_size);
+    ibf_dump_write_small_value(dump, (VALUE)body->ic_size);
+    ibf_dump_write_small_value(dump, (VALUE)body->ci_size);
+    ibf_dump_write_small_value(dump, (VALUE)body->stack_max);
+    ibf_dump_write_small_value(dump, (VALUE)body->builtin_attrs);
 
 #undef IBF_BODY_OFFSET
 
@@ -12565,7 +12569,7 @@ ibf_load_iseq_each(struct ibf_load *load, rb_iseq_t *iseq, ibf_offset_t offset)
 
     const unsigned int type = (unsigned int)ibf_load_small_value(load, &reading_pos);
     const unsigned int iseq_size = (unsigned int)ibf_load_small_value(load, &reading_pos);
-    const ibf_offset_t bytecode_offset = (ibf_offset_t)IBF_BODY_OFFSET(ibf_load_small_value(load, &reading_pos));
+    const ibf_offset_t bytecode_offset = (ibf_offset_t)IBF_BODY_OFFSET((uintptr_t)ibf_load_small_value(load, &reading_pos));
     const ibf_offset_t bytecode_size = (ibf_offset_t)ibf_load_small_value(load, &reading_pos);
     const unsigned int param_flags = (unsigned int)ibf_load_small_value(load, &reading_pos);
     const unsigned int param_size = (unsigned int)ibf_load_small_value(load, &reading_pos);
@@ -12575,7 +12579,7 @@ ibf_load_iseq_each(struct ibf_load *load, rb_iseq_t *iseq, ibf_offset_t offset)
     const int param_post_start = (int)ibf_load_small_value(load, &reading_pos);
     const int param_post_num = (int)ibf_load_small_value(load, &reading_pos);
     const int param_block_start = (int)ibf_load_small_value(load, &reading_pos);
-    const ibf_offset_t param_opt_table_offset = (ibf_offset_t)IBF_BODY_OFFSET(ibf_load_small_value(load, &reading_pos));
+    const ibf_offset_t param_opt_table_offset = (ibf_offset_t)IBF_BODY_OFFSET((uintptr_t)ibf_load_small_value(load, &reading_pos));
     const ibf_offset_t param_keyword_offset = (ibf_offset_t)ibf_load_small_value(load, &reading_pos);
     const VALUE location_pathobj_index = ibf_load_small_value(load, &reading_pos);
     const VALUE location_base_label_index = ibf_load_small_value(load, &reading_pos);
@@ -12586,17 +12590,17 @@ ibf_load_iseq_each(struct ibf_load *load, rb_iseq_t *iseq, ibf_offset_t offset)
     const int location_code_location_beg_pos_column = (int)ibf_load_small_value(load, &reading_pos);
     const int location_code_location_end_pos_lineno = (int)ibf_load_small_value(load, &reading_pos);
     const int location_code_location_end_pos_column = (int)ibf_load_small_value(load, &reading_pos);
-    const ibf_offset_t insns_info_body_offset = (ibf_offset_t)IBF_BODY_OFFSET(ibf_load_small_value(load, &reading_pos));
-    const ibf_offset_t insns_info_positions_offset = (ibf_offset_t)IBF_BODY_OFFSET(ibf_load_small_value(load, &reading_pos));
+    const ibf_offset_t insns_info_body_offset = (ibf_offset_t)IBF_BODY_OFFSET((uintptr_t)ibf_load_small_value(load, &reading_pos));
+    const ibf_offset_t insns_info_positions_offset = (ibf_offset_t)IBF_BODY_OFFSET((uintptr_t)ibf_load_small_value(load, &reading_pos));
     const unsigned int insns_info_size = (unsigned int)ibf_load_small_value(load, &reading_pos);
-    const ibf_offset_t local_table_offset = (ibf_offset_t)IBF_BODY_OFFSET(ibf_load_small_value(load, &reading_pos));
+    const ibf_offset_t local_table_offset = (ibf_offset_t)IBF_BODY_OFFSET((uintptr_t)ibf_load_small_value(load, &reading_pos));
     const unsigned int catch_table_size = (unsigned int)ibf_load_small_value(load, &reading_pos);
-    const ibf_offset_t catch_table_offset = (ibf_offset_t)IBF_BODY_OFFSET(ibf_load_small_value(load, &reading_pos));
+    const ibf_offset_t catch_table_offset = (ibf_offset_t)IBF_BODY_OFFSET((uintptr_t)ibf_load_small_value(load, &reading_pos));
     const int parent_iseq_index = (int)ibf_load_small_value(load, &reading_pos);
     const int local_iseq_index = (int)ibf_load_small_value(load, &reading_pos);
     const int mandatory_only_iseq_index = (int)ibf_load_small_value(load, &reading_pos);
-    const ibf_offset_t ci_entries_offset = (ibf_offset_t)IBF_BODY_OFFSET(ibf_load_small_value(load, &reading_pos));
-    const ibf_offset_t outer_variables_offset = (ibf_offset_t)IBF_BODY_OFFSET(ibf_load_small_value(load, &reading_pos));
+    const ibf_offset_t ci_entries_offset = (ibf_offset_t)IBF_BODY_OFFSET((uintptr_t)ibf_load_small_value(load, &reading_pos));
+    const ibf_offset_t outer_variables_offset = (ibf_offset_t)IBF_BODY_OFFSET((uintptr_t)ibf_load_small_value(load, &reading_pos));
     const rb_snum_t variable_flip_count = (rb_snum_t)ibf_load_small_value(load, &reading_pos);
     const unsigned int local_table_size = (unsigned int)ibf_load_small_value(load, &reading_pos);
 
@@ -12627,7 +12631,7 @@ ibf_load_iseq_each(struct ibf_load *load, rb_iseq_t *iseq, ibf_offset_t offset)
             if (!NIL_P(realpath)) {
                 if (!RB_TYPE_P(realpath, T_STRING)) {
                     rb_raise(rb_eArgError, "unexpected realpath %"PRIxVALUE
-                             "(%x), path=%+"PRIsVALUE,
+                             "(%x), path=%"PRIsVALUE,
                              realpath, TYPE(realpath), path);
                 }
                 realpath = rb_fstring(realpath);
@@ -12946,11 +12950,11 @@ ibf_dump_object_string(struct ibf_dump *dump, VALUE obj)
     if (encindex > RUBY_ENCINDEX_BUILTIN_MAX) {
         rb_encoding *enc = rb_enc_from_index((int)encindex);
         const char *enc_name = rb_enc_name(enc);
-        encindex = RUBY_ENCINDEX_BUILTIN_MAX + ibf_dump_object(dump, rb_str_new2(enc_name));
+        encindex = RUBY_ENCINDEX_BUILTIN_MAX + (uintptr_t)ibf_dump_object(dump, rb_str_new2(enc_name));
     }
 
-    ibf_dump_write_small_value(dump, encindex);
-    ibf_dump_write_small_value(dump, len);
+    ibf_dump_write_small_value(dump, (VALUE)encindex);
+    ibf_dump_write_small_value(dump, (VALUE)len);
     IBF_WP(ptr, char, len);
 }
 
@@ -12964,7 +12968,7 @@ ibf_load_object_string(const struct ibf_load *load, const struct ibf_object_head
     const char *ptr = load->current_buffer->buff + reading_pos;
 
     if (encindex > RUBY_ENCINDEX_BUILTIN_MAX) {
-        VALUE enc_name_str = ibf_load_object(load, encindex - RUBY_ENCINDEX_BUILTIN_MAX);
+        VALUE enc_name_str = ibf_load_object(load, (VALUE)(encindex - RUBY_ENCINDEX_BUILTIN_MAX));
         encindex = rb_enc_find_index(RSTRING_PTR(enc_name_str));
     }
 
@@ -12990,7 +12994,7 @@ ibf_dump_object_regexp(struct ibf_dump *dump, VALUE obj)
     regexp.srcstr = (long)ibf_dump_object(dump, srcstr);
 
     ibf_dump_write_byte(dump, (unsigned char)regexp.option);
-    ibf_dump_write_small_value(dump, regexp.srcstr);
+    ibf_dump_write_small_value(dump, (VALUE)regexp.srcstr);
 }
 
 static VALUE
@@ -12998,9 +13002,9 @@ ibf_load_object_regexp(const struct ibf_load *load, const struct ibf_object_head
 {
     struct ibf_object_regexp regexp;
     regexp.option = ibf_load_byte(load, &offset);
-    regexp.srcstr = ibf_load_small_value(load, &offset);
+    regexp.srcstr = (uintptr_t)ibf_load_small_value(load, &offset);
 
-    VALUE srcstr = ibf_load_object(load, regexp.srcstr);
+    VALUE srcstr = ibf_load_object(load, (VALUE)regexp.srcstr);
     VALUE reg = rb_reg_compile(srcstr, (int)regexp.option, NULL, 0);
 
     if (header->internal) rb_obj_hide(reg);
@@ -13013,10 +13017,10 @@ static void
 ibf_dump_object_array(struct ibf_dump *dump, VALUE obj)
 {
     long i, len = RARRAY_LEN(obj);
-    ibf_dump_write_small_value(dump, len);
+    ibf_dump_write_small_value(dump, (VALUE)len);
     for (i=0; i<len; i++) {
         long index = (long)ibf_dump_object(dump, RARRAY_AREF(obj, i));
-        ibf_dump_write_small_value(dump, index);
+        ibf_dump_write_small_value(dump, (VALUE)index);
     }
 }
 
@@ -13112,8 +13116,8 @@ static VALUE
 ibf_load_object_struct(const struct ibf_load *load, const struct ibf_object_header *header, ibf_offset_t offset)
 {
     const struct ibf_object_struct_range *range = IBF_OBJBODY(struct ibf_object_struct_range, offset);
-    VALUE beg = ibf_load_object(load, range->beg);
-    VALUE end = ibf_load_object(load, range->end);
+    VALUE beg = ibf_load_object(load, (VALUE)range->beg);
+    VALUE end = ibf_load_object(load, (VALUE)range->end);
     VALUE obj = rb_range_new(beg, end, range->excl);
     if (header->internal) rb_obj_hide(obj);
     if (header->frozen)   rb_obj_freeze(obj);
@@ -13199,8 +13203,8 @@ static VALUE
 ibf_load_object_complex_rational(const struct ibf_load *load, const struct ibf_object_header *header, ibf_offset_t offset)
 {
     const struct ibf_object_complex_rational *nums = IBF_OBJBODY(struct ibf_object_complex_rational, offset);
-    VALUE a = ibf_load_object(load, nums->a);
-    VALUE b = ibf_load_object(load, nums->b);
+    VALUE a = ibf_load_object(load, (VALUE)nums->a);
+    VALUE b = ibf_load_object(load, (VALUE)nums->b);
     VALUE obj = header->type == T_COMPLEX ?
       rb_complex_new(a, b) : rb_rational_new(a, b);
 
@@ -13225,7 +13229,7 @@ ibf_load_object_symbol(const struct ibf_load *load, const struct ibf_object_head
     const char *ptr = load->current_buffer->buff + reading_pos;
 
     if (encindex > RUBY_ENCINDEX_BUILTIN_MAX) {
-        VALUE enc_name_str = ibf_load_object(load, encindex - RUBY_ENCINDEX_BUILTIN_MAX);
+        VALUE enc_name_str = ibf_load_object(load, (VALUE)(encindex - RUBY_ENCINDEX_BUILTIN_MAX));
         encindex = rb_enc_find_index(RSTRING_PTR(enc_name_str));
     }
 
@@ -13365,14 +13369,14 @@ static const ibf_load_object_function load_object_functions[RUBY_T_MASK+1] = {
 static VALUE
 ibf_load_object(const struct ibf_load *load, VALUE object_index)
 {
-    if (object_index == 0) {
+    if (object_index == (VALUE)0) {
         return Qnil;
     }
     else {
         VALUE obj = pinned_list_fetch(load->current_buffer->obj_list, (long)object_index);
         if (!obj) {
             ibf_offset_t *offsets = (ibf_offset_t *)(load->current_buffer->obj_list_offset + load->current_buffer->buff);
-            ibf_offset_t offset = offsets[object_index];
+            ibf_offset_t offset = offsets[(uintptr_t)object_index];
             const struct ibf_object_header header = ibf_load_object_object_header(load, &offset);
 
 #if IBF_ISEQ_DEBUG
diff --git a/configure.txt b/configure.txt
new file mode 100644
index 000000000000..4a1929bff567
--- /dev/null
+++ b/configure.txt
@@ -0,0 +1 @@
+CC=$PWD/../../build/bin/clang CXX=$PWD/../../build/bin/clang++ ./configure --enable-shared --disable-yjit --disable-rjit --without-jit --without-gcc --without-valgrind --with-thread=pthread --without-jemalloc --with-coroutine=pthread --prefix=$PWD/../../pizfix
diff --git a/debug.c b/debug.c
index e84e3d602a3e..3d4b1ffbcfe3 100644
--- a/debug.c
+++ b/debug.c
@@ -213,14 +213,18 @@ ruby_env_debug_option(const char *str, int len, void *arg)
 #define SET_WHEN_UINT(name, vals, num, req) \
     if (NAME_MATCH_VALUE(name)) SET_UINT_LIST(name, vals, num);
 
+#ifndef __FILC__
     SET_WHEN("gc_stress", *ruby_initial_gc_stress_ptr, Qtrue);
+#endif
     SET_WHEN("core", ruby_enable_coredump, 1);
     SET_WHEN("ci", ruby_on_ci, 1);
+#ifndef __FILC__
     if (NAME_MATCH_VALUE("rgengc")) {
         if (!len) ruby_rgengc_debug = 1;
         else SET_UINT_LIST("rgengc", &ruby_rgengc_debug, 1);
         return 1;
     }
+#endif
 #if defined _WIN32
 # if RUBY_MSVCRT_VERSION >= 80
     SET_WHEN("rtc_error", ruby_w32_rtc_error, 1);
diff --git a/dir.c b/dir.c
index 96c1a455b3cd..d3cae1ba42af 100644
--- a/dir.c
+++ b/dir.c
@@ -1706,7 +1706,7 @@ gc_for_fd_with_gvl(int e)
     if (vm_initialized)
         return (int)(VALUE)rb_thread_call_with_gvl(with_gvl_gc_for_fd, &e);
     else
-        return RBOOL(rb_gc_for_fd(e));
+        return (int)RBOOL(rb_gc_for_fd(e));
 }
 
 static void *
diff --git a/enc/trans/emoji.c b/enc/trans/emoji.c
index 72ef11dbf05a..e29e09924677 100644
--- a/enc/trans/emoji.c
+++ b/enc/trans/emoji.c
@@ -1,7 +1,7 @@
 /* autogenerated. */
 /* src="transcode-tblgen.rb", len=30823, checksum=59589 */
 /* src="emoji.trans", len=1009, checksum=14571 */
-/* src="emoji-exchange-tbl.rb", len=524703, checksum=40005 */
+/* src="emoji-exchange-tbl.rb", len=515597, checksum=40005 */
 
 #include "transcode_data.h"
 
diff --git a/enc/trans/gb18030.c b/enc/trans/gb18030.c
index b38f5ac4717d..460bc4367bec 100644
--- a/enc/trans/gb18030.c
+++ b/enc/trans/gb18030.c
@@ -1,6 +1,6 @@
 /* autogenerated. */
 /* src="transcode-tblgen.rb", len=30823, checksum=59589 */
-/* src="gb18030.trans", len=5681, checksum=53185 */
+/* src="gb18030.trans", len=5703, checksum=55349 */
 /* src="gb18030-tbl.rb", len=1357449, checksum=30205 */
 
 #include "transcode_data.h"
@@ -21511,7 +21511,7 @@ fun_so_to_gb18030(void *statep, const unsigned char *s, size_t l, unsigned char
 static ssize_t
 fun_sio_from_gb18030(void *statep, const unsigned char *s, size_t l, VALUE info, unsigned char *o, size_t osize)
 {
-    unsigned int diff = (unsigned int)(info >> 8);
+    unsigned int diff = (unsigned int)((uintptr_t)info >> 8);
     unsigned int u;    /* Unicode Scalar Value */
     if (diff & 0x20000) { /* GB18030 4 bytes */
         u = ((s[0]*10+s[1])*126+s[2])*10+s[3] - diff - 0x170000;
@@ -21529,7 +21529,7 @@ fun_sio_from_gb18030(void *statep, const unsigned char *s, size_t l, VALUE info,
 static ssize_t
 fun_sio_to_gb18030(void *statep, const unsigned char *s, size_t l, VALUE info, unsigned char *o, size_t osize)
 {
-    unsigned int diff = (unsigned int)(info >> 8);
+    unsigned int diff = (unsigned int)((uintptr_t)info >> 8);
     unsigned int u;    /* Unicode Scalar Value */
 
     u = ((s[0]&0x0F)<<12) | ((s[1]&0x3F)<<6) | (s[2]&0x3F);
diff --git a/enc/trans/gb18030.trans b/enc/trans/gb18030.trans
index f42f8fd2d53c..b14c3fa3b3ab 100644
--- a/enc/trans/gb18030.trans
+++ b/enc/trans/gb18030.trans
@@ -103,7 +103,7 @@ fun_so_to_gb18030(void *statep, const unsigned char *s, size_t l, unsigned char
 static ssize_t
 fun_sio_from_gb18030(void *statep, const unsigned char *s, size_t l, VALUE info, unsigned char *o, size_t osize)
 {
-    unsigned int diff = (unsigned int)(info >> 8);
+    unsigned int diff = (unsigned int)((uintptr_t)info >> 8);
     unsigned int u;    /* Unicode Scalar Value */
     if (diff & 0x20000) { /* GB18030 4 bytes */
         u = ((s[0]*10+s[1])*126+s[2])*10+s[3] - diff - 0x170000;
@@ -121,7 +121,7 @@ fun_sio_from_gb18030(void *statep, const unsigned char *s, size_t l, VALUE info,
 static ssize_t
 fun_sio_to_gb18030(void *statep, const unsigned char *s, size_t l, VALUE info, unsigned char *o, size_t osize)
 {
-    unsigned int diff = (unsigned int)(info >> 8);
+    unsigned int diff = (unsigned int)((uintptr_t)info >> 8);
     unsigned int u;    /* Unicode Scalar Value */
 
     u = ((s[0]&0x0F)<<12) | ((s[1]&0x3F)<<6) | (s[2]&0x3F);
diff --git a/enc/trans/utf8_mac.c b/enc/trans/utf8_mac.c
index 6984e3d0c481..7c08a34b3e16 100644
--- a/enc/trans/utf8_mac.c
+++ b/enc/trans/utf8_mac.c
@@ -1,6 +1,6 @@
 /* autogenerated. */
 /* src="transcode-tblgen.rb", len=30823, checksum=59589 */
-/* src="utf8_mac.trans", len=7053, checksum=2830 */
+/* src="utf8_mac.trans", len=7080, checksum=6392 */
 /* src="utf8_mac-tbl.rb", len=754604, checksum=27903 */
 
 #include "transcode_data.h"
@@ -68924,8 +68924,8 @@ rb_to_UTF8_MAC = {
 
 #define BYTE_ADDR(index) (utf8_mac_byte_array + (index))
 #define WORD_ADDR(index) (utf8_mac_word_array + INFO2WORDINDEX(index))
-#define BL_BASE BYTE_ADDR(BYTE_LOOKUP_BASE(WORD_ADDR(next_info)))
-#define BL_INFO WORD_ADDR(BYTE_LOOKUP_INFO(WORD_ADDR(next_info)))
+#define BL_BASE BYTE_ADDR(BYTE_LOOKUP_BASE(WORD_ADDR((uintptr_t)next_info)))
+#define BL_INFO WORD_ADDR(BYTE_LOOKUP_INFO(WORD_ADDR((uintptr_t)next_info)))
 #define BL_MIN_BYTE     (BL_BASE[0])
 #define BL_MAX_BYTE     (BL_BASE[1])
 #define BL_OFFSET(byte) (BL_BASE[2+(byte)-BL_MIN_BYTE])
@@ -68996,15 +68996,15 @@ buf_output_all(struct from_utf8_mac_status *sp, unsigned char *o)
     return n;
 }
 
-static VALUE
-get_info(VALUE next_info, struct from_utf8_mac_status *sp) {
+static uintptr_t
+get_info(uintptr_t next_info, struct from_utf8_mac_status *sp) {
     int pos = 0;
     while (pos < buf_bytesize(sp)) {
         unsigned char next_byte = buf_at(sp, pos++);
         if (next_byte < BL_MIN_BYTE || BL_MAX_BYTE < next_byte)
             next_info = INVALID;
         else {
-            next_info = (VALUE)BL_ACTION(next_byte);
+            next_info = BL_ACTION(next_byte);
         }
         if ((next_info & 3) == 0) continue;
         break;
@@ -69016,7 +69016,7 @@ static size_t
 buf_apply(struct from_utf8_mac_status *sp, unsigned char *o)
 {
     size_t n = 0;
-    VALUE next_info;
+    uintptr_t next_info;
     unsigned char buf[3];
     if (buf_bytesize(sp) < 3 || (buf_bytesize(sp) == 3 && buf_at(sp, 0) >= 0xE0)) {
         /* char length is less than 2 */
diff --git a/enc/trans/utf8_mac.trans b/enc/trans/utf8_mac.trans
index bcaa785eade5..1418de99109e 100644
--- a/enc/trans/utf8_mac.trans
+++ b/enc/trans/utf8_mac.trans
@@ -78,8 +78,8 @@
 
 #define BYTE_ADDR(index) (<%= OUTPUT_PREFIX %>byte_array + (index))
 #define WORD_ADDR(index) (<%= OUTPUT_PREFIX %>word_array + INFO2WORDINDEX(index))
-#define BL_BASE BYTE_ADDR(BYTE_LOOKUP_BASE(WORD_ADDR(next_info)))
-#define BL_INFO WORD_ADDR(BYTE_LOOKUP_INFO(WORD_ADDR(next_info)))
+#define BL_BASE BYTE_ADDR(BYTE_LOOKUP_BASE(WORD_ADDR((uintptr_t)next_info)))
+#define BL_INFO WORD_ADDR(BYTE_LOOKUP_INFO(WORD_ADDR((uintptr_t)next_info)))
 #define BL_MIN_BYTE     (BL_BASE[0])
 #define BL_MAX_BYTE     (BL_BASE[1])
 #define BL_OFFSET(byte) (BL_BASE[2+(byte)-BL_MIN_BYTE])
@@ -150,15 +150,15 @@ buf_output_all(struct from_utf8_mac_status *sp, unsigned char *o)
     return n;
 }
 
-static VALUE
-get_info(VALUE next_info, struct from_utf8_mac_status *sp) {
+static uintptr_t
+get_info(uintptr_t next_info, struct from_utf8_mac_status *sp) {
     int pos = 0;
     while (pos < buf_bytesize(sp)) {
         unsigned char next_byte = buf_at(sp, pos++);
         if (next_byte < BL_MIN_BYTE || BL_MAX_BYTE < next_byte)
             next_info = INVALID;
         else {
-            next_info = (VALUE)BL_ACTION(next_byte);
+            next_info = BL_ACTION(next_byte);
         }
         if ((next_info & 3) == 0) continue;
         break;
@@ -170,7 +170,7 @@ static size_t
 buf_apply(struct from_utf8_mac_status *sp, unsigned char *o)
 {
     size_t n = 0;
-    VALUE next_info;
+    uintptr_t next_info;
     unsigned char buf[3];
     if (buf_bytesize(sp) < 3 || (buf_bytesize(sp) == 3 && buf_at(sp, 0) >= 0xE0)) {
         /* char length is less than 2 */
diff --git a/enc/trans/utf_16_32.c b/enc/trans/utf_16_32.c
index d83341b0502b..f21d83b840c6 100644
--- a/enc/trans/utf_16_32.c
+++ b/enc/trans/utf_16_32.c
@@ -1,6 +1,6 @@
 /* autogenerated. */
 /* src="transcode-tblgen.rb", len=30823, checksum=59589 */
-/* src="utf_16_32.trans", len=15308, checksum=28538 */
+/* src="utf_16_32.trans", len=15336, checksum=30386 */
 
 #include "transcode_data.h"
 
@@ -575,11 +575,11 @@ fun_si_from_utf_16(void *statep, const unsigned char *s, size_t l)
     case 0:
         if (s[0] == 0xFE && s[1] == 0xFF) {
             *sp = BE;
-            return ZERObt;
+            return (VALUE)ZERObt;
         }
         else if (s[0] == 0xFF && s[1] == 0xFE) {
             *sp = LE;
-            return ZERObt;
+            return (VALUE)ZERObt;
         }
         break;
     case BE:
@@ -623,11 +623,11 @@ fun_si_from_utf_32(void *statep, const unsigned char *s, size_t l)
     case 0:
         if (s[0] == 0 && s[1] == 0 && s[2] == 0xFE && s[3] == 0xFF) {
             *sp = BE;
-            return ZERObt;
+            return (VALUE)ZERObt;
         }
         else if (s[0] == 0xFF && s[1] == 0xFE && s[2] == 0 && s[3] == 0) {
             *sp = LE;
-            return ZERObt;
+            return (VALUE)ZERObt;
         }
         break;
     case BE:
diff --git a/enc/trans/utf_16_32.trans b/enc/trans/utf_16_32.trans
index 632c8808efc6..1b172a475310 100644
--- a/enc/trans/utf_16_32.trans
+++ b/enc/trans/utf_16_32.trans
@@ -285,11 +285,11 @@ fun_si_from_utf_16(void *statep, const unsigned char *s, size_t l)
     case 0:
         if (s[0] == 0xFE && s[1] == 0xFF) {
             *sp = BE;
-            return ZERObt;
+            return (VALUE)ZERObt;
         }
         else if (s[0] == 0xFF && s[1] == 0xFE) {
             *sp = LE;
-            return ZERObt;
+            return (VALUE)ZERObt;
         }
         break;
     case BE:
@@ -333,11 +333,11 @@ fun_si_from_utf_32(void *statep, const unsigned char *s, size_t l)
     case 0:
         if (s[0] == 0 && s[1] == 0 && s[2] == 0xFE && s[3] == 0xFF) {
             *sp = BE;
-            return ZERObt;
+            return (VALUE)ZERObt;
         }
         else if (s[0] == 0xFF && s[1] == 0xFE && s[2] == 0 && s[3] == 0) {
             *sp = LE;
-            return ZERObt;
+            return (VALUE)ZERObt;
         }
         break;
     case BE:
diff --git a/enum.c b/enum.c
index cd48e8086667..1a5abd145b80 100644
--- a/enum.c
+++ b/enum.c
@@ -1170,7 +1170,7 @@ tally_up(st_data_t *group, st_data_t *value, st_data_t arg, int existing)
         tally = INT2FIX(1);
     }
     else if (FIXNUM_P(tally) && tally < INT2FIX(FIXNUM_MAX)) {
-        tally += INT2FIX(1) & ~FIXNUM_FLAG;
+        tally += (uintptr_t)INT2FIX(1) & ~FIXNUM_FLAG;
     }
     else {
         Check_Type(tally, T_BIGNUM);
@@ -4770,7 +4770,7 @@ enum_sum(int argc, VALUE* argv, VALUE obj)
         memo.c = 0.0;
     }
 
-    if (RTEST(rb_range_values(obj, &beg, &end, &excl))) {
+    if (RTEST((VALUE)rb_range_values(obj, &beg, &end, &excl))) {
         if (!memo.block_given && !memo.float_value &&
                 (FIXNUM_P(beg) || RB_BIGNUM_TYPE_P(beg)) &&
                 (FIXNUM_P(end) || RB_BIGNUM_TYPE_P(end))) {
diff --git a/error.c b/error.c
index 70ba070f422a..45d07fe7aaa2 100644
--- a/error.c
+++ b/error.c
@@ -171,7 +171,7 @@ rb_warning_category_from_name(VALUE category)
     ID cat_id;
     Check_Type(category, T_SYMBOL);
     if (!(cat_id = rb_check_id(&category)) ||
-        !st_lookup(warning_categories.id2enum, cat_id, &cat_value)) {
+        !st_lookup(warning_categories.id2enum, (st_data_t)cat_id, &cat_value)) {
         rb_raise(rb_eArgError, "unknown category: %"PRIsVALUE, category);
     }
     return (rb_warning_category_t)cat_value;
@@ -181,10 +181,10 @@ static VALUE
 rb_warning_category_to_name(rb_warning_category_t category)
 {
     st_data_t id;
-    if (!st_lookup(warning_categories.enum2id, category, &id)) {
+    if (!st_lookup(warning_categories.enum2id, (st_data_t)category, &id)) {
         rb_raise(rb_eArgError, "invalid category: %d", (int)category);
     }
-    return id ? ID2SYM(id) : Qnil;
+    return id ? ID2SYM((ID)id) : Qnil;
 }
 
 void
@@ -1178,10 +1178,10 @@ rb_builtin_type_name(int t)
 static VALUE
 displaying_class_of(VALUE x)
 {
-    switch (x) {
-      case Qfalse: return rb_fstring_cstr("false");
-      case Qnil:   return rb_fstring_cstr("nil");
-      case Qtrue:  return rb_fstring_cstr("true");
+    switch ((uintptr_t)x) {
+      case (uintptr_t)Qfalse: return rb_fstring_cstr("false");
+      case (uintptr_t)Qnil:   return rb_fstring_cstr("nil");
+      case (uintptr_t)Qtrue:  return rb_fstring_cstr("true");
       default:     return rb_obj_class(x);
     }
 }
@@ -1515,11 +1515,11 @@ check_highlight_keyword(VALUE opt, int auto_tty_detect)
     if (!NIL_P(opt)) {
         highlight = rb_hash_lookup(opt, sym_highlight);
 
-        switch (highlight) {
+        switch ((uintptr_t)highlight) {
           default:
             rb_bool_expected(highlight, "highlight", TRUE);
             UNREACHABLE;
-          case Qtrue: case Qfalse: case Qnil: break;
+          case (uintptr_t)Qtrue: case (uintptr_t)Qfalse: case (uintptr_t)Qnil: break;
         }
     }
 
@@ -1921,13 +1921,13 @@ exit_initialize(int argc, VALUE *argv, VALUE exc)
     if (argc > 0) {
         status = *argv;
 
-        switch (status) {
-          case Qtrue:
+        switch ((uintptr_t)status) {
+          case (uintptr_t)Qtrue:
             status = INT2FIX(EXIT_SUCCESS);
             ++argv;
             --argc;
             break;
-          case Qfalse:
+          case (uintptr_t)Qfalse:
             status = INT2FIX(EXIT_FAILURE);
             ++argv;
             --argc;
@@ -2329,14 +2329,14 @@ name_err_mesg_to_str(VALUE obj)
 #define FAKE_CSTR(v, str) rb_setup_fake_str((v), (str), rb_strlen_lit(str), usascii)
         c = s = FAKE_CSTR(&s_str, "");
         obj = ptr->recv;
-        switch (obj) {
-          case Qnil:
+        switch ((uintptr_t)obj) {
+          case (uintptr_t)Qnil:
             c = d = FAKE_CSTR(&d_str, "nil");
             break;
-          case Qtrue:
+          case (uintptr_t)Qtrue:
             c = d = FAKE_CSTR(&d_str, "true");
             break;
-          case Qfalse:
+          case (uintptr_t)Qfalse:
             c = d = FAKE_CSTR(&d_str, "false");
             break;
           default:
@@ -2477,7 +2477,7 @@ rb_invalid_str(const char *str, const char *type)
 {
     VALUE s = rb_str_new2(str);
 
-    rb_raise(rb_eArgError, "invalid value for %s: %+"PRIsVALUE, type, s);
+    rb_raise(rb_eArgError, "invalid value for %s: %"PRIsVALUE, type, s);
 }
 
 /*
@@ -2707,7 +2707,7 @@ set_syserr(int n, const char *name)
 {
     st_data_t error;
 
-    if (!st_lookup(syserr_tbl, n, &error)) {
+    if (!st_lookup(syserr_tbl, (st_data_t)n, &error)) {
         error = rb_define_class_under(rb_mErrno, name, rb_eSystemCallError);
 
         /* capture nonblock errnos for WaitReadable/WaitWritable subclasses */
@@ -2728,7 +2728,7 @@ set_syserr(int n, const char *name)
         }
 
         rb_define_const(error, "Errno", INT2NUM(n));
-        st_add_direct(syserr_tbl, n, error);
+        st_add_direct(syserr_tbl, (st_data_t)n, error);
     }
     else {
         rb_define_const(rb_mErrno, name, error);
@@ -2741,7 +2741,7 @@ get_syserr(int n)
 {
     st_data_t error;
 
-    if (!st_lookup(syserr_tbl, n, &error)) {
+    if (!st_lookup(syserr_tbl, (st_data_t)n, &error)) {
         char name[8];	/* some Windows' errno have 5 digits. */
 
         snprintf(name, sizeof(name), "E%03d", n);
@@ -2773,7 +2773,7 @@ syserr_initialize(int argc, VALUE *argv, VALUE self)
         if (argc == 1 && FIXNUM_P(mesg)) {
             error = mesg; mesg = Qnil;
         }
-        if (!NIL_P(error) && st_lookup(syserr_tbl, NUM2LONG(error), &data)) {
+        if (!NIL_P(error) && st_lookup(syserr_tbl, (st_data_t)NUM2LONG(error), &data)) {
             klass = (VALUE)data;
             /* change class */
             if (!RB_TYPE_P(self, T_OBJECT)) { /* insurance to avoid type crash */
@@ -3421,15 +3421,15 @@ Init_Exception(void)
     sym_highlight = ID2SYM(rb_intern_const("highlight"));
 
     warning_categories.id2enum = rb_init_identtable();
-    st_add_direct(warning_categories.id2enum, id_deprecated, RB_WARN_CATEGORY_DEPRECATED);
-    st_add_direct(warning_categories.id2enum, id_experimental, RB_WARN_CATEGORY_EXPERIMENTAL);
-    st_add_direct(warning_categories.id2enum, id_performance, RB_WARN_CATEGORY_PERFORMANCE);
+    st_add_direct(warning_categories.id2enum, (st_data_t)id_deprecated, (st_data_t)RB_WARN_CATEGORY_DEPRECATED);
+    st_add_direct(warning_categories.id2enum, (st_data_t)id_experimental, (st_data_t)RB_WARN_CATEGORY_EXPERIMENTAL);
+    st_add_direct(warning_categories.id2enum, (st_data_t)id_performance, (st_data_t)RB_WARN_CATEGORY_PERFORMANCE);
 
     warning_categories.enum2id = rb_init_identtable();
-    st_add_direct(warning_categories.enum2id, RB_WARN_CATEGORY_NONE, 0);
-    st_add_direct(warning_categories.enum2id, RB_WARN_CATEGORY_DEPRECATED, id_deprecated);
-    st_add_direct(warning_categories.enum2id, RB_WARN_CATEGORY_EXPERIMENTAL, id_experimental);
-    st_add_direct(warning_categories.enum2id, RB_WARN_CATEGORY_PERFORMANCE, id_performance);
+    st_add_direct(warning_categories.enum2id, (st_data_t)RB_WARN_CATEGORY_NONE, (st_data_t)0);
+    st_add_direct(warning_categories.enum2id, (st_data_t)RB_WARN_CATEGORY_DEPRECATED, (st_data_t)id_deprecated);
+    st_add_direct(warning_categories.enum2id, (st_data_t)RB_WARN_CATEGORY_EXPERIMENTAL, (st_data_t)id_experimental);
+    st_add_direct(warning_categories.enum2id, (st_data_t)RB_WARN_CATEGORY_PERFORMANCE, (st_data_t)id_performance);
 }
 
 void
diff --git a/eval.c b/eval.c
index a8fc48daf54a..464b10481f42 100644
--- a/eval.c
+++ b/eval.c
@@ -304,9 +304,9 @@ ruby_executable_node(void *n, int *status)
     VALUE v = (VALUE)n;
     int s;
 
-    switch (v) {
-      case Qtrue:  s = EXIT_SUCCESS; break;
-      case Qfalse: s = EXIT_FAILURE; break;
+    switch ((uintptr_t)v) {
+      case (uintptr_t)Qtrue:  s = EXIT_SUCCESS; break;
+      case (uintptr_t)Qfalse: s = EXIT_FAILURE; break;
       default:
         if (!FIXNUM_P(v)) return TRUE;
         s = FIX2INT(v);
diff --git a/ext/-test-/cxxanyargs/cxxanyargs.cpp b/ext/-test-/cxxanyargs/cxxanyargs.cpp
index eded13e2eec0..c3c5b72c0844 100644
--- a/ext/-test-/cxxanyargs/cxxanyargs.cpp
+++ b/ext/-test-/cxxanyargs/cxxanyargs.cpp
@@ -419,7 +419,7 @@ namespace test_rb_hash_foreach {
 
 namespace test_rb_ivar_foreach {
     static int
-    iter(VALUE, VALUE, VALUE)
+    iter(ID, VALUE, VALUE)
     {
         return ST_CONTINUE;
     }
diff --git a/ext/-test-/memory_view/memory_view.c b/ext/-test-/memory_view/memory_view.c
index c1df0353cfc5..fcdc02aeb852 100644
--- a/ext/-test-/memory_view/memory_view.c
+++ b/ext/-test-/memory_view/memory_view.c
@@ -198,7 +198,7 @@ memory_view_get_ref_count(VALUE obj)
 
     st_data_t count;
     if (st_lookup(table, (st_data_t)obj, &count)) {
-        return ULL2NUM(count);
+        return ULL2NUM((unsigned long long)count);
     }
 
     return Qnil;
diff --git a/ext/-test-/st/foreach/foreach.c b/ext/-test-/st/foreach/foreach.c
index 7fbf0646941c..5da4ca8d2ba5 100644
--- a/ext/-test-/st/foreach/foreach.c
+++ b/ext/-test-/st/foreach/foreach.c
@@ -1,7 +1,7 @@
 #include <ruby.h>
 #include <ruby/st.h>
 
-static st_data_t expect_size = 32;
+static uintptr_t expect_size = 32;
 struct checker {
     st_table *tbl;
     st_index_t nr;
@@ -12,13 +12,13 @@ static void
 force_unpack_check(struct checker *c, st_data_t key, st_data_t val)
 {
     if (c->nr == 0) {
-        st_data_t i;
+        uintptr_t i;
 
         if (c->tbl->bins != NULL) rb_bug("should be packed");
 
         /* force unpacking during iteration: */
         for (i = 1; i < expect_size; i++)
-            st_add_direct(c->tbl, i, i);
+            st_add_direct(c->tbl, (st_data_t)i, (st_data_t)i);
 
         if (c->tbl->bins == NULL) rb_bug("should be unpacked");
     }
@@ -86,7 +86,7 @@ unp_fec(VALUE self, VALUE test)
 
     if (tbl->bins != NULL) rb_bug("should still be packed");
 
-    st_foreach_check(tbl, unp_fec_i, (st_data_t)&c, -1);
+    st_foreach_check(tbl, unp_fec_i, (st_data_t)&c, (st_data_t)-1);
 
     if (c.test == ID2SYM(rb_intern("delete2"))) {
         if (c.nr != 1) {
diff --git a/ext/-test-/st/numhash/numhash.c b/ext/-test-/st/numhash/numhash.c
index 7e8d5d9fe2db..473bbc90d3ad 100644
--- a/ext/-test-/st/numhash/numhash.c
+++ b/ext/-test-/st/numhash/numhash.c
@@ -77,10 +77,10 @@ static int
 update_func(st_data_t *key, st_data_t *value, st_data_t arg, int existing)
 {
     VALUE ret = rb_yield_values(existing ? 2 : 1, (VALUE)*key, (VALUE)*value);
-    switch (ret) {
-      case Qfalse:
+    switch ((uintptr_t)ret) {
+      case (uintptr_t)Qfalse:
         return ST_STOP;
-      case Qnil:
+      case (uintptr_t)Qnil:
         return ST_DELETE;
       default:
         *value = ret;
diff --git a/ext/-test-/st/update/update.c b/ext/-test-/st/update/update.c
index ea7fab12e115..3d9c2198d4b4 100644
--- a/ext/-test-/st/update/update.c
+++ b/ext/-test-/st/update/update.c
@@ -5,10 +5,10 @@ static int
 update_func(st_data_t *key, st_data_t *value, st_data_t arg, int existing)
 {
     VALUE ret = rb_yield_values(existing ? 2 : 1, (VALUE)*key, (VALUE)*value);
-    switch (ret) {
-      case Qfalse:
+    switch ((uintptr_t)ret) {
+      case (uintptr_t)Qfalse:
         return ST_STOP;
-      case Qnil:
+      case (uintptr_t)Qnil:
         return ST_DELETE;
       default:
         *value = ret;
diff --git a/ext/-test-/vm/at_exit.c b/ext/-test-/vm/at_exit.c
index efc439b26ade..a571bacbfdfc 100644
--- a/ext/-test-/vm/at_exit.c
+++ b/ext/-test-/vm/at_exit.c
@@ -21,11 +21,11 @@ print_end(ruby_vm_t *vm)
 static VALUE
 register_at_exit(VALUE self, VALUE t)
 {
-    switch (t) {
-      case Qtrue:
+    switch ((uintptr_t)t) {
+      case (uintptr_t)Qtrue:
         ruby_vm_at_exit(print_begin);
         break;
-      case Qfalse:
+      case (uintptr_t)Qfalse:
         ruby_vm_at_exit(print_end);
         break;
       default:
diff --git a/ext/bigdecimal/bigdecimal.c b/ext/bigdecimal/bigdecimal.c
index cb8874d31a1a..776d3faafaf5 100644
--- a/ext/bigdecimal/bigdecimal.c
+++ b/ext/bigdecimal/bigdecimal.c
@@ -2906,7 +2906,7 @@ is_zero(VALUE x)
 	return FIX2LONG(x) == 0;
 
       case T_BIGNUM:
-	return Qfalse;
+	return (int)Qfalse;
 
       case T_RATIONAL:
 	num = rb_rational_num(x);
@@ -2929,7 +2929,7 @@ is_one(VALUE x)
 	return FIX2LONG(x) == 1;
 
       case T_BIGNUM:
-	return Qfalse;
+	return (int)Qfalse;
 
       case T_RATIONAL:
 	num = rb_rational_num(x);
@@ -3614,10 +3614,10 @@ rb_str_convert_to_BigDecimal(VALUE val, size_t digs, int raise_exception)
 static VALUE
 rb_convert_to_BigDecimal(VALUE val, size_t digs, int raise_exception)
 {
-    switch (val) {
-      case Qnil:
-      case Qtrue:
-      case Qfalse:
+    switch ((uintptr_t)val) {
+      case (uintptr_t)Qnil:
+      case (uintptr_t)Qtrue:
+      case (uintptr_t)Qfalse:
         if (raise_exception) {
             const char *cname = NIL_P(val)    ? "nil"   :
                                 val == Qtrue  ? "true"  :
diff --git a/ext/date/date_core.c b/ext/date/date_core.c
index 55706088f427..bb989984aa01 100644
--- a/ext/date/date_core.c
+++ b/ext/date/date_core.c
@@ -6957,7 +6957,7 @@ d_lite_hash(VALUE self)
 
     h[2] = m_jd(dat);
     h[3] = m_df(dat);
-    h[4] = m_sf(dat);
+    h[4] = (st_index_t)m_sf(dat);
 
     v = rb_memhash(h, sizeof(h));
     return ST2FIX(v);
diff --git a/ext/fiddle/fiddle.c b/ext/fiddle/fiddle.c
index f420d9fa3bb5..5c65e8e2e651 100644
--- a/ext/fiddle/fiddle.c
+++ b/ext/fiddle/fiddle.c
@@ -679,25 +679,25 @@ Init_fiddle(void)
      *
      * The value of Qtrue
      */
-    rb_define_const(mFiddle, "Qtrue", INT2NUM(Qtrue));
+    rb_define_const(mFiddle, "Qtrue", INT2NUM((uintptr_t)Qtrue));
 
     /* Document-const: Qfalse
      *
      * The value of Qfalse
      */
-    rb_define_const(mFiddle, "Qfalse", INT2NUM(Qfalse));
+    rb_define_const(mFiddle, "Qfalse", INT2NUM((uintptr_t)Qfalse));
 
     /* Document-const: Qnil
      *
      * The value of Qnil
      */
-    rb_define_const(mFiddle, "Qnil", INT2NUM(Qnil));
+    rb_define_const(mFiddle, "Qnil", INT2NUM((uintptr_t)Qnil));
 
     /* Document-const: Qundef
      *
      * The value of Qundef
      */
-    rb_define_const(mFiddle, "Qundef", INT2NUM(Qundef));
+    rb_define_const(mFiddle, "Qundef", INT2NUM((uintptr_t)Qundef));
 
     Init_fiddle_function();
     Init_fiddle_closure();
diff --git a/ext/io/console/console.c b/ext/io/console/console.c
index 78eb11a209e8..a05b56c3501c 100644
--- a/ext/io/console/console.c
+++ b/ext/io/console/console.c
@@ -205,17 +205,17 @@ rawmode_opt(int *argcp, VALUE *argv, int min_argc, int max_argc, rawmode_arg_t *
 	    opts->vtime = NUM2INT(vtime);
 	    optp = opts;
 	}
-	switch (intr) {
-	  case Qtrue:
+	switch ((uintptr_t)intr) {
+	  case (uintptr_t)Qtrue:
 	    opts->intr = 1;
 	    optp = opts;
 	    break;
-	  case Qfalse:
+	  case (uintptr_t)Qfalse:
 	    opts->intr = 0;
 	    optp = opts;
 	    break;
-	  case Qundef:
-	  case Qnil:
+	  case (uintptr_t)Qundef:
+	  case (uintptr_t)Qnil:
 	    break;
 	  default:
 	    rb_raise(rb_eArgError, "true or false expected as intr: %"PRIsVALUE,
diff --git a/ext/json/generator/generator.c b/ext/json/generator/generator.c
index 6d78284bc444..762f4fb6271c 100644
--- a/ext/json/generator/generator.c
+++ b/ext/json/generator/generator.c
@@ -1442,7 +1442,7 @@ static VALUE cState_max_nesting_set(VALUE self, VALUE depth)
 {
     GET_STATE(self);
     Check_Type(depth, T_FIXNUM);
-    return state->max_nesting = FIX2LONG(depth);
+    return (VALUE)(state->max_nesting = FIX2LONG(depth));
 }
 
 /*
diff --git a/ext/objspace/object_tracing.c b/ext/objspace/object_tracing.c
index c1c93c51f5fe..041e2e70cc6d 100644
--- a/ext/objspace/object_tracing.c
+++ b/ext/objspace/object_tracing.c
@@ -47,7 +47,7 @@ make_unique_str(st_table *tbl, const char *str, long len)
             result = (char *)ruby_xmalloc(len+1);
             strncpy(result, str, len);
             result[len] = 0;
-            st_add_direct(tbl, (st_data_t)result, 1);
+            st_add_direct(tbl, (st_data_t)result, (st_data_t)1);
         }
         return result;
     }
diff --git a/ext/objspace/objspace.h b/ext/objspace/objspace.h
index 95b84d6c1e0d..12514400297a 100644
--- a/ext/objspace/objspace.h
+++ b/ext/objspace/objspace.h
@@ -5,7 +5,7 @@
 struct allocation_info {
     /* all of information don't need marking. */
     int living;
-    VALUE flags;
+    uintptr_t flags;
     VALUE klass;
 
     /* allocation info */
diff --git a/ext/objspace/objspace_dump.c b/ext/objspace/objspace_dump.c
index 1812ba1d08c6..55ddcb34e431 100644
--- a/ext/objspace/objspace_dump.c
+++ b/ext/objspace/objspace_dump.c
@@ -176,8 +176,8 @@ dump_append_ptr(struct dump_config *dc, VALUE ref)
     buffer_start = buffer_end = &buffer[sizeof(buffer)];
     *--buffer_start = '"';
     while (ref) {
-        *--buffer_start = ruby_hexdigits[ref & 0xF];
-        ref >>= 4;
+        *--buffer_start = ruby_hexdigits[(uintptr_t)ref & 0xF];
+        ref = (VALUE)((uintptr_t)ref >> 4);
     }
     *--buffer_start = 'x';
     *--buffer_start = '0';
diff --git a/ext/openssl/ossl.c b/ext/openssl/ossl.c
index 00eded55cb9a..744ace5fe101 100644
--- a/ext/openssl/ossl.c
+++ b/ext/openssl/ossl.c
@@ -109,7 +109,7 @@ ossl_str_new(const char *ptr, long len, int *pstate)
     VALUE str;
     int state;
 
-    str = rb_protect(ossl_str_new_i, len, &state);
+    str = rb_protect(ossl_str_new_i, (VALUE)len, &state);
     if (pstate)
 	*pstate = state;
     if (state) {
diff --git a/ext/openssl/ossl_asn1.c b/ext/openssl/ossl_asn1.c
index f26a4759cf78..04dd11bad550 100644
--- a/ext/openssl/ossl_asn1.c
+++ b/ext/openssl/ossl_asn1.c
@@ -1758,7 +1758,7 @@ Init_ossl_asn1(void)
      * _tagging_ is not set when a ASN.1 structure is parsed using
      * OpenSSL::ASN1.decode.
      */
-    rb_attr(cASN1Primitive, rb_intern("tagging"), 1, 1, Qtrue);
+    rb_attr(cASN1Primitive, rb_intern("tagging"), 1, 1, (int)Qtrue);
     rb_undef_method(cASN1Primitive, "indefinite_length=");
     rb_undef_method(cASN1Primitive, "infinite_length=");
     rb_define_method(cASN1Primitive, "initialize", ossl_asn1_initialize, -1);
@@ -1799,7 +1799,7 @@ Init_ossl_asn1(void)
      * _tagging_ is not set when a ASN.1 structure is parsed using
      * OpenSSL::ASN1.decode.
      */
-    rb_attr(cASN1Constructive, rb_intern("tagging"), 1, 1, Qtrue);
+    rb_attr(cASN1Constructive, rb_intern("tagging"), 1, 1, (int)Qtrue);
     rb_define_method(cASN1Constructive, "initialize", ossl_asn1_initialize, -1);
     rb_define_method(cASN1Constructive, "to_der", ossl_asn1cons_to_der, 0);
     rb_define_method(cASN1Constructive, "each", ossl_asn1cons_each, 0);
diff --git a/ext/openssl/ossl_bn.c b/ext/openssl/ossl_bn.c
index ce0d3ec7eed1..baddf2c622f8 100644
--- a/ext/openssl/ossl_bn.c
+++ b/ext/openssl/ossl_bn.c
@@ -385,7 +385,7 @@ ossl_bn_to_i(VALUE self)
     if (!(txt = BN_bn2hex(bn))) {
 	ossl_raise(eBNError, NULL);
     }
-    num = rb_cstr_to_inum(txt, 16, Qtrue);
+    num = rb_cstr_to_inum(txt, 16, (int)Qtrue);
     OPENSSL_free(txt);
 
     return num;
diff --git a/ext/openssl/ossl_pkcs12.c b/ext/openssl/ossl_pkcs12.c
index 164b2da465fb..cbf5fc88116b 100644
--- a/ext/openssl/ossl_pkcs12.c
+++ b/ext/openssl/ossl_pkcs12.c
@@ -267,9 +267,10 @@ Init_ossl_pkcs12(void)
 
     rb_define_alloc_func(cPKCS12, ossl_pkcs12_s_allocate);
     rb_define_method(cPKCS12, "initialize_copy", ossl_pkcs12_initialize_copy, 1);
-    rb_attr(cPKCS12, rb_intern("key"), 1, 0, Qfalse);
-    rb_attr(cPKCS12, rb_intern("certificate"), 1, 0, Qfalse);
-    rb_attr(cPKCS12, rb_intern("ca_certs"), 1, 0, Qfalse);
+
+    rb_attr(cPKCS12, rb_intern("key"), 1, 0, (int)Qfalse);
+    rb_attr(cPKCS12, rb_intern("certificate"), 1, 0, (int)Qfalse);
+    rb_attr(cPKCS12, rb_intern("ca_certs"), 1, 0, (int)Qfalse);
     rb_define_method(cPKCS12, "initialize", ossl_pkcs12_initialize, -1);
     rb_define_method(cPKCS12, "to_der", ossl_pkcs12_to_der, 0);
 }
diff --git a/ext/openssl/ossl_pkcs7.c b/ext/openssl/ossl_pkcs7.c
index 7e5fb9c1b2da..7ea107e771a0 100644
--- a/ext/openssl/ossl_pkcs7.c
+++ b/ext/openssl/ossl_pkcs7.c
@@ -389,7 +389,7 @@ ossl_pkcs7_copy(VALUE self, VALUE other)
 static int
 ossl_pkcs7_sym2typeid(VALUE sym)
 {
-    int i, ret = Qnil;
+    int i, ret = (int)Qnil;
     const char *s;
     size_t l;
 
@@ -1032,8 +1032,8 @@ Init_ossl_pkcs7(void)
     rb_define_singleton_method(cPKCS7, "write_smime", ossl_pkcs7_s_write_smime, -1);
     rb_define_singleton_method(cPKCS7, "sign",  ossl_pkcs7_s_sign, -1);
     rb_define_singleton_method(cPKCS7, "encrypt", ossl_pkcs7_s_encrypt, -1);
-    rb_attr(cPKCS7, rb_intern("data"), 1, 0, Qfalse);
-    rb_attr(cPKCS7, rb_intern("error_string"), 1, 1, Qfalse);
+    rb_attr(cPKCS7, rb_intern("data"), 1, 0, (int)Qfalse);
+    rb_attr(cPKCS7, rb_intern("error_string"), 1, 1, (int)Qfalse);
     rb_define_alloc_func(cPKCS7, ossl_pkcs7_alloc);
     rb_define_method(cPKCS7, "initialize_copy", ossl_pkcs7_copy, 1);
     rb_define_method(cPKCS7, "initialize", ossl_pkcs7_initialize, -1);
diff --git a/ext/openssl/ossl_pkey_ec.c b/ext/openssl/ossl_pkey_ec.c
index 4b3a1fd0febb..2b25aaabb1b6 100644
--- a/ext/openssl/ossl_pkey_ec.c
+++ b/ext/openssl/ossl_pkey_ec.c
@@ -955,7 +955,7 @@ static VALUE ossl_ec_group_get_point_conversion_form(VALUE self)
 {
     EC_GROUP *group = NULL;
     point_conversion_form_t form;
-    VALUE ret;
+    ID ret;
 
     GetECGroup(self, group);
     form = EC_GROUP_get_point_conversion_form(group);
diff --git a/ext/openssl/ossl_ssl.c b/ext/openssl/ossl_ssl.c
index 236d455ff2a4..386fac0d1727 100644
--- a/ext/openssl/ossl_ssl.c
+++ b/ext/openssl/ossl_ssl.c
@@ -2640,7 +2640,7 @@ Init_ossl_ssl(void)
      * The _cert_, _key_, and _extra_chain_cert_ attributes are deprecated.
      * It is recommended to use #add_certificate instead.
      */
-    rb_attr(cSSLContext, rb_intern_const("cert"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("cert"), 1, 1, (int)Qfalse);
 
     /*
      * Context private key
@@ -2648,29 +2648,29 @@ Init_ossl_ssl(void)
      * The _cert_, _key_, and _extra_chain_cert_ attributes are deprecated.
      * It is recommended to use #add_certificate instead.
      */
-    rb_attr(cSSLContext, rb_intern_const("key"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("key"), 1, 1, (int)Qfalse);
 
     /*
      * A certificate or Array of certificates that will be sent to the client.
      */
-    rb_attr(cSSLContext, rb_intern_const("client_ca"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("client_ca"), 1, 1, (int)Qfalse);
 
     /*
      * The path to a file containing a PEM-format CA certificate
      */
-    rb_attr(cSSLContext, rb_intern_const("ca_file"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("ca_file"), 1, 1, (int)Qfalse);
 
     /*
      * The path to a directory containing CA certificates in PEM format.
      *
      * Files are looked up by subject's X509 name's hash value.
      */
-    rb_attr(cSSLContext, rb_intern_const("ca_path"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("ca_path"), 1, 1, (int)Qfalse);
 
     /*
      * Maximum session lifetime in seconds.
      */
-    rb_attr(cSSLContext, rb_intern_const("timeout"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("timeout"), 1, 1, (int)Qfalse);
 
     /*
      * Session verification mode.
@@ -2683,12 +2683,12 @@ Init_ossl_ssl(void)
      *
      * See SSL_CTX_set_verify(3) for details.
      */
-    rb_attr(cSSLContext, rb_intern_const("verify_mode"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("verify_mode"), 1, 1, (int)Qfalse);
 
     /*
      * Number of CA certificates to walk when verifying a certificate chain.
      */
-    rb_attr(cSSLContext, rb_intern_const("verify_depth"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("verify_depth"), 1, 1, (int)Qfalse);
 
     /*
      * A callback for additional certificate verification.  The callback is
@@ -2702,7 +2702,7 @@ Init_ossl_ssl(void)
      * If the callback returns +false+, the chain verification is immediately
      * stopped and a bad_certificate alert is then sent.
      */
-    rb_attr(cSSLContext, rb_intern_const("verify_callback"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("verify_callback"), 1, 1, (int)Qfalse);
 
     /*
      * Whether to check the server certificate is valid for the hostname.
@@ -2710,12 +2710,12 @@ Init_ossl_ssl(void)
      * In order to make this work, verify_mode must be set to VERIFY_PEER and
      * the server hostname must be given by OpenSSL::SSL::SSLSocket#hostname=.
      */
-    rb_attr(cSSLContext, rb_intern_const("verify_hostname"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("verify_hostname"), 1, 1, (int)Qfalse);
 
     /*
      * An OpenSSL::X509::Store used for certificate verification.
      */
-    rb_attr(cSSLContext, rb_intern_const("cert_store"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("cert_store"), 1, 1, (int)Qfalse);
 
     /*
      * An Array of extra X509 certificates to be added to the certificate
@@ -2724,7 +2724,7 @@ Init_ossl_ssl(void)
      * The _cert_, _key_, and _extra_chain_cert_ attributes are deprecated.
      * It is recommended to use #add_certificate instead.
      */
-    rb_attr(cSSLContext, rb_intern_const("extra_chain_cert"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("extra_chain_cert"), 1, 1, (int)Qfalse);
 
     /*
      * A callback invoked when a client certificate is requested by a server
@@ -2734,14 +2734,14 @@ Init_ossl_ssl(void)
      * containing an OpenSSL::X509::Certificate and an OpenSSL::PKey.  If any
      * other value is returned the handshake is suspended.
      */
-    rb_attr(cSSLContext, rb_intern_const("client_cert_cb"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("client_cert_cb"), 1, 1, (int)Qfalse);
 
     /*
      * Sets the context in which a session can be reused.  This allows
      * sessions for multiple applications to be distinguished, for example, by
      * name.
      */
-    rb_attr(cSSLContext, rb_intern_const("session_id_context"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("session_id_context"), 1, 1, (int)Qfalse);
 
     /*
      * A callback invoked on a server when a session is proposed by the client
@@ -2750,7 +2750,7 @@ Init_ossl_ssl(void)
      * The callback is invoked with the SSLSocket and session id.  The
      * callback may return a Session from an external cache.
      */
-    rb_attr(cSSLContext, rb_intern_const("session_get_cb"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("session_get_cb"), 1, 1, (int)Qfalse);
 
     /*
      * A callback invoked when a new session was negotiated.
@@ -2758,7 +2758,7 @@ Init_ossl_ssl(void)
      * The callback is invoked with an SSLSocket.  If +false+ is returned the
      * session will be removed from the internal cache.
      */
-    rb_attr(cSSLContext, rb_intern_const("session_new_cb"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("session_new_cb"), 1, 1, (int)Qfalse);
 
     /*
      * A callback invoked when a session is removed from the internal cache.
@@ -2769,7 +2769,7 @@ Init_ossl_ssl(void)
      * multi-threaded application. The callback is called inside a global lock
      * and it can randomly cause deadlock on Ruby thread switching.
      */
-    rb_attr(cSSLContext, rb_intern_const("session_remove_cb"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("session_remove_cb"), 1, 1, (int)Qfalse);
 
     /*
      * A callback invoked whenever a new handshake is initiated on an
@@ -2790,7 +2790,7 @@ Init_ossl_ssl(void)
      *     raise RuntimeError, "Client renegotiation disabled"
      *   end
      */
-    rb_attr(cSSLContext, rb_intern_const("renegotiation_cb"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("renegotiation_cb"), 1, 1, (int)Qfalse);
 #ifdef OSSL_USE_NEXTPROTONEG
     /*
      * An Enumerable of Strings. Each String represents a protocol to be
@@ -2803,7 +2803,7 @@ Init_ossl_ssl(void)
      *
      *   ctx.npn_protocols = ["http/1.1", "spdy/2"]
      */
-    rb_attr(cSSLContext, rb_intern_const("npn_protocols"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("npn_protocols"), 1, 1, (int)Qfalse);
     /*
      * A callback invoked on the client side when the client needs to select
      * a protocol from the list sent by the server. Supported in OpenSSL 1.0.1
@@ -2820,7 +2820,7 @@ Init_ossl_ssl(void)
      *     protocols.first
      *   end
      */
-    rb_attr(cSSLContext, rb_intern_const("npn_select_cb"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("npn_select_cb"), 1, 1, (int)Qfalse);
 #endif
 
     /*
@@ -2834,7 +2834,7 @@ Init_ossl_ssl(void)
      *
      *   ctx.alpn_protocols = ["http/1.1", "spdy/2", "h2"]
      */
-    rb_attr(cSSLContext, rb_intern_const("alpn_protocols"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("alpn_protocols"), 1, 1, (int)Qfalse);
     /*
      * A callback invoked on the server side when the server needs to select
      * a protocol from the list sent by the client. Supported in OpenSSL 1.0.2
@@ -2851,7 +2851,7 @@ Init_ossl_ssl(void)
      *     protocols.first
      *   end
      */
-    rb_attr(cSSLContext, rb_intern_const("alpn_select_cb"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("alpn_select_cb"), 1, 1, (int)Qfalse);
 
     /*
      * A callback invoked when TLS key material is generated or received, in
@@ -2874,7 +2874,7 @@ Init_ossl_ssl(void)
      *     end
      *   end
      */
-    rb_attr(cSSLContext, rb_intern_const("keylog_cb"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("keylog_cb"), 1, 1, (int)Qfalse);
 
     rb_define_alias(cSSLContext, "ssl_timeout", "timeout");
     rb_define_alias(cSSLContext, "ssl_timeout=", "timeout=");
diff --git a/ext/openssl/ossl_x509ext.c b/ext/openssl/ossl_x509ext.c
index 192d09bd3fea..2ffacd4c00ff 100644
--- a/ext/openssl/ossl_x509ext.c
+++ b/ext/openssl/ossl_x509ext.c
@@ -469,11 +469,11 @@ Init_ossl_x509ext(void)
     rb_define_alloc_func(cX509ExtFactory, ossl_x509extfactory_alloc);
     rb_define_method(cX509ExtFactory, "initialize", ossl_x509extfactory_initialize, -1);
 
-    rb_attr(cX509ExtFactory, rb_intern("issuer_certificate"), 1, 0, Qfalse);
-    rb_attr(cX509ExtFactory, rb_intern("subject_certificate"), 1, 0, Qfalse);
-    rb_attr(cX509ExtFactory, rb_intern("subject_request"), 1, 0, Qfalse);
-    rb_attr(cX509ExtFactory, rb_intern("crl"), 1, 0, Qfalse);
-    rb_attr(cX509ExtFactory, rb_intern("config"), 1, 1, Qfalse);
+    rb_attr(cX509ExtFactory, rb_intern("issuer_certificate"), 1, 0, (int)Qfalse);
+    rb_attr(cX509ExtFactory, rb_intern("subject_certificate"), 1, 0, (int)Qfalse);
+    rb_attr(cX509ExtFactory, rb_intern("subject_request"), 1, 0, (int)Qfalse);
+    rb_attr(cX509ExtFactory, rb_intern("crl"), 1, 0, (int)Qfalse);
+    rb_attr(cX509ExtFactory, rb_intern("config"), 1, 1, (int)Qfalse);
 
     rb_define_method(cX509ExtFactory, "issuer_certificate=", ossl_x509extfactory_set_issuer_cert, 1);
     rb_define_method(cX509ExtFactory, "subject_certificate=", ossl_x509extfactory_set_subject_cert, 1);
diff --git a/ext/openssl/ossl_x509store.c b/ext/openssl/ossl_x509store.c
index f27381ca905f..6ad557203ae2 100644
--- a/ext/openssl/ossl_x509store.c
+++ b/ext/openssl/ossl_x509store.c
@@ -934,25 +934,25 @@ Init_ossl_x509store(void)
      *
      * See also the man page X509_STORE_CTX_set_verify_cb(3).
      */
-    rb_attr(cX509Store, rb_intern("verify_callback"), 1, 0, Qfalse);
+    rb_attr(cX509Store, rb_intern("verify_callback"), 1, 0, (int)Qfalse);
     /*
      * The error code set by the last call of #verify.
      *
      * See also StoreContext#error.
      */
-    rb_attr(cX509Store, rb_intern("error"), 1, 0, Qfalse);
+    rb_attr(cX509Store, rb_intern("error"), 1, 0, (int)Qfalse);
     /*
      * The description for the error code set by the last call of #verify.
      *
      * See also StoreContext#error_string.
      */
-    rb_attr(cX509Store, rb_intern("error_string"), 1, 0, Qfalse);
+    rb_attr(cX509Store, rb_intern("error_string"), 1, 0, (int)Qfalse);
     /*
      * The certificate chain constructed by the last call of #verify.
      *
      * See also StoreContext#chain.
      */
-    rb_attr(cX509Store, rb_intern("chain"), 1, 0, Qfalse);
+    rb_attr(cX509Store, rb_intern("chain"), 1, 0, (int)Qfalse);
     rb_define_alloc_func(cX509Store, ossl_x509store_alloc);
     rb_define_method(cX509Store, "initialize",   ossl_x509store_initialize, -1);
     rb_undef_method(cX509Store, "initialize_copy");
diff --git a/ext/ripper/ripper.c b/ext/ripper/ripper.c
index 6c97cb50ddb7..8db8c8d9f699 100644
--- a/ext/ripper/ripper.c
+++ b/ext/ripper/ripper.c
@@ -405,7 +405,7 @@ RBIMPL_WARNING_POP()
     parser_set_lex_state(p, ls, __LINE__)
 static inline enum lex_state_e parser_set_lex_state(struct parser_params *p, enum lex_state_e ls, int line);
 
-typedef VALUE stack_type;
+typedef uintptr_t stack_type;
 
 static const rb_code_location_t NULL_LOC = { {0, -1}, {0, -1} };
 
@@ -1512,6 +1512,7 @@ void ripper_error(struct parser_params *p);
 
 #define yyparse ripper_yyparse
 
+#define THINGY(tok) ((VALUE)(tok))
 #define ID2VAL(id) STATIC_ID2SYM(id)
 #define TOKEN2VAL(t) ID2VAL(TOKEN2ID(t))
 #define KWD2EID(t, v) ripper_new_yylval(p, keyword_##t, get_value(v), 0)
@@ -1557,7 +1558,7 @@ new_array_pattern(struct parser_params *p, VALUE constant, VALUE pre_arg, VALUE
 }
 
 static VALUE
-new_array_pattern_tail(struct parser_params *p, VALUE pre_args, VALUE has_rest, VALUE rest_arg, VALUE post_args, const YYLTYPE *loc)
+new_array_pattern_tail(struct parser_params *p, VALUE pre_args, int has_rest, VALUE rest_arg, VALUE post_args, const YYLTYPE *loc)
 {
     return ripper_new_yylval2(p, pre_args, rest_arg, post_args);
 }
@@ -1610,6 +1611,7 @@ new_hash_pattern_tail(struct parser_params *p, VALUE kw_args, VALUE kw_rest_arg,
 static VALUE heredoc_dedent(struct parser_params*,VALUE);
 
 #else
+#define THINGY(tok) (tok)
 #define ID2VAL(id) (id)
 #define TOKEN2VAL(t) ID2VAL(t)
 #define KWD2EID(t, v) keyword_##t
@@ -1963,7 +1965,7 @@ get_nd_args(struct parser_params *p, NODE *node)
 }
 #endif
 
-#line 1967 "ripper.c"
+#line 1969 "ripper.c"
 
 # ifndef YY_CAST
 #  ifdef __cplusplus
@@ -2142,7 +2144,7 @@ extern int yydebug;
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 union YYSTYPE
 {
-#line 1962 "ripper.y"
+#line 1964 "ripper.y"
 
     VALUE val;
     NODE *node;
@@ -2162,7 +2164,7 @@ union YYSTYPE
     struct rb_strterm_struct *strterm;
     struct lex_context ctxt;
 
-#line 2166 "ripper.c"
+#line 2168 "ripper.c"
 
 };
 typedef union YYSTYPE YYSTYPE;
@@ -3035,85 +3037,85 @@ static const yytype_uint8 yytranslate[] =
 /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
 static const yytype_int16 yyrline[] =
 {
-       0,  2193,  2193,  2193,  2221,  2227,  2234,  2241,  2250,  2255,
-    2261,  2263,  2279,  2284,  2275,  2297,  2294,  2309,  2315,  2322,
-    2329,  2338,  2343,  2342,  2352,  2354,  2360,  2360,  2367,  2374,
-    2384,  2393,  2400,  2408,  2416,  2429,  2442,  2453,  2468,  2469,
-    2477,  2484,  2497,  2504,  2505,  2514,  2521,  2528,  2536,  2543,
-    2550,  2558,  2565,  2578,  2591,  2601,  2602,  2610,  2616,  2621,
-    2631,  2634,  2635,  2639,  2643,  2647,  2652,  2651,  2667,  2666,
-    2681,  2684,  2696,  2709,  2708,  2728,  2733,  2741,  2741,  2741,
-    2747,  2748,  2751,  2752,  2761,  2770,  2779,  2788,  2799,  2806,
-    2813,  2820,  2827,  2835,  2843,  2851,  2858,  2867,  2878,  2879,
-    2888,  2889,  2898,  2905,  2912,  2919,  2926,  2933,  2940,  2947,
-    2954,  2961,  2970,  2971,  2980,  2987,  2996,  3003,  3012,  3019,
-    3026,  3033,  3041,  3048,  3056,  3063,  3070,  3080,  3087,  3094,
-    3101,  3108,  3115,  3122,  3129,  3136,  3146,  3154,  3157,  3164,
-    3171,  3180,  3181,  3182,  3183,  3188,  3191,  3198,  3201,  3208,
-    3208,  3218,  3219,  3220,  3221,  3222,  3223,  3224,  3225,  3226,
-    3227,  3228,  3229,  3230,  3231,  3232,  3233,  3234,  3235,  3236,
-    3237,  3238,  3239,  3240,  3241,  3242,  3243,  3244,  3245,  3246,
-    3247,  3250,  3250,  3250,  3251,  3251,  3252,  3252,  3252,  3253,
-    3253,  3253,  3253,  3254,  3254,  3254,  3254,  3255,  3255,  3255,
-    3256,  3256,  3256,  3256,  3257,  3257,  3257,  3257,  3258,  3258,
-    3258,  3258,  3259,  3259,  3259,  3259,  3260,  3260,  3260,  3260,
-    3261,  3261,  3264,  3271,  3278,  3285,  3292,  3299,  3306,  3314,
-    3322,  3330,  3339,  3348,  3356,  3364,  3372,  3380,  3384,  3388,
-    3392,  3396,  3400,  3404,  3408,  3412,  3416,  3420,  3424,  3428,
-    3432,  3433,  3437,  3441,  3445,  3449,  3453,  3457,  3461,  3465,
-    3469,  3473,  3477,  3482,  3491,  3504,  3517,  3523,  3524,  3532,
-    3538,  3539,  3540,  3541,  3544,  3548,  3555,  3561,  3568,  3575,
-    3582,  3583,  3587,  3594,  3603,  3608,  3619,  3626,  3638,  3652,
-    3653,  3656,  3657,  3658,  3662,  3669,  3678,  3686,  3693,  3701,
-    3709,  3713,  3713,  3750,  3757,  3767,  3771,  3778,  3785,  3792,
-    3799,  3809,  3813,  3824,  3825,  3829,  3836,  3843,  3852,  3853,
-    3854,  3855,  3856,  3857,  3858,  3859,  3860,  3861,  3862,  3870,
-    3869,  3884,  3884,  3892,  3900,  3907,  3914,  3921,  3929,  3936,
-    3943,  3950,  3957,  3962,  3966,  3970,  3977,  3978,  3986,  3987,
-    3998,  4009,  4020,  4032,  4031,  4048,  4047,  4062,  4071,  4116,
-    4115,  4134,  4133,  4154,  4153,  4173,  4171,  4192,  4190,  4209,
-    4214,  4219,  4224,  4241,  4248,  4257,  4277,  4286,  4296,  4306,
-    4315,  4325,  4336,  4347,  4355,  4364,  4373,  4381,  4388,  4394,
-    4409,  4416,  4423,  4429,  4436,  4443,  4444,  4445,  4448,  4449,
-    4452,  4453,  4465,  4466,  4475,  4476,  4479,  4487,  4496,  4503,
-    4512,  4519,  4526,  4533,  4540,  4549,  4557,  4566,  4567,  4570,
-    4570,  4572,  4576,  4580,  4584,  4590,  4595,  4600,  4610,  4614,
-    4618,  4622,  4626,  4630,  4635,  4639,  4643,  4647,  4651,  4655,
-    4659,  4663,  4667,  4673,  4674,  4680,  4691,  4704,  4708,  4717,
-    4719,  4723,  4728,  4734,  4740,  4746,  4754,  4745,  4780,  4789,
-    4800,  4806,  4805,  4817,  4826,  4840,  4847,  4854,  4863,  4872,
-    4880,  4888,  4895,  4903,  4911,  4918,  4925,  4935,  4942,  4951,
-    4951,  4968,  4968,  4989,  4997,  5004,  5012,  5021,  5033,  5034,
-    5037,  5038,  5040,  5051,  5048,  5066,  5067,  5070,  5071,  5079,
-    5089,  5090,  5095,  5103,  5107,  5111,  5117,  5120,  5129,  5132,
-    5139,  5142,  5143,  5145,  5146,  5147,  5156,  5165,  5174,  5179,
-    5188,  5197,  5206,  5211,  5215,  5219,  5225,  5224,  5234,  5239,
-    5246,  5255,  5259,  5268,  5272,  5276,  5279,  5283,  5292,  5296,
-    5302,  5309,  5317,  5326,  5327,  5336,  5345,  5349,  5353,  5357,
-    5363,  5365,  5374,  5382,  5396,  5397,  5420,  5424,  5430,  5436,
-    5437,  5440,  5441,  5450,  5459,  5467,  5475,  5476,  5477,  5478,
-    5486,  5496,  5497,  5498,  5499,  5500,  5501,  5502,  5503,  5504,
-    5511,  5514,  5524,  5535,  5544,  5553,  5560,  5567,  5576,  5600,
-    5603,  5610,  5617,  5620,  5624,  5627,  5635,  5638,  5639,  5642,
-    5659,  5660,  5661,  5670,  5680,  5689,  5695,  5696,  5699,  5709,
-    5715,  5724,  5726,  5735,  5745,  5751,  5760,  5769,  5779,  5785,
-    5795,  5801,  5811,  5821,  5840,  5846,  5856,  5866,  5907,  5910,
-    5909,  5926,  5935,  5939,  5925,  5960,  5961,  5964,  5971,  5974,
-    5975,  5978,  5988,  5989,  5992,  6002,  6003,  6013,  6014,  6015,
-    6016,  6019,  6020,  6021,  6024,  6025,  6026,  6029,  6030,  6031,
-    6032,  6033,  6034,  6035,  6038,  6051,  6060,  6067,  6076,  6077,
-    6081,  6080,  6090,  6098,  6099,  6107,  6119,  6120,  6120,  6136,
-    6140,  6144,  6148,  6152,  6162,  6167,  6172,  6176,  6180,  6184,
-    6188,  6192,  6196,  6200,  6204,  6208,  6212,  6216,  6220,  6224,
-    6229,  6235,  6248,  6257,  6266,  6275,  6286,  6287,  6295,  6304,
-    6312,  6333,  6335,  6348,  6358,  6367,  6378,  6386,  6396,  6403,
-    6413,  6420,  6429,  6430,  6433,  6441,  6449,  6459,  6470,  6481,
-    6488,  6497,  6504,  6513,  6514,  6517,  6525,  6535,  6536,  6539,
-    6547,  6557,  6561,  6567,  6572,  6572,  6598,  6599,  6608,  6610,
-    6633,  6644,  6651,  6660,  6668,  6685,  6696,  6697,  6698,  6701,
-    6702,  6705,  6706,  6707,  6710,  6711,  6714,  6715,  6718,  6719,
-    6722,  6723,  6726,  6727,  6730,  6733,  6736,  6739,  6740,  6743,
-    6744,  6751,  6752,  6756
+       0,  2195,  2195,  2195,  2223,  2229,  2236,  2243,  2252,  2257,
+    2263,  2265,  2281,  2286,  2277,  2299,  2296,  2311,  2317,  2324,
+    2331,  2340,  2345,  2344,  2354,  2356,  2362,  2362,  2369,  2376,
+    2386,  2395,  2402,  2410,  2418,  2431,  2444,  2455,  2470,  2471,
+    2479,  2486,  2499,  2506,  2507,  2516,  2523,  2530,  2538,  2545,
+    2552,  2560,  2567,  2580,  2593,  2603,  2604,  2612,  2618,  2623,
+    2633,  2636,  2637,  2641,  2645,  2649,  2654,  2653,  2669,  2668,
+    2683,  2686,  2698,  2711,  2710,  2730,  2735,  2743,  2743,  2743,
+    2749,  2750,  2753,  2754,  2763,  2772,  2781,  2790,  2801,  2808,
+    2815,  2822,  2829,  2837,  2845,  2853,  2860,  2869,  2880,  2881,
+    2890,  2891,  2900,  2907,  2914,  2921,  2928,  2935,  2942,  2949,
+    2956,  2963,  2972,  2973,  2982,  2989,  2998,  3005,  3014,  3021,
+    3028,  3035,  3043,  3050,  3058,  3065,  3072,  3082,  3089,  3096,
+    3103,  3110,  3117,  3124,  3131,  3138,  3148,  3156,  3159,  3166,
+    3173,  3182,  3183,  3184,  3185,  3190,  3193,  3200,  3203,  3210,
+    3210,  3220,  3221,  3222,  3223,  3224,  3225,  3226,  3227,  3228,
+    3229,  3230,  3231,  3232,  3233,  3234,  3235,  3236,  3237,  3238,
+    3239,  3240,  3241,  3242,  3243,  3244,  3245,  3246,  3247,  3248,
+    3249,  3252,  3252,  3252,  3253,  3253,  3254,  3254,  3254,  3255,
+    3255,  3255,  3255,  3256,  3256,  3256,  3256,  3257,  3257,  3257,
+    3258,  3258,  3258,  3258,  3259,  3259,  3259,  3259,  3260,  3260,
+    3260,  3260,  3261,  3261,  3261,  3261,  3262,  3262,  3262,  3262,
+    3263,  3263,  3266,  3273,  3280,  3287,  3294,  3301,  3308,  3316,
+    3324,  3332,  3341,  3350,  3358,  3366,  3374,  3382,  3386,  3390,
+    3394,  3398,  3402,  3406,  3410,  3414,  3418,  3422,  3426,  3430,
+    3434,  3435,  3439,  3443,  3447,  3451,  3455,  3459,  3463,  3467,
+    3471,  3475,  3479,  3484,  3493,  3506,  3519,  3525,  3526,  3534,
+    3540,  3541,  3542,  3543,  3546,  3550,  3557,  3563,  3570,  3577,
+    3584,  3585,  3589,  3596,  3605,  3610,  3621,  3628,  3640,  3654,
+    3655,  3658,  3659,  3660,  3664,  3671,  3680,  3688,  3695,  3703,
+    3711,  3715,  3715,  3752,  3759,  3769,  3773,  3780,  3787,  3794,
+    3801,  3811,  3815,  3826,  3827,  3831,  3838,  3845,  3854,  3855,
+    3856,  3857,  3858,  3859,  3860,  3861,  3862,  3863,  3864,  3872,
+    3871,  3886,  3886,  3894,  3902,  3909,  3916,  3923,  3931,  3938,
+    3945,  3952,  3959,  3964,  3968,  3972,  3979,  3980,  3988,  3989,
+    4000,  4011,  4022,  4034,  4033,  4050,  4049,  4064,  4073,  4118,
+    4117,  4136,  4135,  4156,  4155,  4175,  4173,  4194,  4192,  4211,
+    4216,  4221,  4226,  4243,  4250,  4259,  4279,  4288,  4298,  4308,
+    4317,  4327,  4338,  4349,  4357,  4366,  4375,  4383,  4390,  4396,
+    4411,  4418,  4425,  4431,  4438,  4445,  4446,  4447,  4450,  4451,
+    4454,  4455,  4467,  4468,  4477,  4478,  4481,  4489,  4498,  4505,
+    4514,  4521,  4528,  4535,  4542,  4551,  4559,  4568,  4569,  4572,
+    4572,  4574,  4578,  4582,  4586,  4592,  4597,  4602,  4612,  4616,
+    4620,  4624,  4628,  4632,  4637,  4641,  4645,  4649,  4653,  4657,
+    4661,  4665,  4669,  4675,  4676,  4682,  4693,  4706,  4710,  4719,
+    4721,  4725,  4730,  4736,  4742,  4748,  4756,  4747,  4782,  4791,
+    4802,  4808,  4807,  4819,  4828,  4842,  4849,  4856,  4865,  4874,
+    4882,  4890,  4897,  4905,  4913,  4920,  4927,  4937,  4944,  4953,
+    4953,  4970,  4970,  4991,  4999,  5006,  5014,  5023,  5035,  5036,
+    5039,  5040,  5042,  5053,  5050,  5068,  5069,  5072,  5073,  5081,
+    5091,  5092,  5097,  5105,  5109,  5113,  5119,  5122,  5131,  5134,
+    5141,  5144,  5145,  5147,  5148,  5149,  5158,  5167,  5176,  5181,
+    5190,  5199,  5208,  5213,  5217,  5221,  5227,  5226,  5236,  5241,
+    5248,  5257,  5261,  5270,  5274,  5278,  5281,  5285,  5294,  5298,
+    5304,  5311,  5319,  5328,  5329,  5338,  5347,  5351,  5355,  5359,
+    5365,  5367,  5376,  5384,  5398,  5399,  5422,  5426,  5432,  5438,
+    5439,  5442,  5443,  5452,  5461,  5469,  5477,  5478,  5479,  5480,
+    5488,  5498,  5499,  5500,  5501,  5502,  5503,  5504,  5505,  5506,
+    5513,  5516,  5526,  5537,  5546,  5555,  5562,  5569,  5578,  5602,
+    5605,  5612,  5619,  5622,  5626,  5629,  5637,  5640,  5641,  5644,
+    5661,  5662,  5663,  5672,  5682,  5691,  5697,  5698,  5701,  5711,
+    5717,  5726,  5728,  5737,  5747,  5753,  5762,  5771,  5781,  5787,
+    5797,  5803,  5813,  5823,  5842,  5848,  5858,  5868,  5909,  5912,
+    5911,  5928,  5937,  5941,  5927,  5962,  5963,  5966,  5973,  5976,
+    5977,  5980,  5990,  5991,  5994,  6004,  6005,  6015,  6016,  6017,
+    6018,  6021,  6022,  6023,  6026,  6027,  6028,  6031,  6032,  6033,
+    6034,  6035,  6036,  6037,  6040,  6053,  6062,  6069,  6078,  6079,
+    6083,  6082,  6092,  6100,  6101,  6109,  6121,  6122,  6122,  6138,
+    6142,  6146,  6150,  6154,  6164,  6169,  6174,  6178,  6182,  6186,
+    6190,  6194,  6198,  6202,  6206,  6210,  6214,  6218,  6222,  6226,
+    6231,  6237,  6250,  6259,  6268,  6277,  6288,  6289,  6297,  6306,
+    6314,  6335,  6337,  6350,  6360,  6369,  6380,  6388,  6398,  6405,
+    6415,  6422,  6431,  6432,  6435,  6443,  6451,  6461,  6472,  6483,
+    6490,  6499,  6506,  6515,  6516,  6519,  6527,  6537,  6538,  6541,
+    6549,  6559,  6563,  6569,  6574,  6574,  6600,  6601,  6610,  6612,
+    6635,  6646,  6653,  6662,  6670,  6687,  6698,  6699,  6700,  6703,
+    6704,  6707,  6708,  6709,  6712,  6713,  6716,  6717,  6720,  6721,
+    6724,  6725,  6728,  6729,  6732,  6735,  6738,  6741,  6742,  6745,
+    6746,  6753,  6754,  6758
 };
 #endif
 
@@ -7166,7 +7168,7 @@ yy_symbol_value_print (FILE *yyo,
 switch (yykind)
     {
     case YYSYMBOL_keyword_class: /* "`class'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7178,11 +7180,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7182 "ripper.c"
+#line 7184 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_module: /* "`module'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7194,11 +7196,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7198 "ripper.c"
+#line 7200 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_def: /* "`def'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7210,11 +7212,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7214 "ripper.c"
+#line 7216 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_undef: /* "`undef'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7226,11 +7228,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7230 "ripper.c"
+#line 7232 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_begin: /* "`begin'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7242,11 +7244,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7246 "ripper.c"
+#line 7248 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_rescue: /* "`rescue'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7258,11 +7260,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7262 "ripper.c"
+#line 7264 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_ensure: /* "`ensure'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7274,11 +7276,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7278 "ripper.c"
+#line 7280 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_end: /* "`end'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7290,11 +7292,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7294 "ripper.c"
+#line 7296 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_if: /* "`if'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7306,11 +7308,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7310 "ripper.c"
+#line 7312 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_unless: /* "`unless'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7322,11 +7324,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7326 "ripper.c"
+#line 7328 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_then: /* "`then'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7338,11 +7340,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7342 "ripper.c"
+#line 7344 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_elsif: /* "`elsif'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7354,11 +7356,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7358 "ripper.c"
+#line 7360 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_else: /* "`else'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7370,11 +7372,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7374 "ripper.c"
+#line 7376 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_case: /* "`case'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7386,11 +7388,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7390 "ripper.c"
+#line 7392 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_when: /* "`when'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7402,11 +7404,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7406 "ripper.c"
+#line 7408 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_while: /* "`while'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7418,11 +7420,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7422 "ripper.c"
+#line 7424 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_until: /* "`until'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7434,11 +7436,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7438 "ripper.c"
+#line 7440 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_for: /* "`for'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7450,11 +7452,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7454 "ripper.c"
+#line 7456 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_break: /* "`break'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7466,11 +7468,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7470 "ripper.c"
+#line 7472 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_next: /* "`next'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7482,11 +7484,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7486 "ripper.c"
+#line 7488 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_redo: /* "`redo'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7498,11 +7500,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7502 "ripper.c"
+#line 7504 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_retry: /* "`retry'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7514,11 +7516,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7518 "ripper.c"
+#line 7520 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_in: /* "`in'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7530,11 +7532,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7534 "ripper.c"
+#line 7536 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_do: /* "`do'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7546,11 +7548,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7550 "ripper.c"
+#line 7552 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_do_cond: /* "`do' for condition"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7562,11 +7564,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7566 "ripper.c"
+#line 7568 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_do_block: /* "`do' for block"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7578,11 +7580,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7582 "ripper.c"
+#line 7584 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_do_LAMBDA: /* "`do' for lambda"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7594,11 +7596,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7598 "ripper.c"
+#line 7600 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_return: /* "`return'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7610,11 +7612,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7614 "ripper.c"
+#line 7616 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_yield: /* "`yield'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7626,11 +7628,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7630 "ripper.c"
+#line 7632 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_super: /* "`super'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7642,11 +7644,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7646 "ripper.c"
+#line 7648 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_self: /* "`self'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7658,11 +7660,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7662 "ripper.c"
+#line 7664 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_nil: /* "`nil'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7674,11 +7676,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7678 "ripper.c"
+#line 7680 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_true: /* "`true'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7690,11 +7692,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7694 "ripper.c"
+#line 7696 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_false: /* "`false'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7706,11 +7708,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7710 "ripper.c"
+#line 7712 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_and: /* "`and'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7722,11 +7724,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7726 "ripper.c"
+#line 7728 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_or: /* "`or'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7738,11 +7740,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7742 "ripper.c"
+#line 7744 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_not: /* "`not'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7754,11 +7756,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7758 "ripper.c"
+#line 7760 "ripper.c"
         break;
 
     case YYSYMBOL_modifier_if: /* "`if' modifier"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7770,11 +7772,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7774 "ripper.c"
+#line 7776 "ripper.c"
         break;
 
     case YYSYMBOL_modifier_unless: /* "`unless' modifier"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7786,11 +7788,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7790 "ripper.c"
+#line 7792 "ripper.c"
         break;
 
     case YYSYMBOL_modifier_while: /* "`while' modifier"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7802,11 +7804,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7806 "ripper.c"
+#line 7808 "ripper.c"
         break;
 
     case YYSYMBOL_modifier_until: /* "`until' modifier"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7818,11 +7820,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7822 "ripper.c"
+#line 7824 "ripper.c"
         break;
 
     case YYSYMBOL_modifier_rescue: /* "`rescue' modifier"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7834,11 +7836,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7838 "ripper.c"
+#line 7840 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_alias: /* "`alias'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7850,11 +7852,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7854 "ripper.c"
+#line 7856 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_defined: /* "`defined?'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7866,11 +7868,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7870 "ripper.c"
+#line 7872 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_BEGIN: /* "`BEGIN'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7882,11 +7884,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7886 "ripper.c"
+#line 7888 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_END: /* "`END'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7898,11 +7900,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7902 "ripper.c"
+#line 7904 "ripper.c"
         break;
 
     case YYSYMBOL_keyword__LINE__: /* "`__LINE__'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7914,11 +7916,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7918 "ripper.c"
+#line 7920 "ripper.c"
         break;
 
     case YYSYMBOL_keyword__FILE__: /* "`__FILE__'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7930,11 +7932,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7934 "ripper.c"
+#line 7936 "ripper.c"
         break;
 
     case YYSYMBOL_keyword__ENCODING__: /* "`__ENCODING__'"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -7946,11 +7948,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7950 "ripper.c"
+#line 7952 "ripper.c"
         break;
 
     case YYSYMBOL_tIDENTIFIER: /* "local variable or method"  */
-#line 1926 "ripper.y"
+#line 1928 "ripper.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%"PRIsVALUE, rb_id2str(((*yyvaluep).val)));
@@ -7958,11 +7960,11 @@ switch (yykind)
     rb_parser_printf(p, "%"PRIsVALUE, RNODE_RIPPER(((*yyvaluep).val))->nd_rval);
 #endif
 }
-#line 7962 "ripper.c"
+#line 7964 "ripper.c"
         break;
 
     case YYSYMBOL_tFID: /* "method"  */
-#line 1926 "ripper.y"
+#line 1928 "ripper.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%"PRIsVALUE, rb_id2str(((*yyvaluep).val)));
@@ -7970,11 +7972,11 @@ switch (yykind)
     rb_parser_printf(p, "%"PRIsVALUE, RNODE_RIPPER(((*yyvaluep).val))->nd_rval);
 #endif
 }
-#line 7974 "ripper.c"
+#line 7976 "ripper.c"
         break;
 
     case YYSYMBOL_tGVAR: /* "global variable"  */
-#line 1926 "ripper.y"
+#line 1928 "ripper.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%"PRIsVALUE, rb_id2str(((*yyvaluep).val)));
@@ -7982,11 +7984,11 @@ switch (yykind)
     rb_parser_printf(p, "%"PRIsVALUE, RNODE_RIPPER(((*yyvaluep).val))->nd_rval);
 #endif
 }
-#line 7986 "ripper.c"
+#line 7988 "ripper.c"
         break;
 
     case YYSYMBOL_tIVAR: /* "instance variable"  */
-#line 1926 "ripper.y"
+#line 1928 "ripper.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%"PRIsVALUE, rb_id2str(((*yyvaluep).val)));
@@ -7994,11 +7996,11 @@ switch (yykind)
     rb_parser_printf(p, "%"PRIsVALUE, RNODE_RIPPER(((*yyvaluep).val))->nd_rval);
 #endif
 }
-#line 7998 "ripper.c"
+#line 8000 "ripper.c"
         break;
 
     case YYSYMBOL_tCONSTANT: /* "constant"  */
-#line 1926 "ripper.y"
+#line 1928 "ripper.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%"PRIsVALUE, rb_id2str(((*yyvaluep).val)));
@@ -8006,11 +8008,11 @@ switch (yykind)
     rb_parser_printf(p, "%"PRIsVALUE, RNODE_RIPPER(((*yyvaluep).val))->nd_rval);
 #endif
 }
-#line 8010 "ripper.c"
+#line 8012 "ripper.c"
         break;
 
     case YYSYMBOL_tCVAR: /* "class variable"  */
-#line 1926 "ripper.y"
+#line 1928 "ripper.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%"PRIsVALUE, rb_id2str(((*yyvaluep).val)));
@@ -8018,11 +8020,11 @@ switch (yykind)
     rb_parser_printf(p, "%"PRIsVALUE, RNODE_RIPPER(((*yyvaluep).val))->nd_rval);
 #endif
 }
-#line 8022 "ripper.c"
+#line 8024 "ripper.c"
         break;
 
     case YYSYMBOL_tLABEL: /* "label"  */
-#line 1926 "ripper.y"
+#line 1928 "ripper.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%"PRIsVALUE, rb_id2str(((*yyvaluep).val)));
@@ -8030,11 +8032,11 @@ switch (yykind)
     rb_parser_printf(p, "%"PRIsVALUE, RNODE_RIPPER(((*yyvaluep).val))->nd_rval);
 #endif
 }
-#line 8034 "ripper.c"
+#line 8036 "ripper.c"
         break;
 
     case YYSYMBOL_tINTEGER: /* "integer literal"  */
-#line 1933 "ripper.y"
+#line 1935 "ripper.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%+"PRIsVALUE, RNODE_LIT(((*yyvaluep).val))->nd_lit);
@@ -8042,11 +8044,11 @@ switch (yykind)
     rb_parser_printf(p, "%+"PRIsVALUE, get_value(((*yyvaluep).val)));
 #endif
 }
-#line 8046 "ripper.c"
+#line 8048 "ripper.c"
         break;
 
     case YYSYMBOL_tFLOAT: /* "float literal"  */
-#line 1933 "ripper.y"
+#line 1935 "ripper.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%+"PRIsVALUE, RNODE_LIT(((*yyvaluep).val))->nd_lit);
@@ -8054,11 +8056,11 @@ switch (yykind)
     rb_parser_printf(p, "%+"PRIsVALUE, get_value(((*yyvaluep).val)));
 #endif
 }
-#line 8058 "ripper.c"
+#line 8060 "ripper.c"
         break;
 
     case YYSYMBOL_tRATIONAL: /* "rational literal"  */
-#line 1933 "ripper.y"
+#line 1935 "ripper.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%+"PRIsVALUE, RNODE_LIT(((*yyvaluep).val))->nd_lit);
@@ -8066,11 +8068,11 @@ switch (yykind)
     rb_parser_printf(p, "%+"PRIsVALUE, get_value(((*yyvaluep).val)));
 #endif
 }
-#line 8070 "ripper.c"
+#line 8072 "ripper.c"
         break;
 
     case YYSYMBOL_tIMAGINARY: /* "imaginary literal"  */
-#line 1933 "ripper.y"
+#line 1935 "ripper.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%+"PRIsVALUE, RNODE_LIT(((*yyvaluep).val))->nd_lit);
@@ -8078,11 +8080,11 @@ switch (yykind)
     rb_parser_printf(p, "%+"PRIsVALUE, get_value(((*yyvaluep).val)));
 #endif
 }
-#line 8082 "ripper.c"
+#line 8084 "ripper.c"
         break;
 
     case YYSYMBOL_tCHAR: /* "char literal"  */
-#line 1933 "ripper.y"
+#line 1935 "ripper.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%+"PRIsVALUE, RNODE_LIT(((*yyvaluep).val))->nd_lit);
@@ -8090,11 +8092,11 @@ switch (yykind)
     rb_parser_printf(p, "%+"PRIsVALUE, get_value(((*yyvaluep).val)));
 #endif
 }
-#line 8094 "ripper.c"
+#line 8096 "ripper.c"
         break;
 
     case YYSYMBOL_tNTH_REF: /* "numbered reference"  */
-#line 1940 "ripper.y"
+#line 1942 "ripper.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "$%ld", RNODE_NTH_REF(((*yyvaluep).val))->nd_nth);
@@ -8102,11 +8104,11 @@ switch (yykind)
     rb_parser_printf(p, "%"PRIsVALUE, ((*yyvaluep).val));
 #endif
 }
-#line 8106 "ripper.c"
+#line 8108 "ripper.c"
         break;
 
     case YYSYMBOL_tBACK_REF: /* "back reference"  */
-#line 1947 "ripper.y"
+#line 1949 "ripper.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "$%c", (int)RNODE_BACK_REF(((*yyvaluep).val))->nd_nth);
@@ -8114,11 +8116,11 @@ switch (yykind)
     rb_parser_printf(p, "%"PRIsVALUE, ((*yyvaluep).val));
 #endif
 }
-#line 8118 "ripper.c"
+#line 8120 "ripper.c"
         break;
 
     case YYSYMBOL_tSTRING_CONTENT: /* "literal content"  */
-#line 1933 "ripper.y"
+#line 1935 "ripper.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%+"PRIsVALUE, RNODE_LIT(((*yyvaluep).val))->nd_lit);
@@ -8126,11 +8128,11 @@ switch (yykind)
     rb_parser_printf(p, "%+"PRIsVALUE, get_value(((*yyvaluep).val)));
 #endif
 }
-#line 8130 "ripper.c"
+#line 8132 "ripper.c"
         break;
 
     case YYSYMBOL_tREGEXP_END: /* tREGEXP_END  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8142,11 +8144,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8146 "ripper.c"
+#line 8148 "ripper.c"
         break;
 
     case YYSYMBOL_tDUMNY_END: /* "dummy end"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8158,11 +8160,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8162 "ripper.c"
+#line 8164 "ripper.c"
         break;
 
     case YYSYMBOL_69_: /* '.'  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8174,11 +8176,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8178 "ripper.c"
+#line 8180 "ripper.c"
         break;
 
     case YYSYMBOL_70_backslash_: /* "backslash"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8190,11 +8192,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8194 "ripper.c"
+#line 8196 "ripper.c"
         break;
 
     case YYSYMBOL_72_escaped_horizontal_tab_: /* "escaped horizontal tab"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8206,11 +8208,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8210 "ripper.c"
+#line 8212 "ripper.c"
         break;
 
     case YYSYMBOL_73_escaped_form_feed_: /* "escaped form feed"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8222,11 +8224,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8226 "ripper.c"
+#line 8228 "ripper.c"
         break;
 
     case YYSYMBOL_74_escaped_carriage_return_: /* "escaped carriage return"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8238,11 +8240,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8242 "ripper.c"
+#line 8244 "ripper.c"
         break;
 
     case YYSYMBOL_75_escaped_vertical_tab_: /* "escaped vertical tab"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8254,11 +8256,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8258 "ripper.c"
+#line 8260 "ripper.c"
         break;
 
     case YYSYMBOL_tANDDOT: /* "&."  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8270,11 +8272,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8274 "ripper.c"
+#line 8276 "ripper.c"
         break;
 
     case YYSYMBOL_tCOLON2: /* "::"  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8286,11 +8288,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8290 "ripper.c"
+#line 8292 "ripper.c"
         break;
 
     case YYSYMBOL_tOP_ASGN: /* "operator-assignment"  */
-#line 1926 "ripper.y"
+#line 1928 "ripper.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%"PRIsVALUE, rb_id2str(((*yyvaluep).val)));
@@ -8298,11 +8300,11 @@ switch (yykind)
     rb_parser_printf(p, "%"PRIsVALUE, RNODE_RIPPER(((*yyvaluep).val))->nd_rval);
 #endif
 }
-#line 8302 "ripper.c"
+#line 8304 "ripper.c"
         break;
 
     case YYSYMBOL_top_compstmt: /* top_compstmt  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8314,11 +8316,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8318 "ripper.c"
+#line 8320 "ripper.c"
         break;
 
     case YYSYMBOL_top_stmts: /* top_stmts  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8330,11 +8332,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8334 "ripper.c"
+#line 8336 "ripper.c"
         break;
 
     case YYSYMBOL_top_stmt: /* top_stmt  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8346,11 +8348,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8350 "ripper.c"
+#line 8352 "ripper.c"
         break;
 
     case YYSYMBOL_begin_block: /* begin_block  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8362,11 +8364,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8366 "ripper.c"
+#line 8368 "ripper.c"
         break;
 
     case YYSYMBOL_bodystmt: /* bodystmt  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8378,11 +8380,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8382 "ripper.c"
+#line 8384 "ripper.c"
         break;
 
     case YYSYMBOL_compstmt: /* compstmt  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8394,11 +8396,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8398 "ripper.c"
+#line 8400 "ripper.c"
         break;
 
     case YYSYMBOL_stmts: /* stmts  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8410,11 +8412,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8414 "ripper.c"
+#line 8416 "ripper.c"
         break;
 
     case YYSYMBOL_stmt_or_begin: /* stmt_or_begin  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8426,11 +8428,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8430 "ripper.c"
+#line 8432 "ripper.c"
         break;
 
     case YYSYMBOL_stmt: /* stmt  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8442,11 +8444,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8446 "ripper.c"
+#line 8448 "ripper.c"
         break;
 
     case YYSYMBOL_command_asgn: /* command_asgn  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8458,11 +8460,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8462 "ripper.c"
+#line 8464 "ripper.c"
         break;
 
     case YYSYMBOL_endless_command: /* endless_command  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8474,11 +8476,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8478 "ripper.c"
+#line 8480 "ripper.c"
         break;
 
     case YYSYMBOL_command_rhs: /* command_rhs  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8490,11 +8492,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8494 "ripper.c"
+#line 8496 "ripper.c"
         break;
 
     case YYSYMBOL_expr: /* expr  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8506,11 +8508,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8510 "ripper.c"
+#line 8512 "ripper.c"
         break;
 
     case YYSYMBOL_def_name: /* def_name  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8522,11 +8524,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8526 "ripper.c"
+#line 8528 "ripper.c"
         break;
 
     case YYSYMBOL_expr_value: /* expr_value  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8538,11 +8540,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8542 "ripper.c"
+#line 8544 "ripper.c"
         break;
 
     case YYSYMBOL_expr_value_do: /* expr_value_do  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8554,11 +8556,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8558 "ripper.c"
+#line 8560 "ripper.c"
         break;
 
     case YYSYMBOL_command_call: /* command_call  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8570,11 +8572,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8574 "ripper.c"
+#line 8576 "ripper.c"
         break;
 
     case YYSYMBOL_block_command: /* block_command  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8586,11 +8588,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8590 "ripper.c"
+#line 8592 "ripper.c"
         break;
 
     case YYSYMBOL_cmd_brace_block: /* cmd_brace_block  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8602,11 +8604,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8606 "ripper.c"
+#line 8608 "ripper.c"
         break;
 
     case YYSYMBOL_fcall: /* fcall  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8618,11 +8620,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8622 "ripper.c"
+#line 8624 "ripper.c"
         break;
 
     case YYSYMBOL_command: /* command  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8634,11 +8636,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8638 "ripper.c"
+#line 8640 "ripper.c"
         break;
 
     case YYSYMBOL_mlhs: /* mlhs  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8650,11 +8652,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8654 "ripper.c"
+#line 8656 "ripper.c"
         break;
 
     case YYSYMBOL_mlhs_inner: /* mlhs_inner  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8666,11 +8668,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8670 "ripper.c"
+#line 8672 "ripper.c"
         break;
 
     case YYSYMBOL_mlhs_basic: /* mlhs_basic  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8682,11 +8684,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8686 "ripper.c"
+#line 8688 "ripper.c"
         break;
 
     case YYSYMBOL_mlhs_item: /* mlhs_item  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8698,11 +8700,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8702 "ripper.c"
+#line 8704 "ripper.c"
         break;
 
     case YYSYMBOL_mlhs_head: /* mlhs_head  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8714,11 +8716,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8718 "ripper.c"
+#line 8720 "ripper.c"
         break;
 
     case YYSYMBOL_mlhs_post: /* mlhs_post  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8730,11 +8732,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8734 "ripper.c"
+#line 8736 "ripper.c"
         break;
 
     case YYSYMBOL_mlhs_node: /* mlhs_node  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8746,11 +8748,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8750 "ripper.c"
+#line 8752 "ripper.c"
         break;
 
     case YYSYMBOL_lhs: /* lhs  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8762,11 +8764,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8766 "ripper.c"
+#line 8768 "ripper.c"
         break;
 
     case YYSYMBOL_cname: /* cname  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8778,11 +8780,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8782 "ripper.c"
+#line 8784 "ripper.c"
         break;
 
     case YYSYMBOL_cpath: /* cpath  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8794,11 +8796,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8798 "ripper.c"
+#line 8800 "ripper.c"
         break;
 
     case YYSYMBOL_fname: /* fname  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8810,11 +8812,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8814 "ripper.c"
+#line 8816 "ripper.c"
         break;
 
     case YYSYMBOL_fitem: /* fitem  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8826,11 +8828,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8830 "ripper.c"
+#line 8832 "ripper.c"
         break;
 
     case YYSYMBOL_undef_list: /* undef_list  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8842,11 +8844,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8846 "ripper.c"
+#line 8848 "ripper.c"
         break;
 
     case YYSYMBOL_op: /* op  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8858,11 +8860,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8862 "ripper.c"
+#line 8864 "ripper.c"
         break;
 
     case YYSYMBOL_reswords: /* reswords  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8874,11 +8876,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8878 "ripper.c"
+#line 8880 "ripper.c"
         break;
 
     case YYSYMBOL_arg: /* arg  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8890,11 +8892,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8894 "ripper.c"
+#line 8896 "ripper.c"
         break;
 
     case YYSYMBOL_endless_arg: /* endless_arg  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8906,11 +8908,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8910 "ripper.c"
+#line 8912 "ripper.c"
         break;
 
     case YYSYMBOL_relop: /* relop  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8922,11 +8924,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8926 "ripper.c"
+#line 8928 "ripper.c"
         break;
 
     case YYSYMBOL_rel_expr: /* rel_expr  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8938,11 +8940,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8942 "ripper.c"
+#line 8944 "ripper.c"
         break;
 
     case YYSYMBOL_arg_value: /* arg_value  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8954,11 +8956,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8958 "ripper.c"
+#line 8960 "ripper.c"
         break;
 
     case YYSYMBOL_aref_args: /* aref_args  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8970,11 +8972,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8974 "ripper.c"
+#line 8976 "ripper.c"
         break;
 
     case YYSYMBOL_arg_rhs: /* arg_rhs  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -8986,11 +8988,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8990 "ripper.c"
+#line 8992 "ripper.c"
         break;
 
     case YYSYMBOL_paren_args: /* paren_args  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9002,11 +9004,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9006 "ripper.c"
+#line 9008 "ripper.c"
         break;
 
     case YYSYMBOL_opt_paren_args: /* opt_paren_args  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9018,11 +9020,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9022 "ripper.c"
+#line 9024 "ripper.c"
         break;
 
     case YYSYMBOL_opt_call_args: /* opt_call_args  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9034,11 +9036,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9038 "ripper.c"
+#line 9040 "ripper.c"
         break;
 
     case YYSYMBOL_call_args: /* call_args  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9050,11 +9052,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9054 "ripper.c"
+#line 9056 "ripper.c"
         break;
 
     case YYSYMBOL_command_args: /* command_args  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9066,11 +9068,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9070 "ripper.c"
+#line 9072 "ripper.c"
         break;
 
     case YYSYMBOL_block_arg: /* block_arg  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9082,11 +9084,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9086 "ripper.c"
+#line 9088 "ripper.c"
         break;
 
     case YYSYMBOL_opt_block_arg: /* opt_block_arg  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9098,11 +9100,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9102 "ripper.c"
+#line 9104 "ripper.c"
         break;
 
     case YYSYMBOL_args: /* args  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9114,11 +9116,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9118 "ripper.c"
+#line 9120 "ripper.c"
         break;
 
     case YYSYMBOL_arg_splat: /* arg_splat  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9130,11 +9132,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9134 "ripper.c"
+#line 9136 "ripper.c"
         break;
 
     case YYSYMBOL_mrhs_arg: /* mrhs_arg  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9146,11 +9148,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9150 "ripper.c"
+#line 9152 "ripper.c"
         break;
 
     case YYSYMBOL_mrhs: /* mrhs  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9162,11 +9164,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9166 "ripper.c"
+#line 9168 "ripper.c"
         break;
 
     case YYSYMBOL_primary: /* primary  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9178,11 +9180,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9182 "ripper.c"
+#line 9184 "ripper.c"
         break;
 
     case YYSYMBOL_primary_value: /* primary_value  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9194,11 +9196,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9198 "ripper.c"
+#line 9200 "ripper.c"
         break;
 
     case YYSYMBOL_if_tail: /* if_tail  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9210,11 +9212,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9214 "ripper.c"
+#line 9216 "ripper.c"
         break;
 
     case YYSYMBOL_opt_else: /* opt_else  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9226,11 +9228,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9230 "ripper.c"
+#line 9232 "ripper.c"
         break;
 
     case YYSYMBOL_for_var: /* for_var  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9242,11 +9244,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9246 "ripper.c"
+#line 9248 "ripper.c"
         break;
 
     case YYSYMBOL_f_marg: /* f_marg  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9258,11 +9260,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9262 "ripper.c"
+#line 9264 "ripper.c"
         break;
 
     case YYSYMBOL_f_marg_list: /* f_marg_list  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9274,11 +9276,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9278 "ripper.c"
+#line 9280 "ripper.c"
         break;
 
     case YYSYMBOL_f_margs: /* f_margs  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9290,11 +9292,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9294 "ripper.c"
+#line 9296 "ripper.c"
         break;
 
     case YYSYMBOL_f_rest_marg: /* f_rest_marg  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9306,11 +9308,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9310 "ripper.c"
+#line 9312 "ripper.c"
         break;
 
     case YYSYMBOL_f_any_kwrest: /* f_any_kwrest  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9322,11 +9324,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9326 "ripper.c"
+#line 9328 "ripper.c"
         break;
 
     case YYSYMBOL_block_args_tail: /* block_args_tail  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9338,11 +9340,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9342 "ripper.c"
+#line 9344 "ripper.c"
         break;
 
     case YYSYMBOL_opt_block_args_tail: /* opt_block_args_tail  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9354,11 +9356,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9358 "ripper.c"
+#line 9360 "ripper.c"
         break;
 
     case YYSYMBOL_excessed_comma: /* excessed_comma  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9370,11 +9372,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9374 "ripper.c"
+#line 9376 "ripper.c"
         break;
 
     case YYSYMBOL_block_param: /* block_param  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9386,11 +9388,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9390 "ripper.c"
+#line 9392 "ripper.c"
         break;
 
     case YYSYMBOL_opt_block_param: /* opt_block_param  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9402,11 +9404,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9406 "ripper.c"
+#line 9408 "ripper.c"
         break;
 
     case YYSYMBOL_block_param_def: /* block_param_def  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9418,11 +9420,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9422 "ripper.c"
+#line 9424 "ripper.c"
         break;
 
     case YYSYMBOL_opt_bv_decl: /* opt_bv_decl  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9434,11 +9436,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9438 "ripper.c"
+#line 9440 "ripper.c"
         break;
 
     case YYSYMBOL_bv_decls: /* bv_decls  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9450,11 +9452,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9454 "ripper.c"
+#line 9456 "ripper.c"
         break;
 
     case YYSYMBOL_bvar: /* bvar  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9466,11 +9468,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9470 "ripper.c"
+#line 9472 "ripper.c"
         break;
 
     case YYSYMBOL_lambda: /* lambda  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9482,11 +9484,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9486 "ripper.c"
+#line 9488 "ripper.c"
         break;
 
     case YYSYMBOL_f_larglist: /* f_larglist  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9498,11 +9500,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9502 "ripper.c"
+#line 9504 "ripper.c"
         break;
 
     case YYSYMBOL_lambda_body: /* lambda_body  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9514,11 +9516,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9518 "ripper.c"
+#line 9520 "ripper.c"
         break;
 
     case YYSYMBOL_do_block: /* do_block  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9530,11 +9532,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9534 "ripper.c"
+#line 9536 "ripper.c"
         break;
 
     case YYSYMBOL_block_call: /* block_call  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9546,11 +9548,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9550 "ripper.c"
+#line 9552 "ripper.c"
         break;
 
     case YYSYMBOL_method_call: /* method_call  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9562,11 +9564,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9566 "ripper.c"
+#line 9568 "ripper.c"
         break;
 
     case YYSYMBOL_brace_block: /* brace_block  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9578,11 +9580,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9582 "ripper.c"
+#line 9584 "ripper.c"
         break;
 
     case YYSYMBOL_brace_body: /* brace_body  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9594,11 +9596,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9598 "ripper.c"
+#line 9600 "ripper.c"
         break;
 
     case YYSYMBOL_do_body: /* do_body  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9610,11 +9612,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9614 "ripper.c"
+#line 9616 "ripper.c"
         break;
 
     case YYSYMBOL_case_args: /* case_args  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9626,11 +9628,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9630 "ripper.c"
+#line 9632 "ripper.c"
         break;
 
     case YYSYMBOL_case_body: /* case_body  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9642,11 +9644,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9646 "ripper.c"
+#line 9648 "ripper.c"
         break;
 
     case YYSYMBOL_cases: /* cases  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9658,11 +9660,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9662 "ripper.c"
+#line 9664 "ripper.c"
         break;
 
     case YYSYMBOL_p_case_body: /* p_case_body  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9674,11 +9676,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9678 "ripper.c"
+#line 9680 "ripper.c"
         break;
 
     case YYSYMBOL_p_cases: /* p_cases  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9690,11 +9692,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9694 "ripper.c"
+#line 9696 "ripper.c"
         break;
 
     case YYSYMBOL_p_top_expr: /* p_top_expr  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9706,11 +9708,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9710 "ripper.c"
+#line 9712 "ripper.c"
         break;
 
     case YYSYMBOL_p_top_expr_body: /* p_top_expr_body  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9722,11 +9724,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9726 "ripper.c"
+#line 9728 "ripper.c"
         break;
 
     case YYSYMBOL_p_expr: /* p_expr  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9738,11 +9740,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9742 "ripper.c"
+#line 9744 "ripper.c"
         break;
 
     case YYSYMBOL_p_as: /* p_as  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9754,11 +9756,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9758 "ripper.c"
+#line 9760 "ripper.c"
         break;
 
     case YYSYMBOL_p_alt: /* p_alt  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9770,11 +9772,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9774 "ripper.c"
+#line 9776 "ripper.c"
         break;
 
     case YYSYMBOL_p_expr_basic: /* p_expr_basic  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9786,11 +9788,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9790 "ripper.c"
+#line 9792 "ripper.c"
         break;
 
     case YYSYMBOL_p_args: /* p_args  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9802,11 +9804,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9806 "ripper.c"
+#line 9808 "ripper.c"
         break;
 
     case YYSYMBOL_p_args_head: /* p_args_head  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9818,11 +9820,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9822 "ripper.c"
+#line 9824 "ripper.c"
         break;
 
     case YYSYMBOL_p_args_tail: /* p_args_tail  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9834,11 +9836,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9838 "ripper.c"
+#line 9840 "ripper.c"
         break;
 
     case YYSYMBOL_p_find: /* p_find  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9850,11 +9852,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9854 "ripper.c"
+#line 9856 "ripper.c"
         break;
 
     case YYSYMBOL_p_rest: /* p_rest  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9866,11 +9868,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9870 "ripper.c"
+#line 9872 "ripper.c"
         break;
 
     case YYSYMBOL_p_args_post: /* p_args_post  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9882,11 +9884,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9886 "ripper.c"
+#line 9888 "ripper.c"
         break;
 
     case YYSYMBOL_p_arg: /* p_arg  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9898,11 +9900,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9902 "ripper.c"
+#line 9904 "ripper.c"
         break;
 
     case YYSYMBOL_p_kwargs: /* p_kwargs  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9914,11 +9916,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9918 "ripper.c"
+#line 9920 "ripper.c"
         break;
 
     case YYSYMBOL_p_kwarg: /* p_kwarg  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9930,11 +9932,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9934 "ripper.c"
+#line 9936 "ripper.c"
         break;
 
     case YYSYMBOL_p_kw: /* p_kw  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9946,11 +9948,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9950 "ripper.c"
+#line 9952 "ripper.c"
         break;
 
     case YYSYMBOL_p_kw_label: /* p_kw_label  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9962,11 +9964,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9966 "ripper.c"
+#line 9968 "ripper.c"
         break;
 
     case YYSYMBOL_p_kwrest: /* p_kwrest  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9978,11 +9980,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9982 "ripper.c"
+#line 9984 "ripper.c"
         break;
 
     case YYSYMBOL_p_kwnorest: /* p_kwnorest  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -9994,11 +9996,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9998 "ripper.c"
+#line 10000 "ripper.c"
         break;
 
     case YYSYMBOL_p_any_kwrest: /* p_any_kwrest  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10010,11 +10012,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10014 "ripper.c"
+#line 10016 "ripper.c"
         break;
 
     case YYSYMBOL_p_value: /* p_value  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10026,11 +10028,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10030 "ripper.c"
+#line 10032 "ripper.c"
         break;
 
     case YYSYMBOL_p_primitive: /* p_primitive  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10042,11 +10044,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10046 "ripper.c"
+#line 10048 "ripper.c"
         break;
 
     case YYSYMBOL_p_variable: /* p_variable  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10058,11 +10060,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10062 "ripper.c"
+#line 10064 "ripper.c"
         break;
 
     case YYSYMBOL_p_var_ref: /* p_var_ref  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10074,11 +10076,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10078 "ripper.c"
+#line 10080 "ripper.c"
         break;
 
     case YYSYMBOL_p_expr_ref: /* p_expr_ref  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10090,11 +10092,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10094 "ripper.c"
+#line 10096 "ripper.c"
         break;
 
     case YYSYMBOL_p_const: /* p_const  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10106,11 +10108,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10110 "ripper.c"
+#line 10112 "ripper.c"
         break;
 
     case YYSYMBOL_opt_rescue: /* opt_rescue  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10122,11 +10124,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10126 "ripper.c"
+#line 10128 "ripper.c"
         break;
 
     case YYSYMBOL_exc_list: /* exc_list  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10138,11 +10140,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10142 "ripper.c"
+#line 10144 "ripper.c"
         break;
 
     case YYSYMBOL_exc_var: /* exc_var  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10154,11 +10156,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10158 "ripper.c"
+#line 10160 "ripper.c"
         break;
 
     case YYSYMBOL_opt_ensure: /* opt_ensure  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10170,11 +10172,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10174 "ripper.c"
+#line 10176 "ripper.c"
         break;
 
     case YYSYMBOL_literal: /* literal  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10186,11 +10188,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10190 "ripper.c"
+#line 10192 "ripper.c"
         break;
 
     case YYSYMBOL_strings: /* strings  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10202,11 +10204,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10206 "ripper.c"
+#line 10208 "ripper.c"
         break;
 
     case YYSYMBOL_string: /* string  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10218,11 +10220,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10222 "ripper.c"
+#line 10224 "ripper.c"
         break;
 
     case YYSYMBOL_string1: /* string1  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10234,11 +10236,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10238 "ripper.c"
+#line 10240 "ripper.c"
         break;
 
     case YYSYMBOL_xstring: /* xstring  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10250,11 +10252,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10254 "ripper.c"
+#line 10256 "ripper.c"
         break;
 
     case YYSYMBOL_regexp: /* regexp  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10266,11 +10268,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10270 "ripper.c"
+#line 10272 "ripper.c"
         break;
 
     case YYSYMBOL_words: /* words  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10282,11 +10284,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10286 "ripper.c"
+#line 10288 "ripper.c"
         break;
 
     case YYSYMBOL_word_list: /* word_list  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10298,11 +10300,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10302 "ripper.c"
+#line 10304 "ripper.c"
         break;
 
     case YYSYMBOL_word: /* word  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10314,11 +10316,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10318 "ripper.c"
+#line 10320 "ripper.c"
         break;
 
     case YYSYMBOL_symbols: /* symbols  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10330,11 +10332,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10334 "ripper.c"
+#line 10336 "ripper.c"
         break;
 
     case YYSYMBOL_symbol_list: /* symbol_list  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10346,11 +10348,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10350 "ripper.c"
+#line 10352 "ripper.c"
         break;
 
     case YYSYMBOL_qwords: /* qwords  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10362,11 +10364,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10366 "ripper.c"
+#line 10368 "ripper.c"
         break;
 
     case YYSYMBOL_qsymbols: /* qsymbols  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10378,11 +10380,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10382 "ripper.c"
+#line 10384 "ripper.c"
         break;
 
     case YYSYMBOL_qword_list: /* qword_list  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10394,11 +10396,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10398 "ripper.c"
+#line 10400 "ripper.c"
         break;
 
     case YYSYMBOL_qsym_list: /* qsym_list  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10410,11 +10412,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10414 "ripper.c"
+#line 10416 "ripper.c"
         break;
 
     case YYSYMBOL_string_contents: /* string_contents  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10426,11 +10428,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10430 "ripper.c"
+#line 10432 "ripper.c"
         break;
 
     case YYSYMBOL_xstring_contents: /* xstring_contents  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10442,11 +10444,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10446 "ripper.c"
+#line 10448 "ripper.c"
         break;
 
     case YYSYMBOL_regexp_contents: /* regexp_contents  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10458,11 +10460,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10462 "ripper.c"
+#line 10464 "ripper.c"
         break;
 
     case YYSYMBOL_string_content: /* string_content  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10474,11 +10476,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10478 "ripper.c"
+#line 10480 "ripper.c"
         break;
 
     case YYSYMBOL_string_dvar: /* string_dvar  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10490,11 +10492,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10494 "ripper.c"
+#line 10496 "ripper.c"
         break;
 
     case YYSYMBOL_symbol: /* symbol  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10506,11 +10508,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10510 "ripper.c"
+#line 10512 "ripper.c"
         break;
 
     case YYSYMBOL_ssym: /* ssym  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10522,11 +10524,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10526 "ripper.c"
+#line 10528 "ripper.c"
         break;
 
     case YYSYMBOL_sym: /* sym  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10538,11 +10540,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10542 "ripper.c"
+#line 10544 "ripper.c"
         break;
 
     case YYSYMBOL_dsym: /* dsym  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10554,11 +10556,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10558 "ripper.c"
+#line 10560 "ripper.c"
         break;
 
     case YYSYMBOL_numeric: /* numeric  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10570,11 +10572,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10574 "ripper.c"
+#line 10576 "ripper.c"
         break;
 
     case YYSYMBOL_simple_numeric: /* simple_numeric  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10586,11 +10588,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10590 "ripper.c"
+#line 10592 "ripper.c"
         break;
 
     case YYSYMBOL_nonlocal_var: /* nonlocal_var  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10602,11 +10604,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10606 "ripper.c"
+#line 10608 "ripper.c"
         break;
 
     case YYSYMBOL_user_variable: /* user_variable  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10618,11 +10620,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10622 "ripper.c"
+#line 10624 "ripper.c"
         break;
 
     case YYSYMBOL_keyword_variable: /* keyword_variable  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10634,11 +10636,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10638 "ripper.c"
+#line 10640 "ripper.c"
         break;
 
     case YYSYMBOL_var_ref: /* var_ref  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10650,11 +10652,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10654 "ripper.c"
+#line 10656 "ripper.c"
         break;
 
     case YYSYMBOL_var_lhs: /* var_lhs  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10666,11 +10668,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10670 "ripper.c"
+#line 10672 "ripper.c"
         break;
 
     case YYSYMBOL_backref: /* backref  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10682,11 +10684,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10686 "ripper.c"
+#line 10688 "ripper.c"
         break;
 
     case YYSYMBOL_superclass: /* superclass  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10698,11 +10700,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10702 "ripper.c"
+#line 10704 "ripper.c"
         break;
 
     case YYSYMBOL_f_opt_paren_args: /* f_opt_paren_args  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10714,11 +10716,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10718 "ripper.c"
+#line 10720 "ripper.c"
         break;
 
     case YYSYMBOL_f_paren_args: /* f_paren_args  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10730,11 +10732,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10734 "ripper.c"
+#line 10736 "ripper.c"
         break;
 
     case YYSYMBOL_f_arglist: /* f_arglist  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10746,11 +10748,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10750 "ripper.c"
+#line 10752 "ripper.c"
         break;
 
     case YYSYMBOL_args_tail: /* args_tail  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10762,11 +10764,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10766 "ripper.c"
+#line 10768 "ripper.c"
         break;
 
     case YYSYMBOL_opt_args_tail: /* opt_args_tail  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10778,11 +10780,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10782 "ripper.c"
+#line 10784 "ripper.c"
         break;
 
     case YYSYMBOL_f_args: /* f_args  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10794,11 +10796,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10798 "ripper.c"
+#line 10800 "ripper.c"
         break;
 
     case YYSYMBOL_args_forward: /* args_forward  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10810,11 +10812,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10814 "ripper.c"
+#line 10816 "ripper.c"
         break;
 
     case YYSYMBOL_f_bad_arg: /* f_bad_arg  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10826,11 +10828,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10830 "ripper.c"
+#line 10832 "ripper.c"
         break;
 
     case YYSYMBOL_f_norm_arg: /* f_norm_arg  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10842,11 +10844,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10846 "ripper.c"
+#line 10848 "ripper.c"
         break;
 
     case YYSYMBOL_f_arg_asgn: /* f_arg_asgn  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10858,11 +10860,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10862 "ripper.c"
+#line 10864 "ripper.c"
         break;
 
     case YYSYMBOL_f_arg_item: /* f_arg_item  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10874,11 +10876,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10878 "ripper.c"
+#line 10880 "ripper.c"
         break;
 
     case YYSYMBOL_f_arg: /* f_arg  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10890,11 +10892,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10894 "ripper.c"
+#line 10896 "ripper.c"
         break;
 
     case YYSYMBOL_f_label: /* f_label  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10906,11 +10908,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10910 "ripper.c"
+#line 10912 "ripper.c"
         break;
 
     case YYSYMBOL_f_kw: /* f_kw  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10922,11 +10924,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10926 "ripper.c"
+#line 10928 "ripper.c"
         break;
 
     case YYSYMBOL_f_block_kw: /* f_block_kw  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10938,11 +10940,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10942 "ripper.c"
+#line 10944 "ripper.c"
         break;
 
     case YYSYMBOL_f_block_kwarg: /* f_block_kwarg  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10954,11 +10956,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10958 "ripper.c"
+#line 10960 "ripper.c"
         break;
 
     case YYSYMBOL_f_kwarg: /* f_kwarg  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10970,11 +10972,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10974 "ripper.c"
+#line 10976 "ripper.c"
         break;
 
     case YYSYMBOL_f_no_kwarg: /* f_no_kwarg  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -10986,11 +10988,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 10990 "ripper.c"
+#line 10992 "ripper.c"
         break;
 
     case YYSYMBOL_f_kwrest: /* f_kwrest  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -11002,11 +11004,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 11006 "ripper.c"
+#line 11008 "ripper.c"
         break;
 
     case YYSYMBOL_f_opt: /* f_opt  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -11018,11 +11020,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 11022 "ripper.c"
+#line 11024 "ripper.c"
         break;
 
     case YYSYMBOL_f_block_opt: /* f_block_opt  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -11034,11 +11036,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 11038 "ripper.c"
+#line 11040 "ripper.c"
         break;
 
     case YYSYMBOL_f_block_optarg: /* f_block_optarg  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -11050,11 +11052,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 11054 "ripper.c"
+#line 11056 "ripper.c"
         break;
 
     case YYSYMBOL_f_optarg: /* f_optarg  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -11066,11 +11068,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 11070 "ripper.c"
+#line 11072 "ripper.c"
         break;
 
     case YYSYMBOL_f_rest_arg: /* f_rest_arg  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -11082,11 +11084,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 11086 "ripper.c"
+#line 11088 "ripper.c"
         break;
 
     case YYSYMBOL_f_block_arg: /* f_block_arg  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -11098,11 +11100,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 11102 "ripper.c"
+#line 11104 "ripper.c"
         break;
 
     case YYSYMBOL_opt_f_block_arg: /* opt_f_block_arg  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -11114,11 +11116,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 11118 "ripper.c"
+#line 11120 "ripper.c"
         break;
 
     case YYSYMBOL_singleton: /* singleton  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -11130,11 +11132,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 11134 "ripper.c"
+#line 11136 "ripper.c"
         break;
 
     case YYSYMBOL_assoc_list: /* assoc_list  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -11146,11 +11148,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 11150 "ripper.c"
+#line 11152 "ripper.c"
         break;
 
     case YYSYMBOL_assocs: /* assocs  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -11162,11 +11164,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 11166 "ripper.c"
+#line 11168 "ripper.c"
         break;
 
     case YYSYMBOL_assoc: /* assoc  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -11178,11 +11180,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 11182 "ripper.c"
+#line 11184 "ripper.c"
         break;
 
     case YYSYMBOL_operation: /* operation  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -11194,11 +11196,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 11198 "ripper.c"
+#line 11200 "ripper.c"
         break;
 
     case YYSYMBOL_operation2: /* operation2  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -11210,11 +11212,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 11214 "ripper.c"
+#line 11216 "ripper.c"
         break;
 
     case YYSYMBOL_operation3: /* operation3  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -11226,11 +11228,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 11230 "ripper.c"
+#line 11232 "ripper.c"
         break;
 
     case YYSYMBOL_dot_or_colon: /* dot_or_colon  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -11242,11 +11244,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 11246 "ripper.c"
+#line 11248 "ripper.c"
         break;
 
     case YYSYMBOL_call_op: /* call_op  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -11258,11 +11260,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 11262 "ripper.c"
+#line 11264 "ripper.c"
         break;
 
     case YYSYMBOL_call_op2: /* call_op2  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -11274,11 +11276,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 11278 "ripper.c"
+#line 11280 "ripper.c"
         break;
 
     case YYSYMBOL_none: /* none  */
-#line 1915 "ripper.y"
+#line 1917 "ripper.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).val) == (NODE *)-1) {
@@ -11290,7 +11292,7 @@ switch (yykind)
 #else
 #endif
 }
-#line 11294 "ripper.c"
+#line 11296 "ripper.c"
         break;
 
       default:
@@ -11783,12 +11785,12 @@ YYLTYPE yylloc = yyloc_default;
 
 
         /* User initialization code.  */
-#line 1958 "ripper.y"
+#line 1960 "ripper.y"
         {
     RUBY_SET_YYLLOC_OF_NONE(yylloc);
 }
 
-#line 11792 "ripper.c"
+#line 11794 "ripper.c"
 
   yylsp[0] = yylloc;
   goto yysetstate;
@@ -11999,18 +12001,18 @@ yyreduce:
   switch (yyn)
     {
   case 2: /* $@1: %empty  */
-#line 2193 "ripper.y"
+#line 2195 "ripper.y"
           {
                         SET_LEX_STATE(EXPR_BEG);
                         local_push(p, ifndef_ripper(1)+0);
                         /* jumps are possible in the top-level loop. */
                         if (!ifndef_ripper(p->do_loop) + 0) init_block_exit(p);
                     }
-#line 12010 "ripper.c"
+#line 12012 "ripper.c"
     break;
 
   case 3: /* program: $@1 top_compstmt  */
-#line 2200 "ripper.y"
+#line 2202 "ripper.y"
                   {
 #if 0
                         if ((yyvsp[0].val) && !compile_for_eval) {
@@ -12030,75 +12032,75 @@ yyreduce:
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(program,v1);p->result=v2;}
                         local_pop(p);
                     }
-#line 12034 "ripper.c"
+#line 12036 "ripper.c"
     break;
 
   case 4: /* top_compstmt: top_stmts opt_terms  */
-#line 2222 "ripper.y"
+#line 2224 "ripper.y"
                   {
                         (yyval.val) = void_stmts(p, (yyvsp[-1].val));
                     }
-#line 12042 "ripper.c"
+#line 12044 "ripper.c"
     break;
 
   case 5: /* top_stmts: none  */
-#line 2228 "ripper.y"
+#line 2230 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_BEGIN(0, &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5;v1=dispatch0(stmts_new);v2=dispatch0(void_stmt);v3=v1;v4=v2;v5=dispatch2(stmts_add,v3,v4);(yyval.val)=v5;}
                     }
-#line 12053 "ripper.c"
+#line 12055 "ripper.c"
     break;
 
   case 6: /* top_stmts: top_stmt  */
-#line 2235 "ripper.y"
+#line 2237 "ripper.y"
                   {
 #if 0
                         (yyval.val) = newline_node((yyvsp[0].val));
 #endif
 			{VALUE v1,v2,v3,v4;v1=dispatch0(stmts_new);v2=v1;v3=(yyvsp[0].val);v4=dispatch2(stmts_add,v2,v3);(yyval.val)=v4;}
                     }
-#line 12064 "ripper.c"
+#line 12066 "ripper.c"
     break;
 
   case 7: /* top_stmts: top_stmts terms top_stmt  */
-#line 2242 "ripper.y"
+#line 2244 "ripper.y"
                   {
 #if 0
                         (yyval.val) = block_append(p, (yyvsp[-2].val), newline_node((yyvsp[0].val)));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[0].val);v3=dispatch2(stmts_add,v1,v2);(yyval.val)=v3;}
                     }
-#line 12075 "ripper.c"
+#line 12077 "ripper.c"
     break;
 
   case 8: /* top_stmt: stmt  */
-#line 2251 "ripper.y"
+#line 2253 "ripper.y"
                   {
                         clear_block_exit(p, true);
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 12084 "ripper.c"
+#line 12086 "ripper.c"
     break;
 
   case 9: /* top_stmt: "`BEGIN'" begin_block  */
-#line 2256 "ripper.y"
+#line 2258 "ripper.y"
                   {
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 12092 "ripper.c"
+#line 12094 "ripper.c"
     break;
 
   case 10: /* block_open: '{'  */
-#line 2261 "ripper.y"
+#line 2263 "ripper.y"
                {(yyval.node_exits) = init_block_exit(p);}
-#line 12098 "ripper.c"
+#line 12100 "ripper.c"
     break;
 
   case 11: /* begin_block: block_open top_compstmt '}'  */
-#line 2264 "ripper.y"
+#line 2266 "ripper.y"
                   {
                         restore_block_exit(p, (yyvsp[-2].node_exits));
 #if 0
@@ -12108,166 +12110,166 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=(yyvsp[-1].val);v2=dispatch1(BEGIN,v1);(yyval.val)=v2;}
                     }
-#line 12112 "ripper.c"
+#line 12114 "ripper.c"
     break;
 
   case 12: /* $@2: %empty  */
-#line 2279 "ripper.y"
+#line 2281 "ripper.y"
                   {
                         if (!(yyvsp[-1].val)) yyerror1(&(yylsp[0]), "else without rescue is useless");
                         next_rescue_context(&p->ctxt, &(yyvsp[-2].ctxt), after_else);
                     }
-#line 12121 "ripper.c"
+#line 12123 "ripper.c"
     break;
 
   case 13: /* $@3: %empty  */
-#line 2284 "ripper.y"
+#line 2286 "ripper.y"
                   {
                         next_rescue_context(&p->ctxt, &(yyvsp[-4].ctxt), after_ensure);
                     }
-#line 12129 "ripper.c"
+#line 12131 "ripper.c"
     break;
 
   case 14: /* bodystmt: compstmt lex_ctxt opt_rescue k_else $@2 compstmt $@3 opt_ensure  */
-#line 2288 "ripper.y"
+#line 2290 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_bodystmt(p, (yyvsp[-7].val), (yyvsp[-5].val), (yyvsp[-2].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5;v1=(yyvsp[-7].val);v2=(yyvsp[-5].val);v3=(yyvsp[-2].val);v4=(yyvsp[0].val);v5=dispatch4(bodystmt,v1,v2,v3,v4);(yyval.val)=v5;}
                     }
-#line 12140 "ripper.c"
+#line 12142 "ripper.c"
     break;
 
   case 15: /* $@4: %empty  */
-#line 2297 "ripper.y"
+#line 2299 "ripper.y"
                   {
                         next_rescue_context(&p->ctxt, &(yyvsp[-1].ctxt), after_ensure);
                     }
-#line 12148 "ripper.c"
+#line 12150 "ripper.c"
     break;
 
   case 16: /* bodystmt: compstmt lex_ctxt opt_rescue $@4 opt_ensure  */
-#line 2301 "ripper.y"
+#line 2303 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_bodystmt(p, (yyvsp[-4].val), (yyvsp[-2].val), 0, (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5;v1=(yyvsp[-4].val);v2=(yyvsp[-2].val);v3=Qnil;v4=(yyvsp[0].val);v5=dispatch4(bodystmt,v1,v2,v3,v4);(yyval.val)=v5;}
                     }
-#line 12159 "ripper.c"
+#line 12161 "ripper.c"
     break;
 
   case 17: /* compstmt: stmts opt_terms  */
-#line 2310 "ripper.y"
+#line 2312 "ripper.y"
                   {
                         (yyval.val) = void_stmts(p, (yyvsp[-1].val));
                     }
-#line 12167 "ripper.c"
+#line 12169 "ripper.c"
     break;
 
   case 18: /* stmts: none  */
-#line 2316 "ripper.y"
+#line 2318 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_BEGIN(0, &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5;v1=dispatch0(stmts_new);v2=dispatch0(void_stmt);v3=v1;v4=v2;v5=dispatch2(stmts_add,v3,v4);(yyval.val)=v5;}
                     }
-#line 12178 "ripper.c"
+#line 12180 "ripper.c"
     break;
 
   case 19: /* stmts: stmt_or_begin  */
-#line 2323 "ripper.y"
+#line 2325 "ripper.y"
                   {
 #if 0
                         (yyval.val) = newline_node((yyvsp[0].val));
 #endif
 			{VALUE v1,v2,v3,v4;v1=dispatch0(stmts_new);v2=v1;v3=(yyvsp[0].val);v4=dispatch2(stmts_add,v2,v3);(yyval.val)=v4;}
                     }
-#line 12189 "ripper.c"
+#line 12191 "ripper.c"
     break;
 
   case 20: /* stmts: stmts terms stmt_or_begin  */
-#line 2330 "ripper.y"
+#line 2332 "ripper.y"
                   {
 #if 0
                         (yyval.val) = block_append(p, (yyvsp[-2].val), newline_node((yyvsp[0].val)));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[0].val);v3=dispatch2(stmts_add,v1,v2);(yyval.val)=v3;}
                     }
-#line 12200 "ripper.c"
+#line 12202 "ripper.c"
     break;
 
   case 21: /* stmt_or_begin: stmt  */
-#line 2339 "ripper.y"
+#line 2341 "ripper.y"
                   {
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 12208 "ripper.c"
+#line 12210 "ripper.c"
     break;
 
   case 22: /* $@5: %empty  */
-#line 2343 "ripper.y"
+#line 2345 "ripper.y"
                   {
                         yyerror1(&(yylsp[0]), "BEGIN is permitted only at toplevel");
                     }
-#line 12216 "ripper.c"
+#line 12218 "ripper.c"
     break;
 
   case 23: /* stmt_or_begin: "`BEGIN'" $@5 begin_block  */
-#line 2347 "ripper.y"
+#line 2349 "ripper.y"
                   {
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 12224 "ripper.c"
+#line 12226 "ripper.c"
     break;
 
   case 24: /* allow_exits: %empty  */
-#line 2352 "ripper.y"
+#line 2354 "ripper.y"
             {(yyval.node_exits) = allow_block_exit(p);}
-#line 12230 "ripper.c"
+#line 12232 "ripper.c"
     break;
 
   case 25: /* k_END: "`END'" lex_ctxt  */
-#line 2355 "ripper.y"
+#line 2357 "ripper.y"
                   {
                         (yyval.ctxt) = (yyvsp[0].ctxt);
                         p->ctxt.in_rescue = before_rescue;
                     }
-#line 12239 "ripper.c"
+#line 12241 "ripper.c"
     break;
 
   case 26: /* $@6: %empty  */
-#line 2360 "ripper.y"
+#line 2362 "ripper.y"
                           {SET_LEX_STATE(EXPR_FNAME|EXPR_FITEM);}
-#line 12245 "ripper.c"
+#line 12247 "ripper.c"
     break;
 
   case 27: /* stmt: "`alias'" fitem $@6 fitem  */
-#line 2361 "ripper.y"
+#line 2363 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_ALIAS((yyvsp[-2].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[0].val);v3=dispatch2(alias,v1,v2);(yyval.val)=v3;}
                     }
-#line 12256 "ripper.c"
+#line 12258 "ripper.c"
     break;
 
   case 28: /* stmt: "`alias'" "global variable" "global variable"  */
-#line 2368 "ripper.y"
+#line 2370 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_VALIAS((yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-1].val);v2=(yyvsp[0].val);v3=dispatch2(var_alias,v1,v2);(yyval.val)=v3;}
                     }
-#line 12267 "ripper.c"
+#line 12269 "ripper.c"
     break;
 
   case 29: /* stmt: "`alias'" "global variable" "back reference"  */
-#line 2375 "ripper.y"
+#line 2377 "ripper.y"
                   {
 #if 0
                         char buf[2];
@@ -12277,11 +12279,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-1].val);v2=(yyvsp[0].val);v3=dispatch2(var_alias,v1,v2);(yyval.val)=v3;}
                     }
-#line 12281 "ripper.c"
+#line 12283 "ripper.c"
     break;
 
   case 30: /* stmt: "`alias'" "global variable" "numbered reference"  */
-#line 2385 "ripper.y"
+#line 2387 "ripper.y"
                   {
                         static const char mesg[] = "can't make alias for the number variables";
 #if 0
@@ -12290,22 +12292,22 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=ERR_MESG();v2=(yyvsp[0].val);v3=dispatch2(alias_error,v1,v2);(yyval.val)=v3;}ripper_error(p);
                     }
-#line 12294 "ripper.c"
+#line 12296 "ripper.c"
     break;
 
   case 31: /* stmt: "`undef'" undef_list  */
-#line 2394 "ripper.y"
+#line 2396 "ripper.y"
                   {
 #if 0
                         (yyval.val) = (yyvsp[0].val);
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(undef,v1);(yyval.val)=v2;}
                     }
-#line 12305 "ripper.c"
+#line 12307 "ripper.c"
     break;
 
   case 32: /* stmt: stmt "`if' modifier" expr_value  */
-#line 2401 "ripper.y"
+#line 2403 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_if(p, (yyvsp[0].val), remove_begin((yyvsp[-2].val)), 0, &(yyloc));
@@ -12313,11 +12315,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[0].val);v2=(yyvsp[-2].val);v3=dispatch2(if_mod,v1,v2);(yyval.val)=v3;}
                     }
-#line 12317 "ripper.c"
+#line 12319 "ripper.c"
     break;
 
   case 33: /* stmt: stmt "`unless' modifier" expr_value  */
-#line 2409 "ripper.y"
+#line 2411 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_unless(p, (yyvsp[0].val), remove_begin((yyvsp[-2].val)), 0, &(yyloc));
@@ -12325,11 +12327,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[0].val);v2=(yyvsp[-2].val);v3=dispatch2(unless_mod,v1,v2);(yyval.val)=v3;}
                     }
-#line 12329 "ripper.c"
+#line 12331 "ripper.c"
     break;
 
   case 34: /* stmt: stmt "`while' modifier" expr_value  */
-#line 2417 "ripper.y"
+#line 2419 "ripper.y"
                   {
                         clear_block_exit(p, false);
 #if 0
@@ -12342,11 +12344,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[0].val);v2=(yyvsp[-2].val);v3=dispatch2(while_mod,v1,v2);(yyval.val)=v3;}
                     }
-#line 12346 "ripper.c"
+#line 12348 "ripper.c"
     break;
 
   case 35: /* stmt: stmt "`until' modifier" expr_value  */
-#line 2430 "ripper.y"
+#line 2432 "ripper.y"
                   {
                         clear_block_exit(p, false);
 #if 0
@@ -12359,11 +12361,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[0].val);v2=(yyvsp[-2].val);v3=dispatch2(until_mod,v1,v2);(yyval.val)=v3;}
                     }
-#line 12363 "ripper.c"
+#line 12365 "ripper.c"
     break;
 
   case 36: /* stmt: stmt "`rescue' modifier" after_rescue stmt  */
-#line 2443 "ripper.y"
+#line 2445 "ripper.y"
                   {
                         p->ctxt.in_rescue = (yyvsp[-1].ctxt).in_rescue;
 #if 0
@@ -12374,11 +12376,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-3].val);v2=(yyvsp[0].val);v3=dispatch2(rescue_mod,v1,v2);(yyval.val)=v3;}
                     }
-#line 12378 "ripper.c"
+#line 12380 "ripper.c"
     break;
 
   case 37: /* stmt: k_END allow_exits '{' compstmt '}'  */
-#line 2454 "ripper.y"
+#line 2456 "ripper.y"
                   {
                         if (p->ctxt.in_def) {
                             rb_warn0("END in method; use at_exit");
@@ -12393,11 +12395,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=(yyvsp[-1].val);v2=dispatch1(END,v1);(yyval.val)=v2;}
                     }
-#line 12397 "ripper.c"
+#line 12399 "ripper.c"
     break;
 
   case 39: /* stmt: mlhs '=' lex_ctxt command_call  */
-#line 2470 "ripper.y"
+#line 2472 "ripper.y"
                   {
 #if 0
                         value_expr((yyvsp[0].val));
@@ -12405,22 +12407,22 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-3].val);v2=(yyvsp[0].val);v3=dispatch2(massign,v1,v2);(yyval.val)=v3;}
                     }
-#line 12409 "ripper.c"
+#line 12411 "ripper.c"
     break;
 
   case 40: /* stmt: lhs '=' lex_ctxt mrhs  */
-#line 2478 "ripper.y"
+#line 2480 "ripper.y"
                   {
 #if 0
                         (yyval.val) = node_assign(p, (yyvsp[-3].val), (yyvsp[0].val), (yyvsp[-1].ctxt), &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-3].val);v2=(yyvsp[0].val);v3=dispatch2(assign,v1,v2);(yyval.val)=v3;}
                     }
-#line 12420 "ripper.c"
+#line 12422 "ripper.c"
     break;
 
   case 41: /* stmt: mlhs '=' lex_ctxt mrhs_arg "`rescue' modifier" after_rescue stmt  */
-#line 2486 "ripper.y"
+#line 2488 "ripper.y"
                   {
                         p->ctxt.in_rescue = (yyvsp[-4].ctxt).in_rescue;
 #if 0
@@ -12432,55 +12434,55 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6;v1=(yyvsp[-3].val);v2=(yyvsp[0].val);v3=dispatch2(rescue_mod,v1,v2);v4=(yyvsp[-6].val);v5=v3;v6=dispatch2(massign,v4,v5);(yyval.val)=v6;}
                     }
-#line 12436 "ripper.c"
+#line 12438 "ripper.c"
     break;
 
   case 42: /* stmt: mlhs '=' lex_ctxt mrhs_arg  */
-#line 2498 "ripper.y"
+#line 2500 "ripper.y"
                   {
 #if 0
                         (yyval.val) = node_assign(p, (NODE *)(yyvsp[-3].val), (yyvsp[0].val), (yyvsp[-1].ctxt), &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-3].val);v2=(yyvsp[0].val);v3=dispatch2(massign,v1,v2);(yyval.val)=v3;}
                     }
-#line 12447 "ripper.c"
+#line 12449 "ripper.c"
     break;
 
   case 44: /* stmt: error  */
-#line 2506 "ripper.y"
+#line 2508 "ripper.y"
                   {
                         (void)yynerrs;
 #if 0
                         (yyval.val) = NEW_ERROR(&(yyloc));
 #endif
                     }
-#line 12458 "ripper.c"
+#line 12460 "ripper.c"
     break;
 
   case 45: /* command_asgn: lhs '=' lex_ctxt command_rhs  */
-#line 2515 "ripper.y"
+#line 2517 "ripper.y"
                   {
 #if 0
                         (yyval.val) = node_assign(p, (yyvsp[-3].val), (yyvsp[0].val), (yyvsp[-1].ctxt), &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-3].val);v2=(yyvsp[0].val);v3=dispatch2(assign,v1,v2);(yyval.val)=v3;}
                     }
-#line 12469 "ripper.c"
+#line 12471 "ripper.c"
     break;
 
   case 46: /* command_asgn: var_lhs "operator-assignment" lex_ctxt command_rhs  */
-#line 2522 "ripper.y"
+#line 2524 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_op_assign(p, (yyvsp[-3].val), (yyvsp[-2].val), (yyvsp[0].val), (yyvsp[-1].ctxt), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4;v1=(yyvsp[-3].val);v2=(yyvsp[-2].val);v3=(yyvsp[0].val);v4=dispatch3(opassign,v1,v2,v3);(yyval.val)=v4;}
                     }
-#line 12480 "ripper.c"
+#line 12482 "ripper.c"
     break;
 
   case 47: /* command_asgn: primary_value '[' opt_call_args rbracket "operator-assignment" lex_ctxt command_rhs  */
-#line 2529 "ripper.y"
+#line 2531 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_ary_op_assign(p, (yyvsp[-6].val), (yyvsp[-4].val), (yyvsp[-2].val), (yyvsp[0].val), &(yylsp[-4]), &(yyloc));
@@ -12488,33 +12490,33 @@ yyreduce:
 			{VALUE v1,v2,v3,v4,v5,v6,v7;v1=(yyvsp[-6].val);v2=(yyvsp[-4].val);v3=dispatch2(aref_field,v1,v2);v4=v3;v5=(yyvsp[-2].val);v6=(yyvsp[0].val);v7=dispatch3(opassign,v4,v5,v6);(yyval.val)=v7;}
 
                     }
-#line 12492 "ripper.c"
+#line 12494 "ripper.c"
     break;
 
   case 48: /* command_asgn: primary_value call_op "local variable or method" "operator-assignment" lex_ctxt command_rhs  */
-#line 2537 "ripper.y"
+#line 2539 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_attr_op_assign(p, (yyvsp[-5].val), (yyvsp[-4].val), (yyvsp[-3].val), (yyvsp[-2].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7,v8;v1=(yyvsp[-5].val);v2=(yyvsp[-4].val);v3=(yyvsp[-3].val);v4=dispatch3(field,v1,v2,v3);v5=v4;v6=(yyvsp[-2].val);v7=(yyvsp[0].val);v8=dispatch3(opassign,v5,v6,v7);(yyval.val)=v8;}
                     }
-#line 12503 "ripper.c"
+#line 12505 "ripper.c"
     break;
 
   case 49: /* command_asgn: primary_value call_op "constant" "operator-assignment" lex_ctxt command_rhs  */
-#line 2544 "ripper.y"
+#line 2546 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_attr_op_assign(p, (yyvsp[-5].val), (yyvsp[-4].val), (yyvsp[-3].val), (yyvsp[-2].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7,v8;v1=(yyvsp[-5].val);v2=(yyvsp[-4].val);v3=(yyvsp[-3].val);v4=dispatch3(field,v1,v2,v3);v5=v4;v6=(yyvsp[-2].val);v7=(yyvsp[0].val);v8=dispatch3(opassign,v5,v6,v7);(yyval.val)=v8;}
                     }
-#line 12514 "ripper.c"
+#line 12516 "ripper.c"
     break;
 
   case 50: /* command_asgn: primary_value "::" "constant" "operator-assignment" lex_ctxt command_rhs  */
-#line 2551 "ripper.y"
+#line 2553 "ripper.y"
                   {
 #if 0
                         YYLTYPE loc = code_loc_gen(&(yylsp[-5]), &(yylsp[-3]));
@@ -12522,22 +12524,22 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7;v1=(yyvsp[-5].val);v2=(yyvsp[-3].val);v3=dispatch2(const_path_field,v1,v2);v4=v3;v5=(yyvsp[-2].val);v6=(yyvsp[0].val);v7=dispatch3(opassign,v4,v5,v6);(yyval.val)=v7;}
                     }
-#line 12526 "ripper.c"
+#line 12528 "ripper.c"
     break;
 
   case 51: /* command_asgn: primary_value "::" "local variable or method" "operator-assignment" lex_ctxt command_rhs  */
-#line 2559 "ripper.y"
+#line 2561 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_attr_op_assign(p, (yyvsp[-5].val), ID2VAL(idCOLON2), (yyvsp[-3].val), (yyvsp[-2].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7,v8;v1=(yyvsp[-5].val);v2=(yyvsp[-4].val);v3=(yyvsp[-3].val);v4=dispatch3(field,v1,v2,v3);v5=v4;v6=(yyvsp[-2].val);v7=(yyvsp[0].val);v8=dispatch3(opassign,v5,v6,v7);(yyval.val)=v8;}
                     }
-#line 12537 "ripper.c"
+#line 12539 "ripper.c"
     break;
 
   case 52: /* command_asgn: defn_head f_opt_paren_args '=' endless_command  */
-#line 2566 "ripper.y"
+#line 2568 "ripper.y"
                   {
                         endless_method_name(p, get_id((yyvsp[-3].node_def_temp)->nd_mid), &(yylsp[-3]));
                         restore_defun(p, (yyvsp[-3].node_def_temp));
@@ -12550,11 +12552,11 @@ yyreduce:
 			{VALUE v1,v2,v3,v4;v1=(yyvsp[-3].node_def_temp)->nd_mid;v2=(yyvsp[-2].val);v3=(yyvsp[0].val);v4=dispatch3(def,v1,v2,v3);(yyval.val)=v4;}
                         local_pop(p);
                     }
-#line 12554 "ripper.c"
+#line 12556 "ripper.c"
     break;
 
   case 53: /* command_asgn: defs_head f_opt_paren_args '=' endless_command  */
-#line 2579 "ripper.y"
+#line 2581 "ripper.y"
                   {
                         endless_method_name(p, get_id((yyvsp[-3].node_def_temp)->nd_mid), &(yylsp[-3]));
                         restore_defun(p, (yyvsp[-3].node_def_temp));
@@ -12567,11 +12569,11 @@ yyreduce:
 			{VALUE v1,v2,v3,v4,v5,v6;v1=(yyvsp[-3].node_def_temp)->nd_recv;v2=(yyvsp[-3].node_def_temp)->dot_or_colon;v3=(yyvsp[-3].node_def_temp)->nd_mid;v4=(yyvsp[-2].val);v5=(yyvsp[0].val);v6=dispatch5(defs,v1,v2,v3,v4,v5);(yyval.val)=v6;}
                         local_pop(p);
                     }
-#line 12571 "ripper.c"
+#line 12573 "ripper.c"
     break;
 
   case 54: /* command_asgn: backref "operator-assignment" lex_ctxt command_rhs  */
-#line 2592 "ripper.y"
+#line 2594 "ripper.y"
                   {
 #if 0
                         rb_backref_error(p, (yyvsp[-3].val));
@@ -12579,11 +12581,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=var_field(p, (yyvsp[-3].val));v2=(yyvsp[0].val);v3=dispatch2(assign,v1,v2);(yyval.val)=backref_error(p, RNODE((yyvsp[-3].val)), v3);}ripper_error(p);
                     }
-#line 12583 "ripper.c"
+#line 12585 "ripper.c"
     break;
 
   case 56: /* endless_command: endless_command "`rescue' modifier" after_rescue arg  */
-#line 2603 "ripper.y"
+#line 2605 "ripper.y"
                   {
                         p->ctxt.in_rescue = (yyvsp[-1].ctxt).in_rescue;
 #if 0
@@ -12591,28 +12593,28 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-3].val);v2=(yyvsp[0].val);v3=dispatch2(rescue_mod,v1,v2);(yyval.val)=v3;}
                     }
-#line 12595 "ripper.c"
+#line 12597 "ripper.c"
     break;
 
   case 57: /* endless_command: "`not'" opt_nl endless_command  */
-#line 2611 "ripper.y"
+#line 2613 "ripper.y"
                   {
                         (yyval.val) = call_uni_op(p, method_cond(p, (yyvsp[0].val), &(yylsp[0])), METHOD_NOT, &(yylsp[-2]), &(yyloc));
                     }
-#line 12603 "ripper.c"
+#line 12605 "ripper.c"
     break;
 
   case 58: /* command_rhs: command_call  */
-#line 2617 "ripper.y"
+#line 2619 "ripper.y"
                   {
                         value_expr((yyvsp[0].val));
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 12612 "ripper.c"
+#line 12614 "ripper.c"
     break;
 
   case 59: /* command_rhs: command_call "`rescue' modifier" after_rescue stmt  */
-#line 2622 "ripper.y"
+#line 2624 "ripper.y"
                   {
                         p->ctxt.in_rescue = (yyvsp[-1].ctxt).in_rescue;
 #if 0
@@ -12622,51 +12624,51 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-3].val);v2=(yyvsp[0].val);v3=dispatch2(rescue_mod,v1,v2);(yyval.val)=v3;}
                     }
-#line 12626 "ripper.c"
+#line 12628 "ripper.c"
     break;
 
   case 62: /* expr: expr "`and'" expr  */
-#line 2636 "ripper.y"
+#line 2638 "ripper.y"
                   {
                         (yyval.val) = logop(p, idAND, (yyvsp[-2].val), (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
                     }
-#line 12634 "ripper.c"
+#line 12636 "ripper.c"
     break;
 
   case 63: /* expr: expr "`or'" expr  */
-#line 2640 "ripper.y"
+#line 2642 "ripper.y"
                   {
                         (yyval.val) = logop(p, idOR, (yyvsp[-2].val), (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
                     }
-#line 12642 "ripper.c"
+#line 12644 "ripper.c"
     break;
 
   case 64: /* expr: "`not'" opt_nl expr  */
-#line 2644 "ripper.y"
+#line 2646 "ripper.y"
                   {
                         (yyval.val) = call_uni_op(p, method_cond(p, (yyvsp[0].val), &(yylsp[0])), METHOD_NOT, &(yylsp[-2]), &(yyloc));
                     }
-#line 12650 "ripper.c"
+#line 12652 "ripper.c"
     break;
 
   case 65: /* expr: '!' command_call  */
-#line 2648 "ripper.y"
+#line 2650 "ripper.y"
                   {
                         (yyval.val) = call_uni_op(p, method_cond(p, (yyvsp[0].val), &(yylsp[0])), '!', &(yylsp[-1]), &(yyloc));
                     }
-#line 12658 "ripper.c"
+#line 12660 "ripper.c"
     break;
 
   case 66: /* $@7: %empty  */
-#line 2652 "ripper.y"
+#line 2654 "ripper.y"
                   {
                         value_expr((yyvsp[-1].val));
                     }
-#line 12666 "ripper.c"
+#line 12668 "ripper.c"
     break;
 
   case 67: /* expr: arg "=>" $@7 p_in_kwarg p_pvtbl p_pktbl p_top_expr_body  */
-#line 2657 "ripper.y"
+#line 2659 "ripper.y"
                   {
                         pop_pktbl(p, (yyvsp[-1].tbl));
                         pop_pvtbl(p, (yyvsp[-2].tbl));
@@ -12676,19 +12678,19 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7;v1=(yyvsp[0].val);v2=Qnil;v3=Qnil;v4=dispatch3(in,v1,v2,v3);v5=(yyvsp[-6].val);v6=v4;v7=dispatch2(case,v5,v6);(yyval.val)=v7;}
                     }
-#line 12680 "ripper.c"
+#line 12682 "ripper.c"
     break;
 
   case 68: /* $@8: %empty  */
-#line 2667 "ripper.y"
+#line 2669 "ripper.y"
                   {
                         value_expr((yyvsp[-1].val));
                     }
-#line 12688 "ripper.c"
+#line 12690 "ripper.c"
     break;
 
   case 69: /* expr: arg "`in'" $@8 p_in_kwarg p_pvtbl p_pktbl p_top_expr_body  */
-#line 2672 "ripper.y"
+#line 2674 "ripper.y"
                   {
                         pop_pktbl(p, (yyvsp[-1].tbl));
                         pop_pvtbl(p, (yyvsp[-2].tbl));
@@ -12698,11 +12700,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7;v1=(yyvsp[0].val);v2=Qnil;v3=Qnil;v4=dispatch3(in,v1,v2,v3);v5=(yyvsp[-6].val);v6=v4;v7=dispatch2(case,v5,v6);(yyval.val)=v7;}
                     }
-#line 12702 "ripper.c"
+#line 12704 "ripper.c"
     break;
 
   case 71: /* def_name: fname  */
-#line 2685 "ripper.y"
+#line 2687 "ripper.y"
                   {
                         ID fname = get_id((yyvsp[0].val));
                         numparam_name(p, fname);
@@ -12712,11 +12714,11 @@ yyreduce:
                         p->ctxt.in_rescue = before_rescue;
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 12716 "ripper.c"
+#line 12718 "ripper.c"
     break;
 
   case 72: /* defn_head: k_def def_name  */
-#line 2697 "ripper.y"
+#line 2699 "ripper.y"
                   {
                         (yyval.node_def_temp) = def_head_save(p, (yyvsp[-1].node_def_temp));
                         (yyval.node_def_temp)->nd_mid = (yyvsp[0].val);
@@ -12726,20 +12728,20 @@ yyreduce:
                         add_mark_object(p, (yyvsp[0].val));
 
                     }
-#line 12730 "ripper.c"
+#line 12732 "ripper.c"
     break;
 
   case 73: /* $@9: %empty  */
-#line 2709 "ripper.y"
+#line 2711 "ripper.y"
                   {
                         SET_LEX_STATE(EXPR_FNAME);
                         p->ctxt.in_argdef = 1;
                     }
-#line 12739 "ripper.c"
+#line 12741 "ripper.c"
     break;
 
   case 74: /* defs_head: k_def singleton dot_or_colon $@9 def_name  */
-#line 2714 "ripper.y"
+#line 2716 "ripper.y"
                   {
                         SET_LEX_STATE(EXPR_ENDFN|EXPR_LABEL); /* force for args */
                         (yyval.node_def_temp) = def_head_save(p, (yyvsp[-4].node_def_temp));
@@ -12752,83 +12754,83 @@ yyreduce:
                         (yyval.node_def_temp)->dot_or_colon = add_mark_object(p, (yyvsp[-2].val));
 
                     }
-#line 12756 "ripper.c"
+#line 12758 "ripper.c"
     break;
 
   case 75: /* expr_value: expr  */
-#line 2729 "ripper.y"
+#line 2731 "ripper.y"
                   {
                         value_expr((yyvsp[0].val));
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 12765 "ripper.c"
+#line 12767 "ripper.c"
     break;
 
   case 76: /* expr_value: error  */
-#line 2734 "ripper.y"
+#line 2736 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_ERROR(&(yyloc));
 #endif
                     }
-#line 12775 "ripper.c"
+#line 12777 "ripper.c"
     break;
 
   case 77: /* $@10: %empty  */
-#line 2741 "ripper.y"
+#line 2743 "ripper.y"
               {COND_PUSH(1);}
-#line 12781 "ripper.c"
+#line 12783 "ripper.c"
     break;
 
   case 78: /* $@11: %empty  */
-#line 2741 "ripper.y"
+#line 2743 "ripper.y"
                                             {COND_POP();}
-#line 12787 "ripper.c"
+#line 12789 "ripper.c"
     break;
 
   case 79: /* expr_value_do: $@10 expr_value do $@11  */
-#line 2742 "ripper.y"
+#line 2744 "ripper.y"
                   {
                         (yyval.val) = (yyvsp[-2].val);
                     }
-#line 12795 "ripper.c"
+#line 12797 "ripper.c"
     break;
 
   case 83: /* block_command: block_call call_op2 operation2 command_args  */
-#line 2753 "ripper.y"
+#line 2755 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_qcall(p, (yyvsp[-2].val), (yyvsp[-3].val), (yyvsp[-1].val), (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7;v1=(yyvsp[-3].val);v2=(yyvsp[-2].val);v3=(yyvsp[-1].val);v4=dispatch3(call,v1,v2,v3);v5=v4;v6=(yyvsp[0].val);v7=dispatch2(method_add_arg,v5,v6);(yyval.val)=v7;}
                     }
-#line 12806 "ripper.c"
+#line 12808 "ripper.c"
     break;
 
   case 84: /* cmd_brace_block: "{ arg" brace_body '}'  */
-#line 2762 "ripper.y"
+#line 2764 "ripper.y"
                   {
                         (yyval.val) = (yyvsp[-1].val);
 #if 0
                         set_embraced_location((yyval.val), &(yylsp[-2]), &(yylsp[0]));
 #endif
                     }
-#line 12817 "ripper.c"
+#line 12819 "ripper.c"
     break;
 
   case 85: /* fcall: operation  */
-#line 2771 "ripper.y"
+#line 2773 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_FCALL((yyvsp[0].val), 0, &(yyloc));
 #endif
 			(yyval.val)=(yyvsp[0].val);
                     }
-#line 12828 "ripper.c"
+#line 12830 "ripper.c"
     break;
 
   case 86: /* command: fcall command_args  */
-#line 2780 "ripper.y"
+#line 2782 "ripper.y"
                   {
 #if 0
                         (yyvsp[-1].val)->nd_args = (yyvsp[0].val);
@@ -12837,11 +12839,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-1].val);v2=(yyvsp[0].val);v3=dispatch2(command,v1,v2);(yyval.val)=v3;}
                     }
-#line 12841 "ripper.c"
+#line 12843 "ripper.c"
     break;
 
   case 87: /* command: fcall command_args cmd_brace_block  */
-#line 2789 "ripper.y"
+#line 2791 "ripper.y"
                   {
 #if 0
                         block_dup_check(p, (yyvsp[-1].val), (yyvsp[0].val));
@@ -12852,55 +12854,55 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6;v1=(yyvsp[-2].val);v2=(yyvsp[-1].val);v3=dispatch2(command,v1,v2);v4=v3;v5=(yyvsp[0].val);v6=dispatch2(method_add_block,v4,v5);(yyval.val)=v6;}
                     }
-#line 12856 "ripper.c"
+#line 12858 "ripper.c"
     break;
 
   case 88: /* command: primary_value call_op operation2 command_args  */
-#line 2800 "ripper.y"
+#line 2802 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_command_qcall(p, (yyvsp[-2].val), (yyvsp[-3].val), (yyvsp[-1].val), (yyvsp[0].val), Qnull, &(yylsp[-1]), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5;v1=(yyvsp[-3].val);v2=(yyvsp[-2].val);v3=(yyvsp[-1].val);v4=(yyvsp[0].val);v5=dispatch4(command_call,v1,v2,v3,v4);(yyval.val)=v5;}
                     }
-#line 12867 "ripper.c"
+#line 12869 "ripper.c"
     break;
 
   case 89: /* command: primary_value call_op operation2 command_args cmd_brace_block  */
-#line 2807 "ripper.y"
+#line 2809 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_command_qcall(p, (yyvsp[-3].val), (yyvsp[-4].val), (yyvsp[-2].val), (yyvsp[-1].val), (yyvsp[0].val), &(yylsp[-2]), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7,v8;v1=(yyvsp[-4].val);v2=(yyvsp[-3].val);v3=(yyvsp[-2].val);v4=(yyvsp[-1].val);v5=dispatch4(command_call,v1,v2,v3,v4);v6=v5;v7=(yyvsp[0].val);v8=dispatch2(method_add_block,v6,v7);(yyval.val)=v8;}
                     }
-#line 12878 "ripper.c"
+#line 12880 "ripper.c"
     break;
 
   case 90: /* command: primary_value "::" operation2 command_args  */
-#line 2814 "ripper.y"
+#line 2816 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_command_qcall(p, ID2VAL(idCOLON2), (yyvsp[-3].val), (yyvsp[-1].val), (yyvsp[0].val), Qnull, &(yylsp[-1]), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5;v1=(yyvsp[-3].val);v2=(yyvsp[-2].val);v3=(yyvsp[-1].val);v4=(yyvsp[0].val);v5=dispatch4(command_call,v1,v2,v3,v4);(yyval.val)=v5;}
                     }
-#line 12889 "ripper.c"
+#line 12891 "ripper.c"
     break;
 
   case 91: /* command: primary_value "::" operation2 command_args cmd_brace_block  */
-#line 2821 "ripper.y"
+#line 2823 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_command_qcall(p, ID2VAL(idCOLON2), (yyvsp[-4].val), (yyvsp[-2].val), (yyvsp[-1].val), (yyvsp[0].val), &(yylsp[-2]), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7,v8;v1=(yyvsp[-4].val);v2=(yyvsp[-3].val);v3=(yyvsp[-2].val);v4=(yyvsp[-1].val);v5=dispatch4(command_call,v1,v2,v3,v4);v6=v5;v7=(yyvsp[0].val);v8=dispatch2(method_add_block,v6,v7);(yyval.val)=v8;}
                    }
-#line 12900 "ripper.c"
+#line 12902 "ripper.c"
     break;
 
   case 92: /* command: primary_value "::" "constant" '{' brace_body '}'  */
-#line 2828 "ripper.y"
+#line 2830 "ripper.y"
                   {
 #if 0
                         set_embraced_location((yyvsp[-1].val), &(yylsp[-2]), &(yylsp[0]));
@@ -12908,11 +12910,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7,v8;v1=(yyvsp[-5].val);v2=(yyvsp[-4].val);v3=(yyvsp[-3].val);v4=Qnull;v5=dispatch4(command_call,v1,v2,v3,v4);v6=v5;v7=(yyvsp[-1].val);v8=dispatch2(method_add_block,v6,v7);(yyval.val)=v8;}
                    }
-#line 12912 "ripper.c"
+#line 12914 "ripper.c"
     break;
 
   case 93: /* command: "`super'" command_args  */
-#line 2836 "ripper.y"
+#line 2838 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_SUPER((yyvsp[0].val), &(yyloc));
@@ -12920,11 +12922,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(super,v1);(yyval.val)=v2;}
                     }
-#line 12924 "ripper.c"
+#line 12926 "ripper.c"
     break;
 
   case 94: /* command: k_yield command_args  */
-#line 2844 "ripper.y"
+#line 2846 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_yield(p, (yyvsp[0].val), &(yyloc));
@@ -12932,22 +12934,22 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(yield,v1);(yyval.val)=v2;}
                     }
-#line 12936 "ripper.c"
+#line 12938 "ripper.c"
     break;
 
   case 95: /* command: k_return call_args  */
-#line 2852 "ripper.y"
+#line 2854 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_RETURN(ret_args(p, (yyvsp[0].val)), &(yyloc));
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(return,v1);(yyval.val)=v2;}
                     }
-#line 12947 "ripper.c"
+#line 12949 "ripper.c"
     break;
 
   case 96: /* command: "`break'" call_args  */
-#line 2859 "ripper.y"
+#line 2861 "ripper.y"
                   {
                         NODE *args = 0;
 #if 0
@@ -12956,11 +12958,11 @@ yyreduce:
                         (yyval.node) = add_block_exit(p, NEW_BREAK(args, &(yyloc)));
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(break,v1);(yyval.val)=v2;}
                     }
-#line 12960 "ripper.c"
+#line 12962 "ripper.c"
     break;
 
   case 97: /* command: "`next'" call_args  */
-#line 2868 "ripper.y"
+#line 2870 "ripper.y"
                   {
                         NODE *args = 0;
 #if 0
@@ -12969,288 +12971,288 @@ yyreduce:
                         (yyval.node) = add_block_exit(p, NEW_NEXT(args, &(yyloc)));
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(next,v1);(yyval.val)=v2;}
                     }
-#line 12973 "ripper.c"
+#line 12975 "ripper.c"
     break;
 
   case 99: /* mlhs: "(" mlhs_inner rparen  */
-#line 2880 "ripper.y"
+#line 2882 "ripper.y"
                   {
 #if 0
                         (yyval.val) = (yyvsp[-1].val);
 #endif
 			{VALUE v1,v2;v1=(yyvsp[-1].val);v2=dispatch1(mlhs_paren,v1);(yyval.val)=v2;}
                     }
-#line 12984 "ripper.c"
+#line 12986 "ripper.c"
     break;
 
   case 101: /* mlhs_inner: "(" mlhs_inner rparen  */
-#line 2890 "ripper.y"
+#line 2892 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_MASGN(NEW_LIST((NODE *)(yyvsp[-1].val), &(yyloc)), 0, &(yyloc));
 #endif
 			{VALUE v1,v2;v1=(yyvsp[-1].val);v2=dispatch1(mlhs_paren,v1);(yyval.val)=v2;}
                     }
-#line 12995 "ripper.c"
+#line 12997 "ripper.c"
     break;
 
   case 102: /* mlhs_basic: mlhs_head  */
-#line 2899 "ripper.y"
+#line 2901 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_MASGN((yyvsp[0].val), 0, &(yyloc));
 #endif
 			(yyval.val)=(yyvsp[0].val);
                     }
-#line 13006 "ripper.c"
+#line 13008 "ripper.c"
     break;
 
   case 103: /* mlhs_basic: mlhs_head mlhs_item  */
-#line 2906 "ripper.y"
+#line 2908 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_MASGN(list_append(p, (yyvsp[-1].val), (yyvsp[0].val)), 0, &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-1].val);v2=(yyvsp[0].val);v3=dispatch2(mlhs_add,v1,v2);(yyval.val)=v3;}
                     }
-#line 13017 "ripper.c"
+#line 13019 "ripper.c"
     break;
 
   case 104: /* mlhs_basic: mlhs_head "*" mlhs_node  */
-#line 2913 "ripper.y"
+#line 2915 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_MASGN((yyvsp[-2].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[0].val);v3=dispatch2(mlhs_add_star,v1,v2);(yyval.val)=v3;}
                     }
-#line 13028 "ripper.c"
+#line 13030 "ripper.c"
     break;
 
   case 105: /* mlhs_basic: mlhs_head "*" mlhs_node ',' mlhs_post  */
-#line 2920 "ripper.y"
+#line 2922 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_MASGN((yyvsp[-4].val), NEW_POSTARG((yyvsp[-2].val),(yyvsp[0].val),&(yyloc)), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6;v1=(yyvsp[-4].val);v2=(yyvsp[-2].val);v3=dispatch2(mlhs_add_star,v1,v2);v4=v3;v5=(yyvsp[0].val);v6=dispatch2(mlhs_add_post,v4,v5);(yyval.val)=v6;}
                     }
-#line 13039 "ripper.c"
+#line 13041 "ripper.c"
     break;
 
   case 106: /* mlhs_basic: mlhs_head "*"  */
-#line 2927 "ripper.y"
+#line 2929 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_MASGN((yyvsp[-1].val), NODE_SPECIAL_NO_NAME_REST, &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-1].val);v2=Qnil;v3=dispatch2(mlhs_add_star,v1,v2);(yyval.val)=v3;}
                     }
-#line 13050 "ripper.c"
+#line 13052 "ripper.c"
     break;
 
   case 107: /* mlhs_basic: mlhs_head "*" ',' mlhs_post  */
-#line 2934 "ripper.y"
+#line 2936 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_MASGN((yyvsp[-3].val), NEW_POSTARG(NODE_SPECIAL_NO_NAME_REST, (yyvsp[0].val), &(yyloc)), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6;v1=(yyvsp[-3].val);v2=Qnil;v3=dispatch2(mlhs_add_star,v1,v2);v4=v3;v5=(yyvsp[0].val);v6=dispatch2(mlhs_add_post,v4,v5);(yyval.val)=v6;}
                     }
-#line 13061 "ripper.c"
+#line 13063 "ripper.c"
     break;
 
   case 108: /* mlhs_basic: "*" mlhs_node  */
-#line 2941 "ripper.y"
+#line 2943 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_MASGN(0, (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4;v1=dispatch0(mlhs_new);v2=v1;v3=(yyvsp[0].val);v4=dispatch2(mlhs_add_star,v2,v3);(yyval.val)=v4;}
                     }
-#line 13072 "ripper.c"
+#line 13074 "ripper.c"
     break;
 
   case 109: /* mlhs_basic: "*" mlhs_node ',' mlhs_post  */
-#line 2948 "ripper.y"
+#line 2950 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_MASGN(0, NEW_POSTARG((yyvsp[-2].val),(yyvsp[0].val),&(yyloc)), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7;v1=dispatch0(mlhs_new);v2=v1;v3=(yyvsp[-2].val);v4=dispatch2(mlhs_add_star,v2,v3);v5=v4;v6=(yyvsp[0].val);v7=dispatch2(mlhs_add_post,v5,v6);(yyval.val)=v7;}
                     }
-#line 13083 "ripper.c"
+#line 13085 "ripper.c"
     break;
 
   case 110: /* mlhs_basic: "*"  */
-#line 2955 "ripper.y"
+#line 2957 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_MASGN(0, NODE_SPECIAL_NO_NAME_REST, &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4;v1=dispatch0(mlhs_new);v2=v1;v3=Qnil;v4=dispatch2(mlhs_add_star,v2,v3);(yyval.val)=v4;}
                     }
-#line 13094 "ripper.c"
+#line 13096 "ripper.c"
     break;
 
   case 111: /* mlhs_basic: "*" ',' mlhs_post  */
-#line 2962 "ripper.y"
+#line 2964 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_MASGN(0, NEW_POSTARG(NODE_SPECIAL_NO_NAME_REST, (yyvsp[0].val), &(yyloc)), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7;v1=dispatch0(mlhs_new);v2=v1;v3=Qnil;v4=dispatch2(mlhs_add_star,v2,v3);v5=v4;v6=(yyvsp[0].val);v7=dispatch2(mlhs_add_post,v5,v6);(yyval.val)=v7;}
                     }
-#line 13105 "ripper.c"
+#line 13107 "ripper.c"
     break;
 
   case 113: /* mlhs_item: "(" mlhs_inner rparen  */
-#line 2972 "ripper.y"
+#line 2974 "ripper.y"
                   {
 #if 0
                         (yyval.val) = (NODE *)(yyvsp[-1].val);
 #endif
 			{VALUE v1,v2;v1=(yyvsp[-1].val);v2=dispatch1(mlhs_paren,v1);(yyval.val)=v2;}
                     }
-#line 13116 "ripper.c"
+#line 13118 "ripper.c"
     break;
 
   case 114: /* mlhs_head: mlhs_item ','  */
-#line 2981 "ripper.y"
+#line 2983 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_LIST((yyvsp[-1].val), &(yylsp[-1]));
 #endif
 			{VALUE v1,v2,v3,v4;v1=dispatch0(mlhs_new);v2=v1;v3=(yyvsp[-1].val);v4=dispatch2(mlhs_add,v2,v3);(yyval.val)=v4;}
                     }
-#line 13127 "ripper.c"
+#line 13129 "ripper.c"
     break;
 
   case 115: /* mlhs_head: mlhs_head mlhs_item ','  */
-#line 2988 "ripper.y"
+#line 2990 "ripper.y"
                   {
 #if 0
                         (yyval.val) = list_append(p, (yyvsp[-2].val), (yyvsp[-1].val));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[-1].val);v3=dispatch2(mlhs_add,v1,v2);(yyval.val)=v3;}
                     }
-#line 13138 "ripper.c"
+#line 13140 "ripper.c"
     break;
 
   case 116: /* mlhs_post: mlhs_item  */
-#line 2997 "ripper.y"
+#line 2999 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_LIST((yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4;v1=dispatch0(mlhs_new);v2=v1;v3=(yyvsp[0].val);v4=dispatch2(mlhs_add,v2,v3);(yyval.val)=v4;}
                     }
-#line 13149 "ripper.c"
+#line 13151 "ripper.c"
     break;
 
   case 117: /* mlhs_post: mlhs_post ',' mlhs_item  */
-#line 3004 "ripper.y"
+#line 3006 "ripper.y"
                   {
 #if 0
                         (yyval.val) = list_append(p, (yyvsp[-2].val), (yyvsp[0].val));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[0].val);v3=dispatch2(mlhs_add,v1,v2);(yyval.val)=v3;}
                     }
-#line 13160 "ripper.c"
+#line 13162 "ripper.c"
     break;
 
   case 118: /* mlhs_node: user_variable  */
-#line 3013 "ripper.y"
+#line 3015 "ripper.y"
                   {
 #if 0
                         (yyval.val) = assignable(p, (yyvsp[0].val), 0, &(yyloc));
 #endif
 			(yyval.val)=assignable(p, var_field(p, (yyvsp[0].val)));
                     }
-#line 13171 "ripper.c"
+#line 13173 "ripper.c"
     break;
 
   case 119: /* mlhs_node: keyword_variable  */
-#line 3020 "ripper.y"
+#line 3022 "ripper.y"
                   {
 #if 0
                         (yyval.val) = assignable(p, (yyvsp[0].val), 0, &(yyloc));
 #endif
 			(yyval.val)=assignable(p, var_field(p, (yyvsp[0].val)));
                     }
-#line 13182 "ripper.c"
+#line 13184 "ripper.c"
     break;
 
   case 120: /* mlhs_node: primary_value '[' opt_call_args rbracket  */
-#line 3027 "ripper.y"
+#line 3029 "ripper.y"
                   {
 #if 0
                         (yyval.val) = aryset(p, (yyvsp[-3].val), (yyvsp[-1].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-3].val);v2=(yyvsp[-1].val);v3=dispatch2(aref_field,v1,v2);(yyval.val)=v3;}
                     }
-#line 13193 "ripper.c"
+#line 13195 "ripper.c"
     break;
 
   case 121: /* mlhs_node: primary_value call_op "local variable or method"  */
-#line 3034 "ripper.y"
+#line 3036 "ripper.y"
                   {
-                        anddot_multiple_assignment_check(p, &(yylsp[-1]), (yyvsp[-1].val));
+                        anddot_multiple_assignment_check(p, &(yylsp[-1]), (ID)(yyvsp[-1].val));
 #if 0
                         (yyval.val) = attrset(p, (yyvsp[-2].val), (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4;v1=(yyvsp[-2].val);v2=(yyvsp[-1].val);v3=(yyvsp[0].val);v4=dispatch3(field,v1,v2,v3);(yyval.val)=v4;}
                     }
-#line 13205 "ripper.c"
+#line 13207 "ripper.c"
     break;
 
   case 122: /* mlhs_node: primary_value "::" "local variable or method"  */
-#line 3042 "ripper.y"
+#line 3044 "ripper.y"
                   {
 #if 0
                         (yyval.val) = attrset(p, (yyvsp[-2].val), idCOLON2, (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[0].val);v3=dispatch2(const_path_field,v1,v2);(yyval.val)=v3;}
                     }
-#line 13216 "ripper.c"
+#line 13218 "ripper.c"
     break;
 
   case 123: /* mlhs_node: primary_value call_op "constant"  */
-#line 3049 "ripper.y"
+#line 3051 "ripper.y"
                   {
-                        anddot_multiple_assignment_check(p, &(yylsp[-1]), (yyvsp[-1].val));
+                        anddot_multiple_assignment_check(p, &(yylsp[-1]), (ID)(yyvsp[-1].val));
 #if 0
                         (yyval.val) = attrset(p, (yyvsp[-2].val), (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4;v1=(yyvsp[-2].val);v2=(yyvsp[-1].val);v3=(yyvsp[0].val);v4=dispatch3(field,v1,v2,v3);(yyval.val)=v4;}
                     }
-#line 13228 "ripper.c"
+#line 13230 "ripper.c"
     break;
 
   case 124: /* mlhs_node: primary_value "::" "constant"  */
-#line 3057 "ripper.y"
+#line 3059 "ripper.y"
                   {
 #if 0
                         (yyval.val) = const_decl(p, NEW_COLON2((yyvsp[-2].val), (yyvsp[0].val), &(yyloc)), &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[0].val);v3=dispatch2(const_path_field,v1,v2);(yyval.val)=const_decl(p, v3);}
                     }
-#line 13239 "ripper.c"
+#line 13241 "ripper.c"
     break;
 
   case 125: /* mlhs_node: ":: at EXPR_BEG" "constant"  */
-#line 3064 "ripper.y"
+#line 3066 "ripper.y"
                   {
 #if 0
                         (yyval.val) = const_decl(p, NEW_COLON3((yyvsp[0].val), &(yyloc)), &(yyloc));
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(top_const_field,v1);(yyval.val)=const_decl(p, v2);}
                     }
-#line 13250 "ripper.c"
+#line 13252 "ripper.c"
     break;
 
   case 126: /* mlhs_node: backref  */
-#line 3071 "ripper.y"
+#line 3073 "ripper.y"
                   {
 #if 0
                         rb_backref_error(p, (yyvsp[0].val));
@@ -13258,99 +13260,99 @@ yyreduce:
 #endif
 			(yyval.val)=backref_error(p, RNODE((yyvsp[0].val)), var_field(p, (yyvsp[0].val)));ripper_error(p);
                     }
-#line 13262 "ripper.c"
+#line 13264 "ripper.c"
     break;
 
   case 127: /* lhs: user_variable  */
-#line 3081 "ripper.y"
+#line 3083 "ripper.y"
                   {
 #if 0
                         (yyval.val) = assignable(p, (yyvsp[0].val), 0, &(yyloc));
 #endif
 			(yyval.val)=assignable(p, var_field(p, (yyvsp[0].val)));
                     }
-#line 13273 "ripper.c"
+#line 13275 "ripper.c"
     break;
 
   case 128: /* lhs: keyword_variable  */
-#line 3088 "ripper.y"
+#line 3090 "ripper.y"
                   {
 #if 0
                         (yyval.val) = assignable(p, (yyvsp[0].val), 0, &(yyloc));
 #endif
 			(yyval.val)=assignable(p, var_field(p, (yyvsp[0].val)));
                     }
-#line 13284 "ripper.c"
+#line 13286 "ripper.c"
     break;
 
   case 129: /* lhs: primary_value '[' opt_call_args rbracket  */
-#line 3095 "ripper.y"
+#line 3097 "ripper.y"
                   {
 #if 0
                         (yyval.val) = aryset(p, (yyvsp[-3].val), (yyvsp[-1].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-3].val);v2=(yyvsp[-1].val);v3=dispatch2(aref_field,v1,v2);(yyval.val)=v3;}
                     }
-#line 13295 "ripper.c"
+#line 13297 "ripper.c"
     break;
 
   case 130: /* lhs: primary_value call_op "local variable or method"  */
-#line 3102 "ripper.y"
+#line 3104 "ripper.y"
                   {
 #if 0
                         (yyval.val) = attrset(p, (yyvsp[-2].val), (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4;v1=(yyvsp[-2].val);v2=(yyvsp[-1].val);v3=(yyvsp[0].val);v4=dispatch3(field,v1,v2,v3);(yyval.val)=v4;}
                     }
-#line 13306 "ripper.c"
+#line 13308 "ripper.c"
     break;
 
   case 131: /* lhs: primary_value "::" "local variable or method"  */
-#line 3109 "ripper.y"
+#line 3111 "ripper.y"
                   {
 #if 0
                         (yyval.val) = attrset(p, (yyvsp[-2].val), idCOLON2, (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4;v1=(yyvsp[-2].val);v2=(yyvsp[-1].val);v3=(yyvsp[0].val);v4=dispatch3(field,v1,v2,v3);(yyval.val)=v4;}
                     }
-#line 13317 "ripper.c"
+#line 13319 "ripper.c"
     break;
 
   case 132: /* lhs: primary_value call_op "constant"  */
-#line 3116 "ripper.y"
+#line 3118 "ripper.y"
                   {
 #if 0
                         (yyval.val) = attrset(p, (yyvsp[-2].val), (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4;v1=(yyvsp[-2].val);v2=(yyvsp[-1].val);v3=(yyvsp[0].val);v4=dispatch3(field,v1,v2,v3);(yyval.val)=v4;}
                     }
-#line 13328 "ripper.c"
+#line 13330 "ripper.c"
     break;
 
   case 133: /* lhs: primary_value "::" "constant"  */
-#line 3123 "ripper.y"
+#line 3125 "ripper.y"
                   {
 #if 0
                         (yyval.val) = const_decl(p, NEW_COLON2((yyvsp[-2].val), (yyvsp[0].val), &(yyloc)), &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[0].val);v3=dispatch2(const_path_field,v1,v2);(yyval.val)=const_decl(p, v3);}
                     }
-#line 13339 "ripper.c"
+#line 13341 "ripper.c"
     break;
 
   case 134: /* lhs: ":: at EXPR_BEG" "constant"  */
-#line 3130 "ripper.y"
+#line 3132 "ripper.y"
                   {
 #if 0
                         (yyval.val) = const_decl(p, NEW_COLON3((yyvsp[0].val), &(yyloc)), &(yyloc));
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(top_const_field,v1);(yyval.val)=const_decl(p, v2);}
                     }
-#line 13350 "ripper.c"
+#line 13352 "ripper.c"
     break;
 
   case 135: /* lhs: backref  */
-#line 3137 "ripper.y"
+#line 3139 "ripper.y"
                   {
 #if 0
                         rb_backref_error(p, (yyvsp[0].val));
@@ -13358,11 +13360,11 @@ yyreduce:
 #endif
 			(yyval.val)=backref_error(p, RNODE((yyvsp[0].val)), var_field(p, (yyvsp[0].val)));ripper_error(p);
                     }
-#line 13362 "ripper.c"
+#line 13364 "ripper.c"
     break;
 
   case 136: /* cname: "local variable or method"  */
-#line 3147 "ripper.y"
+#line 3149 "ripper.y"
                   {
                         static const char mesg[] = "class/module name must be CONSTANT";
 #if 0
@@ -13370,81 +13372,81 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=ERR_MESG();v2=(yyvsp[0].val);v3=dispatch2(class_name_error,v1,v2);(yyval.val)=v3;}ripper_error(p);
                     }
-#line 13374 "ripper.c"
+#line 13376 "ripper.c"
     break;
 
   case 138: /* cpath: ":: at EXPR_BEG" cname  */
-#line 3158 "ripper.y"
+#line 3160 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_COLON3((yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(top_const_ref,v1);(yyval.val)=v2;}
                     }
-#line 13385 "ripper.c"
+#line 13387 "ripper.c"
     break;
 
   case 139: /* cpath: cname  */
-#line 3165 "ripper.y"
+#line 3167 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_COLON2(0, (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(const_ref,v1);(yyval.val)=v2;}
                     }
-#line 13396 "ripper.c"
+#line 13398 "ripper.c"
     break;
 
   case 140: /* cpath: primary_value "::" cname  */
-#line 3172 "ripper.y"
+#line 3174 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_COLON2((yyvsp[-2].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[0].val);v3=dispatch2(const_path_ref,v1,v2);(yyval.val)=v3;}
                     }
-#line 13407 "ripper.c"
+#line 13409 "ripper.c"
     break;
 
   case 144: /* fname: op  */
-#line 3184 "ripper.y"
+#line 3186 "ripper.y"
                   {
                         SET_LEX_STATE(EXPR_ENDFN);
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 13416 "ripper.c"
+#line 13418 "ripper.c"
     break;
 
   case 146: /* fitem: fname  */
-#line 3192 "ripper.y"
+#line 3194 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_LIT(ID2SYM((yyvsp[0].val)), &(yyloc));
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(symbol_literal,v1);(yyval.val)=v2;}
                     }
-#line 13427 "ripper.c"
+#line 13429 "ripper.c"
     break;
 
   case 148: /* undef_list: fitem  */
-#line 3202 "ripper.y"
+#line 3204 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_UNDEF((yyvsp[0].val), &(yyloc));
 #endif
 			(yyval.val)=rb_ary_new3(1, get_value((yyvsp[0].val)));
                     }
-#line 13438 "ripper.c"
+#line 13440 "ripper.c"
     break;
 
   case 149: /* $@12: %empty  */
-#line 3208 "ripper.y"
+#line 3210 "ripper.y"
                                {SET_LEX_STATE(EXPR_FNAME|EXPR_FITEM);}
-#line 13444 "ripper.c"
+#line 13446 "ripper.c"
     break;
 
   case 150: /* undef_list: undef_list ',' $@12 fitem  */
-#line 3209 "ripper.y"
+#line 3211 "ripper.y"
                   {
 #if 0
                         NODE *undef = NEW_UNDEF((yyvsp[0].val), &(yylsp[0]));
@@ -13452,257 +13454,257 @@ yyreduce:
 #endif
 			(yyval.val)=rb_ary_push((yyvsp[-3].val), get_value((yyvsp[0].val)));
                     }
-#line 13456 "ripper.c"
+#line 13458 "ripper.c"
     break;
 
   case 151: /* op: '|'  */
-#line 3218 "ripper.y"
+#line 3220 "ripper.y"
          { ifndef_ripper((yyval.val) = '|'); }
-#line 13462 "ripper.c"
+#line 13464 "ripper.c"
     break;
 
   case 152: /* op: '^'  */
-#line 3219 "ripper.y"
+#line 3221 "ripper.y"
                      { ifndef_ripper((yyval.val) = '^'); }
-#line 13468 "ripper.c"
+#line 13470 "ripper.c"
     break;
 
   case 153: /* op: '&'  */
-#line 3220 "ripper.y"
+#line 3222 "ripper.y"
                      { ifndef_ripper((yyval.val) = '&'); }
-#line 13474 "ripper.c"
+#line 13476 "ripper.c"
     break;
 
   case 154: /* op: "<=>"  */
-#line 3221 "ripper.y"
+#line 3223 "ripper.y"
                       { ifndef_ripper((yyval.val) = tCMP); }
-#line 13480 "ripper.c"
+#line 13482 "ripper.c"
     break;
 
   case 155: /* op: "=="  */
-#line 3222 "ripper.y"
+#line 3224 "ripper.y"
                      { ifndef_ripper((yyval.val) = tEQ); }
-#line 13486 "ripper.c"
+#line 13488 "ripper.c"
     break;
 
   case 156: /* op: "==="  */
-#line 3223 "ripper.y"
+#line 3225 "ripper.y"
                       { ifndef_ripper((yyval.val) = tEQQ); }
-#line 13492 "ripper.c"
+#line 13494 "ripper.c"
     break;
 
   case 157: /* op: "=~"  */
-#line 3224 "ripper.y"
+#line 3226 "ripper.y"
                        { ifndef_ripper((yyval.val) = tMATCH); }
-#line 13498 "ripper.c"
+#line 13500 "ripper.c"
     break;
 
   case 158: /* op: "!~"  */
-#line 3225 "ripper.y"
+#line 3227 "ripper.y"
                         { ifndef_ripper((yyval.val) = tNMATCH); }
-#line 13504 "ripper.c"
+#line 13506 "ripper.c"
     break;
 
   case 159: /* op: '>'  */
-#line 3226 "ripper.y"
+#line 3228 "ripper.y"
                      { ifndef_ripper((yyval.val) = '>'); }
-#line 13510 "ripper.c"
+#line 13512 "ripper.c"
     break;
 
   case 160: /* op: ">="  */
-#line 3227 "ripper.y"
+#line 3229 "ripper.y"
                       { ifndef_ripper((yyval.val) = tGEQ); }
-#line 13516 "ripper.c"
+#line 13518 "ripper.c"
     break;
 
   case 161: /* op: '<'  */
-#line 3228 "ripper.y"
+#line 3230 "ripper.y"
                      { ifndef_ripper((yyval.val) = '<'); }
-#line 13522 "ripper.c"
+#line 13524 "ripper.c"
     break;
 
   case 162: /* op: "<="  */
-#line 3229 "ripper.y"
+#line 3231 "ripper.y"
                       { ifndef_ripper((yyval.val) = tLEQ); }
-#line 13528 "ripper.c"
+#line 13530 "ripper.c"
     break;
 
   case 163: /* op: "!="  */
-#line 3230 "ripper.y"
+#line 3232 "ripper.y"
                       { ifndef_ripper((yyval.val) = tNEQ); }
-#line 13534 "ripper.c"
+#line 13536 "ripper.c"
     break;
 
   case 164: /* op: "<<"  */
-#line 3231 "ripper.y"
+#line 3233 "ripper.y"
                        { ifndef_ripper((yyval.val) = tLSHFT); }
-#line 13540 "ripper.c"
+#line 13542 "ripper.c"
     break;
 
   case 165: /* op: ">>"  */
-#line 3232 "ripper.y"
+#line 3234 "ripper.y"
                        { ifndef_ripper((yyval.val) = tRSHFT); }
-#line 13546 "ripper.c"
+#line 13548 "ripper.c"
     break;
 
   case 166: /* op: '+'  */
-#line 3233 "ripper.y"
+#line 3235 "ripper.y"
                      { ifndef_ripper((yyval.val) = '+'); }
-#line 13552 "ripper.c"
+#line 13554 "ripper.c"
     break;
 
   case 167: /* op: '-'  */
-#line 3234 "ripper.y"
+#line 3236 "ripper.y"
                      { ifndef_ripper((yyval.val) = '-'); }
-#line 13558 "ripper.c"
+#line 13560 "ripper.c"
     break;
 
   case 168: /* op: '*'  */
-#line 3235 "ripper.y"
+#line 3237 "ripper.y"
                      { ifndef_ripper((yyval.val) = '*'); }
-#line 13564 "ripper.c"
+#line 13566 "ripper.c"
     break;
 
   case 169: /* op: "*"  */
-#line 3236 "ripper.y"
+#line 3238 "ripper.y"
                        { ifndef_ripper((yyval.val) = '*'); }
-#line 13570 "ripper.c"
+#line 13572 "ripper.c"
     break;
 
   case 170: /* op: '/'  */
-#line 3237 "ripper.y"
+#line 3239 "ripper.y"
                      { ifndef_ripper((yyval.val) = '/'); }
-#line 13576 "ripper.c"
+#line 13578 "ripper.c"
     break;
 
   case 171: /* op: '%'  */
-#line 3238 "ripper.y"
+#line 3240 "ripper.y"
                      { ifndef_ripper((yyval.val) = '%'); }
-#line 13582 "ripper.c"
+#line 13584 "ripper.c"
     break;
 
   case 172: /* op: "**"  */
-#line 3239 "ripper.y"
+#line 3241 "ripper.y"
                       { ifndef_ripper((yyval.val) = tPOW); }
-#line 13588 "ripper.c"
+#line 13590 "ripper.c"
     break;
 
   case 173: /* op: "**arg"  */
-#line 3240 "ripper.y"
+#line 3242 "ripper.y"
                        { ifndef_ripper((yyval.val) = tDSTAR); }
-#line 13594 "ripper.c"
+#line 13596 "ripper.c"
     break;
 
   case 174: /* op: '!'  */
-#line 3241 "ripper.y"
+#line 3243 "ripper.y"
                      { ifndef_ripper((yyval.val) = '!'); }
-#line 13600 "ripper.c"
+#line 13602 "ripper.c"
     break;
 
   case 175: /* op: '~'  */
-#line 3242 "ripper.y"
+#line 3244 "ripper.y"
                      { ifndef_ripper((yyval.val) = '~'); }
-#line 13606 "ripper.c"
+#line 13608 "ripper.c"
     break;
 
   case 176: /* op: "unary+"  */
-#line 3243 "ripper.y"
+#line 3245 "ripper.y"
                        { ifndef_ripper((yyval.val) = tUPLUS); }
-#line 13612 "ripper.c"
+#line 13614 "ripper.c"
     break;
 
   case 177: /* op: "unary-"  */
-#line 3244 "ripper.y"
+#line 3246 "ripper.y"
                         { ifndef_ripper((yyval.val) = tUMINUS); }
-#line 13618 "ripper.c"
+#line 13620 "ripper.c"
     break;
 
   case 178: /* op: "[]"  */
-#line 3245 "ripper.y"
+#line 3247 "ripper.y"
                        { ifndef_ripper((yyval.val) = tAREF); }
-#line 13624 "ripper.c"
+#line 13626 "ripper.c"
     break;
 
   case 179: /* op: "[]="  */
-#line 3246 "ripper.y"
+#line 3248 "ripper.y"
                        { ifndef_ripper((yyval.val) = tASET); }
-#line 13630 "ripper.c"
+#line 13632 "ripper.c"
     break;
 
   case 180: /* op: '`'  */
-#line 3247 "ripper.y"
+#line 3249 "ripper.y"
                      { ifndef_ripper((yyval.val) = '`'); }
-#line 13636 "ripper.c"
+#line 13638 "ripper.c"
     break;
 
   case 222: /* arg: lhs '=' lex_ctxt arg_rhs  */
-#line 3265 "ripper.y"
+#line 3267 "ripper.y"
                   {
 #if 0
                         (yyval.val) = node_assign(p, (yyvsp[-3].val), (yyvsp[0].val), (yyvsp[-1].ctxt), &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-3].val);v2=(yyvsp[0].val);v3=dispatch2(assign,v1,v2);(yyval.val)=v3;}
                     }
-#line 13647 "ripper.c"
+#line 13649 "ripper.c"
     break;
 
   case 223: /* arg: var_lhs "operator-assignment" lex_ctxt arg_rhs  */
-#line 3272 "ripper.y"
+#line 3274 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_op_assign(p, (yyvsp[-3].val), (yyvsp[-2].val), (yyvsp[0].val), (yyvsp[-1].ctxt), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4;v1=(yyvsp[-3].val);v2=(yyvsp[-2].val);v3=(yyvsp[0].val);v4=dispatch3(opassign,v1,v2,v3);(yyval.val)=v4;}
                     }
-#line 13658 "ripper.c"
+#line 13660 "ripper.c"
     break;
 
   case 224: /* arg: primary_value '[' opt_call_args rbracket "operator-assignment" lex_ctxt arg_rhs  */
-#line 3279 "ripper.y"
+#line 3281 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_ary_op_assign(p, (yyvsp[-6].val), (yyvsp[-4].val), (yyvsp[-2].val), (yyvsp[0].val), &(yylsp[-4]), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7;v1=(yyvsp[-6].val);v2=(yyvsp[-4].val);v3=dispatch2(aref_field,v1,v2);v4=v3;v5=(yyvsp[-2].val);v6=(yyvsp[0].val);v7=dispatch3(opassign,v4,v5,v6);(yyval.val)=v7;}
                     }
-#line 13669 "ripper.c"
+#line 13671 "ripper.c"
     break;
 
   case 225: /* arg: primary_value call_op "local variable or method" "operator-assignment" lex_ctxt arg_rhs  */
-#line 3286 "ripper.y"
+#line 3288 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_attr_op_assign(p, (yyvsp[-5].val), (yyvsp[-4].val), (yyvsp[-3].val), (yyvsp[-2].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7,v8;v1=(yyvsp[-5].val);v2=(yyvsp[-4].val);v3=(yyvsp[-3].val);v4=dispatch3(field,v1,v2,v3);v5=v4;v6=(yyvsp[-2].val);v7=(yyvsp[0].val);v8=dispatch3(opassign,v5,v6,v7);(yyval.val)=v8;}
                     }
-#line 13680 "ripper.c"
+#line 13682 "ripper.c"
     break;
 
   case 226: /* arg: primary_value call_op "constant" "operator-assignment" lex_ctxt arg_rhs  */
-#line 3293 "ripper.y"
+#line 3295 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_attr_op_assign(p, (yyvsp[-5].val), (yyvsp[-4].val), (yyvsp[-3].val), (yyvsp[-2].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7,v8;v1=(yyvsp[-5].val);v2=(yyvsp[-4].val);v3=(yyvsp[-3].val);v4=dispatch3(field,v1,v2,v3);v5=v4;v6=(yyvsp[-2].val);v7=(yyvsp[0].val);v8=dispatch3(opassign,v5,v6,v7);(yyval.val)=v8;}
                     }
-#line 13691 "ripper.c"
+#line 13693 "ripper.c"
     break;
 
   case 227: /* arg: primary_value "::" "local variable or method" "operator-assignment" lex_ctxt arg_rhs  */
-#line 3300 "ripper.y"
+#line 3302 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_attr_op_assign(p, (yyvsp[-5].val), ID2VAL(idCOLON2), (yyvsp[-3].val), (yyvsp[-2].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7,v8;v1=(yyvsp[-5].val);v2=(yyvsp[-4].val);v3=(yyvsp[-3].val);v4=dispatch3(field,v1,v2,v3);v5=v4;v6=(yyvsp[-2].val);v7=(yyvsp[0].val);v8=dispatch3(opassign,v5,v6,v7);(yyval.val)=v8;}
                     }
-#line 13702 "ripper.c"
+#line 13704 "ripper.c"
     break;
 
   case 228: /* arg: primary_value "::" "constant" "operator-assignment" lex_ctxt arg_rhs  */
-#line 3307 "ripper.y"
+#line 3309 "ripper.y"
                   {
 #if 0
                         YYLTYPE loc = code_loc_gen(&(yylsp[-5]), &(yylsp[-3]));
@@ -13710,11 +13712,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7;v1=(yyvsp[-5].val);v2=(yyvsp[-3].val);v3=dispatch2(const_path_field,v1,v2);v4=v3;v5=(yyvsp[-2].val);v6=(yyvsp[0].val);v7=dispatch3(opassign,v4,v5,v6);(yyval.val)=v7;}
                     }
-#line 13714 "ripper.c"
+#line 13716 "ripper.c"
     break;
 
   case 229: /* arg: ":: at EXPR_BEG" "constant" "operator-assignment" lex_ctxt arg_rhs  */
-#line 3315 "ripper.y"
+#line 3317 "ripper.y"
                   {
 #if 0
                         YYLTYPE loc = code_loc_gen(&(yylsp[-4]), &(yylsp[-3]));
@@ -13722,11 +13724,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6;v1=(yyvsp[-3].val);v2=dispatch1(top_const_field,v1);v3=v2;v4=(yyvsp[-2].val);v5=(yyvsp[0].val);v6=dispatch3(opassign,v3,v4,v5);(yyval.val)=v6;}
                     }
-#line 13726 "ripper.c"
+#line 13728 "ripper.c"
     break;
 
   case 230: /* arg: backref "operator-assignment" lex_ctxt arg_rhs  */
-#line 3323 "ripper.y"
+#line 3325 "ripper.y"
                   {
 #if 0
                         rb_backref_error(p, (yyvsp[-3].val));
@@ -13734,11 +13736,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4;v1=var_field(p, (yyvsp[-3].val));v2=(yyvsp[-2].val);v3=(yyvsp[0].val);v4=dispatch3(opassign,v1,v2,v3);(yyval.val)=backref_error(p, RNODE((yyvsp[-3].val)), v4);}ripper_error(p);
                     }
-#line 13738 "ripper.c"
+#line 13740 "ripper.c"
     break;
 
   case 231: /* arg: arg ".." arg  */
-#line 3331 "ripper.y"
+#line 3333 "ripper.y"
                   {
 #if 0
                         value_expr((yyvsp[-2].val));
@@ -13747,11 +13749,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[0].val);v3=dispatch2(dot2,v1,v2);(yyval.val)=v3;}
                     }
-#line 13751 "ripper.c"
+#line 13753 "ripper.c"
     break;
 
   case 232: /* arg: arg "..." arg  */
-#line 3340 "ripper.y"
+#line 3342 "ripper.y"
                   {
 #if 0
                         value_expr((yyvsp[-2].val));
@@ -13760,11 +13762,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[0].val);v3=dispatch2(dot3,v1,v2);(yyval.val)=v3;}
                     }
-#line 13764 "ripper.c"
+#line 13766 "ripper.c"
     break;
 
   case 233: /* arg: arg ".."  */
-#line 3349 "ripper.y"
+#line 3351 "ripper.y"
                   {
 #if 0
                         value_expr((yyvsp[-1].val));
@@ -13772,11 +13774,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-1].val);v2=Qnil;v3=dispatch2(dot2,v1,v2);(yyval.val)=v3;}
                     }
-#line 13776 "ripper.c"
+#line 13778 "ripper.c"
     break;
 
   case 234: /* arg: arg "..."  */
-#line 3357 "ripper.y"
+#line 3359 "ripper.y"
                   {
 #if 0
                         value_expr((yyvsp[-1].val));
@@ -13784,11 +13786,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-1].val);v2=Qnil;v3=dispatch2(dot3,v1,v2);(yyval.val)=v3;}
                     }
-#line 13788 "ripper.c"
+#line 13790 "ripper.c"
     break;
 
   case 235: /* arg: "(.." arg  */
-#line 3365 "ripper.y"
+#line 3367 "ripper.y"
                   {
 #if 0
                         value_expr((yyvsp[0].val));
@@ -13796,11 +13798,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=Qnil;v2=(yyvsp[0].val);v3=dispatch2(dot2,v1,v2);(yyval.val)=v3;}
                     }
-#line 13800 "ripper.c"
+#line 13802 "ripper.c"
     break;
 
   case 236: /* arg: "(..." arg  */
-#line 3373 "ripper.y"
+#line 3375 "ripper.y"
                   {
 #if 0
                         value_expr((yyvsp[0].val));
@@ -13808,212 +13810,212 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=Qnil;v2=(yyvsp[0].val);v3=dispatch2(dot3,v1,v2);(yyval.val)=v3;}
                     }
-#line 13812 "ripper.c"
+#line 13814 "ripper.c"
     break;
 
   case 237: /* arg: arg '+' arg  */
-#line 3381 "ripper.y"
+#line 3383 "ripper.y"
                   {
                         (yyval.val) = call_bin_op(p, (yyvsp[-2].val), '+', (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
                     }
-#line 13820 "ripper.c"
+#line 13822 "ripper.c"
     break;
 
   case 238: /* arg: arg '-' arg  */
-#line 3385 "ripper.y"
+#line 3387 "ripper.y"
                   {
                         (yyval.val) = call_bin_op(p, (yyvsp[-2].val), '-', (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
                     }
-#line 13828 "ripper.c"
+#line 13830 "ripper.c"
     break;
 
   case 239: /* arg: arg '*' arg  */
-#line 3389 "ripper.y"
+#line 3391 "ripper.y"
                   {
                         (yyval.val) = call_bin_op(p, (yyvsp[-2].val), '*', (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
                     }
-#line 13836 "ripper.c"
+#line 13838 "ripper.c"
     break;
 
   case 240: /* arg: arg '/' arg  */
-#line 3393 "ripper.y"
+#line 3395 "ripper.y"
                   {
                         (yyval.val) = call_bin_op(p, (yyvsp[-2].val), '/', (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
                     }
-#line 13844 "ripper.c"
+#line 13846 "ripper.c"
     break;
 
   case 241: /* arg: arg '%' arg  */
-#line 3397 "ripper.y"
+#line 3399 "ripper.y"
                   {
                         (yyval.val) = call_bin_op(p, (yyvsp[-2].val), '%', (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
                     }
-#line 13852 "ripper.c"
+#line 13854 "ripper.c"
     break;
 
   case 242: /* arg: arg "**" arg  */
-#line 3401 "ripper.y"
+#line 3403 "ripper.y"
                   {
                         (yyval.val) = call_bin_op(p, (yyvsp[-2].val), idPow, (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
                     }
-#line 13860 "ripper.c"
+#line 13862 "ripper.c"
     break;
 
   case 243: /* arg: tUMINUS_NUM simple_numeric "**" arg  */
-#line 3405 "ripper.y"
+#line 3407 "ripper.y"
                   {
                         (yyval.val) = call_uni_op(p, call_bin_op(p, (yyvsp[-2].val), idPow, (yyvsp[0].val), &(yylsp[-2]), &(yyloc)), idUMinus, &(yylsp[-3]), &(yyloc));
                     }
-#line 13868 "ripper.c"
+#line 13870 "ripper.c"
     break;
 
   case 244: /* arg: "unary+" arg  */
-#line 3409 "ripper.y"
+#line 3411 "ripper.y"
                   {
                         (yyval.val) = call_uni_op(p, (yyvsp[0].val), idUPlus, &(yylsp[-1]), &(yyloc));
                     }
-#line 13876 "ripper.c"
+#line 13878 "ripper.c"
     break;
 
   case 245: /* arg: "unary-" arg  */
-#line 3413 "ripper.y"
+#line 3415 "ripper.y"
                   {
                         (yyval.val) = call_uni_op(p, (yyvsp[0].val), idUMinus, &(yylsp[-1]), &(yyloc));
                     }
-#line 13884 "ripper.c"
+#line 13886 "ripper.c"
     break;
 
   case 246: /* arg: arg '|' arg  */
-#line 3417 "ripper.y"
+#line 3419 "ripper.y"
                   {
                         (yyval.val) = call_bin_op(p, (yyvsp[-2].val), '|', (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
                     }
-#line 13892 "ripper.c"
+#line 13894 "ripper.c"
     break;
 
   case 247: /* arg: arg '^' arg  */
-#line 3421 "ripper.y"
+#line 3423 "ripper.y"
                   {
                         (yyval.val) = call_bin_op(p, (yyvsp[-2].val), '^', (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
                     }
-#line 13900 "ripper.c"
+#line 13902 "ripper.c"
     break;
 
   case 248: /* arg: arg '&' arg  */
-#line 3425 "ripper.y"
+#line 3427 "ripper.y"
                   {
                         (yyval.val) = call_bin_op(p, (yyvsp[-2].val), '&', (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
                     }
-#line 13908 "ripper.c"
+#line 13910 "ripper.c"
     break;
 
   case 249: /* arg: arg "<=>" arg  */
-#line 3429 "ripper.y"
+#line 3431 "ripper.y"
                   {
                         (yyval.val) = call_bin_op(p, (yyvsp[-2].val), idCmp, (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
                     }
-#line 13916 "ripper.c"
+#line 13918 "ripper.c"
     break;
 
   case 251: /* arg: arg "==" arg  */
-#line 3434 "ripper.y"
+#line 3436 "ripper.y"
                   {
                         (yyval.val) = call_bin_op(p, (yyvsp[-2].val), idEq, (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
                     }
-#line 13924 "ripper.c"
+#line 13926 "ripper.c"
     break;
 
   case 252: /* arg: arg "===" arg  */
-#line 3438 "ripper.y"
+#line 3440 "ripper.y"
                   {
                         (yyval.val) = call_bin_op(p, (yyvsp[-2].val), idEqq, (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
                     }
-#line 13932 "ripper.c"
+#line 13934 "ripper.c"
     break;
 
   case 253: /* arg: arg "!=" arg  */
-#line 3442 "ripper.y"
+#line 3444 "ripper.y"
                   {
                         (yyval.val) = call_bin_op(p, (yyvsp[-2].val), idNeq, (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
                     }
-#line 13940 "ripper.c"
+#line 13942 "ripper.c"
     break;
 
   case 254: /* arg: arg "=~" arg  */
-#line 3446 "ripper.y"
+#line 3448 "ripper.y"
                   {
                         (yyval.val) = match_op(p, (yyvsp[-2].val), (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
                     }
-#line 13948 "ripper.c"
+#line 13950 "ripper.c"
     break;
 
   case 255: /* arg: arg "!~" arg  */
-#line 3450 "ripper.y"
+#line 3452 "ripper.y"
                   {
                         (yyval.val) = call_bin_op(p, (yyvsp[-2].val), idNeqTilde, (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
                     }
-#line 13956 "ripper.c"
+#line 13958 "ripper.c"
     break;
 
   case 256: /* arg: '!' arg  */
-#line 3454 "ripper.y"
+#line 3456 "ripper.y"
                   {
                         (yyval.val) = call_uni_op(p, method_cond(p, (yyvsp[0].val), &(yylsp[0])), '!', &(yylsp[-1]), &(yyloc));
                     }
-#line 13964 "ripper.c"
+#line 13966 "ripper.c"
     break;
 
   case 257: /* arg: '~' arg  */
-#line 3458 "ripper.y"
+#line 3460 "ripper.y"
                   {
                         (yyval.val) = call_uni_op(p, (yyvsp[0].val), '~', &(yylsp[-1]), &(yyloc));
                     }
-#line 13972 "ripper.c"
+#line 13974 "ripper.c"
     break;
 
   case 258: /* arg: arg "<<" arg  */
-#line 3462 "ripper.y"
+#line 3464 "ripper.y"
                   {
                         (yyval.val) = call_bin_op(p, (yyvsp[-2].val), idLTLT, (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
                     }
-#line 13980 "ripper.c"
+#line 13982 "ripper.c"
     break;
 
   case 259: /* arg: arg ">>" arg  */
-#line 3466 "ripper.y"
+#line 3468 "ripper.y"
                   {
                         (yyval.val) = call_bin_op(p, (yyvsp[-2].val), idGTGT, (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
                     }
-#line 13988 "ripper.c"
+#line 13990 "ripper.c"
     break;
 
   case 260: /* arg: arg "&&" arg  */
-#line 3470 "ripper.y"
+#line 3472 "ripper.y"
                   {
                         (yyval.val) = logop(p, idANDOP, (yyvsp[-2].val), (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
                     }
-#line 13996 "ripper.c"
+#line 13998 "ripper.c"
     break;
 
   case 261: /* arg: arg "||" arg  */
-#line 3474 "ripper.y"
+#line 3476 "ripper.y"
                   {
                         (yyval.val) = logop(p, idOROP, (yyvsp[-2].val), (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
                     }
-#line 14004 "ripper.c"
+#line 14006 "ripper.c"
     break;
 
   case 262: /* arg: "`defined?'" opt_nl begin_defined arg  */
-#line 3478 "ripper.y"
+#line 3480 "ripper.y"
                   {
                         p->ctxt.in_defined = (yyvsp[-1].ctxt).in_defined;
                         (yyval.val) = new_defined(p, (yyvsp[0].val), &(yyloc));
                     }
-#line 14013 "ripper.c"
+#line 14015 "ripper.c"
     break;
 
   case 263: /* arg: arg '?' arg opt_nl ':' arg  */
-#line 3483 "ripper.y"
+#line 3485 "ripper.y"
                   {
 #if 0
                         value_expr((yyvsp[-5].val));
@@ -14022,11 +14024,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4;v1=(yyvsp[-5].val);v2=(yyvsp[-3].val);v3=(yyvsp[0].val);v4=dispatch3(ifop,v1,v2,v3);(yyval.val)=v4;}
                     }
-#line 14026 "ripper.c"
+#line 14028 "ripper.c"
     break;
 
   case 264: /* arg: defn_head f_opt_paren_args '=' endless_arg  */
-#line 3492 "ripper.y"
+#line 3494 "ripper.y"
                   {
                         endless_method_name(p, get_id((yyvsp[-3].node_def_temp)->nd_mid), &(yylsp[-3]));
                         restore_defun(p, (yyvsp[-3].node_def_temp));
@@ -14039,11 +14041,11 @@ yyreduce:
 			{VALUE v1,v2,v3,v4;v1=(yyvsp[-3].node_def_temp)->nd_mid;v2=(yyvsp[-2].val);v3=(yyvsp[0].val);v4=dispatch3(def,v1,v2,v3);(yyval.val)=v4;}
                         local_pop(p);
                     }
-#line 14043 "ripper.c"
+#line 14045 "ripper.c"
     break;
 
   case 265: /* arg: defs_head f_opt_paren_args '=' endless_arg  */
-#line 3505 "ripper.y"
+#line 3507 "ripper.y"
                   {
                         endless_method_name(p, get_id((yyvsp[-3].node_def_temp)->nd_mid), &(yylsp[-3]));
                         restore_defun(p, (yyvsp[-3].node_def_temp));
@@ -14056,19 +14058,19 @@ yyreduce:
 			{VALUE v1,v2,v3,v4,v5,v6;v1=(yyvsp[-3].node_def_temp)->nd_recv;v2=(yyvsp[-3].node_def_temp)->dot_or_colon;v3=(yyvsp[-3].node_def_temp)->nd_mid;v4=(yyvsp[-2].val);v5=(yyvsp[0].val);v6=dispatch5(defs,v1,v2,v3,v4,v5);(yyval.val)=v6;}
                         local_pop(p);
                     }
-#line 14060 "ripper.c"
+#line 14062 "ripper.c"
     break;
 
   case 266: /* arg: primary  */
-#line 3518 "ripper.y"
+#line 3520 "ripper.y"
                   {
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 14068 "ripper.c"
+#line 14070 "ripper.c"
     break;
 
   case 268: /* endless_arg: endless_arg "`rescue' modifier" after_rescue arg  */
-#line 3525 "ripper.y"
+#line 3527 "ripper.y"
                   {
                         p->ctxt.in_rescue = (yyvsp[-1].ctxt).in_rescue;
 #if 0
@@ -14076,134 +14078,134 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-3].val);v2=(yyvsp[0].val);v3=dispatch2(rescue_mod,v1,v2);(yyval.val)=v3;}
                     }
-#line 14080 "ripper.c"
+#line 14082 "ripper.c"
     break;
 
   case 269: /* endless_arg: "`not'" opt_nl endless_arg  */
-#line 3533 "ripper.y"
+#line 3535 "ripper.y"
                   {
                         (yyval.val) = call_uni_op(p, method_cond(p, (yyvsp[0].val), &(yylsp[0])), METHOD_NOT, &(yylsp[-2]), &(yyloc));
                     }
-#line 14088 "ripper.c"
+#line 14090 "ripper.c"
     break;
 
   case 270: /* relop: '>'  */
-#line 3538 "ripper.y"
-            {(yyval.val) = '>';}
-#line 14094 "ripper.c"
+#line 3540 "ripper.y"
+            {(yyval.val) = THINGY('>');}
+#line 14096 "ripper.c"
     break;
 
   case 271: /* relop: '<'  */
-#line 3539 "ripper.y"
-                     {(yyval.val) = '<';}
-#line 14100 "ripper.c"
+#line 3541 "ripper.y"
+                     {(yyval.val) = THINGY('<');}
+#line 14102 "ripper.c"
     break;
 
   case 272: /* relop: ">="  */
-#line 3540 "ripper.y"
-                     {(yyval.val) = idGE;}
-#line 14106 "ripper.c"
+#line 3542 "ripper.y"
+                     {(yyval.val) = THINGY(idGE);}
+#line 14108 "ripper.c"
     break;
 
   case 273: /* relop: "<="  */
-#line 3541 "ripper.y"
-                     {(yyval.val) = idLE;}
-#line 14112 "ripper.c"
+#line 3543 "ripper.y"
+                     {(yyval.val) = THINGY(idLE);}
+#line 14114 "ripper.c"
     break;
 
   case 274: /* rel_expr: arg relop arg  */
-#line 3545 "ripper.y"
+#line 3547 "ripper.y"
                   {
                         (yyval.val) = call_bin_op(p, (yyvsp[-2].val), (yyvsp[-1].val), (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
                     }
-#line 14120 "ripper.c"
+#line 14122 "ripper.c"
     break;
 
   case 275: /* rel_expr: rel_expr relop arg  */
-#line 3549 "ripper.y"
+#line 3551 "ripper.y"
                   {
-                        rb_warning1("comparison '%s' after comparison", WARN_ID((yyvsp[-1].val)));
+                        rb_warning1("comparison '%s' after comparison", WARN_ID((ID)(yyvsp[-1].val)));
                         (yyval.val) = call_bin_op(p, (yyvsp[-2].val), (yyvsp[-1].val), (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
                     }
-#line 14129 "ripper.c"
+#line 14131 "ripper.c"
     break;
 
   case 276: /* lex_ctxt: none  */
-#line 3556 "ripper.y"
+#line 3558 "ripper.y"
                   {
                         (yyval.ctxt) = p->ctxt;
                     }
-#line 14137 "ripper.c"
+#line 14139 "ripper.c"
     break;
 
   case 277: /* begin_defined: lex_ctxt  */
-#line 3562 "ripper.y"
+#line 3564 "ripper.y"
                   {
                         p->ctxt.in_defined = 1;
                         (yyval.ctxt) = (yyvsp[0].ctxt);
                     }
-#line 14146 "ripper.c"
+#line 14148 "ripper.c"
     break;
 
   case 278: /* after_rescue: lex_ctxt  */
-#line 3569 "ripper.y"
+#line 3571 "ripper.y"
                   {
                         p->ctxt.in_rescue = after_rescue;
                         (yyval.ctxt) = (yyvsp[0].ctxt);
                     }
-#line 14155 "ripper.c"
+#line 14157 "ripper.c"
     break;
 
   case 279: /* arg_value: arg  */
-#line 3576 "ripper.y"
+#line 3578 "ripper.y"
                   {
                         value_expr((yyvsp[0].val));
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 14164 "ripper.c"
+#line 14166 "ripper.c"
     break;
 
   case 281: /* aref_args: args trailer  */
-#line 3584 "ripper.y"
+#line 3586 "ripper.y"
                   {
                         (yyval.val) = (yyvsp[-1].val);
                     }
-#line 14172 "ripper.c"
+#line 14174 "ripper.c"
     break;
 
   case 282: /* aref_args: args ',' assocs trailer  */
-#line 3588 "ripper.y"
+#line 3590 "ripper.y"
                   {
 #if 0
                         (yyval.val) = (yyvsp[-1].val) ? arg_append(p, (yyvsp[-3].val), new_hash(p, (yyvsp[-1].val), &(yylsp[-1])), &(yyloc)) : (yyvsp[-3].val);
 #endif
 			{VALUE v1,v2,v3,v4,v5;v1=(yyvsp[-1].val);v2=dispatch1(bare_assoc_hash,v1);v3=(yyvsp[-3].val);v4=v2;v5=dispatch2(args_add,v3,v4);(yyval.val)=v5;}
                     }
-#line 14183 "ripper.c"
+#line 14185 "ripper.c"
     break;
 
   case 283: /* aref_args: assocs trailer  */
-#line 3595 "ripper.y"
+#line 3597 "ripper.y"
                   {
 #if 0
                         (yyval.val) = (yyvsp[-1].val) ? NEW_LIST(new_hash(p, (yyvsp[-1].val), &(yylsp[-1])), &(yyloc)) : 0;
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6;v1=dispatch0(args_new);v2=(yyvsp[-1].val);v3=dispatch1(bare_assoc_hash,v2);v4=v1;v5=v3;v6=dispatch2(args_add,v4,v5);(yyval.val)=v6;}
                     }
-#line 14194 "ripper.c"
+#line 14196 "ripper.c"
     break;
 
   case 284: /* arg_rhs: arg  */
-#line 3604 "ripper.y"
+#line 3606 "ripper.y"
                   {
                         value_expr((yyvsp[0].val));
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 14203 "ripper.c"
+#line 14205 "ripper.c"
     break;
 
   case 285: /* arg_rhs: arg "`rescue' modifier" after_rescue arg  */
-#line 3609 "ripper.y"
+#line 3611 "ripper.y"
                   {
                         p->ctxt.in_rescue = (yyvsp[-1].ctxt).in_rescue;
 #if 0
@@ -14212,22 +14214,22 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-3].val);v2=(yyvsp[0].val);v3=dispatch2(rescue_mod,v1,v2);(yyval.val)=v3;}
                     }
-#line 14216 "ripper.c"
+#line 14218 "ripper.c"
     break;
 
   case 286: /* paren_args: '(' opt_call_args rparen  */
-#line 3620 "ripper.y"
+#line 3622 "ripper.y"
                   {
 #if 0
                         (yyval.val) = (yyvsp[-1].val);
 #endif
 			{VALUE v1,v2;v1=(yyvsp[-1].val);v2=dispatch1(arg_paren,v1);(yyval.val)=v2;}
                     }
-#line 14227 "ripper.c"
+#line 14229 "ripper.c"
     break;
 
   case 287: /* paren_args: '(' args ',' args_forward rparen  */
-#line 3627 "ripper.y"
+#line 3629 "ripper.y"
                   {
                         if (!check_forwarding_args(p)) {
                             (yyval.val) = Qnone;
@@ -14239,11 +14241,11 @@ yyreduce:
 			{VALUE v1,v2,v3,v4,v5;v1=(yyvsp[-3].val);v2=(yyvsp[-1].val);v3=dispatch2(args_add,v1,v2);v4=v3;v5=dispatch1(arg_paren,v4);(yyval.val)=v5;}
                         }
                     }
-#line 14243 "ripper.c"
+#line 14245 "ripper.c"
     break;
 
   case 288: /* paren_args: '(' args_forward rparen  */
-#line 3639 "ripper.y"
+#line 3641 "ripper.y"
                   {
                         if (!check_forwarding_args(p)) {
                             (yyval.val) = Qnone;
@@ -14255,41 +14257,41 @@ yyreduce:
 			{VALUE v1,v2;v1=(yyvsp[-1].val);v2=dispatch1(arg_paren,v1);(yyval.val)=v2;}
                         }
                     }
-#line 14259 "ripper.c"
+#line 14261 "ripper.c"
     break;
 
   case 293: /* opt_call_args: args ','  */
-#line 3659 "ripper.y"
+#line 3661 "ripper.y"
                   {
                       (yyval.val) = (yyvsp[-1].val);
                     }
-#line 14267 "ripper.c"
+#line 14269 "ripper.c"
     break;
 
   case 294: /* opt_call_args: args ',' assocs ','  */
-#line 3663 "ripper.y"
+#line 3665 "ripper.y"
                   {
 #if 0
                         (yyval.val) = (yyvsp[-1].val) ? arg_append(p, (yyvsp[-3].val), new_hash(p, (yyvsp[-1].val), &(yylsp[-1])), &(yyloc)) : (yyvsp[-3].val);
 #endif
 			{VALUE v1,v2,v3,v4,v5;v1=(yyvsp[-1].val);v2=dispatch1(bare_assoc_hash,v1);v3=(yyvsp[-3].val);v4=v2;v5=dispatch2(args_add,v3,v4);(yyval.val)=v5;}
                     }
-#line 14278 "ripper.c"
+#line 14280 "ripper.c"
     break;
 
   case 295: /* opt_call_args: assocs ','  */
-#line 3670 "ripper.y"
+#line 3672 "ripper.y"
                   {
 #if 0
                         (yyval.val) = (yyvsp[-1].val) ? NEW_LIST(new_hash(p, (yyvsp[-1].val), &(yylsp[-1])), &(yylsp[-1])) : 0;
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6;v1=dispatch0(args_new);v2=(yyvsp[-1].val);v3=dispatch1(bare_assoc_hash,v2);v4=v1;v5=v3;v6=dispatch2(args_add,v4,v5);(yyval.val)=v6;}
                     }
-#line 14289 "ripper.c"
+#line 14291 "ripper.c"
     break;
 
   case 296: /* call_args: command  */
-#line 3679 "ripper.y"
+#line 3681 "ripper.y"
                   {
 #if 0
                         value_expr((yyvsp[0].val));
@@ -14297,22 +14299,22 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4;v1=dispatch0(args_new);v2=v1;v3=(yyvsp[0].val);v4=dispatch2(args_add,v2,v3);(yyval.val)=v4;}
                     }
-#line 14301 "ripper.c"
+#line 14303 "ripper.c"
     break;
 
   case 297: /* call_args: args opt_block_arg  */
-#line 3687 "ripper.y"
+#line 3689 "ripper.y"
                   {
 #if 0
                         (yyval.val) = arg_blk_pass((yyvsp[-1].val), (yyvsp[0].val));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-1].val);v2=(yyvsp[0].val);v3=dispatch2(args_add_block,v1,v2);(yyval.val)=v3;}
                     }
-#line 14312 "ripper.c"
+#line 14314 "ripper.c"
     break;
 
   case 298: /* call_args: assocs opt_block_arg  */
-#line 3694 "ripper.y"
+#line 3696 "ripper.y"
                   {
 #if 0
                         (yyval.val) = (yyvsp[-1].val) ? NEW_LIST(new_hash(p, (yyvsp[-1].val), &(yylsp[-1])), &(yylsp[-1])) : 0;
@@ -14320,11 +14322,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7,v8,v9;v1=dispatch0(args_new);v2=(yyvsp[-1].val);v3=dispatch1(bare_assoc_hash,v2);v4=v1;v5=v3;v6=dispatch2(args_add,v4,v5);v7=v6;v8=(yyvsp[0].val);v9=dispatch2(args_add_block,v7,v8);(yyval.val)=v9;}
                     }
-#line 14324 "ripper.c"
+#line 14326 "ripper.c"
     break;
 
   case 299: /* call_args: args ',' assocs opt_block_arg  */
-#line 3702 "ripper.y"
+#line 3704 "ripper.y"
                   {
 #if 0
                         (yyval.val) = (yyvsp[-1].val) ? arg_append(p, (yyvsp[-3].val), new_hash(p, (yyvsp[-1].val), &(yylsp[-1])), &(yyloc)) : (yyvsp[-3].val);
@@ -14332,17 +14334,17 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7,v8;v1=(yyvsp[-1].val);v2=dispatch1(bare_assoc_hash,v1);v3=(yyvsp[-3].val);v4=v2;v5=dispatch2(args_add,v3,v4);v6=v5;v7=(yyvsp[0].val);v8=dispatch2(args_add_block,v6,v7);(yyval.val)=v8;}
                     }
-#line 14336 "ripper.c"
+#line 14338 "ripper.c"
     break;
 
   case 300: /* call_args: block_arg  */
-#line 3710 "ripper.y"
+#line 3712 "ripper.y"
  {{VALUE v1,v2,v3,v4;v1=dispatch0(args_new);v2=v1;v3=(yyvsp[0].val);v4=dispatch2(args_add_block,v2,v3);(yyval.val)=v4;}}
-#line 14342 "ripper.c"
+#line 14344 "ripper.c"
     break;
 
   case 301: /* $@13: %empty  */
-#line 3713 "ripper.y"
+#line 3715 "ripper.y"
                {
                         /* If call_args starts with a open paren '(' or '[',
                          * look-ahead reading of the letters calls CMDARG_PUSH(0),
@@ -14360,11 +14362,11 @@ yyreduce:
                         CMDARG_PUSH(1);
                         if (lookahead) CMDARG_PUSH(0);
                     }
-#line 14364 "ripper.c"
+#line 14366 "ripper.c"
     break;
 
   case 302: /* command_args: $@13 call_args  */
-#line 3731 "ripper.y"
+#line 3733 "ripper.y"
                   {
                         /* call_args can be followed by tLBRACE_ARG (that does CMDARG_PUSH(0) in the lexer)
                          * but the push must be done after CMDARG_POP() in the parser.
@@ -14382,22 +14384,22 @@ yyreduce:
                         if (lookahead) CMDARG_PUSH(0);
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 14386 "ripper.c"
+#line 14388 "ripper.c"
     break;
 
   case 303: /* block_arg: "&" arg_value  */
-#line 3751 "ripper.y"
+#line 3753 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_BLOCK_PASS((yyvsp[0].val), &(yyloc));
 #endif
 			(yyval.val)=(yyvsp[0].val);
                     }
-#line 14397 "ripper.c"
+#line 14399 "ripper.c"
     break;
 
   case 304: /* block_arg: "&"  */
-#line 3758 "ripper.y"
+#line 3760 "ripper.y"
                   {
                         forwarding_arg_check(p, idFWD_BLOCK, 0, "block");
 #if 0
@@ -14405,79 +14407,79 @@ yyreduce:
 #endif
 			(yyval.val)=Qnil;
                     }
-#line 14409 "ripper.c"
+#line 14411 "ripper.c"
     break;
 
   case 305: /* opt_block_arg: ',' block_arg  */
-#line 3768 "ripper.y"
+#line 3770 "ripper.y"
                   {
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 14417 "ripper.c"
+#line 14419 "ripper.c"
     break;
 
   case 306: /* opt_block_arg: none  */
-#line 3772 "ripper.y"
+#line 3774 "ripper.y"
                   {
                         (yyval.val) = 0;
                     }
-#line 14425 "ripper.c"
+#line 14427 "ripper.c"
     break;
 
   case 307: /* args: arg_value  */
-#line 3779 "ripper.y"
+#line 3781 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_LIST((yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4;v1=dispatch0(args_new);v2=v1;v3=(yyvsp[0].val);v4=dispatch2(args_add,v2,v3);(yyval.val)=v4;}
                     }
-#line 14436 "ripper.c"
+#line 14438 "ripper.c"
     break;
 
   case 308: /* args: arg_splat  */
-#line 3786 "ripper.y"
+#line 3788 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_SPLAT((yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4;v1=dispatch0(args_new);v2=v1;v3=(yyvsp[0].val);v4=dispatch2(args_add_star,v2,v3);(yyval.val)=v4;}
                     }
-#line 14447 "ripper.c"
+#line 14449 "ripper.c"
     break;
 
   case 309: /* args: args ',' arg_value  */
-#line 3793 "ripper.y"
+#line 3795 "ripper.y"
                   {
 #if 0
                         (yyval.val) = last_arg_append(p, (yyvsp[-2].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[0].val);v3=dispatch2(args_add,v1,v2);(yyval.val)=v3;}
                     }
-#line 14458 "ripper.c"
+#line 14460 "ripper.c"
     break;
 
   case 310: /* args: args ',' arg_splat  */
-#line 3800 "ripper.y"
+#line 3802 "ripper.y"
                   {
 #if 0
                         (yyval.val) = rest_arg_append(p, (yyvsp[-2].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[0].val);v3=dispatch2(args_add_star,v1,v2);(yyval.val)=v3;}
                     }
-#line 14469 "ripper.c"
+#line 14471 "ripper.c"
     break;
 
   case 311: /* arg_splat: "*" arg_value  */
-#line 3810 "ripper.y"
+#line 3812 "ripper.y"
                   {
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 14477 "ripper.c"
+#line 14479 "ripper.c"
     break;
 
   case 312: /* arg_splat: "*"  */
-#line 3814 "ripper.y"
+#line 3816 "ripper.y"
                   {
                         forwarding_arg_check(p, idFWD_REST, idFWD_ALL, "rest");
 #if 0
@@ -14485,63 +14487,63 @@ yyreduce:
 #endif
 			(yyval.val)=Qnil;
                     }
-#line 14489 "ripper.c"
+#line 14491 "ripper.c"
     break;
 
   case 315: /* mrhs: args ',' arg_value  */
-#line 3830 "ripper.y"
+#line 3832 "ripper.y"
                   {
 #if 0
                         (yyval.val) = last_arg_append(p, (yyvsp[-2].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5;v1=(yyvsp[-2].val);v2=dispatch1(mrhs_new_from_args,v1);v3=v2;v4=(yyvsp[0].val);v5=dispatch2(mrhs_add,v3,v4);(yyval.val)=v5;}
                     }
-#line 14500 "ripper.c"
+#line 14502 "ripper.c"
     break;
 
   case 316: /* mrhs: args ',' "*" arg_value  */
-#line 3837 "ripper.y"
+#line 3839 "ripper.y"
                   {
 #if 0
                         (yyval.val) = rest_arg_append(p, (yyvsp[-3].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5;v1=(yyvsp[-3].val);v2=dispatch1(mrhs_new_from_args,v1);v3=v2;v4=(yyvsp[0].val);v5=dispatch2(mrhs_add_star,v3,v4);(yyval.val)=v5;}
                     }
-#line 14511 "ripper.c"
+#line 14513 "ripper.c"
     break;
 
   case 317: /* mrhs: "*" arg_value  */
-#line 3844 "ripper.y"
+#line 3846 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_SPLAT((yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4;v1=dispatch0(mrhs_new);v2=v1;v3=(yyvsp[0].val);v4=dispatch2(mrhs_add_star,v2,v3);(yyval.val)=v4;}
                     }
-#line 14522 "ripper.c"
+#line 14524 "ripper.c"
     break;
 
   case 328: /* primary: "method"  */
-#line 3863 "ripper.y"
+#line 3865 "ripper.y"
                   {
 #if 0
                         (yyval.val) = (NODE *)NEW_FCALL((yyvsp[0].val), 0, &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6;v1=(yyvsp[0].val);v2=dispatch1(fcall,v1);v3=dispatch0(args_new);v4=v2;v5=v3;v6=dispatch2(method_add_arg,v4,v5);(yyval.val)=v6;}
                     }
-#line 14533 "ripper.c"
+#line 14535 "ripper.c"
     break;
 
   case 329: /* $@14: %empty  */
-#line 3870 "ripper.y"
+#line 3872 "ripper.y"
                   {
                         CMDARG_PUSH(0);
                     }
-#line 14541 "ripper.c"
+#line 14543 "ripper.c"
     break;
 
   case 330: /* primary: k_begin $@14 bodystmt k_end  */
-#line 3875 "ripper.y"
+#line 3877 "ripper.y"
                   {
                         CMDARG_POP();
 #if 0
@@ -14551,17 +14553,17 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=(yyvsp[-1].val);v2=dispatch1(begin,v1);(yyval.val)=v2;}
                     }
-#line 14555 "ripper.c"
+#line 14557 "ripper.c"
     break;
 
   case 331: /* $@15: %empty  */
-#line 3884 "ripper.y"
+#line 3886 "ripper.y"
                                      {SET_LEX_STATE(EXPR_ENDARG);}
-#line 14561 "ripper.c"
+#line 14563 "ripper.c"
     break;
 
   case 332: /* primary: "( arg" compstmt $@15 ')'  */
-#line 3885 "ripper.y"
+#line 3887 "ripper.y"
                   {
 #if 0
                         if (nd_type_p((yyvsp[-2].val), NODE_SELF)) RNODE_SELF((yyvsp[-2].val))->nd_state = 0;
@@ -14569,11 +14571,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=(yyvsp[-2].val);v2=dispatch1(paren,v1);(yyval.val)=v2;}
                     }
-#line 14573 "ripper.c"
+#line 14575 "ripper.c"
     break;
 
   case 333: /* primary: "(" compstmt ')'  */
-#line 3893 "ripper.y"
+#line 3895 "ripper.y"
                   {
 #if 0
                         if (nd_type_p((yyvsp[-1].val), NODE_SELF)) RNODE_SELF((yyvsp[-1].val))->nd_state = 0;
@@ -14581,44 +14583,44 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=(yyvsp[-1].val);v2=dispatch1(paren,v1);(yyval.val)=v2;}
                     }
-#line 14585 "ripper.c"
+#line 14587 "ripper.c"
     break;
 
   case 334: /* primary: primary_value "::" "constant"  */
-#line 3901 "ripper.y"
+#line 3903 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_COLON2((yyvsp[-2].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[0].val);v3=dispatch2(const_path_ref,v1,v2);(yyval.val)=v3;}
                     }
-#line 14596 "ripper.c"
+#line 14598 "ripper.c"
     break;
 
   case 335: /* primary: ":: at EXPR_BEG" "constant"  */
-#line 3908 "ripper.y"
+#line 3910 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_COLON3((yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(top_const_ref,v1);(yyval.val)=v2;}
                     }
-#line 14607 "ripper.c"
+#line 14609 "ripper.c"
     break;
 
   case 336: /* primary: "[" aref_args ']'  */
-#line 3915 "ripper.y"
+#line 3917 "ripper.y"
                   {
 #if 0
                         (yyval.val) = make_list((yyvsp[-1].val), &(yyloc));
 #endif
 			{VALUE v1,v2;v1=(yyvsp[-1].val);v2=dispatch1(array,v1);(yyval.val)=v2;}
                     }
-#line 14618 "ripper.c"
+#line 14620 "ripper.c"
     break;
 
   case 337: /* primary: "{" assoc_list '}'  */
-#line 3922 "ripper.y"
+#line 3924 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_hash(p, (yyvsp[-1].val), &(yyloc));
@@ -14626,91 +14628,91 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=(yyvsp[-1].val);v2=dispatch1(hash,v1);(yyval.val)=v2;}
                     }
-#line 14630 "ripper.c"
+#line 14632 "ripper.c"
     break;
 
   case 338: /* primary: k_return  */
-#line 3930 "ripper.y"
+#line 3932 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_RETURN(0, &(yyloc));
 #endif
 			{VALUE v1;v1=dispatch0(return0);(yyval.val)=v1;}
                     }
-#line 14641 "ripper.c"
+#line 14643 "ripper.c"
     break;
 
   case 339: /* primary: k_yield '(' call_args rparen  */
-#line 3937 "ripper.y"
+#line 3939 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_yield(p, (yyvsp[-1].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4;v1=(yyvsp[-1].val);v2=dispatch1(paren,v1);v3=v2;v4=dispatch1(yield,v3);(yyval.val)=v4;}
                     }
-#line 14652 "ripper.c"
+#line 14654 "ripper.c"
     break;
 
   case 340: /* primary: k_yield '(' rparen  */
-#line 3944 "ripper.y"
+#line 3946 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_YIELD(0, &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5;v1=dispatch0(args_new);v2=v1;v3=dispatch1(paren,v2);v4=v3;v5=dispatch1(yield,v4);(yyval.val)=v5;}
                     }
-#line 14663 "ripper.c"
+#line 14665 "ripper.c"
     break;
 
   case 341: /* primary: k_yield  */
-#line 3951 "ripper.y"
+#line 3953 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_YIELD(0, &(yyloc));
 #endif
 			{VALUE v1;v1=dispatch0(yield0);(yyval.val)=v1;}
                     }
-#line 14674 "ripper.c"
+#line 14676 "ripper.c"
     break;
 
   case 342: /* primary: "`defined?'" opt_nl '(' begin_defined expr rparen  */
-#line 3958 "ripper.y"
+#line 3960 "ripper.y"
                   {
                         p->ctxt.in_defined = (yyvsp[-2].ctxt).in_defined;
                         (yyval.val) = new_defined(p, (yyvsp[-1].val), &(yyloc));
                     }
-#line 14683 "ripper.c"
+#line 14685 "ripper.c"
     break;
 
   case 343: /* primary: "`not'" '(' expr rparen  */
-#line 3963 "ripper.y"
+#line 3965 "ripper.y"
                   {
                         (yyval.val) = call_uni_op(p, method_cond(p, (yyvsp[-1].val), &(yylsp[-1])), METHOD_NOT, &(yylsp[-3]), &(yyloc));
                     }
-#line 14691 "ripper.c"
+#line 14693 "ripper.c"
     break;
 
   case 344: /* primary: "`not'" '(' rparen  */
-#line 3967 "ripper.y"
+#line 3969 "ripper.y"
                   {
                         (yyval.val) = call_uni_op(p, method_cond(p, new_nil(&(yylsp[-1])), &(yylsp[-1])), METHOD_NOT, &(yylsp[-2]), &(yyloc));
                     }
-#line 14699 "ripper.c"
+#line 14701 "ripper.c"
     break;
 
   case 345: /* primary: fcall brace_block  */
-#line 3971 "ripper.y"
+#line 3973 "ripper.y"
                   {
 #if 0
                         (yyval.val) = method_add_block(p, (NODE *)(yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7,v8,v9;v1=(yyvsp[-1].val);v2=dispatch1(fcall,v1);v3=dispatch0(args_new);v4=v2;v5=v3;v6=dispatch2(method_add_arg,v4,v5);v7=v6;v8=(yyvsp[0].val);v9=dispatch2(method_add_block,v7,v8);(yyval.val)=v9;}
                     }
-#line 14710 "ripper.c"
+#line 14712 "ripper.c"
     break;
 
   case 347: /* primary: method_call brace_block  */
-#line 3979 "ripper.y"
+#line 3981 "ripper.y"
                   {
 #if 0
                         block_dup_check(p, get_nd_args(p, (yyvsp[-1].val)), (yyvsp[0].val));
@@ -14718,11 +14720,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-1].val);v2=(yyvsp[0].val);v3=dispatch2(method_add_block,v1,v2);(yyval.val)=v3;}
                     }
-#line 14722 "ripper.c"
+#line 14724 "ripper.c"
     break;
 
   case 349: /* primary: k_if expr_value then compstmt if_tail k_end  */
-#line 3991 "ripper.y"
+#line 3993 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_if(p, (yyvsp[-4].val), (yyvsp[-2].val), (yyvsp[-1].val), &(yyloc));
@@ -14730,11 +14732,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4;v1=(yyvsp[-4].val);v2=(yyvsp[-2].val);v3=(yyvsp[-1].val);v4=dispatch3(if,v1,v2,v3);(yyval.val)=v4;}
                     }
-#line 14734 "ripper.c"
+#line 14736 "ripper.c"
     break;
 
   case 350: /* primary: k_unless expr_value then compstmt opt_else k_end  */
-#line 4002 "ripper.y"
+#line 4004 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_unless(p, (yyvsp[-4].val), (yyvsp[-2].val), (yyvsp[-1].val), &(yyloc));
@@ -14742,11 +14744,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4;v1=(yyvsp[-4].val);v2=(yyvsp[-2].val);v3=(yyvsp[-1].val);v4=dispatch3(unless,v1,v2,v3);(yyval.val)=v4;}
                     }
-#line 14746 "ripper.c"
+#line 14748 "ripper.c"
     break;
 
   case 351: /* primary: k_while expr_value_do compstmt k_end  */
-#line 4012 "ripper.y"
+#line 4014 "ripper.y"
                   {
                         restore_block_exit(p, (yyvsp[-3].node_exits));
 #if 0
@@ -14755,11 +14757,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[-1].val);v3=dispatch2(while,v1,v2);(yyval.val)=v3;}
                     }
-#line 14759 "ripper.c"
+#line 14761 "ripper.c"
     break;
 
   case 352: /* primary: k_until expr_value_do compstmt k_end  */
-#line 4023 "ripper.y"
+#line 4025 "ripper.y"
                   {
                         restore_block_exit(p, (yyvsp[-3].node_exits));
 #if 0
@@ -14768,20 +14770,20 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[-1].val);v3=dispatch2(until,v1,v2);(yyval.val)=v3;}
                     }
-#line 14772 "ripper.c"
+#line 14774 "ripper.c"
     break;
 
   case 353: /* @16: %empty  */
-#line 4032 "ripper.y"
+#line 4034 "ripper.y"
                   {
                         (yyval.val) = p->case_labels;
                         p->case_labels = Qnil;
                     }
-#line 14781 "ripper.c"
+#line 14783 "ripper.c"
     break;
 
   case 354: /* primary: k_case expr_value opt_terms @16 case_body k_end  */
-#line 4038 "ripper.y"
+#line 4040 "ripper.y"
                   {
                         if (RTEST(p->case_labels)) rb_hash_clear(p->case_labels);
                         p->case_labels = (yyvsp[-2].val);
@@ -14791,20 +14793,20 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-4].val);v2=(yyvsp[-1].val);v3=dispatch2(case,v1,v2);(yyval.val)=v3;}
                     }
-#line 14795 "ripper.c"
+#line 14797 "ripper.c"
     break;
 
   case 355: /* @17: %empty  */
-#line 4048 "ripper.y"
+#line 4050 "ripper.y"
                   {
                         (yyval.val) = p->case_labels;
                         p->case_labels = 0;
                     }
-#line 14804 "ripper.c"
+#line 14806 "ripper.c"
     break;
 
   case 356: /* primary: k_case opt_terms @17 case_body k_end  */
-#line 4054 "ripper.y"
+#line 4056 "ripper.y"
                   {
                         if (RTEST(p->case_labels)) rb_hash_clear(p->case_labels);
                         p->case_labels = (yyvsp[-2].val);
@@ -14813,22 +14815,22 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=Qnil;v2=(yyvsp[-1].val);v3=dispatch2(case,v1,v2);(yyval.val)=v3;}
                     }
-#line 14817 "ripper.c"
+#line 14819 "ripper.c"
     break;
 
   case 357: /* primary: k_case expr_value opt_terms p_case_body k_end  */
-#line 4065 "ripper.y"
+#line 4067 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_CASE3((yyvsp[-3].val), (yyvsp[-1].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-3].val);v2=(yyvsp[-1].val);v3=dispatch2(case,v1,v2);(yyval.val)=v3;}
                     }
-#line 14828 "ripper.c"
+#line 14830 "ripper.c"
     break;
 
   case 358: /* primary: k_for for_var "`in'" expr_value_do compstmt k_end  */
-#line 4074 "ripper.y"
+#line 4076 "ripper.y"
                   {
                         restore_block_exit(p, (yyvsp[-5].node_exits));
 #if 0
@@ -14870,19 +14872,19 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4;v1=(yyvsp[-4].val);v2=(yyvsp[-2].val);v3=(yyvsp[-1].val);v4=dispatch3(for,v1,v2,v3);(yyval.val)=v4;}
                     }
-#line 14874 "ripper.c"
+#line 14876 "ripper.c"
     break;
 
   case 359: /* $@18: %empty  */
-#line 4116 "ripper.y"
+#line 4118 "ripper.y"
                   {
                         begin_definition("class", &(yylsp[-2]), &(yylsp[-1]));
                     }
-#line 14882 "ripper.c"
+#line 14884 "ripper.c"
     break;
 
   case 360: /* primary: k_class cpath superclass $@18 bodystmt k_end  */
-#line 4121 "ripper.y"
+#line 4123 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_CLASS((yyvsp[-4].val), (yyvsp[-1].val), (yyvsp[-3].val), &(yyloc));
@@ -14895,19 +14897,19 @@ yyreduce:
                         p->ctxt.in_class = (yyvsp[-5].ctxt).in_class;
                         p->ctxt.shareable_constant_value = (yyvsp[-5].ctxt).shareable_constant_value;
                     }
-#line 14899 "ripper.c"
+#line 14901 "ripper.c"
     break;
 
   case 361: /* $@19: %empty  */
-#line 4134 "ripper.y"
+#line 4136 "ripper.y"
                   {
                         begin_definition("", &(yylsp[-2]), &(yylsp[-1]));
                     }
-#line 14907 "ripper.c"
+#line 14909 "ripper.c"
     break;
 
   case 362: /* primary: k_class "<<" expr_value $@19 term bodystmt k_end  */
-#line 4140 "ripper.y"
+#line 4142 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_SCLASS((yyvsp[-4].val), (yyvsp[-1].val), &(yyloc));
@@ -14921,19 +14923,19 @@ yyreduce:
                         p->ctxt.in_class = (yyvsp[-6].ctxt).in_class;
                         p->ctxt.shareable_constant_value = (yyvsp[-6].ctxt).shareable_constant_value;
                     }
-#line 14925 "ripper.c"
+#line 14927 "ripper.c"
     break;
 
   case 363: /* $@20: %empty  */
-#line 4154 "ripper.y"
+#line 4156 "ripper.y"
                   {
                         begin_definition("module", &(yylsp[-1]), &(yylsp[0]));
                     }
-#line 14933 "ripper.c"
+#line 14935 "ripper.c"
     break;
 
   case 364: /* primary: k_module cpath $@20 bodystmt k_end  */
-#line 4159 "ripper.y"
+#line 4161 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_MODULE((yyvsp[-3].val), (yyvsp[-1].val), &(yyloc));
@@ -14946,21 +14948,21 @@ yyreduce:
                         p->ctxt.in_class = (yyvsp[-4].ctxt).in_class;
                         p->ctxt.shareable_constant_value = (yyvsp[-4].ctxt).shareable_constant_value;
                     }
-#line 14950 "ripper.c"
+#line 14952 "ripper.c"
     break;
 
   case 365: /* $@21: %empty  */
-#line 4173 "ripper.y"
+#line 4175 "ripper.y"
                   {
 #if 0
                         push_end_expect_token_locations(p, &(yylsp[-1]).beg_pos);
 #endif
                     }
-#line 14960 "ripper.c"
+#line 14962 "ripper.c"
     break;
 
   case 366: /* primary: defn_head f_arglist $@21 bodystmt k_end  */
-#line 4180 "ripper.y"
+#line 4182 "ripper.y"
                   {
                         restore_defun(p, (yyvsp[-4].node_def_temp));
 #if 0
@@ -14971,21 +14973,21 @@ yyreduce:
 			{VALUE v1,v2,v3,v4;v1=(yyvsp[-4].node_def_temp)->nd_mid;v2=(yyvsp[-3].val);v3=(yyvsp[-1].val);v4=dispatch3(def,v1,v2,v3);(yyval.val)=v4;}
                         local_pop(p);
                     }
-#line 14975 "ripper.c"
+#line 14977 "ripper.c"
     break;
 
   case 367: /* $@22: %empty  */
-#line 4192 "ripper.y"
+#line 4194 "ripper.y"
                   {
 #if 0
                         push_end_expect_token_locations(p, &(yylsp[-1]).beg_pos);
 #endif
                     }
-#line 14985 "ripper.c"
+#line 14987 "ripper.c"
     break;
 
   case 368: /* primary: defs_head f_arglist $@22 bodystmt k_end  */
-#line 4199 "ripper.y"
+#line 4201 "ripper.y"
                   {
                         restore_defun(p, (yyvsp[-4].node_def_temp));
 #if 0
@@ -14996,38 +14998,38 @@ yyreduce:
 			{VALUE v1,v2,v3,v4,v5,v6;v1=(yyvsp[-4].node_def_temp)->nd_recv;v2=(yyvsp[-4].node_def_temp)->dot_or_colon;v3=(yyvsp[-4].node_def_temp)->nd_mid;v4=(yyvsp[-3].val);v5=(yyvsp[-1].val);v6=dispatch5(defs,v1,v2,v3,v4,v5);(yyval.val)=v6;}
                         local_pop(p);
                     }
-#line 15000 "ripper.c"
+#line 15002 "ripper.c"
     break;
 
   case 369: /* primary: "`break'"  */
-#line 4210 "ripper.y"
+#line 4212 "ripper.y"
                   {
                         (yyval.node) = add_block_exit(p, NEW_BREAK(0, &(yyloc)));
 			{VALUE v1,v2,v3;v1=dispatch0(args_new);v2=v1;v3=dispatch1(break,v2);(yyval.val)=v3;}
                     }
-#line 15009 "ripper.c"
+#line 15011 "ripper.c"
     break;
 
   case 370: /* primary: "`next'"  */
-#line 4215 "ripper.y"
+#line 4217 "ripper.y"
                   {
                         (yyval.node) = add_block_exit(p, NEW_NEXT(0, &(yyloc)));
 			{VALUE v1,v2,v3;v1=dispatch0(args_new);v2=v1;v3=dispatch1(next,v2);(yyval.val)=v3;}
                     }
-#line 15018 "ripper.c"
+#line 15020 "ripper.c"
     break;
 
   case 371: /* primary: "`redo'"  */
-#line 4220 "ripper.y"
+#line 4222 "ripper.y"
                   {
                         (yyval.node) = add_block_exit(p, NEW_REDO(&(yyloc)));
 			{VALUE v1;v1=dispatch0(redo);(yyval.val)=v1;}
                     }
-#line 15027 "ripper.c"
+#line 15029 "ripper.c"
     break;
 
   case 372: /* primary: "`retry'"  */
-#line 4225 "ripper.y"
+#line 4227 "ripper.y"
                   {
                         if (!p->ctxt.in_defined) {
                             switch (p->ctxt.in_rescue) {
@@ -15042,31 +15044,31 @@ yyreduce:
 #endif
 			{VALUE v1;v1=dispatch0(retry);(yyval.val)=v1;}
                     }
-#line 15046 "ripper.c"
+#line 15048 "ripper.c"
     break;
 
   case 373: /* primary_value: primary  */
-#line 4242 "ripper.y"
+#line 4244 "ripper.y"
                   {
                         value_expr((yyvsp[0].val));
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 15055 "ripper.c"
+#line 15057 "ripper.c"
     break;
 
   case 374: /* k_begin: "`begin'"  */
-#line 4249 "ripper.y"
+#line 4251 "ripper.y"
                   {
                         token_info_push(p, "begin", &(yyloc));
 #if 0
                         push_end_expect_token_locations(p, &(yylsp[0]).beg_pos);
 #endif
                     }
-#line 15066 "ripper.c"
+#line 15068 "ripper.c"
     break;
 
   case 375: /* k_if: "`if'"  */
-#line 4258 "ripper.y"
+#line 4260 "ripper.y"
                   {
                         WARN_EOL("if");
                         token_info_push(p, "if", &(yyloc));
@@ -15084,22 +15086,22 @@ yyreduce:
                         push_end_expect_token_locations(p, &(yylsp[0]).beg_pos);
 #endif
                     }
-#line 15088 "ripper.c"
+#line 15090 "ripper.c"
     break;
 
   case 376: /* k_unless: "`unless'"  */
-#line 4278 "ripper.y"
+#line 4280 "ripper.y"
                   {
                         token_info_push(p, "unless", &(yyloc));
 #if 0
                         push_end_expect_token_locations(p, &(yylsp[0]).beg_pos);
 #endif
                     }
-#line 15099 "ripper.c"
+#line 15101 "ripper.c"
     break;
 
   case 377: /* k_while: "`while'" allow_exits  */
-#line 4287 "ripper.y"
+#line 4289 "ripper.y"
                   {
                         (yyval.node_exits) = (yyvsp[0].node_exits);
                         token_info_push(p, "while", &(yyloc));
@@ -15107,11 +15109,11 @@ yyreduce:
                         push_end_expect_token_locations(p, &(yylsp[-1]).beg_pos);
 #endif
                     }
-#line 15111 "ripper.c"
+#line 15113 "ripper.c"
     break;
 
   case 378: /* k_until: "`until'" allow_exits  */
-#line 4297 "ripper.y"
+#line 4299 "ripper.y"
                   {
                         (yyval.node_exits) = (yyvsp[0].node_exits);
                         token_info_push(p, "until", &(yyloc));
@@ -15119,22 +15121,22 @@ yyreduce:
                         push_end_expect_token_locations(p, &(yylsp[-1]).beg_pos);
 #endif
                     }
-#line 15123 "ripper.c"
+#line 15125 "ripper.c"
     break;
 
   case 379: /* k_case: "`case'"  */
-#line 4307 "ripper.y"
+#line 4309 "ripper.y"
                   {
                         token_info_push(p, "case", &(yyloc));
 #if 0
                         push_end_expect_token_locations(p, &(yylsp[0]).beg_pos);
 #endif
                     }
-#line 15134 "ripper.c"
+#line 15136 "ripper.c"
     break;
 
   case 380: /* k_for: "`for'" allow_exits  */
-#line 4316 "ripper.y"
+#line 4318 "ripper.y"
                   {
                         (yyval.node_exits) = (yyvsp[0].node_exits);
                         token_info_push(p, "for", &(yyloc));
@@ -15142,11 +15144,11 @@ yyreduce:
                         push_end_expect_token_locations(p, &(yylsp[-1]).beg_pos);
 #endif
                     }
-#line 15146 "ripper.c"
+#line 15148 "ripper.c"
     break;
 
   case 381: /* k_class: "`class'"  */
-#line 4326 "ripper.y"
+#line 4328 "ripper.y"
                   {
                         token_info_push(p, "class", &(yyloc));
                         (yyval.ctxt) = p->ctxt;
@@ -15155,11 +15157,11 @@ yyreduce:
                         push_end_expect_token_locations(p, &(yylsp[0]).beg_pos);
 #endif
                     }
-#line 15159 "ripper.c"
+#line 15161 "ripper.c"
     break;
 
   case 382: /* k_module: "`module'"  */
-#line 4337 "ripper.y"
+#line 4339 "ripper.y"
                   {
                         token_info_push(p, "module", &(yyloc));
                         (yyval.ctxt) = p->ctxt;
@@ -15168,70 +15170,70 @@ yyreduce:
                         push_end_expect_token_locations(p, &(yylsp[0]).beg_pos);
 #endif
                     }
-#line 15172 "ripper.c"
+#line 15174 "ripper.c"
     break;
 
   case 383: /* k_def: "`def'"  */
-#line 4348 "ripper.y"
+#line 4350 "ripper.y"
                   {
                         token_info_push(p, "def", &(yyloc));
                         (yyval.node_def_temp) = NEW_DEF_TEMP(&(yyloc));
                         p->ctxt.in_argdef = 1;
                     }
-#line 15182 "ripper.c"
+#line 15184 "ripper.c"
     break;
 
   case 384: /* k_do: "`do'"  */
-#line 4356 "ripper.y"
+#line 4358 "ripper.y"
                   {
                         token_info_push(p, "do", &(yyloc));
 #if 0
                         push_end_expect_token_locations(p, &(yylsp[0]).beg_pos);
 #endif
                     }
-#line 15193 "ripper.c"
+#line 15195 "ripper.c"
     break;
 
   case 385: /* k_do_block: "`do' for block"  */
-#line 4365 "ripper.y"
+#line 4367 "ripper.y"
                   {
                         token_info_push(p, "do", &(yyloc));
 #if 0
                         push_end_expect_token_locations(p, &(yylsp[0]).beg_pos);
 #endif
                     }
-#line 15204 "ripper.c"
+#line 15206 "ripper.c"
     break;
 
   case 386: /* k_rescue: "`rescue'"  */
-#line 4374 "ripper.y"
+#line 4376 "ripper.y"
                   {
                         token_info_warn(p, "rescue", p->token_info, 1, &(yyloc));
                         (yyval.ctxt) = p->ctxt;
                         p->ctxt.in_rescue = after_rescue;
                     }
-#line 15214 "ripper.c"
+#line 15216 "ripper.c"
     break;
 
   case 387: /* k_ensure: "`ensure'"  */
-#line 4382 "ripper.y"
+#line 4384 "ripper.y"
                   {
                         token_info_warn(p, "ensure", p->token_info, 1, &(yyloc));
                         (yyval.ctxt) = p->ctxt;
                     }
-#line 15223 "ripper.c"
+#line 15225 "ripper.c"
     break;
 
   case 388: /* k_when: "`when'"  */
-#line 4389 "ripper.y"
+#line 4391 "ripper.y"
                   {
                         token_info_warn(p, "when", p->token_info, 0, &(yyloc));
                     }
-#line 15231 "ripper.c"
+#line 15233 "ripper.c"
     break;
 
   case 389: /* k_else: "`else'"  */
-#line 4395 "ripper.y"
+#line 4397 "ripper.y"
                   {
                         token_info *ptinfo_beg = p->token_info;
                         int same = ptinfo_beg && strcmp(ptinfo_beg->token, "case") != 0;
@@ -15244,57 +15246,57 @@ yyreduce:
                             if (!e.nonspc) *ptinfo_beg = e;
                         }
                     }
-#line 15248 "ripper.c"
+#line 15250 "ripper.c"
     break;
 
   case 390: /* k_elsif: "`elsif'"  */
-#line 4410 "ripper.y"
+#line 4412 "ripper.y"
                   {
                         WARN_EOL("elsif");
                         token_info_warn(p, "elsif", p->token_info, 1, &(yyloc));
                     }
-#line 15257 "ripper.c"
+#line 15259 "ripper.c"
     break;
 
   case 391: /* k_end: "`end'"  */
-#line 4417 "ripper.y"
+#line 4419 "ripper.y"
                   {
                         token_info_pop(p, "end", &(yyloc));
 #if 0
                         pop_end_expect_token_locations(p);
 #endif
                     }
-#line 15268 "ripper.c"
+#line 15270 "ripper.c"
     break;
 
   case 392: /* k_end: "dummy end"  */
-#line 4424 "ripper.y"
+#line 4426 "ripper.y"
                   {
                         compile_error(p, "syntax error, unexpected end-of-input");
                     }
-#line 15276 "ripper.c"
+#line 15278 "ripper.c"
     break;
 
   case 393: /* k_return: "`return'"  */
-#line 4430 "ripper.y"
+#line 4432 "ripper.y"
                   {
                         if (p->ctxt.in_class && !p->ctxt.in_def && !dyna_in_block(p))
                             yyerror1(&(yylsp[0]), "Invalid return in class/module body");
                     }
-#line 15285 "ripper.c"
+#line 15287 "ripper.c"
     break;
 
   case 394: /* k_yield: "`yield'"  */
-#line 4437 "ripper.y"
+#line 4439 "ripper.y"
                   {
                         if (!p->ctxt.in_defined && !p->ctxt.in_def && !compile_for_eval)
                             yyerror1(&(yylsp[0]), "Invalid yield");
                     }
-#line 15294 "ripper.c"
+#line 15296 "ripper.c"
     break;
 
   case 401: /* if_tail: k_elsif expr_value then compstmt if_tail  */
-#line 4456 "ripper.y"
+#line 4458 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_if(p, (yyvsp[-3].val), (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
@@ -15302,22 +15304,22 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4;v1=(yyvsp[-3].val);v2=(yyvsp[-1].val);v3=(yyvsp[0].val);v4=dispatch3(elsif,v1,v2,v3);(yyval.val)=v4;}
                     }
-#line 15306 "ripper.c"
+#line 15308 "ripper.c"
     break;
 
   case 403: /* opt_else: k_else compstmt  */
-#line 4467 "ripper.y"
+#line 4469 "ripper.y"
                   {
 #if 0
                         (yyval.val) = (yyvsp[0].val);
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(else,v1);(yyval.val)=v2;}
                     }
-#line 15317 "ripper.c"
+#line 15319 "ripper.c"
     break;
 
   case 406: /* f_marg: f_norm_arg  */
-#line 4480 "ripper.y"
+#line 4482 "ripper.y"
                   {
 #if 0
                         (yyval.val) = assignable(p, (yyvsp[0].val), 0, &(yyloc));
@@ -15325,99 +15327,99 @@ yyreduce:
 #endif
 			(yyval.val)=assignable(p, (yyvsp[0].val));
                     }
-#line 15329 "ripper.c"
+#line 15331 "ripper.c"
     break;
 
   case 407: /* f_marg: "(" f_margs rparen  */
-#line 4488 "ripper.y"
+#line 4490 "ripper.y"
                   {
 #if 0
                         (yyval.val) = (NODE *)(yyvsp[-1].val);
 #endif
 			{VALUE v1,v2;v1=(yyvsp[-1].val);v2=dispatch1(mlhs_paren,v1);(yyval.val)=v2;}
                     }
-#line 15340 "ripper.c"
+#line 15342 "ripper.c"
     break;
 
   case 408: /* f_marg_list: f_marg  */
-#line 4497 "ripper.y"
+#line 4499 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_LIST((yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4;v1=dispatch0(mlhs_new);v2=v1;v3=(yyvsp[0].val);v4=dispatch2(mlhs_add,v2,v3);(yyval.val)=v4;}
                     }
-#line 15351 "ripper.c"
+#line 15353 "ripper.c"
     break;
 
   case 409: /* f_marg_list: f_marg_list ',' f_marg  */
-#line 4504 "ripper.y"
+#line 4506 "ripper.y"
                   {
 #if 0
                         (yyval.val) = list_append(p, (yyvsp[-2].val), (yyvsp[0].val));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[0].val);v3=dispatch2(mlhs_add,v1,v2);(yyval.val)=v3;}
                     }
-#line 15362 "ripper.c"
+#line 15364 "ripper.c"
     break;
 
   case 410: /* f_margs: f_marg_list  */
-#line 4513 "ripper.y"
+#line 4515 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_MASGN((yyvsp[0].val), 0, &(yyloc));
 #endif
 			(yyval.val)=(yyvsp[0].val);
                     }
-#line 15373 "ripper.c"
+#line 15375 "ripper.c"
     break;
 
   case 411: /* f_margs: f_marg_list ',' f_rest_marg  */
-#line 4520 "ripper.y"
+#line 4522 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_MASGN((yyvsp[-2].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[0].val);v3=dispatch2(mlhs_add_star,v1,v2);(yyval.val)=v3;}
                     }
-#line 15384 "ripper.c"
+#line 15386 "ripper.c"
     break;
 
   case 412: /* f_margs: f_marg_list ',' f_rest_marg ',' f_marg_list  */
-#line 4527 "ripper.y"
+#line 4529 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_MASGN((yyvsp[-4].val), NEW_POSTARG((yyvsp[-2].val), (yyvsp[0].val), &(yyloc)), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6;v1=(yyvsp[-4].val);v2=(yyvsp[-2].val);v3=dispatch2(mlhs_add_star,v1,v2);v4=v3;v5=(yyvsp[0].val);v6=dispatch2(mlhs_add_post,v4,v5);(yyval.val)=v6;}
                     }
-#line 15395 "ripper.c"
+#line 15397 "ripper.c"
     break;
 
   case 413: /* f_margs: f_rest_marg  */
-#line 4534 "ripper.y"
+#line 4536 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_MASGN(0, (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4;v1=dispatch0(mlhs_new);v2=v1;v3=(yyvsp[0].val);v4=dispatch2(mlhs_add_star,v2,v3);(yyval.val)=v4;}
                     }
-#line 15406 "ripper.c"
+#line 15408 "ripper.c"
     break;
 
   case 414: /* f_margs: f_rest_marg ',' f_marg_list  */
-#line 4541 "ripper.y"
+#line 4543 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_MASGN(0, NEW_POSTARG((yyvsp[-2].val), (yyvsp[0].val), &(yyloc)), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7;v1=dispatch0(mlhs_new);v2=v1;v3=(yyvsp[-2].val);v4=dispatch2(mlhs_add_star,v2,v3);v5=v4;v6=(yyvsp[0].val);v7=dispatch2(mlhs_add_post,v5,v6);(yyval.val)=v7;}
                     }
-#line 15417 "ripper.c"
+#line 15419 "ripper.c"
     break;
 
   case 415: /* f_rest_marg: "*" f_norm_arg  */
-#line 4550 "ripper.y"
+#line 4552 "ripper.y"
                   {
 #if 0
                         (yyval.val) = assignable(p, (yyvsp[0].val), 0, &(yyloc));
@@ -15425,82 +15427,82 @@ yyreduce:
 #endif
 			(yyval.val)=assignable(p, (yyvsp[0].val));
                     }
-#line 15429 "ripper.c"
+#line 15431 "ripper.c"
     break;
 
   case 416: /* f_rest_marg: "*"  */
-#line 4558 "ripper.y"
+#line 4560 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NODE_SPECIAL_NO_NAME_REST;
 #endif
 			(yyval.val)=Qnil;
                     }
-#line 15440 "ripper.c"
+#line 15442 "ripper.c"
     break;
 
   case 418: /* f_any_kwrest: f_no_kwarg  */
-#line 4567 "ripper.y"
+#line 4569 "ripper.y"
                            {(yyval.val) = ID2VAL(idNil);}
-#line 15446 "ripper.c"
+#line 15448 "ripper.c"
     break;
 
   case 419: /* $@23: %empty  */
-#line 4570 "ripper.y"
+#line 4572 "ripper.y"
       {p->ctxt.in_argdef = 0;}
-#line 15452 "ripper.c"
+#line 15454 "ripper.c"
     break;
 
   case 421: /* block_args_tail: f_block_kwarg ',' f_kwrest opt_f_block_arg  */
-#line 4573 "ripper.y"
+#line 4575 "ripper.y"
                   {
                         (yyval.val) = new_args_tail(p, (yyvsp[-3].val), (yyvsp[-1].val), (yyvsp[0].val), &(yylsp[-1]));
                     }
-#line 15460 "ripper.c"
+#line 15462 "ripper.c"
     break;
 
   case 422: /* block_args_tail: f_block_kwarg opt_f_block_arg  */
-#line 4577 "ripper.y"
+#line 4579 "ripper.y"
                   {
                         (yyval.val) = new_args_tail(p, (yyvsp[-1].val), Qnone, (yyvsp[0].val), &(yylsp[-1]));
                     }
-#line 15468 "ripper.c"
+#line 15470 "ripper.c"
     break;
 
   case 423: /* block_args_tail: f_any_kwrest opt_f_block_arg  */
-#line 4581 "ripper.y"
+#line 4583 "ripper.y"
                   {
                         (yyval.val) = new_args_tail(p, Qnone, (yyvsp[-1].val), (yyvsp[0].val), &(yylsp[-1]));
                     }
-#line 15476 "ripper.c"
+#line 15478 "ripper.c"
     break;
 
   case 424: /* block_args_tail: f_block_arg  */
-#line 4585 "ripper.y"
+#line 4587 "ripper.y"
                   {
                         (yyval.val) = new_args_tail(p, Qnone, Qnone, (yyvsp[0].val), &(yylsp[0]));
                     }
-#line 15484 "ripper.c"
+#line 15486 "ripper.c"
     break;
 
   case 425: /* opt_block_args_tail: ',' block_args_tail  */
-#line 4591 "ripper.y"
+#line 4593 "ripper.y"
                   {
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 15492 "ripper.c"
+#line 15494 "ripper.c"
     break;
 
   case 426: /* opt_block_args_tail: %empty  */
-#line 4595 "ripper.y"
+#line 4597 "ripper.y"
                   {
                         (yyval.val) = new_args_tail(p, Qnone, Qnone, Qnone, &(yylsp[0]));
                     }
-#line 15500 "ripper.c"
+#line 15502 "ripper.c"
     break;
 
   case 427: /* excessed_comma: ','  */
-#line 4601 "ripper.y"
+#line 4603 "ripper.y"
                   {
                         /* magic number for rest_id in iseq_set_arguments() */
 #if 0
@@ -15508,140 +15510,140 @@ yyreduce:
 #endif
 			{VALUE v1;v1=dispatch0(excessed_comma);(yyval.val)=v1;}
                     }
-#line 15512 "ripper.c"
+#line 15514 "ripper.c"
     break;
 
   case 428: /* block_param: f_arg ',' f_block_optarg ',' f_rest_arg opt_block_args_tail  */
-#line 4611 "ripper.y"
+#line 4613 "ripper.y"
                   {
                         (yyval.val) = new_args(p, (yyvsp[-5].val), (yyvsp[-3].val), (yyvsp[-1].val), Qnone, (yyvsp[0].val), &(yyloc));
                     }
-#line 15520 "ripper.c"
+#line 15522 "ripper.c"
     break;
 
   case 429: /* block_param: f_arg ',' f_block_optarg ',' f_rest_arg ',' f_arg opt_block_args_tail  */
-#line 4615 "ripper.y"
+#line 4617 "ripper.y"
                   {
                         (yyval.val) = new_args(p, (yyvsp[-7].val), (yyvsp[-5].val), (yyvsp[-3].val), (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
                     }
-#line 15528 "ripper.c"
+#line 15530 "ripper.c"
     break;
 
   case 430: /* block_param: f_arg ',' f_block_optarg opt_block_args_tail  */
-#line 4619 "ripper.y"
+#line 4621 "ripper.y"
                   {
                         (yyval.val) = new_args(p, (yyvsp[-3].val), (yyvsp[-1].val), Qnone, Qnone, (yyvsp[0].val), &(yyloc));
                     }
-#line 15536 "ripper.c"
+#line 15538 "ripper.c"
     break;
 
   case 431: /* block_param: f_arg ',' f_block_optarg ',' f_arg opt_block_args_tail  */
-#line 4623 "ripper.y"
+#line 4625 "ripper.y"
                   {
                         (yyval.val) = new_args(p, (yyvsp[-5].val), (yyvsp[-3].val), Qnone, (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
                     }
-#line 15544 "ripper.c"
+#line 15546 "ripper.c"
     break;
 
   case 432: /* block_param: f_arg ',' f_rest_arg opt_block_args_tail  */
-#line 4627 "ripper.y"
+#line 4629 "ripper.y"
                   {
                         (yyval.val) = new_args(p, (yyvsp[-3].val), Qnone, (yyvsp[-1].val), Qnone, (yyvsp[0].val), &(yyloc));
                     }
-#line 15552 "ripper.c"
+#line 15554 "ripper.c"
     break;
 
   case 433: /* block_param: f_arg excessed_comma  */
-#line 4631 "ripper.y"
+#line 4633 "ripper.y"
                   {
                         (yyval.val) = new_args_tail(p, Qnone, Qnone, Qnone, &(yylsp[0]));
                         (yyval.val) = new_args(p, (yyvsp[-1].val), Qnone, (yyvsp[0].val), Qnone, (yyval.val), &(yyloc));
                     }
-#line 15561 "ripper.c"
+#line 15563 "ripper.c"
     break;
 
   case 434: /* block_param: f_arg ',' f_rest_arg ',' f_arg opt_block_args_tail  */
-#line 4636 "ripper.y"
+#line 4638 "ripper.y"
                   {
                         (yyval.val) = new_args(p, (yyvsp[-5].val), Qnone, (yyvsp[-3].val), (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
                     }
-#line 15569 "ripper.c"
+#line 15571 "ripper.c"
     break;
 
   case 435: /* block_param: f_arg opt_block_args_tail  */
-#line 4640 "ripper.y"
+#line 4642 "ripper.y"
                   {
                         (yyval.val) = new_args(p, (yyvsp[-1].val), Qnone, Qnone, Qnone, (yyvsp[0].val), &(yyloc));
                     }
-#line 15577 "ripper.c"
+#line 15579 "ripper.c"
     break;
 
   case 436: /* block_param: f_block_optarg ',' f_rest_arg opt_block_args_tail  */
-#line 4644 "ripper.y"
+#line 4646 "ripper.y"
                   {
                         (yyval.val) = new_args(p, Qnone, (yyvsp[-3].val), (yyvsp[-1].val), Qnone, (yyvsp[0].val), &(yyloc));
                     }
-#line 15585 "ripper.c"
+#line 15587 "ripper.c"
     break;
 
   case 437: /* block_param: f_block_optarg ',' f_rest_arg ',' f_arg opt_block_args_tail  */
-#line 4648 "ripper.y"
+#line 4650 "ripper.y"
                   {
                         (yyval.val) = new_args(p, Qnone, (yyvsp[-5].val), (yyvsp[-3].val), (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
                     }
-#line 15593 "ripper.c"
+#line 15595 "ripper.c"
     break;
 
   case 438: /* block_param: f_block_optarg opt_block_args_tail  */
-#line 4652 "ripper.y"
+#line 4654 "ripper.y"
                   {
                         (yyval.val) = new_args(p, Qnone, (yyvsp[-1].val), Qnone, Qnone, (yyvsp[0].val), &(yyloc));
                     }
-#line 15601 "ripper.c"
+#line 15603 "ripper.c"
     break;
 
   case 439: /* block_param: f_block_optarg ',' f_arg opt_block_args_tail  */
-#line 4656 "ripper.y"
+#line 4658 "ripper.y"
                   {
                         (yyval.val) = new_args(p, Qnone, (yyvsp[-3].val), Qnone, (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
                     }
-#line 15609 "ripper.c"
+#line 15611 "ripper.c"
     break;
 
   case 440: /* block_param: f_rest_arg opt_block_args_tail  */
-#line 4660 "ripper.y"
+#line 4662 "ripper.y"
                   {
                         (yyval.val) = new_args(p, Qnone, Qnone, (yyvsp[-1].val), Qnone, (yyvsp[0].val), &(yyloc));
                     }
-#line 15617 "ripper.c"
+#line 15619 "ripper.c"
     break;
 
   case 441: /* block_param: f_rest_arg ',' f_arg opt_block_args_tail  */
-#line 4664 "ripper.y"
+#line 4666 "ripper.y"
                   {
                         (yyval.val) = new_args(p, Qnone, Qnone, (yyvsp[-3].val), (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
                     }
-#line 15625 "ripper.c"
+#line 15627 "ripper.c"
     break;
 
   case 442: /* block_param: block_args_tail  */
-#line 4668 "ripper.y"
+#line 4670 "ripper.y"
                   {
                         (yyval.val) = new_args(p, Qnone, Qnone, Qnone, Qnone, (yyvsp[0].val), &(yyloc));
                     }
-#line 15633 "ripper.c"
+#line 15635 "ripper.c"
     break;
 
   case 444: /* opt_block_param: block_param_def  */
-#line 4675 "ripper.y"
+#line 4677 "ripper.y"
                   {
                         p->command_start = TRUE;
                     }
-#line 15641 "ripper.c"
+#line 15643 "ripper.c"
     break;
 
   case 445: /* block_param_def: '|' opt_bv_decl '|'  */
-#line 4681 "ripper.y"
+#line 4683 "ripper.y"
                   {
                         p->cur_arg = 0;
                         p->max_numparam = ORDINAL_PARAM;
@@ -15652,11 +15654,11 @@ yyreduce:
 			{VALUE v1,v2,v3,v4,v5,v6,v7,v8;v1=Qnil;v2=Qnil;v3=Qnil;v4=Qnil;v5=Qnil;v6=Qnil;v7=Qnil;v8=dispatch7(params,v1,v2,v3,v4,v5,v6,v7);(yyval.val)=v8;}
 			{VALUE v1,v2,v3;v1=(yyval.val);v2=(yyvsp[-1].val);v3=dispatch2(block_var,v1,v2);(yyval.val)=v3;}
                     }
-#line 15656 "ripper.c"
+#line 15658 "ripper.c"
     break;
 
   case 446: /* block_param_def: '|' block_param opt_bv_decl '|'  */
-#line 4692 "ripper.y"
+#line 4694 "ripper.y"
                   {
                         p->cur_arg = 0;
                         p->max_numparam = ORDINAL_PARAM;
@@ -15666,95 +15668,95 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[-1].val);v3=dispatch2(block_var,v1,v2);(yyval.val)=v3;}
                     }
-#line 15670 "ripper.c"
+#line 15672 "ripper.c"
     break;
 
   case 447: /* opt_bv_decl: opt_nl  */
-#line 4705 "ripper.y"
+#line 4707 "ripper.y"
                   {
                         (yyval.val) = 0;
                     }
-#line 15678 "ripper.c"
+#line 15680 "ripper.c"
     break;
 
   case 448: /* opt_bv_decl: opt_nl ';' bv_decls opt_nl  */
-#line 4709 "ripper.y"
+#line 4711 "ripper.y"
                   {
 #if 0
                         (yyval.val) = 0;
 #endif
 			(yyval.val)=(yyvsp[-1].val);
                     }
-#line 15689 "ripper.c"
+#line 15691 "ripper.c"
     break;
 
   case 449: /* bv_decls: bvar  */
-#line 4718 "ripper.y"
+#line 4720 "ripper.y"
  {(yyval.val)=rb_ary_new3(1, get_value((yyvsp[0].val)));}
-#line 15695 "ripper.c"
+#line 15697 "ripper.c"
     break;
 
   case 450: /* bv_decls: bv_decls ',' bvar  */
-#line 4720 "ripper.y"
+#line 4722 "ripper.y"
  {(yyval.val)=rb_ary_push((yyvsp[-2].val), get_value((yyvsp[0].val)));}
-#line 15701 "ripper.c"
+#line 15703 "ripper.c"
     break;
 
   case 451: /* bvar: "local variable or method"  */
-#line 4724 "ripper.y"
+#line 4726 "ripper.y"
                   {
                         new_bv(p, get_id((yyvsp[0].val)));
 			(yyval.val)=get_value((yyvsp[0].val));
                     }
-#line 15710 "ripper.c"
+#line 15712 "ripper.c"
     break;
 
   case 452: /* bvar: f_bad_arg  */
-#line 4729 "ripper.y"
+#line 4731 "ripper.y"
                   {
                         (yyval.val) = 0;
                     }
-#line 15718 "ripper.c"
+#line 15720 "ripper.c"
     break;
 
   case 453: /* max_numparam: %empty  */
-#line 4734 "ripper.y"
+#line 4736 "ripper.y"
                {
                         (yyval.num) = p->max_numparam;
                         p->max_numparam = 0;
                     }
-#line 15727 "ripper.c"
+#line 15729 "ripper.c"
     break;
 
   case 454: /* numparam: %empty  */
-#line 4740 "ripper.y"
+#line 4742 "ripper.y"
            {
                         (yyval.node) = numparam_push(p);
                     }
-#line 15735 "ripper.c"
+#line 15737 "ripper.c"
     break;
 
   case 455: /* @24: %empty  */
-#line 4746 "ripper.y"
+#line 4748 "ripper.y"
                   {
                         token_info_push(p, "->", &(yylsp[0]));
                         (yyvsp[0].vars) = dyna_push(p);
                         (yyval.num) = p->lex.lpar_beg;
                         p->lex.lpar_beg = p->lex.paren_nest;
                     }
-#line 15746 "ripper.c"
+#line 15748 "ripper.c"
     break;
 
   case 456: /* $@25: %empty  */
-#line 4754 "ripper.y"
+#line 4756 "ripper.y"
                   {
                         CMDARG_PUSH(0);
                     }
-#line 15754 "ripper.c"
+#line 15756 "ripper.c"
     break;
 
   case 457: /* lambda: "->" @24 max_numparam numparam allow_exits f_larglist $@25 lambda_body  */
-#line 4758 "ripper.y"
+#line 4760 "ripper.y"
                   {
                         int max_numparam = p->max_numparam;
                         p->lex.lpar_beg = (yyvsp[-6].num);
@@ -15775,11 +15777,11 @@ yyreduce:
                         numparam_pop(p, (yyvsp[-4].node));
                         dyna_pop(p, (yyvsp[-7].vars));
                     }
-#line 15779 "ripper.c"
+#line 15781 "ripper.c"
     break;
 
   case 458: /* f_larglist: '(' f_args opt_bv_decl ')'  */
-#line 4781 "ripper.y"
+#line 4783 "ripper.y"
                   {
                         p->ctxt.in_argdef = 0;
 #if 0
@@ -15788,11 +15790,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=(yyvsp[-2].val);v2=dispatch1(paren,v1);(yyval.val)=v2;}
                     }
-#line 15792 "ripper.c"
+#line 15794 "ripper.c"
     break;
 
   case 459: /* f_larglist: f_args  */
-#line 4790 "ripper.y"
+#line 4792 "ripper.y"
                   {
                         p->ctxt.in_argdef = 0;
 #if 0
@@ -15801,49 +15803,49 @@ yyreduce:
 #endif
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 15805 "ripper.c"
+#line 15807 "ripper.c"
     break;
 
   case 460: /* lambda_body: tLAMBEG compstmt '}'  */
-#line 4801 "ripper.y"
+#line 4803 "ripper.y"
                   {
                         token_info_pop(p, "}", &(yylsp[0]));
                         (yyval.val) = (yyvsp[-1].val);
                     }
-#line 15814 "ripper.c"
+#line 15816 "ripper.c"
     break;
 
   case 461: /* $@26: %empty  */
-#line 4806 "ripper.y"
+#line 4808 "ripper.y"
                   {
 #if 0
                         push_end_expect_token_locations(p, &(yylsp[0]).beg_pos);
 #endif
                     }
-#line 15824 "ripper.c"
+#line 15826 "ripper.c"
     break;
 
   case 462: /* lambda_body: "`do' for lambda" $@26 bodystmt k_end  */
-#line 4812 "ripper.y"
+#line 4814 "ripper.y"
                   {
                         (yyval.val) = (yyvsp[-1].val);
                     }
-#line 15832 "ripper.c"
+#line 15834 "ripper.c"
     break;
 
   case 463: /* do_block: k_do_block do_body k_end  */
-#line 4818 "ripper.y"
+#line 4820 "ripper.y"
                   {
                         (yyval.val) = (yyvsp[-1].val);
 #if 0
                         set_embraced_location((yyval.val), &(yylsp[-2]), &(yylsp[0]));
 #endif
                     }
-#line 15843 "ripper.c"
+#line 15845 "ripper.c"
     break;
 
   case 464: /* block_call: command do_block  */
-#line 4827 "ripper.y"
+#line 4829 "ripper.y"
                   {
 #if 0
                         if (nd_type_p((yyvsp[-1].val), NODE_YIELD)) {
@@ -15857,44 +15859,44 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-1].val);v2=(yyvsp[0].val);v3=dispatch2(method_add_block,v1,v2);(yyval.val)=v3;}
                     }
-#line 15861 "ripper.c"
+#line 15863 "ripper.c"
     break;
 
   case 465: /* block_call: block_call call_op2 operation2 opt_paren_args  */
-#line 4841 "ripper.y"
+#line 4843 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_qcall(p, (yyvsp[-2].val), (yyvsp[-3].val), (yyvsp[-1].val), (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7;v1=(yyvsp[-3].val);v2=(yyvsp[-2].val);v3=(yyvsp[-1].val);v4=dispatch3(call,v1,v2,v3);v5=v4;v6=(yyvsp[0].val);v7=v6==Qundef ? v5 : dispatch2(method_add_arg,v5,v6);(yyval.val)=v7;}
                     }
-#line 15872 "ripper.c"
+#line 15874 "ripper.c"
     break;
 
   case 466: /* block_call: block_call call_op2 operation2 opt_paren_args brace_block  */
-#line 4848 "ripper.y"
+#line 4850 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_command_qcall(p, (yyvsp[-3].val), (yyvsp[-4].val), (yyvsp[-2].val), (yyvsp[-1].val), (yyvsp[0].val), &(yylsp[-2]), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7,v8;v1=(yyvsp[-4].val);v2=(yyvsp[-3].val);v3=(yyvsp[-2].val);v4=(yyvsp[-1].val);v5=dispatch4(command_call,v1,v2,v3,v4);v6=v5;v7=(yyvsp[0].val);v8=v7==Qundef ? v6 : dispatch2(method_add_block,v6,v7);(yyval.val)=v8;}
                     }
-#line 15883 "ripper.c"
+#line 15885 "ripper.c"
     break;
 
   case 467: /* block_call: block_call call_op2 operation2 command_args do_block  */
-#line 4855 "ripper.y"
+#line 4857 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_command_qcall(p, (yyvsp[-3].val), (yyvsp[-4].val), (yyvsp[-2].val), (yyvsp[-1].val), (yyvsp[0].val), &(yylsp[-2]), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7,v8;v1=(yyvsp[-4].val);v2=(yyvsp[-3].val);v3=(yyvsp[-2].val);v4=(yyvsp[-1].val);v5=dispatch4(command_call,v1,v2,v3,v4);v6=v5;v7=(yyvsp[0].val);v8=dispatch2(method_add_block,v6,v7);(yyval.val)=v8;}
                     }
-#line 15894 "ripper.c"
+#line 15896 "ripper.c"
     break;
 
   case 468: /* method_call: fcall paren_args  */
-#line 4864 "ripper.y"
+#line 4866 "ripper.y"
                   {
 #if 0
                         (yyvsp[-1].val)->nd_args = (yyvsp[0].val);
@@ -15903,11 +15905,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4,v5;v1=(yyvsp[-1].val);v2=dispatch1(fcall,v1);v3=v2;v4=(yyvsp[0].val);v5=dispatch2(method_add_arg,v3,v4);(yyval.val)=v5;}
                     }
-#line 15907 "ripper.c"
+#line 15909 "ripper.c"
     break;
 
   case 469: /* method_call: primary_value call_op operation2 opt_paren_args  */
-#line 4873 "ripper.y"
+#line 4875 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_qcall(p, (yyvsp[-2].val), (yyvsp[-3].val), (yyvsp[-1].val), (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
@@ -15915,11 +15917,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7;v1=(yyvsp[-3].val);v2=(yyvsp[-2].val);v3=(yyvsp[-1].val);v4=dispatch3(call,v1,v2,v3);v5=v4;v6=(yyvsp[0].val);v7=v6==Qundef ? v5 : dispatch2(method_add_arg,v5,v6);(yyval.val)=v7;}
                     }
-#line 15919 "ripper.c"
+#line 15921 "ripper.c"
     break;
 
   case 470: /* method_call: primary_value "::" operation2 paren_args  */
-#line 4881 "ripper.y"
+#line 4883 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_qcall(p, ID2VAL(idCOLON2), (yyvsp[-3].val), (yyvsp[-1].val), (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
@@ -15927,22 +15929,22 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7;v1=(yyvsp[-3].val);v2=(yyvsp[-2].val);v3=(yyvsp[-1].val);v4=dispatch3(call,v1,v2,v3);v5=v4;v6=(yyvsp[0].val);v7=dispatch2(method_add_arg,v5,v6);(yyval.val)=v7;}
                     }
-#line 15931 "ripper.c"
+#line 15933 "ripper.c"
     break;
 
   case 471: /* method_call: primary_value "::" operation3  */
-#line 4889 "ripper.y"
+#line 4891 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_qcall(p, ID2VAL(idCOLON2), (yyvsp[-2].val), (yyvsp[0].val), Qnull, &(yylsp[0]), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4;v1=(yyvsp[-2].val);v2=(yyvsp[-1].val);v3=(yyvsp[0].val);v4=dispatch3(call,v1,v2,v3);(yyval.val)=v4;}
                     }
-#line 15942 "ripper.c"
+#line 15944 "ripper.c"
     break;
 
   case 472: /* method_call: primary_value call_op paren_args  */
-#line 4896 "ripper.y"
+#line 4898 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_qcall(p, (yyvsp[-1].val), (yyvsp[-2].val), ID2VAL(idCall), (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
@@ -15950,11 +15952,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7;v1=(yyvsp[-2].val);v2=(yyvsp[-1].val);v3=ID2VAL(idCall);v4=dispatch3(call,v1,v2,v3);v5=v4;v6=(yyvsp[0].val);v7=dispatch2(method_add_arg,v5,v6);(yyval.val)=v7;}
                     }
-#line 15954 "ripper.c"
+#line 15956 "ripper.c"
     break;
 
   case 473: /* method_call: primary_value "::" paren_args  */
-#line 4904 "ripper.y"
+#line 4906 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_qcall(p, ID2VAL(idCOLON2), (yyvsp[-2].val), ID2VAL(idCall), (yyvsp[0].val), &(yylsp[-1]), &(yyloc));
@@ -15962,33 +15964,33 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4,v5,v6,v7;v1=(yyvsp[-2].val);v2=(yyvsp[-1].val);v3=ID2VAL(idCall);v4=dispatch3(call,v1,v2,v3);v5=v4;v6=(yyvsp[0].val);v7=dispatch2(method_add_arg,v5,v6);(yyval.val)=v7;}
                     }
-#line 15966 "ripper.c"
+#line 15968 "ripper.c"
     break;
 
   case 474: /* method_call: "`super'" paren_args  */
-#line 4912 "ripper.y"
+#line 4914 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_SUPER((yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(super,v1);(yyval.val)=v2;}
                     }
-#line 15977 "ripper.c"
+#line 15979 "ripper.c"
     break;
 
   case 475: /* method_call: "`super'"  */
-#line 4919 "ripper.y"
+#line 4921 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_ZSUPER(&(yyloc));
 #endif
 			{VALUE v1;v1=dispatch0(zsuper);(yyval.val)=v1;}
                     }
-#line 15988 "ripper.c"
+#line 15990 "ripper.c"
     break;
 
   case 476: /* method_call: primary_value '[' opt_call_args rbracket  */
-#line 4926 "ripper.y"
+#line 4928 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_CALL((yyvsp[-3].val), tAREF, (yyvsp[-1].val), &(yyloc));
@@ -15996,39 +15998,39 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-3].val);v2=(yyvsp[-1].val);v3=dispatch2(aref,v1,v2);(yyval.val)=v3;}
                     }
-#line 16000 "ripper.c"
+#line 16002 "ripper.c"
     break;
 
   case 477: /* brace_block: '{' brace_body '}'  */
-#line 4936 "ripper.y"
+#line 4938 "ripper.y"
                   {
                         (yyval.val) = (yyvsp[-1].val);
 #if 0
                         set_embraced_location((yyval.val), &(yylsp[-2]), &(yylsp[0]));
 #endif
                     }
-#line 16011 "ripper.c"
+#line 16013 "ripper.c"
     break;
 
   case 478: /* brace_block: k_do do_body k_end  */
-#line 4943 "ripper.y"
+#line 4945 "ripper.y"
                   {
                         (yyval.val) = (yyvsp[-1].val);
 #if 0
                         set_embraced_location((yyval.val), &(yylsp[-2]), &(yylsp[0]));
 #endif
                     }
-#line 16022 "ripper.c"
+#line 16024 "ripper.c"
     break;
 
   case 479: /* @27: %empty  */
-#line 4951 "ripper.y"
+#line 4953 "ripper.y"
            {(yyval.vars) = dyna_push(p);}
-#line 16028 "ripper.c"
+#line 16030 "ripper.c"
     break;
 
   case 480: /* brace_body: @27 max_numparam numparam allow_exits opt_block_param compstmt  */
-#line 4954 "ripper.y"
+#line 4956 "ripper.y"
                   {
                         int max_numparam = p->max_numparam;
                         p->max_numparam = (yyvsp[-4].num);
@@ -16041,20 +16043,20 @@ yyreduce:
                         numparam_pop(p, (yyvsp[-3].node));
                         dyna_pop(p, (yyvsp[-5].vars));
                     }
-#line 16045 "ripper.c"
+#line 16047 "ripper.c"
     break;
 
   case 481: /* @28: %empty  */
-#line 4968 "ripper.y"
+#line 4970 "ripper.y"
            {
                         (yyval.vars) = dyna_push(p);
                         CMDARG_PUSH(0);
                     }
-#line 16054 "ripper.c"
+#line 16056 "ripper.c"
     break;
 
   case 482: /* do_body: @28 max_numparam numparam allow_exits opt_block_param bodystmt  */
-#line 4974 "ripper.y"
+#line 4976 "ripper.y"
                   {
                         int max_numparam = p->max_numparam;
                         p->max_numparam = (yyvsp[-4].num);
@@ -16068,11 +16070,11 @@ yyreduce:
                         numparam_pop(p, (yyvsp[-3].node));
                         dyna_pop(p, (yyvsp[-5].vars));
                     }
-#line 16072 "ripper.c"
+#line 16074 "ripper.c"
     break;
 
   case 483: /* case_args: arg_value  */
-#line 4990 "ripper.y"
+#line 4992 "ripper.y"
                   {
 #if 0
                         check_literal_when(p, (yyvsp[0].val), &(yylsp[0]));
@@ -16080,22 +16082,22 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4;v1=dispatch0(args_new);v2=v1;v3=(yyvsp[0].val);v4=dispatch2(args_add,v2,v3);(yyval.val)=v4;}
                     }
-#line 16084 "ripper.c"
+#line 16086 "ripper.c"
     break;
 
   case 484: /* case_args: "*" arg_value  */
-#line 4998 "ripper.y"
+#line 5000 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_SPLAT((yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4;v1=dispatch0(args_new);v2=v1;v3=(yyvsp[0].val);v4=dispatch2(args_add_star,v2,v3);(yyval.val)=v4;}
                     }
-#line 16095 "ripper.c"
+#line 16097 "ripper.c"
     break;
 
   case 485: /* case_args: case_args ',' arg_value  */
-#line 5005 "ripper.y"
+#line 5007 "ripper.y"
                   {
 #if 0
                         check_literal_when(p, (yyvsp[0].val), &(yylsp[0]));
@@ -16103,22 +16105,22 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[0].val);v3=dispatch2(args_add,v1,v2);(yyval.val)=v3;}
                     }
-#line 16107 "ripper.c"
+#line 16109 "ripper.c"
     break;
 
   case 486: /* case_args: case_args ',' "*" arg_value  */
-#line 5013 "ripper.y"
+#line 5015 "ripper.y"
                   {
 #if 0
                         (yyval.val) = rest_arg_append(p, (yyvsp[-3].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-3].val);v2=(yyvsp[0].val);v3=dispatch2(args_add_star,v1,v2);(yyval.val)=v3;}
                     }
-#line 16118 "ripper.c"
+#line 16120 "ripper.c"
     break;
 
   case 487: /* case_body: k_when case_args then compstmt cases  */
-#line 5024 "ripper.y"
+#line 5026 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_WHEN((yyvsp[-3].val), (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
@@ -16126,55 +16128,55 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4;v1=(yyvsp[-3].val);v2=(yyvsp[-1].val);v3=(yyvsp[0].val);v4=dispatch3(when,v1,v2,v3);(yyval.val)=v4;}
                     }
-#line 16130 "ripper.c"
+#line 16132 "ripper.c"
     break;
 
   case 490: /* p_pvtbl: %empty  */
-#line 5037 "ripper.y"
+#line 5039 "ripper.y"
          {(yyval.tbl) = p->pvtbl; p->pvtbl = st_init_numtable();}
-#line 16136 "ripper.c"
+#line 16138 "ripper.c"
     break;
 
   case 491: /* p_pktbl: %empty  */
-#line 5038 "ripper.y"
+#line 5040 "ripper.y"
          {(yyval.tbl) = p->pktbl; p->pktbl = 0;}
-#line 16142 "ripper.c"
+#line 16144 "ripper.c"
     break;
 
   case 492: /* p_in_kwarg: %empty  */
-#line 5040 "ripper.y"
+#line 5042 "ripper.y"
              {
                         (yyval.ctxt) = p->ctxt;
                         SET_LEX_STATE(EXPR_BEG|EXPR_LABEL);
                         p->command_start = FALSE;
                         p->ctxt.in_kwarg = 1;
                     }
-#line 16153 "ripper.c"
+#line 16155 "ripper.c"
     break;
 
   case 493: /* $@29: %empty  */
-#line 5051 "ripper.y"
+#line 5053 "ripper.y"
                   {
                         pop_pktbl(p, (yyvsp[-2].tbl));
                         pop_pvtbl(p, (yyvsp[-3].tbl));
                         p->ctxt.in_kwarg = (yyvsp[-4].ctxt).in_kwarg;
                     }
-#line 16163 "ripper.c"
+#line 16165 "ripper.c"
     break;
 
   case 494: /* p_case_body: "`in'" p_in_kwarg p_pvtbl p_pktbl p_top_expr then $@29 compstmt p_cases  */
-#line 5058 "ripper.y"
+#line 5060 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_IN((yyvsp[-4].val), (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4;v1=(yyvsp[-4].val);v2=(yyvsp[-1].val);v3=(yyvsp[0].val);v4=dispatch3(in,v1,v2,v3);(yyval.val)=v4;}
                     }
-#line 16174 "ripper.c"
+#line 16176 "ripper.c"
     break;
 
   case 498: /* p_top_expr: p_top_expr_body "`if' modifier" expr_value  */
-#line 5072 "ripper.y"
+#line 5074 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_if(p, (yyvsp[0].val), (yyvsp[-2].val), 0, &(yyloc));
@@ -16182,11 +16184,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[0].val);v2=(yyvsp[-2].val);v3=dispatch2(if_mod,v1,v2);(yyval.val)=v3;}
                     }
-#line 16186 "ripper.c"
+#line 16188 "ripper.c"
     break;
 
   case 499: /* p_top_expr: p_top_expr_body "`unless' modifier" expr_value  */
-#line 5080 "ripper.y"
+#line 5082 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_unless(p, (yyvsp[0].val), (yyvsp[-2].val), 0, &(yyloc));
@@ -16194,20 +16196,20 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[0].val);v2=(yyvsp[-2].val);v3=dispatch2(unless_mod,v1,v2);(yyval.val)=v3;}
                     }
-#line 16198 "ripper.c"
+#line 16200 "ripper.c"
     break;
 
   case 501: /* p_top_expr_body: p_expr ','  */
-#line 5091 "ripper.y"
+#line 5093 "ripper.y"
                   {
                         (yyval.val) = new_array_pattern_tail(p, Qnone, 1, Qnone, Qnone, &(yyloc));
                         (yyval.val) = new_array_pattern(p, Qnone, get_value((yyvsp[-1].val)), (yyval.val), &(yyloc));
                     }
-#line 16207 "ripper.c"
+#line 16209 "ripper.c"
     break;
 
   case 502: /* p_top_expr_body: p_expr ',' p_args  */
-#line 5096 "ripper.y"
+#line 5098 "ripper.y"
                   {
                         (yyval.val) = new_array_pattern(p, Qnone, get_value((yyvsp[-2].val)), (yyvsp[0].val), &(yyloc));
 #if 0
@@ -16215,35 +16217,35 @@ yyreduce:
 #endif
 
                     }
-#line 16219 "ripper.c"
+#line 16221 "ripper.c"
     break;
 
   case 503: /* p_top_expr_body: p_find  */
-#line 5104 "ripper.y"
+#line 5106 "ripper.y"
                   {
                         (yyval.val) = new_find_pattern(p, Qnone, (yyvsp[0].val), &(yyloc));
                     }
-#line 16227 "ripper.c"
+#line 16229 "ripper.c"
     break;
 
   case 504: /* p_top_expr_body: p_args_tail  */
-#line 5108 "ripper.y"
+#line 5110 "ripper.y"
                   {
                         (yyval.val) = new_array_pattern(p, Qnone, Qnone, (yyvsp[0].val), &(yyloc));
                     }
-#line 16235 "ripper.c"
+#line 16237 "ripper.c"
     break;
 
   case 505: /* p_top_expr_body: p_kwargs  */
-#line 5112 "ripper.y"
+#line 5114 "ripper.y"
                   {
                         (yyval.val) = new_hash_pattern(p, Qnone, (yyvsp[0].val), &(yyloc));
                     }
-#line 16243 "ripper.c"
+#line 16245 "ripper.c"
     break;
 
   case 507: /* p_as: p_expr "=>" p_variable  */
-#line 5121 "ripper.y"
+#line 5123 "ripper.y"
                   {
 #if 0
                         NODE *n = NEW_LIST((yyvsp[-2].val), &(yyloc));
@@ -16252,34 +16254,34 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4;v1=(yyvsp[-2].val);v2=STATIC_ID2SYM(id_assoc);v3=(yyvsp[0].val);v4=dispatch3(binary,v1,v2,v3);(yyval.val)=v4;}
                     }
-#line 16256 "ripper.c"
+#line 16258 "ripper.c"
     break;
 
   case 509: /* p_alt: p_alt '|' p_expr_basic  */
-#line 5133 "ripper.y"
+#line 5135 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_OR((yyvsp[-2].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3,v4;v1=(yyvsp[-2].val);v2=STATIC_ID2SYM(idOr);v3=(yyvsp[0].val);v4=dispatch3(binary,v1,v2,v3);(yyval.val)=v4;}
                     }
-#line 16267 "ripper.c"
+#line 16269 "ripper.c"
     break;
 
   case 511: /* p_lparen: '(' p_pktbl  */
-#line 5142 "ripper.y"
+#line 5144 "ripper.y"
                      { (yyval.tbl) = (yyvsp[0].tbl);}
-#line 16273 "ripper.c"
+#line 16275 "ripper.c"
     break;
 
   case 512: /* p_lbracket: '[' p_pktbl  */
-#line 5143 "ripper.y"
+#line 5145 "ripper.y"
                        { (yyval.tbl) = (yyvsp[0].tbl);}
-#line 16279 "ripper.c"
+#line 16281 "ripper.c"
     break;
 
   case 515: /* p_expr_basic: p_const p_lparen p_args rparen  */
-#line 5148 "ripper.y"
+#line 5150 "ripper.y"
                   {
                         pop_pktbl(p, (yyvsp[-2].tbl));
                         (yyval.val) = new_array_pattern(p, (yyvsp[-3].val), Qnone, (yyvsp[-1].val), &(yyloc));
@@ -16288,11 +16290,11 @@ yyreduce:
 #endif
 
                     }
-#line 16292 "ripper.c"
+#line 16294 "ripper.c"
     break;
 
   case 516: /* p_expr_basic: p_const p_lparen p_find rparen  */
-#line 5157 "ripper.y"
+#line 5159 "ripper.y"
                   {
                         pop_pktbl(p, (yyvsp[-2].tbl));
                         (yyval.val) = new_find_pattern(p, (yyvsp[-3].val), (yyvsp[-1].val), &(yyloc));
@@ -16301,11 +16303,11 @@ yyreduce:
 #endif
 
                     }
-#line 16305 "ripper.c"
+#line 16307 "ripper.c"
     break;
 
   case 517: /* p_expr_basic: p_const p_lparen p_kwargs rparen  */
-#line 5166 "ripper.y"
+#line 5168 "ripper.y"
                   {
                         pop_pktbl(p, (yyvsp[-2].tbl));
                         (yyval.val) = new_hash_pattern(p, (yyvsp[-3].val), (yyvsp[-1].val), &(yyloc));
@@ -16314,20 +16316,20 @@ yyreduce:
 #endif
 
                     }
-#line 16318 "ripper.c"
+#line 16320 "ripper.c"
     break;
 
   case 518: /* p_expr_basic: p_const '(' rparen  */
-#line 5175 "ripper.y"
+#line 5177 "ripper.y"
                   {
                         (yyval.val) = new_array_pattern_tail(p, Qnone, 0, Qnone, Qnone, &(yyloc));
                         (yyval.val) = new_array_pattern(p, (yyvsp[-2].val), Qnone, (yyval.val), &(yyloc));
                     }
-#line 16327 "ripper.c"
+#line 16329 "ripper.c"
     break;
 
   case 519: /* p_expr_basic: p_const p_lbracket p_args rbracket  */
-#line 5180 "ripper.y"
+#line 5182 "ripper.y"
                   {
                         pop_pktbl(p, (yyvsp[-2].tbl));
                         (yyval.val) = new_array_pattern(p, (yyvsp[-3].val), Qnone, (yyvsp[-1].val), &(yyloc));
@@ -16336,11 +16338,11 @@ yyreduce:
 #endif
 
                     }
-#line 16340 "ripper.c"
+#line 16342 "ripper.c"
     break;
 
   case 520: /* p_expr_basic: p_const p_lbracket p_find rbracket  */
-#line 5189 "ripper.y"
+#line 5191 "ripper.y"
                   {
                         pop_pktbl(p, (yyvsp[-2].tbl));
                         (yyval.val) = new_find_pattern(p, (yyvsp[-3].val), (yyvsp[-1].val), &(yyloc));
@@ -16349,11 +16351,11 @@ yyreduce:
 #endif
 
                     }
-#line 16353 "ripper.c"
+#line 16355 "ripper.c"
     break;
 
   case 521: /* p_expr_basic: p_const p_lbracket p_kwargs rbracket  */
-#line 5198 "ripper.y"
+#line 5200 "ripper.y"
                   {
                         pop_pktbl(p, (yyvsp[-2].tbl));
                         (yyval.val) = new_hash_pattern(p, (yyvsp[-3].val), (yyvsp[-1].val), &(yyloc));
@@ -16362,81 +16364,81 @@ yyreduce:
 #endif
 
                     }
-#line 16366 "ripper.c"
+#line 16368 "ripper.c"
     break;
 
   case 522: /* p_expr_basic: p_const '[' rbracket  */
-#line 5207 "ripper.y"
+#line 5209 "ripper.y"
                   {
                         (yyval.val) = new_array_pattern_tail(p, Qnone, 0, Qnone, Qnone, &(yyloc));
                         (yyval.val) = new_array_pattern(p, (yyvsp[-2].val), Qnone, (yyval.val), &(yyloc));
                     }
-#line 16375 "ripper.c"
+#line 16377 "ripper.c"
     break;
 
   case 523: /* p_expr_basic: "[" p_args rbracket  */
-#line 5212 "ripper.y"
+#line 5214 "ripper.y"
                   {
                         (yyval.val) = new_array_pattern(p, Qnone, Qnone, (yyvsp[-1].val), &(yyloc));
                     }
-#line 16383 "ripper.c"
+#line 16385 "ripper.c"
     break;
 
   case 524: /* p_expr_basic: "[" p_find rbracket  */
-#line 5216 "ripper.y"
+#line 5218 "ripper.y"
                   {
                         (yyval.val) = new_find_pattern(p, Qnone, (yyvsp[-1].val), &(yyloc));
                     }
-#line 16391 "ripper.c"
+#line 16393 "ripper.c"
     break;
 
   case 525: /* p_expr_basic: "[" rbracket  */
-#line 5220 "ripper.y"
+#line 5222 "ripper.y"
                   {
                         (yyval.val) = new_array_pattern_tail(p, Qnone, 0, Qnone, Qnone, &(yyloc));
                         (yyval.val) = new_array_pattern(p, Qnone, Qnone, (yyval.val), &(yyloc));
                     }
-#line 16400 "ripper.c"
+#line 16402 "ripper.c"
     break;
 
   case 526: /* $@30: %empty  */
-#line 5225 "ripper.y"
+#line 5227 "ripper.y"
                   {
                         p->ctxt.in_kwarg = 0;
                     }
-#line 16408 "ripper.c"
+#line 16410 "ripper.c"
     break;
 
   case 527: /* p_expr_basic: "{" p_pktbl lex_ctxt $@30 p_kwargs rbrace  */
-#line 5229 "ripper.y"
+#line 5231 "ripper.y"
                   {
                         pop_pktbl(p, (yyvsp[-4].tbl));
                         p->ctxt.in_kwarg = (yyvsp[-3].ctxt).in_kwarg;
                         (yyval.val) = new_hash_pattern(p, Qnone, (yyvsp[-1].val), &(yyloc));
                     }
-#line 16418 "ripper.c"
+#line 16420 "ripper.c"
     break;
 
   case 528: /* p_expr_basic: "{" rbrace  */
-#line 5235 "ripper.y"
+#line 5237 "ripper.y"
                   {
                         (yyval.val) = new_hash_pattern_tail(p, Qnone, 0, &(yyloc));
                         (yyval.val) = new_hash_pattern(p, Qnone, (yyval.val), &(yyloc));
                     }
-#line 16427 "ripper.c"
+#line 16429 "ripper.c"
     break;
 
   case 529: /* p_expr_basic: "(" p_pktbl p_expr rparen  */
-#line 5240 "ripper.y"
+#line 5242 "ripper.y"
                   {
                         pop_pktbl(p, (yyvsp[-2].tbl));
                         (yyval.val) = (yyvsp[-1].val);
                     }
-#line 16436 "ripper.c"
+#line 16438 "ripper.c"
     break;
 
   case 530: /* p_args: p_expr  */
-#line 5247 "ripper.y"
+#line 5249 "ripper.y"
                   {
 #if 0
                         NODE *pre_args = NEW_LIST((yyvsp[0].val), &(yyloc));
@@ -16445,19 +16447,19 @@ yyreduce:
                         (yyval.val) = new_array_pattern_tail(p, rb_ary_new_from_args(1, get_value((yyvsp[0].val))), 0, Qnone, Qnone, &(yyloc));
 
                     }
-#line 16449 "ripper.c"
+#line 16451 "ripper.c"
     break;
 
   case 531: /* p_args: p_args_head  */
-#line 5256 "ripper.y"
+#line 5258 "ripper.y"
                   {
                         (yyval.val) = new_array_pattern_tail(p, (yyvsp[0].val), 1, Qnone, Qnone, &(yyloc));
                     }
-#line 16457 "ripper.c"
+#line 16459 "ripper.c"
     break;
 
   case 532: /* p_args: p_args_head p_arg  */
-#line 5260 "ripper.y"
+#line 5262 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_array_pattern_tail(p, list_concat((yyvsp[-1].val), (yyvsp[0].val)), 0, Qnone, Qnone, &(yyloc));
@@ -16466,70 +16468,70 @@ yyreduce:
                         (yyval.val) = new_array_pattern_tail(p, pre_args, 0, Qnone, Qnone, &(yyloc));
 
                     }
-#line 16470 "ripper.c"
+#line 16472 "ripper.c"
     break;
 
   case 533: /* p_args: p_args_head p_rest  */
-#line 5269 "ripper.y"
+#line 5271 "ripper.y"
                   {
                         (yyval.val) = new_array_pattern_tail(p, (yyvsp[-1].val), 1, (yyvsp[0].val), Qnone, &(yyloc));
                     }
-#line 16478 "ripper.c"
+#line 16480 "ripper.c"
     break;
 
   case 534: /* p_args: p_args_head p_rest ',' p_args_post  */
-#line 5273 "ripper.y"
+#line 5275 "ripper.y"
                   {
                         (yyval.val) = new_array_pattern_tail(p, (yyvsp[-3].val), 1, (yyvsp[-2].val), (yyvsp[0].val), &(yyloc));
                     }
-#line 16486 "ripper.c"
+#line 16488 "ripper.c"
     break;
 
   case 536: /* p_args_head: p_arg ','  */
-#line 5280 "ripper.y"
+#line 5282 "ripper.y"
                   {
                         (yyval.val) = (yyvsp[-1].val);
                     }
-#line 16494 "ripper.c"
+#line 16496 "ripper.c"
     break;
 
   case 537: /* p_args_head: p_args_head p_arg ','  */
-#line 5284 "ripper.y"
+#line 5286 "ripper.y"
                   {
 #if 0
                         (yyval.val) = list_concat((yyvsp[-2].val), (yyvsp[-1].val));
 #endif
 			(yyval.val)=rb_ary_concat((yyvsp[-2].val), get_value((yyvsp[-1].val)));
                     }
-#line 16505 "ripper.c"
+#line 16507 "ripper.c"
     break;
 
   case 538: /* p_args_tail: p_rest  */
-#line 5293 "ripper.y"
+#line 5295 "ripper.y"
                   {
                         (yyval.val) = new_array_pattern_tail(p, Qnone, 1, (yyvsp[0].val), Qnone, &(yyloc));
                     }
-#line 16513 "ripper.c"
+#line 16515 "ripper.c"
     break;
 
   case 539: /* p_args_tail: p_rest ',' p_args_post  */
-#line 5297 "ripper.y"
+#line 5299 "ripper.y"
                   {
                         (yyval.val) = new_array_pattern_tail(p, Qnone, 1, (yyvsp[-2].val), (yyvsp[0].val), &(yyloc));
                     }
-#line 16521 "ripper.c"
+#line 16523 "ripper.c"
     break;
 
   case 540: /* p_find: p_rest ',' p_args_post ',' p_rest  */
-#line 5303 "ripper.y"
+#line 5305 "ripper.y"
                   {
                         (yyval.val) = new_find_pattern_tail(p, (yyvsp[-4].val), (yyvsp[-2].val), (yyvsp[0].val), &(yyloc));
                     }
-#line 16529 "ripper.c"
+#line 16531 "ripper.c"
     break;
 
   case 541: /* p_rest: "*" "local variable or method"  */
-#line 5310 "ripper.y"
+#line 5312 "ripper.y"
                   {
 #if 0
                         error_duplicate_pattern_variable(p, (yyvsp[0].val), &(yylsp[0]));
@@ -16537,93 +16539,93 @@ yyreduce:
 #endif
 			(yyval.val)=assignable(p, var_field(p, (yyvsp[0].val)));
                     }
-#line 16541 "ripper.c"
+#line 16543 "ripper.c"
     break;
 
   case 542: /* p_rest: "*"  */
-#line 5318 "ripper.y"
+#line 5320 "ripper.y"
                   {
 #if 0
                         (yyval.val) = 0;
 #endif
 			(yyval.val)=var_field(p, Qnil);
                     }
-#line 16552 "ripper.c"
+#line 16554 "ripper.c"
     break;
 
   case 544: /* p_args_post: p_args_post ',' p_arg  */
-#line 5328 "ripper.y"
+#line 5330 "ripper.y"
                   {
 #if 0
                         (yyval.val) = list_concat((yyvsp[-2].val), (yyvsp[0].val));
 #endif
 			(yyval.val)=rb_ary_concat((yyvsp[-2].val), get_value((yyvsp[0].val)));
                     }
-#line 16563 "ripper.c"
+#line 16565 "ripper.c"
     break;
 
   case 545: /* p_arg: p_expr  */
-#line 5337 "ripper.y"
+#line 5339 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_LIST((yyvsp[0].val), &(yyloc));
 #endif
 			(yyval.val)=rb_ary_new_from_args(1, get_value((yyvsp[0].val)));
                     }
-#line 16574 "ripper.c"
+#line 16576 "ripper.c"
     break;
 
   case 546: /* p_kwargs: p_kwarg ',' p_any_kwrest  */
-#line 5346 "ripper.y"
+#line 5348 "ripper.y"
                   {
                         (yyval.val) =  new_hash_pattern_tail(p, new_unique_key_hash(p, (yyvsp[-2].val), &(yyloc)), (yyvsp[0].val), &(yyloc));
                     }
-#line 16582 "ripper.c"
+#line 16584 "ripper.c"
     break;
 
   case 547: /* p_kwargs: p_kwarg  */
-#line 5350 "ripper.y"
+#line 5352 "ripper.y"
                   {
                         (yyval.val) =  new_hash_pattern_tail(p, new_unique_key_hash(p, (yyvsp[0].val), &(yyloc)), 0, &(yyloc));
                     }
-#line 16590 "ripper.c"
+#line 16592 "ripper.c"
     break;
 
   case 548: /* p_kwargs: p_kwarg ','  */
-#line 5354 "ripper.y"
+#line 5356 "ripper.y"
                   {
                         (yyval.val) =  new_hash_pattern_tail(p, new_unique_key_hash(p, (yyvsp[-1].val), &(yyloc)), 0, &(yyloc));
                     }
-#line 16598 "ripper.c"
+#line 16600 "ripper.c"
     break;
 
   case 549: /* p_kwargs: p_any_kwrest  */
-#line 5358 "ripper.y"
+#line 5360 "ripper.y"
                   {
                         (yyval.val) =  new_hash_pattern_tail(p, new_hash(p, Qnone, &(yyloc)), (yyvsp[0].val), &(yyloc));
                     }
-#line 16606 "ripper.c"
+#line 16608 "ripper.c"
     break;
 
   case 550: /* p_kwarg: p_kw  */
-#line 5364 "ripper.y"
+#line 5366 "ripper.y"
  {(yyval.val)=rb_ary_new_from_args(1, (yyvsp[0].val));}
-#line 16612 "ripper.c"
+#line 16614 "ripper.c"
     break;
 
   case 551: /* p_kwarg: p_kwarg ',' p_kw  */
-#line 5366 "ripper.y"
+#line 5368 "ripper.y"
                   {
 #if 0
                         (yyval.val) = list_concat((yyvsp[-2].val), (yyvsp[0].val));
 #endif
 			(yyval.val)=rb_ary_push((yyvsp[-2].val), (yyvsp[0].val));
                     }
-#line 16623 "ripper.c"
+#line 16625 "ripper.c"
     break;
 
   case 552: /* p_kw: p_kw_label p_expr  */
-#line 5375 "ripper.y"
+#line 5377 "ripper.y"
                   {
                         error_duplicate_pattern_key(p, get_id((yyvsp[-1].val)), &(yylsp[-1]));
 #if 0
@@ -16631,11 +16633,11 @@ yyreduce:
 #endif
 			(yyval.val)=rb_ary_new_from_args(2, get_value((yyvsp[-1].val)), get_value((yyvsp[0].val)));
                     }
-#line 16635 "ripper.c"
+#line 16637 "ripper.c"
     break;
 
   case 553: /* p_kw: p_kw_label  */
-#line 5383 "ripper.y"
+#line 5385 "ripper.y"
                   {
                         error_duplicate_pattern_key(p, get_id((yyvsp[0].val)), &(yylsp[0]));
                         if ((yyvsp[0].val) && !is_local_id(get_id((yyvsp[0].val)))) {
@@ -16647,11 +16649,11 @@ yyreduce:
 #endif
 			(yyval.val)=rb_ary_new_from_args(2, get_value(assignable(p, (yyvsp[0].val))), Qnil);
                     }
-#line 16651 "ripper.c"
+#line 16653 "ripper.c"
     break;
 
   case 555: /* p_kw_label: "string literal" string_contents tLABEL_END  */
-#line 5398 "ripper.y"
+#line 5400 "ripper.y"
                   {
                         YYLTYPE loc = code_loc_gen(&(yylsp[-2]), &(yylsp[0]));
 #if 0
@@ -16672,41 +16674,41 @@ yyreduce:
                             (yyval.val) = 0;
                         }
                     }
-#line 16676 "ripper.c"
+#line 16678 "ripper.c"
     break;
 
   case 556: /* p_kwrest: kwrest_mark "local variable or method"  */
-#line 5421 "ripper.y"
+#line 5423 "ripper.y"
                   {
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 16684 "ripper.c"
+#line 16686 "ripper.c"
     break;
 
   case 557: /* p_kwrest: kwrest_mark  */
-#line 5425 "ripper.y"
+#line 5427 "ripper.y"
                   {
                         (yyval.val) = 0;
                     }
-#line 16692 "ripper.c"
+#line 16694 "ripper.c"
     break;
 
   case 558: /* p_kwnorest: kwrest_mark "`nil'"  */
-#line 5431 "ripper.y"
+#line 5433 "ripper.y"
                   {
                         (yyval.val) = 0;
                     }
-#line 16700 "ripper.c"
+#line 16702 "ripper.c"
     break;
 
   case 560: /* p_any_kwrest: p_kwnorest  */
-#line 5437 "ripper.y"
+#line 5439 "ripper.y"
                            {(yyval.val) = ID2VAL(idNil);}
-#line 16706 "ripper.c"
+#line 16708 "ripper.c"
     break;
 
   case 562: /* p_value: p_primitive ".." p_primitive  */
-#line 5442 "ripper.y"
+#line 5444 "ripper.y"
                   {
 #if 0
                         value_expr((yyvsp[-2].val));
@@ -16715,11 +16717,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[0].val);v3=dispatch2(dot2,v1,v2);(yyval.val)=v3;}
                     }
-#line 16719 "ripper.c"
+#line 16721 "ripper.c"
     break;
 
   case 563: /* p_value: p_primitive "..." p_primitive  */
-#line 5451 "ripper.y"
+#line 5453 "ripper.y"
                   {
 #if 0
                         value_expr((yyvsp[-2].val));
@@ -16728,11 +16730,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[0].val);v3=dispatch2(dot3,v1,v2);(yyval.val)=v3;}
                     }
-#line 16732 "ripper.c"
+#line 16734 "ripper.c"
     break;
 
   case 564: /* p_value: p_primitive ".."  */
-#line 5460 "ripper.y"
+#line 5462 "ripper.y"
                   {
 #if 0
                         value_expr((yyvsp[-1].val));
@@ -16740,11 +16742,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-1].val);v2=Qnil;v3=dispatch2(dot2,v1,v2);(yyval.val)=v3;}
                     }
-#line 16744 "ripper.c"
+#line 16746 "ripper.c"
     break;
 
   case 565: /* p_value: p_primitive "..."  */
-#line 5468 "ripper.y"
+#line 5470 "ripper.y"
                   {
 #if 0
                         value_expr((yyvsp[-1].val));
@@ -16752,11 +16754,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-1].val);v2=Qnil;v3=dispatch2(dot3,v1,v2);(yyval.val)=v3;}
                     }
-#line 16756 "ripper.c"
+#line 16758 "ripper.c"
     break;
 
   case 569: /* p_value: "(.." p_primitive  */
-#line 5479 "ripper.y"
+#line 5481 "ripper.y"
                   {
 #if 0
                         value_expr((yyvsp[0].val));
@@ -16764,11 +16766,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=Qnil;v2=(yyvsp[0].val);v3=dispatch2(dot2,v1,v2);(yyval.val)=v3;}
                     }
-#line 16768 "ripper.c"
+#line 16770 "ripper.c"
     break;
 
   case 570: /* p_value: "(..." p_primitive  */
-#line 5487 "ripper.y"
+#line 5489 "ripper.y"
                   {
 #if 0
                         value_expr((yyvsp[0].val));
@@ -16776,22 +16778,22 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=Qnil;v2=(yyvsp[0].val);v3=dispatch2(dot3,v1,v2);(yyval.val)=v3;}
                     }
-#line 16780 "ripper.c"
+#line 16782 "ripper.c"
     break;
 
   case 579: /* p_primitive: keyword_variable  */
-#line 5505 "ripper.y"
+#line 5507 "ripper.y"
                   {
 #if 0
                         if (!((yyval.val) = gettable(p, (yyvsp[0].val), &(yyloc)))) (yyval.val) = NEW_ERROR(&(yyloc));
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(var_ref,v1);(yyval.val)=v2;}
                     }
-#line 16791 "ripper.c"
+#line 16793 "ripper.c"
     break;
 
   case 581: /* p_variable: "local variable or method"  */
-#line 5515 "ripper.y"
+#line 5517 "ripper.y"
                   {
 #if 0
                         error_duplicate_pattern_variable(p, (yyvsp[0].val), &(yylsp[0]));
@@ -16799,11 +16801,11 @@ yyreduce:
 #endif
 			(yyval.val)=assignable(p, var_field(p, (yyvsp[0].val)));
                     }
-#line 16803 "ripper.c"
+#line 16805 "ripper.c"
     break;
 
   case 582: /* p_var_ref: '^' "local variable or method"  */
-#line 5525 "ripper.y"
+#line 5527 "ripper.y"
                   {
 #if 0
                         NODE *n = gettable(p, (yyvsp[0].val), &(yyloc));
@@ -16814,66 +16816,66 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(var_ref,v1);(yyval.val)=v2;}
                     }
-#line 16818 "ripper.c"
+#line 16820 "ripper.c"
     break;
 
   case 583: /* p_var_ref: '^' nonlocal_var  */
-#line 5536 "ripper.y"
+#line 5538 "ripper.y"
                   {
 #if 0
                         if (!((yyval.val) = gettable(p, (yyvsp[0].val), &(yyloc)))) (yyval.val) = NEW_BEGIN(0, &(yyloc));
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(var_ref,v1);(yyval.val)=v2;}
                     }
-#line 16829 "ripper.c"
+#line 16831 "ripper.c"
     break;
 
   case 584: /* p_expr_ref: '^' "(" expr_value rparen  */
-#line 5545 "ripper.y"
+#line 5547 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_BLOCK((yyvsp[-1].val), &(yyloc));
 #endif
 			{VALUE v1,v2;v1=(yyvsp[-1].val);v2=dispatch1(begin,v1);(yyval.val)=v2;}
                     }
-#line 16840 "ripper.c"
+#line 16842 "ripper.c"
     break;
 
   case 585: /* p_const: ":: at EXPR_BEG" cname  */
-#line 5554 "ripper.y"
+#line 5556 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_COLON3((yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(top_const_ref,v1);(yyval.val)=v2;}
                     }
-#line 16851 "ripper.c"
+#line 16853 "ripper.c"
     break;
 
   case 586: /* p_const: p_const "::" cname  */
-#line 5561 "ripper.y"
+#line 5563 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_COLON2((yyvsp[-2].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[0].val);v3=dispatch2(const_path_ref,v1,v2);(yyval.val)=v3;}
                     }
-#line 16862 "ripper.c"
+#line 16864 "ripper.c"
     break;
 
   case 587: /* p_const: "constant"  */
-#line 5568 "ripper.y"
+#line 5570 "ripper.y"
                  {
 #if 0
                         (yyval.val) = gettable(p, (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(var_ref,v1);(yyval.val)=v2;}
                    }
-#line 16873 "ripper.c"
+#line 16875 "ripper.c"
     break;
 
   case 588: /* opt_rescue: k_rescue exc_list exc_var then compstmt opt_rescue  */
-#line 5579 "ripper.y"
+#line 5581 "ripper.y"
                   {
 #if 0
                         NODE *body = (yyvsp[-1].val);
@@ -16895,41 +16897,41 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4,v5;v1=(yyvsp[-4].val);v2=(yyvsp[-3].val);v3=(yyvsp[-1].val);v4=(yyvsp[0].val);v5=dispatch4(rescue,v1,v2,v3,v4);(yyval.val)=v5;}
                     }
-#line 16899 "ripper.c"
+#line 16901 "ripper.c"
     break;
 
   case 590: /* exc_list: arg_value  */
-#line 5604 "ripper.y"
+#line 5606 "ripper.y"
                   {
 #if 0
                         (yyval.val) = NEW_LIST((yyvsp[0].val), &(yyloc));
 #endif
 			(yyval.val)=rb_ary_new3(1, get_value((yyvsp[0].val)));
                     }
-#line 16910 "ripper.c"
+#line 16912 "ripper.c"
     break;
 
   case 591: /* exc_list: mrhs  */
-#line 5611 "ripper.y"
+#line 5613 "ripper.y"
                   {
 #if 0
                         if (!((yyval.val) = splat_array((yyvsp[0].val)))) (yyval.val) = (yyvsp[0].val);
 #endif
 			(yyval.val)=(yyvsp[0].val);
                     }
-#line 16921 "ripper.c"
+#line 16923 "ripper.c"
     break;
 
   case 593: /* exc_var: "=>" lhs  */
-#line 5621 "ripper.y"
+#line 5623 "ripper.y"
                   {
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 16929 "ripper.c"
+#line 16931 "ripper.c"
     break;
 
   case 595: /* opt_ensure: k_ensure compstmt  */
-#line 5628 "ripper.y"
+#line 5630 "ripper.y"
                   {
                         p->ctxt.in_rescue = (yyvsp[-1].ctxt).in_rescue;
 #if 0
@@ -16937,11 +16939,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(ensure,v1);(yyval.val)=v2;}
                     }
-#line 16941 "ripper.c"
+#line 16943 "ripper.c"
     break;
 
   case 599: /* strings: string  */
-#line 5643 "ripper.y"
+#line 5645 "ripper.y"
                   {
 #if 0
                         NODE *node = (yyvsp[0].val);
@@ -16956,22 +16958,22 @@ yyreduce:
 #endif
 			(yyval.val)=(yyvsp[0].val);
                     }
-#line 16960 "ripper.c"
+#line 16962 "ripper.c"
     break;
 
   case 602: /* string: string string1  */
-#line 5662 "ripper.y"
+#line 5664 "ripper.y"
                   {
 #if 0
                         (yyval.val) = literal_concat(p, (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-1].val);v2=(yyvsp[0].val);v3=dispatch2(string_concat,v1,v2);(yyval.val)=v3;}
                     }
-#line 16971 "ripper.c"
+#line 16973 "ripper.c"
     break;
 
   case 603: /* string1: "string literal" string_contents "terminator"  */
-#line 5671 "ripper.y"
+#line 5673 "ripper.y"
                   {
 #if 0
                         (yyval.val) = heredoc_dedent(p, (yyvsp[-1].val));
@@ -16979,185 +16981,185 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=heredoc_dedent(p, (yyvsp[-1].val));v2=dispatch1(string_literal,v1);(yyval.val)=v2;}
                     }
-#line 16983 "ripper.c"
+#line 16985 "ripper.c"
     break;
 
   case 604: /* xstring: "backtick literal" xstring_contents "terminator"  */
-#line 5681 "ripper.y"
+#line 5683 "ripper.y"
                   {
 #if 0
                         (yyval.val) = new_xstring(p, heredoc_dedent(p, (yyvsp[-1].val)), &(yyloc));
 #endif
 			{VALUE v1,v2;v1=heredoc_dedent(p, (yyvsp[-1].val));v2=dispatch1(xstring_literal,v1);(yyval.val)=v2;}
                     }
-#line 16994 "ripper.c"
+#line 16996 "ripper.c"
     break;
 
   case 605: /* regexp: "regexp literal" regexp_contents tREGEXP_END  */
-#line 5690 "ripper.y"
+#line 5692 "ripper.y"
                   {
                         (yyval.val) = new_regexp(p, (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
                     }
-#line 17002 "ripper.c"
+#line 17004 "ripper.c"
     break;
 
   case 606: /* words_sep: ' '  */
-#line 5695 "ripper.y"
+#line 5697 "ripper.y"
               {}
-#line 17008 "ripper.c"
+#line 17010 "ripper.c"
     break;
 
   case 608: /* words: "word list" words_sep word_list "terminator"  */
-#line 5700 "ripper.y"
+#line 5702 "ripper.y"
                   {
 #if 0
                         (yyval.val) = make_list((yyvsp[-1].val), &(yyloc));
 #endif
 			{VALUE v1,v2;v1=(yyvsp[-1].val);v2=dispatch1(array,v1);(yyval.val)=v2;}
                     }
-#line 17019 "ripper.c"
+#line 17021 "ripper.c"
     break;
 
   case 609: /* word_list: %empty  */
-#line 5709 "ripper.y"
+#line 5711 "ripper.y"
                   {
 #if 0
                         (yyval.val) = 0;
 #endif
 			{VALUE v1;v1=dispatch0(words_new);(yyval.val)=v1;}
                     }
-#line 17030 "ripper.c"
+#line 17032 "ripper.c"
     break;
 
   case 610: /* word_list: word_list word words_sep  */
-#line 5716 "ripper.y"
+#line 5718 "ripper.y"
                   {
 #if 0
                         (yyval.val) = list_append(p, (yyvsp[-2].val), evstr2dstr(p, (yyvsp[-1].val)));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[-1].val);v3=dispatch2(words_add,v1,v2);(yyval.val)=v3;}
                     }
-#line 17041 "ripper.c"
+#line 17043 "ripper.c"
     break;
 
   case 611: /* word: string_content  */
-#line 5725 "ripper.y"
+#line 5727 "ripper.y"
  {{VALUE v1,v2,v3,v4;v1=dispatch0(word_new);v2=v1;v3=(yyvsp[0].val);v4=dispatch2(word_add,v2,v3);(yyval.val)=v4;}}
-#line 17047 "ripper.c"
+#line 17049 "ripper.c"
     break;
 
   case 612: /* word: word string_content  */
-#line 5727 "ripper.y"
+#line 5729 "ripper.y"
                   {
 #if 0
                         (yyval.val) = literal_concat(p, (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-1].val);v2=(yyvsp[0].val);v3=dispatch2(word_add,v1,v2);(yyval.val)=v3;}
                     }
-#line 17058 "ripper.c"
+#line 17060 "ripper.c"
     break;
 
   case 613: /* symbols: "symbol list" words_sep symbol_list "terminator"  */
-#line 5736 "ripper.y"
+#line 5738 "ripper.y"
                   {
 #if 0
                         (yyval.val) = make_list((yyvsp[-1].val), &(yyloc));
 #endif
 			{VALUE v1,v2;v1=(yyvsp[-1].val);v2=dispatch1(array,v1);(yyval.val)=v2;}
                     }
-#line 17069 "ripper.c"
+#line 17071 "ripper.c"
     break;
 
   case 614: /* symbol_list: %empty  */
-#line 5745 "ripper.y"
+#line 5747 "ripper.y"
                   {
 #if 0
                         (yyval.val) = 0;
 #endif
 			{VALUE v1;v1=dispatch0(symbols_new);(yyval.val)=v1;}
                     }
-#line 17080 "ripper.c"
+#line 17082 "ripper.c"
     break;
 
   case 615: /* symbol_list: symbol_list word words_sep  */
-#line 5752 "ripper.y"
+#line 5754 "ripper.y"
                   {
 #if 0
                         (yyval.val) = symbol_append(p, (yyvsp[-2].val), evstr2dstr(p, (yyvsp[-1].val)));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[-1].val);v3=dispatch2(symbols_add,v1,v2);(yyval.val)=v3;}
                     }
-#line 17091 "ripper.c"
+#line 17093 "ripper.c"
     break;
 
   case 616: /* qwords: "verbatim word list" words_sep qword_list "terminator"  */
-#line 5761 "ripper.y"
+#line 5763 "ripper.y"
                   {
 #if 0
                         (yyval.val) = make_list((yyvsp[-1].val), &(yyloc));
 #endif
 			{VALUE v1,v2;v1=(yyvsp[-1].val);v2=dispatch1(array,v1);(yyval.val)=v2;}
                     }
-#line 17102 "ripper.c"
+#line 17104 "ripper.c"
     break;
 
   case 617: /* qsymbols: "verbatim symbol list" words_sep qsym_list "terminator"  */
-#line 5770 "ripper.y"
+#line 5772 "ripper.y"
                   {
 #if 0
                         (yyval.val) = make_list((yyvsp[-1].val), &(yyloc));
 #endif
 			{VALUE v1,v2;v1=(yyvsp[-1].val);v2=dispatch1(array,v1);(yyval.val)=v2;}
                     }
-#line 17113 "ripper.c"
+#line 17115 "ripper.c"
     break;
 
   case 618: /* qword_list: %empty  */
-#line 5779 "ripper.y"
+#line 5781 "ripper.y"
                   {
 #if 0
                         (yyval.val) = 0;
 #endif
 			{VALUE v1;v1=dispatch0(qwords_new);(yyval.val)=v1;}
                     }
-#line 17124 "ripper.c"
+#line 17126 "ripper.c"
     break;
 
   case 619: /* qword_list: qword_list "literal content" words_sep  */
-#line 5786 "ripper.y"
+#line 5788 "ripper.y"
                   {
 #if 0
                         (yyval.val) = list_append(p, (yyvsp[-2].val), (yyvsp[-1].val));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[-1].val);v3=dispatch2(qwords_add,v1,v2);(yyval.val)=v3;}
                     }
-#line 17135 "ripper.c"
+#line 17137 "ripper.c"
     break;
 
   case 620: /* qsym_list: %empty  */
-#line 5795 "ripper.y"
+#line 5797 "ripper.y"
                   {
 #if 0
                         (yyval.val) = 0;
 #endif
 			{VALUE v1;v1=dispatch0(qsymbols_new);(yyval.val)=v1;}
                     }
-#line 17146 "ripper.c"
+#line 17148 "ripper.c"
     break;
 
   case 621: /* qsym_list: qsym_list "literal content" words_sep  */
-#line 5802 "ripper.y"
+#line 5804 "ripper.y"
                   {
 #if 0
                         (yyval.val) = symbol_append(p, (yyvsp[-2].val), (yyvsp[-1].val));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[-1].val);v3=dispatch2(qsymbols_add,v1,v2);(yyval.val)=v3;}
                     }
-#line 17157 "ripper.c"
+#line 17159 "ripper.c"
     break;
 
   case 622: /* string_contents: %empty  */
-#line 5811 "ripper.y"
+#line 5813 "ripper.y"
                   {
 #if 0
                         (yyval.val) = 0;
@@ -17168,11 +17170,11 @@ yyreduce:
                         (yyval.val) = ripper_new_yylval(p, 0, (yyval.val), 0);
 
                     }
-#line 17172 "ripper.c"
+#line 17174 "ripper.c"
     break;
 
   case 623: /* string_contents: string_contents string_content  */
-#line 5822 "ripper.y"
+#line 5824 "ripper.y"
                   {
 #if 0
                         (yyval.val) = literal_concat(p, (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
@@ -17188,33 +17190,33 @@ yyreduce:
                         }
 
                     }
-#line 17192 "ripper.c"
+#line 17194 "ripper.c"
     break;
 
   case 624: /* xstring_contents: %empty  */
-#line 5840 "ripper.y"
+#line 5842 "ripper.y"
                   {
 #if 0
                         (yyval.val) = 0;
 #endif
 			{VALUE v1;v1=dispatch0(xstring_new);(yyval.val)=v1;}
                     }
-#line 17203 "ripper.c"
+#line 17205 "ripper.c"
     break;
 
   case 625: /* xstring_contents: xstring_contents string_content  */
-#line 5847 "ripper.y"
+#line 5849 "ripper.y"
                   {
 #if 0
                         (yyval.val) = literal_concat(p, (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-1].val);v2=(yyvsp[0].val);v3=dispatch2(xstring_add,v1,v2);(yyval.val)=v3;}
                     }
-#line 17214 "ripper.c"
+#line 17216 "ripper.c"
     break;
 
   case 626: /* regexp_contents: %empty  */
-#line 5856 "ripper.y"
+#line 5858 "ripper.y"
                   {
 #if 0
                         (yyval.val) = 0;
@@ -17225,11 +17227,11 @@ yyreduce:
                         (yyval.val) = ripper_new_yylval(p, 0, (yyval.val), 0);
 
                     }
-#line 17229 "ripper.c"
+#line 17231 "ripper.c"
     break;
 
   case 627: /* regexp_contents: regexp_contents string_content  */
-#line 5867 "ripper.y"
+#line 5869 "ripper.y"
                   {
 #if 0
                         NODE *head = (yyvsp[-1].val), *tail = (yyvsp[0].val);
@@ -17253,7 +17255,7 @@ yyreduce:
                             (yyval.val) = list_append(p, head, tail);
                         }
 #endif
-                        VALUE s1 = 1, s2 = 0, n1 = (yyvsp[-1].val), n2 = (yyvsp[0].val);
+                        VALUE s1 = (VALUE)1, s2 = 0, n1 = (yyvsp[-1].val), n2 = (yyvsp[0].val);
                         if (ripper_is_node_yylval(p, n1)) {
                             s1 = RNODE_RIPPER(n1)->nd_cval;
                             n1 = RNODE_RIPPER(n1)->nd_rval;
@@ -17268,28 +17270,28 @@ yyreduce:
                         }
 
                     }
-#line 17272 "ripper.c"
+#line 17274 "ripper.c"
     break;
 
   case 628: /* string_content: "literal content"  */
-#line 5908 "ripper.y"
+#line 5910 "ripper.y"
  {(yyval.val)=ripper_new_yylval(p, 0, get_value((yyvsp[0].val)), (yyvsp[0].val));}
-#line 17278 "ripper.c"
+#line 17280 "ripper.c"
     break;
 
   case 629: /* @31: %empty  */
-#line 5910 "ripper.y"
+#line 5912 "ripper.y"
                   {
                         /* need to backup p->lex.strterm so that a string literal `%&foo,#$&,bar&` can be parsed */
                         (yyval.strterm) = p->lex.strterm;
                         p->lex.strterm = 0;
                         SET_LEX_STATE(EXPR_BEG);
                     }
-#line 17289 "ripper.c"
+#line 17291 "ripper.c"
     break;
 
   case 630: /* string_content: tSTRING_DVAR @31 string_dvar  */
-#line 5917 "ripper.y"
+#line 5919 "ripper.y"
                   {
                         p->lex.strterm = (yyvsp[-1].strterm);
 #if 0
@@ -17298,11 +17300,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(string_dvar,v1);(yyval.val)=v2;}
                     }
-#line 17302 "ripper.c"
+#line 17304 "ripper.c"
     break;
 
   case 631: /* @32: %empty  */
-#line 5926 "ripper.y"
+#line 5928 "ripper.y"
                   {
                         CMDARG_PUSH(0);
                         COND_PUSH(0);
@@ -17312,29 +17314,29 @@ yyreduce:
                         (yyval.num) = p->lex.state;
                         SET_LEX_STATE(EXPR_BEG);
                     }
-#line 17316 "ripper.c"
+#line 17318 "ripper.c"
     break;
 
   case 632: /* @33: %empty  */
-#line 5935 "ripper.y"
+#line 5937 "ripper.y"
                   {
                         (yyval.num) = p->lex.brace_nest;
                         p->lex.brace_nest = 0;
                     }
-#line 17325 "ripper.c"
+#line 17327 "ripper.c"
     break;
 
   case 633: /* @34: %empty  */
-#line 5939 "ripper.y"
+#line 5941 "ripper.y"
                   {
                         (yyval.num) = p->heredoc_indent;
                         p->heredoc_indent = 0;
                     }
-#line 17334 "ripper.c"
+#line 17336 "ripper.c"
     break;
 
   case 634: /* string_content: tSTRING_DBEG @32 @33 @34 compstmt string_dend  */
-#line 5944 "ripper.y"
+#line 5946 "ripper.y"
                   {
                         COND_POP();
                         CMDARG_POP();
@@ -17349,22 +17351,22 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=(yyvsp[-1].val);v2=dispatch1(string_embexpr,v1);(yyval.val)=v2;}
                     }
-#line 17353 "ripper.c"
+#line 17355 "ripper.c"
     break;
 
   case 637: /* string_dvar: nonlocal_var  */
-#line 5965 "ripper.y"
+#line 5967 "ripper.y"
                   {
 #if 0
                         if (!((yyval.val) = gettable(p, (yyvsp[0].val), &(yyloc)))) (yyval.val) = NEW_ERROR(&(yyloc));
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(var_ref,v1);(yyval.val)=v2;}
                     }
-#line 17364 "ripper.c"
+#line 17366 "ripper.c"
     break;
 
   case 641: /* ssym: "symbol literal" sym  */
-#line 5979 "ripper.y"
+#line 5981 "ripper.y"
                   {
                         SET_LEX_STATE(EXPR_END);
 #if 0
@@ -17372,11 +17374,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4;v1=(yyvsp[0].val);v2=dispatch1(symbol,v1);v3=v2;v4=dispatch1(symbol_literal,v3);(yyval.val)=v4;}
                     }
-#line 17376 "ripper.c"
+#line 17378 "ripper.c"
     break;
 
   case 644: /* dsym: "symbol literal" string_contents "terminator"  */
-#line 5993 "ripper.y"
+#line 5995 "ripper.y"
                   {
                         SET_LEX_STATE(EXPR_END);
 #if 0
@@ -17384,11 +17386,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=(yyvsp[-1].val);v2=dispatch1(dyna_symbol,v1);(yyval.val)=v2;}
                     }
-#line 17388 "ripper.c"
+#line 17390 "ripper.c"
     break;
 
   case 646: /* numeric: tUMINUS_NUM simple_numeric  */
-#line 6004 "ripper.y"
+#line 6006 "ripper.y"
                   {
 #if 0
                         (yyval.val) = (yyvsp[0].val);
@@ -17396,53 +17398,53 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=ID2VAL(idUMinus);v2=(yyvsp[0].val);v3=dispatch2(unary,v1,v2);(yyval.val)=v3;}
                     }
-#line 17400 "ripper.c"
+#line 17402 "ripper.c"
     break;
 
   case 657: /* keyword_variable: "`nil'"  */
-#line 6029 "ripper.y"
+#line 6031 "ripper.y"
                             {(yyval.val) = KWD2EID(nil, (yyvsp[0].val));}
-#line 17406 "ripper.c"
+#line 17408 "ripper.c"
     break;
 
   case 658: /* keyword_variable: "`self'"  */
-#line 6030 "ripper.y"
+#line 6032 "ripper.y"
                              {(yyval.val) = KWD2EID(self, (yyvsp[0].val));}
-#line 17412 "ripper.c"
+#line 17414 "ripper.c"
     break;
 
   case 659: /* keyword_variable: "`true'"  */
-#line 6031 "ripper.y"
+#line 6033 "ripper.y"
                              {(yyval.val) = KWD2EID(true, (yyvsp[0].val));}
-#line 17418 "ripper.c"
+#line 17420 "ripper.c"
     break;
 
   case 660: /* keyword_variable: "`false'"  */
-#line 6032 "ripper.y"
+#line 6034 "ripper.y"
                               {(yyval.val) = KWD2EID(false, (yyvsp[0].val));}
-#line 17424 "ripper.c"
+#line 17426 "ripper.c"
     break;
 
   case 661: /* keyword_variable: "`__FILE__'"  */
-#line 6033 "ripper.y"
+#line 6035 "ripper.y"
                                 {(yyval.val) = KWD2EID(_FILE__, (yyvsp[0].val));}
-#line 17430 "ripper.c"
+#line 17432 "ripper.c"
     break;
 
   case 662: /* keyword_variable: "`__LINE__'"  */
-#line 6034 "ripper.y"
+#line 6036 "ripper.y"
                                 {(yyval.val) = KWD2EID(_LINE__, (yyvsp[0].val));}
-#line 17436 "ripper.c"
+#line 17438 "ripper.c"
     break;
 
   case 663: /* keyword_variable: "`__ENCODING__'"  */
-#line 6035 "ripper.y"
+#line 6037 "ripper.y"
                                     {(yyval.val) = KWD2EID(_ENCODING__, (yyvsp[0].val));}
-#line 17442 "ripper.c"
+#line 17444 "ripper.c"
     break;
 
   case 664: /* var_ref: user_variable  */
-#line 6039 "ripper.y"
+#line 6041 "ripper.y"
                   {
 #if 0
                         if (!((yyval.val) = gettable(p, (yyvsp[0].val), &(yyloc)))) (yyval.val) = NEW_BEGIN(0, &(yyloc));
@@ -17455,82 +17457,82 @@ yyreduce:
                         }
 
                     }
-#line 17459 "ripper.c"
+#line 17461 "ripper.c"
     break;
 
   case 665: /* var_ref: keyword_variable  */
-#line 6052 "ripper.y"
+#line 6054 "ripper.y"
                   {
 #if 0
                         if (!((yyval.val) = gettable(p, (yyvsp[0].val), &(yyloc)))) (yyval.val) = NEW_ERROR(&(yyloc));
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(var_ref,v1);(yyval.val)=v2;}
                     }
-#line 17470 "ripper.c"
+#line 17472 "ripper.c"
     break;
 
   case 666: /* var_lhs: user_variable  */
-#line 6061 "ripper.y"
+#line 6063 "ripper.y"
                   {
 #if 0
                         (yyval.val) = assignable(p, (yyvsp[0].val), 0, &(yyloc));
 #endif
 			(yyval.val)=assignable(p, var_field(p, (yyvsp[0].val)));
                     }
-#line 17481 "ripper.c"
+#line 17483 "ripper.c"
     break;
 
   case 667: /* var_lhs: keyword_variable  */
-#line 6068 "ripper.y"
+#line 6070 "ripper.y"
                   {
 #if 0
                         (yyval.val) = assignable(p, (yyvsp[0].val), 0, &(yyloc));
 #endif
 			(yyval.val)=assignable(p, var_field(p, (yyvsp[0].val)));
                     }
-#line 17492 "ripper.c"
+#line 17494 "ripper.c"
     break;
 
   case 670: /* $@35: %empty  */
-#line 6081 "ripper.y"
+#line 6083 "ripper.y"
                   {
                         SET_LEX_STATE(EXPR_BEG);
                         p->command_start = TRUE;
                     }
-#line 17501 "ripper.c"
+#line 17503 "ripper.c"
     break;
 
   case 671: /* superclass: '<' $@35 expr_value term  */
-#line 6086 "ripper.y"
+#line 6088 "ripper.y"
                   {
                         (yyval.val) = (yyvsp[-1].val);
                     }
-#line 17509 "ripper.c"
+#line 17511 "ripper.c"
     break;
 
   case 672: /* superclass: %empty  */
-#line 6090 "ripper.y"
+#line 6092 "ripper.y"
                   {
 #if 0
                         (yyval.val) = 0;
 #endif
 			(yyval.val)=Qnil;
                     }
-#line 17520 "ripper.c"
+#line 17522 "ripper.c"
     break;
 
   case 674: /* f_opt_paren_args: none  */
-#line 6100 "ripper.y"
+#line 6102 "ripper.y"
                   {
                         p->ctxt.in_argdef = 0;
                         (yyval.val) = new_args_tail(p, Qnone, Qnone, Qnone, &(yylsp[-1]));
                         (yyval.val) = new_args(p, Qnone, Qnone, Qnone, Qnone, (yyval.val), &(yylsp[-1]));
                     }
-#line 17530 "ripper.c"
+#line 17532 "ripper.c"
     break;
 
   case 675: /* f_paren_args: '(' f_args rparen  */
-#line 6108 "ripper.y"
+#line 6110 "ripper.y"
                   {
 #if 0
                         (yyval.val) = (yyvsp[-1].val);
@@ -17540,22 +17542,22 @@ yyreduce:
                         p->command_start = TRUE;
                         p->ctxt.in_argdef = 0;
                     }
-#line 17544 "ripper.c"
+#line 17546 "ripper.c"
     break;
 
   case 677: /* @36: %empty  */
-#line 6120 "ripper.y"
+#line 6122 "ripper.y"
                   {
                         (yyval.ctxt) = p->ctxt;
                         p->ctxt.in_kwarg = 1;
                         p->ctxt.in_argdef = 1;
                         SET_LEX_STATE(p->lex.state|EXPR_LABEL); /* force for args */
                     }
-#line 17555 "ripper.c"
+#line 17557 "ripper.c"
     break;
 
   case 678: /* f_arglist: @36 f_args term  */
-#line 6127 "ripper.y"
+#line 6129 "ripper.y"
                   {
                         p->ctxt.in_kwarg = (yyvsp[-2].ctxt).in_kwarg;
                         p->ctxt.in_argdef = 0;
@@ -17563,43 +17565,43 @@ yyreduce:
                         SET_LEX_STATE(EXPR_BEG);
                         p->command_start = TRUE;
                     }
-#line 17567 "ripper.c"
+#line 17569 "ripper.c"
     break;
 
   case 679: /* args_tail: f_kwarg ',' f_kwrest opt_f_block_arg  */
-#line 6137 "ripper.y"
+#line 6139 "ripper.y"
                   {
                         (yyval.val) = new_args_tail(p, (yyvsp[-3].val), (yyvsp[-1].val), (yyvsp[0].val), &(yylsp[-1]));
                     }
-#line 17575 "ripper.c"
+#line 17577 "ripper.c"
     break;
 
   case 680: /* args_tail: f_kwarg opt_f_block_arg  */
-#line 6141 "ripper.y"
+#line 6143 "ripper.y"
                   {
                         (yyval.val) = new_args_tail(p, (yyvsp[-1].val), Qnone, (yyvsp[0].val), &(yylsp[-1]));
                     }
-#line 17583 "ripper.c"
+#line 17585 "ripper.c"
     break;
 
   case 681: /* args_tail: f_any_kwrest opt_f_block_arg  */
-#line 6145 "ripper.y"
+#line 6147 "ripper.y"
                   {
                         (yyval.val) = new_args_tail(p, Qnone, (yyvsp[-1].val), (yyvsp[0].val), &(yylsp[-1]));
                     }
-#line 17591 "ripper.c"
+#line 17593 "ripper.c"
     break;
 
   case 682: /* args_tail: f_block_arg  */
-#line 6149 "ripper.y"
+#line 6151 "ripper.y"
                   {
                         (yyval.val) = new_args_tail(p, Qnone, Qnone, (yyvsp[0].val), &(yylsp[0]));
                     }
-#line 17599 "ripper.c"
+#line 17601 "ripper.c"
     break;
 
   case 683: /* args_tail: args_forward  */
-#line 6153 "ripper.y"
+#line 6155 "ripper.y"
                   {
                         add_forwarding_args(p);
                         (yyval.val) = new_args_tail(p, Qnone, (yyvsp[0].val), arg_FWD_BLOCK, &(yylsp[0]));
@@ -17607,148 +17609,148 @@ yyreduce:
                         (yyval.val)->nd_ainfo.forwarding = 1;
 #endif
                     }
-#line 17611 "ripper.c"
+#line 17613 "ripper.c"
     break;
 
   case 684: /* opt_args_tail: ',' args_tail  */
-#line 6163 "ripper.y"
+#line 6165 "ripper.y"
                   {
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 17619 "ripper.c"
+#line 17621 "ripper.c"
     break;
 
   case 685: /* opt_args_tail: %empty  */
-#line 6167 "ripper.y"
+#line 6169 "ripper.y"
                   {
                         (yyval.val) = new_args_tail(p, Qnone, Qnone, Qnone, &(yylsp[0]));
                     }
-#line 17627 "ripper.c"
+#line 17629 "ripper.c"
     break;
 
   case 686: /* f_args: f_arg ',' f_optarg ',' f_rest_arg opt_args_tail  */
-#line 6173 "ripper.y"
+#line 6175 "ripper.y"
                   {
                         (yyval.val) = new_args(p, (yyvsp[-5].val), (yyvsp[-3].val), (yyvsp[-1].val), Qnone, (yyvsp[0].val), &(yyloc));
                     }
-#line 17635 "ripper.c"
+#line 17637 "ripper.c"
     break;
 
   case 687: /* f_args: f_arg ',' f_optarg ',' f_rest_arg ',' f_arg opt_args_tail  */
-#line 6177 "ripper.y"
+#line 6179 "ripper.y"
                   {
                         (yyval.val) = new_args(p, (yyvsp[-7].val), (yyvsp[-5].val), (yyvsp[-3].val), (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
                     }
-#line 17643 "ripper.c"
+#line 17645 "ripper.c"
     break;
 
   case 688: /* f_args: f_arg ',' f_optarg opt_args_tail  */
-#line 6181 "ripper.y"
+#line 6183 "ripper.y"
                   {
                         (yyval.val) = new_args(p, (yyvsp[-3].val), (yyvsp[-1].val), Qnone, Qnone, (yyvsp[0].val), &(yyloc));
                     }
-#line 17651 "ripper.c"
+#line 17653 "ripper.c"
     break;
 
   case 689: /* f_args: f_arg ',' f_optarg ',' f_arg opt_args_tail  */
-#line 6185 "ripper.y"
+#line 6187 "ripper.y"
                   {
                         (yyval.val) = new_args(p, (yyvsp[-5].val), (yyvsp[-3].val), Qnone, (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
                     }
-#line 17659 "ripper.c"
+#line 17661 "ripper.c"
     break;
 
   case 690: /* f_args: f_arg ',' f_rest_arg opt_args_tail  */
-#line 6189 "ripper.y"
+#line 6191 "ripper.y"
                   {
                         (yyval.val) = new_args(p, (yyvsp[-3].val), Qnone, (yyvsp[-1].val), Qnone, (yyvsp[0].val), &(yyloc));
                     }
-#line 17667 "ripper.c"
+#line 17669 "ripper.c"
     break;
 
   case 691: /* f_args: f_arg ',' f_rest_arg ',' f_arg opt_args_tail  */
-#line 6193 "ripper.y"
+#line 6195 "ripper.y"
                   {
                         (yyval.val) = new_args(p, (yyvsp[-5].val), Qnone, (yyvsp[-3].val), (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
                     }
-#line 17675 "ripper.c"
+#line 17677 "ripper.c"
     break;
 
   case 692: /* f_args: f_arg opt_args_tail  */
-#line 6197 "ripper.y"
+#line 6199 "ripper.y"
                   {
                         (yyval.val) = new_args(p, (yyvsp[-1].val), Qnone, Qnone, Qnone, (yyvsp[0].val), &(yyloc));
                     }
-#line 17683 "ripper.c"
+#line 17685 "ripper.c"
     break;
 
   case 693: /* f_args: f_optarg ',' f_rest_arg opt_args_tail  */
-#line 6201 "ripper.y"
+#line 6203 "ripper.y"
                   {
                         (yyval.val) = new_args(p, Qnone, (yyvsp[-3].val), (yyvsp[-1].val), Qnone, (yyvsp[0].val), &(yyloc));
                     }
-#line 17691 "ripper.c"
+#line 17693 "ripper.c"
     break;
 
   case 694: /* f_args: f_optarg ',' f_rest_arg ',' f_arg opt_args_tail  */
-#line 6205 "ripper.y"
+#line 6207 "ripper.y"
                   {
                         (yyval.val) = new_args(p, Qnone, (yyvsp[-5].val), (yyvsp[-3].val), (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
                     }
-#line 17699 "ripper.c"
+#line 17701 "ripper.c"
     break;
 
   case 695: /* f_args: f_optarg opt_args_tail  */
-#line 6209 "ripper.y"
+#line 6211 "ripper.y"
                   {
                         (yyval.val) = new_args(p, Qnone, (yyvsp[-1].val), Qnone, Qnone, (yyvsp[0].val), &(yyloc));
                     }
-#line 17707 "ripper.c"
+#line 17709 "ripper.c"
     break;
 
   case 696: /* f_args: f_optarg ',' f_arg opt_args_tail  */
-#line 6213 "ripper.y"
+#line 6215 "ripper.y"
                   {
                         (yyval.val) = new_args(p, Qnone, (yyvsp[-3].val), Qnone, (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
                     }
-#line 17715 "ripper.c"
+#line 17717 "ripper.c"
     break;
 
   case 697: /* f_args: f_rest_arg opt_args_tail  */
-#line 6217 "ripper.y"
+#line 6219 "ripper.y"
                   {
                         (yyval.val) = new_args(p, Qnone, Qnone, (yyvsp[-1].val), Qnone, (yyvsp[0].val), &(yyloc));
                     }
-#line 17723 "ripper.c"
+#line 17725 "ripper.c"
     break;
 
   case 698: /* f_args: f_rest_arg ',' f_arg opt_args_tail  */
-#line 6221 "ripper.y"
+#line 6223 "ripper.y"
                   {
                         (yyval.val) = new_args(p, Qnone, Qnone, (yyvsp[-3].val), (yyvsp[-1].val), (yyvsp[0].val), &(yyloc));
                     }
-#line 17731 "ripper.c"
+#line 17733 "ripper.c"
     break;
 
   case 699: /* f_args: args_tail  */
-#line 6225 "ripper.y"
+#line 6227 "ripper.y"
                   {
                         (yyval.val) = new_args(p, Qnone, Qnone, Qnone, Qnone, (yyvsp[0].val), &(yyloc));
                     }
-#line 17739 "ripper.c"
+#line 17741 "ripper.c"
     break;
 
   case 700: /* f_args: %empty  */
-#line 6229 "ripper.y"
+#line 6231 "ripper.y"
                   {
                         (yyval.val) = new_args_tail(p, Qnone, Qnone, Qnone, &(yylsp[0]));
                         (yyval.val) = new_args(p, Qnone, Qnone, Qnone, Qnone, (yyval.val), &(yylsp[0]));
                     }
-#line 17748 "ripper.c"
+#line 17750 "ripper.c"
     break;
 
   case 701: /* args_forward: "(..."  */
-#line 6236 "ripper.y"
+#line 6238 "ripper.y"
                   {
 #if 0
 #ifdef FORWARD_ARGS_WITH_RUBY2_KEYWORDS
@@ -17759,11 +17761,11 @@ yyreduce:
 #endif
 			{VALUE v1;v1=dispatch0(args_forward);(yyval.val)=v1;}
                     }
-#line 17763 "ripper.c"
+#line 17765 "ripper.c"
     break;
 
   case 702: /* f_bad_arg: "constant"  */
-#line 6249 "ripper.y"
+#line 6251 "ripper.y"
                   {
                         static const char mesg[] = "formal argument cannot be a constant";
 #if 0
@@ -17772,11 +17774,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=ERR_MESG();v2=(yyvsp[0].val);v3=dispatch2(param_error,v1,v2);(yyval.val)=v3;}ripper_error(p);
                     }
-#line 17776 "ripper.c"
+#line 17778 "ripper.c"
     break;
 
   case 703: /* f_bad_arg: "instance variable"  */
-#line 6258 "ripper.y"
+#line 6260 "ripper.y"
                   {
                         static const char mesg[] = "formal argument cannot be an instance variable";
 #if 0
@@ -17785,11 +17787,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=ERR_MESG();v2=(yyvsp[0].val);v3=dispatch2(param_error,v1,v2);(yyval.val)=v3;}ripper_error(p);
                     }
-#line 17789 "ripper.c"
+#line 17791 "ripper.c"
     break;
 
   case 704: /* f_bad_arg: "global variable"  */
-#line 6267 "ripper.y"
+#line 6269 "ripper.y"
                   {
                         static const char mesg[] = "formal argument cannot be a global variable";
 #if 0
@@ -17798,11 +17800,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=ERR_MESG();v2=(yyvsp[0].val);v3=dispatch2(param_error,v1,v2);(yyval.val)=v3;}ripper_error(p);
                     }
-#line 17802 "ripper.c"
+#line 17804 "ripper.c"
     break;
 
   case 705: /* f_bad_arg: "class variable"  */
-#line 6276 "ripper.y"
+#line 6278 "ripper.y"
                   {
                         static const char mesg[] = "formal argument cannot be a class variable";
 #if 0
@@ -17811,32 +17813,32 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=ERR_MESG();v2=(yyvsp[0].val);v3=dispatch2(param_error,v1,v2);(yyval.val)=v3;}ripper_error(p);
                     }
-#line 17815 "ripper.c"
+#line 17817 "ripper.c"
     break;
 
   case 707: /* f_norm_arg: "local variable or method"  */
-#line 6288 "ripper.y"
+#line 6290 "ripper.y"
                   {
                         formal_argument(p, (yyvsp[0].val));
                         p->max_numparam = ORDINAL_PARAM;
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 17825 "ripper.c"
+#line 17827 "ripper.c"
     break;
 
   case 708: /* f_arg_asgn: f_norm_arg  */
-#line 6296 "ripper.y"
+#line 6298 "ripper.y"
                   {
                         ID id = get_id((yyvsp[0].val));
                         arg_var(p, id);
                         p->cur_arg = id;
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 17836 "ripper.c"
+#line 17838 "ripper.c"
     break;
 
   case 709: /* f_arg_item: f_arg_asgn  */
-#line 6305 "ripper.y"
+#line 6307 "ripper.y"
                   {
                         p->cur_arg = 0;
 #if 0
@@ -17844,11 +17846,11 @@ yyreduce:
 #endif
 			(yyval.val)=get_value((yyvsp[0].val));
                     }
-#line 17848 "ripper.c"
+#line 17850 "ripper.c"
     break;
 
   case 710: /* f_arg_item: "(" f_margs rparen  */
-#line 6313 "ripper.y"
+#line 6315 "ripper.y"
                   {
 #if 0
                         ID tid = internal_id(p);
@@ -17867,17 +17869,17 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=(yyvsp[-1].val);v2=dispatch1(mlhs_paren,v1);(yyval.val)=v2;}
                     }
-#line 17871 "ripper.c"
+#line 17873 "ripper.c"
     break;
 
   case 711: /* f_arg: f_arg_item  */
-#line 6334 "ripper.y"
+#line 6336 "ripper.y"
  {(yyval.val)=rb_ary_new3(1, get_value((yyvsp[0].val)));}
-#line 17877 "ripper.c"
+#line 17879 "ripper.c"
     break;
 
   case 712: /* f_arg: f_arg ',' f_arg_item  */
-#line 6336 "ripper.y"
+#line 6338 "ripper.y"
                   {
 #if 0
                         (yyval.val) = (yyvsp[-2].val);
@@ -17887,11 +17889,11 @@ yyreduce:
 #endif
 			(yyval.val)=rb_ary_push((yyvsp[-2].val), get_value((yyvsp[0].val)));
                     }
-#line 17891 "ripper.c"
+#line 17893 "ripper.c"
     break;
 
   case 713: /* f_label: "label"  */
-#line 6349 "ripper.y"
+#line 6351 "ripper.y"
                   {
                         arg_var(p, formal_argument(p, (yyvsp[0].val)));
                         p->cur_arg = get_id((yyvsp[0].val));
@@ -17899,11 +17901,11 @@ yyreduce:
                         p->ctxt.in_argdef = 0;
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 17903 "ripper.c"
+#line 17905 "ripper.c"
     break;
 
   case 714: /* f_kw: f_label arg_value  */
-#line 6359 "ripper.y"
+#line 6361 "ripper.y"
                   {
                         p->cur_arg = 0;
                         p->ctxt.in_argdef = 1;
@@ -17912,11 +17914,11 @@ yyreduce:
 #endif
 			(yyval.val)=rb_assoc_new(get_value(assignable(p, (yyvsp[-1].val))), get_value((yyvsp[0].val)));
                     }
-#line 17916 "ripper.c"
+#line 17918 "ripper.c"
     break;
 
   case 715: /* f_kw: f_label  */
-#line 6368 "ripper.y"
+#line 6370 "ripper.y"
                   {
                         p->cur_arg = 0;
                         p->ctxt.in_argdef = 1;
@@ -17925,11 +17927,11 @@ yyreduce:
 #endif
 			(yyval.val)=rb_assoc_new(get_value(assignable(p, (yyvsp[0].val))), 0);
                     }
-#line 17929 "ripper.c"
+#line 17931 "ripper.c"
     break;
 
   case 716: /* f_block_kw: f_label primary_value  */
-#line 6379 "ripper.y"
+#line 6381 "ripper.y"
                   {
                         p->ctxt.in_argdef = 1;
 #if 0
@@ -17937,11 +17939,11 @@ yyreduce:
 #endif
 			(yyval.val)=rb_assoc_new(get_value(assignable(p, (yyvsp[-1].val))), get_value((yyvsp[0].val)));
                     }
-#line 17941 "ripper.c"
+#line 17943 "ripper.c"
     break;
 
   case 717: /* f_block_kw: f_label  */
-#line 6387 "ripper.y"
+#line 6389 "ripper.y"
                   {
                         p->ctxt.in_argdef = 1;
 #if 0
@@ -17949,65 +17951,65 @@ yyreduce:
 #endif
 			(yyval.val)=rb_assoc_new(get_value(assignable(p, (yyvsp[0].val))), 0);
                     }
-#line 17953 "ripper.c"
+#line 17955 "ripper.c"
     break;
 
   case 718: /* f_block_kwarg: f_block_kw  */
-#line 6397 "ripper.y"
+#line 6399 "ripper.y"
                   {
 #if 0
                         (yyval.val) = (yyvsp[0].val);
 #endif
 			(yyval.val)=rb_ary_new3(1, get_value((yyvsp[0].val)));
                     }
-#line 17964 "ripper.c"
+#line 17966 "ripper.c"
     break;
 
   case 719: /* f_block_kwarg: f_block_kwarg ',' f_block_kw  */
-#line 6404 "ripper.y"
+#line 6406 "ripper.y"
                   {
 #if 0
                         (yyval.val) = kwd_append((yyvsp[-2].val), (yyvsp[0].val));
 #endif
 			(yyval.val)=rb_ary_push((yyvsp[-2].val), get_value((yyvsp[0].val)));
                     }
-#line 17975 "ripper.c"
+#line 17977 "ripper.c"
     break;
 
   case 720: /* f_kwarg: f_kw  */
-#line 6414 "ripper.y"
+#line 6416 "ripper.y"
                   {
 #if 0
                         (yyval.val) = (yyvsp[0].val);
 #endif
 			(yyval.val)=rb_ary_new3(1, get_value((yyvsp[0].val)));
                     }
-#line 17986 "ripper.c"
+#line 17988 "ripper.c"
     break;
 
   case 721: /* f_kwarg: f_kwarg ',' f_kw  */
-#line 6421 "ripper.y"
+#line 6423 "ripper.y"
                   {
 #if 0
                         (yyval.val) = kwd_append((yyvsp[-2].val), (yyvsp[0].val));
 #endif
 			(yyval.val)=rb_ary_push((yyvsp[-2].val), get_value((yyvsp[0].val)));
                     }
-#line 17997 "ripper.c"
+#line 17999 "ripper.c"
     break;
 
   case 724: /* f_no_kwarg: p_kwnorest  */
-#line 6434 "ripper.y"
+#line 6436 "ripper.y"
                   {
 #if 0
 #endif
 			{VALUE v1,v2;v1=Qnil;v2=dispatch1(nokw_param,v1);(yyval.val)=v2;}
                     }
-#line 18007 "ripper.c"
+#line 18009 "ripper.c"
     break;
 
   case 725: /* f_kwrest: kwrest_mark "local variable or method"  */
-#line 6442 "ripper.y"
+#line 6444 "ripper.y"
                   {
                         arg_var(p, shadowing_lvar(p, get_id((yyvsp[0].val))));
 #if 0
@@ -18015,11 +18017,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(kwrest_param,v1);(yyval.val)=v2;}
                     }
-#line 18019 "ripper.c"
+#line 18021 "ripper.c"
     break;
 
   case 726: /* f_kwrest: kwrest_mark  */
-#line 6450 "ripper.y"
+#line 6452 "ripper.y"
                   {
                         arg_var(p, idFWD_KWREST);
 #if 0
@@ -18027,11 +18029,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=Qnil;v2=dispatch1(kwrest_param,v1);(yyval.val)=v2;}
                     }
-#line 18031 "ripper.c"
+#line 18033 "ripper.c"
     break;
 
   case 727: /* f_opt: f_arg_asgn f_eq arg_value  */
-#line 6460 "ripper.y"
+#line 6462 "ripper.y"
                   {
                         p->cur_arg = 0;
                         p->ctxt.in_argdef = 1;
@@ -18040,11 +18042,11 @@ yyreduce:
 #endif
 			(yyval.val)=rb_assoc_new(get_value(assignable(p, (yyvsp[-2].val))), get_value((yyvsp[0].val)));
                     }
-#line 18044 "ripper.c"
+#line 18046 "ripper.c"
     break;
 
   case 728: /* f_block_opt: f_arg_asgn f_eq primary_value  */
-#line 6471 "ripper.y"
+#line 6473 "ripper.y"
                   {
                         p->cur_arg = 0;
                         p->ctxt.in_argdef = 1;
@@ -18053,55 +18055,55 @@ yyreduce:
 #endif
 			(yyval.val)=rb_assoc_new(get_value(assignable(p, (yyvsp[-2].val))), get_value((yyvsp[0].val)));
                     }
-#line 18057 "ripper.c"
+#line 18059 "ripper.c"
     break;
 
   case 729: /* f_block_optarg: f_block_opt  */
-#line 6482 "ripper.y"
+#line 6484 "ripper.y"
                   {
 #if 0
                         (yyval.val) = (yyvsp[0].val);
 #endif
 			(yyval.val)=rb_ary_new3(1, get_value((yyvsp[0].val)));
                     }
-#line 18068 "ripper.c"
+#line 18070 "ripper.c"
     break;
 
   case 730: /* f_block_optarg: f_block_optarg ',' f_block_opt  */
-#line 6489 "ripper.y"
+#line 6491 "ripper.y"
                   {
 #if 0
                         (yyval.val) = opt_arg_append((yyvsp[-2].val), (yyvsp[0].val));
 #endif
 			(yyval.val)=rb_ary_push((yyvsp[-2].val), get_value((yyvsp[0].val)));
                     }
-#line 18079 "ripper.c"
+#line 18081 "ripper.c"
     break;
 
   case 731: /* f_optarg: f_opt  */
-#line 6498 "ripper.y"
+#line 6500 "ripper.y"
                   {
 #if 0
                         (yyval.val) = (yyvsp[0].val);
 #endif
 			(yyval.val)=rb_ary_new3(1, get_value((yyvsp[0].val)));
                     }
-#line 18090 "ripper.c"
+#line 18092 "ripper.c"
     break;
 
   case 732: /* f_optarg: f_optarg ',' f_opt  */
-#line 6505 "ripper.y"
+#line 6507 "ripper.y"
                   {
 #if 0
                         (yyval.val) = opt_arg_append((yyvsp[-2].val), (yyvsp[0].val));
 #endif
 			(yyval.val)=rb_ary_push((yyvsp[-2].val), get_value((yyvsp[0].val)));
                     }
-#line 18101 "ripper.c"
+#line 18103 "ripper.c"
     break;
 
   case 735: /* f_rest_arg: restarg_mark "local variable or method"  */
-#line 6518 "ripper.y"
+#line 6520 "ripper.y"
                   {
                         arg_var(p, shadowing_lvar(p, get_id((yyvsp[0].val))));
 #if 0
@@ -18109,11 +18111,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(rest_param,v1);(yyval.val)=v2;}
                     }
-#line 18113 "ripper.c"
+#line 18115 "ripper.c"
     break;
 
   case 736: /* f_rest_arg: restarg_mark  */
-#line 6526 "ripper.y"
+#line 6528 "ripper.y"
                   {
                         arg_var(p, idFWD_REST);
 #if 0
@@ -18121,11 +18123,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=Qnil;v2=dispatch1(rest_param,v1);(yyval.val)=v2;}
                     }
-#line 18125 "ripper.c"
+#line 18127 "ripper.c"
     break;
 
   case 739: /* f_block_arg: blkarg_mark "local variable or method"  */
-#line 6540 "ripper.y"
+#line 6542 "ripper.y"
                   {
                         arg_var(p, shadowing_lvar(p, get_id((yyvsp[0].val))));
 #if 0
@@ -18133,11 +18135,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(blockarg,v1);(yyval.val)=v2;}
                     }
-#line 18137 "ripper.c"
+#line 18139 "ripper.c"
     break;
 
   case 740: /* f_block_arg: blkarg_mark  */
-#line 6548 "ripper.y"
+#line 6550 "ripper.y"
                   {
                         arg_var(p, idFWD_BLOCK);
 #if 0
@@ -18145,42 +18147,42 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=Qnil;v2=dispatch1(blockarg,v1);(yyval.val)=v2;}
                     }
-#line 18149 "ripper.c"
+#line 18151 "ripper.c"
     break;
 
   case 741: /* opt_f_block_arg: ',' f_block_arg  */
-#line 6558 "ripper.y"
+#line 6560 "ripper.y"
                   {
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 18157 "ripper.c"
+#line 18159 "ripper.c"
     break;
 
   case 742: /* opt_f_block_arg: none  */
-#line 6562 "ripper.y"
+#line 6564 "ripper.y"
                   {
                         (yyval.val) = Qnull;
                     }
-#line 18165 "ripper.c"
+#line 18167 "ripper.c"
     break;
 
   case 743: /* singleton: var_ref  */
-#line 6568 "ripper.y"
+#line 6570 "ripper.y"
                   {
                         value_expr((yyvsp[0].val));
                         (yyval.val) = (yyvsp[0].val);
                     }
-#line 18174 "ripper.c"
+#line 18176 "ripper.c"
     break;
 
   case 744: /* $@37: %empty  */
-#line 6572 "ripper.y"
+#line 6574 "ripper.y"
                     {SET_LEX_STATE(EXPR_BEG);}
-#line 18180 "ripper.c"
+#line 18182 "ripper.c"
     break;
 
   case 745: /* singleton: '(' $@37 expr rparen  */
-#line 6573 "ripper.y"
+#line 6575 "ripper.y"
                   {
 #if 0
                         NODE *expr = last_expr_node((yyvsp[-1].val));
@@ -18204,28 +18206,28 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=(yyvsp[-1].val);v2=dispatch1(paren,v1);(yyval.val)=v2;}
                     }
-#line 18208 "ripper.c"
+#line 18210 "ripper.c"
     break;
 
   case 747: /* assoc_list: assocs trailer  */
-#line 6600 "ripper.y"
+#line 6602 "ripper.y"
                   {
 #if 0
                         (yyval.val) = (yyvsp[-1].val);
 #endif
 			{VALUE v1,v2;v1=(yyvsp[-1].val);v2=dispatch1(assoclist_from_args,v1);(yyval.val)=v2;}
                     }
-#line 18219 "ripper.c"
+#line 18221 "ripper.c"
     break;
 
   case 748: /* assocs: assoc  */
-#line 6609 "ripper.y"
+#line 6611 "ripper.y"
  {(yyval.val)=rb_ary_new3(1, get_value((yyvsp[0].val)));}
-#line 18225 "ripper.c"
+#line 18227 "ripper.c"
     break;
 
   case 749: /* assocs: assocs ',' assoc  */
-#line 6611 "ripper.y"
+#line 6613 "ripper.y"
                   {
 #if 0
                         NODE *assocs = (yyvsp[-2].val);
@@ -18246,11 +18248,11 @@ yyreduce:
 #endif
 			(yyval.val)=rb_ary_push((yyvsp[-2].val), get_value((yyvsp[0].val)));
                     }
-#line 18250 "ripper.c"
+#line 18252 "ripper.c"
     break;
 
   case 750: /* assoc: arg_value "=>" arg_value  */
-#line 6634 "ripper.y"
+#line 6636 "ripper.y"
                   {
 #if 0
                         if (nd_type_p((yyvsp[-2].val), NODE_STR)) {
@@ -18261,22 +18263,22 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-2].val);v2=(yyvsp[0].val);v3=dispatch2(assoc_new,v1,v2);(yyval.val)=v3;}
                     }
-#line 18265 "ripper.c"
+#line 18267 "ripper.c"
     break;
 
   case 751: /* assoc: "label" arg_value  */
-#line 6645 "ripper.y"
+#line 6647 "ripper.y"
                   {
 #if 0
                         (yyval.val) = list_append(p, NEW_LIST(NEW_LIT(ID2SYM((yyvsp[-1].val)), &(yylsp[-1])), &(yyloc)), (yyvsp[0].val));
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[-1].val);v2=(yyvsp[0].val);v3=dispatch2(assoc_new,v1,v2);(yyval.val)=v3;}
                     }
-#line 18276 "ripper.c"
+#line 18278 "ripper.c"
     break;
 
   case 752: /* assoc: "label"  */
-#line 6652 "ripper.y"
+#line 6654 "ripper.y"
                   {
 #if 0
                         NODE *val = gettable(p, (yyvsp[0].val), &(yyloc));
@@ -18285,11 +18287,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3;v1=(yyvsp[0].val);v2=Qnil;v3=dispatch2(assoc_new,v1,v2);(yyval.val)=v3;}
                     }
-#line 18289 "ripper.c"
+#line 18291 "ripper.c"
     break;
 
   case 753: /* assoc: "string literal" string_contents tLABEL_END arg_value  */
-#line 6661 "ripper.y"
+#line 6663 "ripper.y"
                   {
 #if 0
                         YYLTYPE loc = code_loc_gen(&(yylsp[-3]), &(yylsp[-1]));
@@ -18297,11 +18299,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2,v3,v4,v5;v1=(yyvsp[-2].val);v2=dispatch1(dyna_symbol,v1);v3=v2;v4=(yyvsp[0].val);v5=dispatch2(assoc_new,v3,v4);(yyval.val)=v5;}
                     }
-#line 18301 "ripper.c"
+#line 18303 "ripper.c"
     break;
 
   case 754: /* assoc: "**arg" arg_value  */
-#line 6669 "ripper.y"
+#line 6671 "ripper.y"
                   {
 #if 0
                         if (nd_type_p((yyvsp[0].val), NODE_HASH) &&
@@ -18318,11 +18320,11 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=(yyvsp[0].val);v2=dispatch1(assoc_splat,v1);(yyval.val)=v2;}
                     }
-#line 18322 "ripper.c"
+#line 18324 "ripper.c"
     break;
 
   case 755: /* assoc: "**arg"  */
-#line 6686 "ripper.y"
+#line 6688 "ripper.y"
                   {
                         forwarding_arg_check(p, idFWD_KWREST, idFWD_ALL, "keyword rest");
 #if 0
@@ -18331,40 +18333,40 @@ yyreduce:
 #endif
 			{VALUE v1,v2;v1=Qnil;v2=dispatch1(assoc_splat,v1);(yyval.val)=v2;}
                     }
-#line 18335 "ripper.c"
+#line 18337 "ripper.c"
     break;
 
   case 779: /* term: ';'  */
-#line 6743 "ripper.y"
+#line 6745 "ripper.y"
           {yyerrok;token_flush(p);}
-#line 18341 "ripper.c"
+#line 18343 "ripper.c"
     break;
 
   case 780: /* term: '\n'  */
-#line 6745 "ripper.y"
+#line 6747 "ripper.y"
                   {
                         (yyloc).end_pos = (yyloc).beg_pos;
                         token_flush(p);
                     }
-#line 18350 "ripper.c"
+#line 18352 "ripper.c"
     break;
 
   case 782: /* terms: terms ';'  */
-#line 6752 "ripper.y"
+#line 6754 "ripper.y"
                           {yyerrok;}
-#line 18356 "ripper.c"
+#line 18358 "ripper.c"
     break;
 
   case 783: /* none: %empty  */
-#line 6756 "ripper.y"
+#line 6758 "ripper.y"
                   {
                         (yyval.val) = Qnull;
                     }
-#line 18364 "ripper.c"
+#line 18366 "ripper.c"
     break;
 
 
-#line 18368 "ripper.c"
+#line 18370 "ripper.c"
 
       default: break;
     }
@@ -18593,7 +18595,7 @@ yyreturnlab:
   return yyresult;
 }
 
-#line 6760 "ripper.y"
+#line 6762 "ripper.y"
 
 # undef p
 # undef yylex
@@ -19250,7 +19252,7 @@ yycompile0(VALUE arg)
     }
     p->ast->body.root = tree;
     if (!p->ast->body.script_lines) p->ast->body.script_lines = INT2FIX(p->line_count);
-    return TRUE;
+    return (VALUE)TRUE;
 }
 
 static rb_ast_t *
@@ -21033,7 +21035,7 @@ formal_argument(struct parser_params *p, VALUE lhs)
 #undef ERR
     }
     shadowing_lvar(p, id);
-    return lhs;
+    return (ID)lhs;
 }
 
 static int
@@ -26493,7 +26495,7 @@ error_duplicate_pattern_variable(struct parser_params *p, ID id, const YYLTYPE *
     if (is_private_local_id(p, id)) {
         return;
     }
-    if (st_is_member(p->pvtbl, id)) {
+    if (st_is_member(p->pvtbl, (st_data_t)id)) {
         yyerror1(loc, "duplicated variable name");
     }
     else {
@@ -26502,12 +26504,12 @@ error_duplicate_pattern_variable(struct parser_params *p, ID id, const YYLTYPE *
 }
 
 static void
-error_duplicate_pattern_key(struct parser_params *p, VALUE key, const YYLTYPE *loc)
+error_duplicate_pattern_key(struct parser_params *p, ID key, const YYLTYPE *loc)
 {
     if (!p->pktbl) {
         p->pktbl = st_init_numtable();
     }
-    else if (st_is_member(p->pktbl, key)) {
+    else if (st_is_member(p->pktbl, (st_data_t)key)) {
         yyerror1(loc, "duplicated key name");
         return;
     }
diff --git a/ext/ripper/ripper.y b/ext/ripper/ripper.y
index b79f1dee4104..bd33962761c8 100644
--- a/ext/ripper/ripper.y
+++ b/ext/ripper/ripper.y
@@ -350,7 +350,7 @@ RBIMPL_WARNING_POP()
     parser_set_lex_state(p, ls, __LINE__)
 static inline enum lex_state_e parser_set_lex_state(struct parser_params *p, enum lex_state_e ls, int line);
 
-typedef VALUE stack_type;
+typedef uintptr_t stack_type;
 
 static const rb_code_location_t NULL_LOC = { {0, -1}, {0, -1} };
 
@@ -1457,6 +1457,7 @@ void ripper_error(struct parser_params *p);
 
 #define yyparse ripper_yyparse
 
+#define THINGY(tok) ((VALUE)(tok))
 #define ID2VAL(id) STATIC_ID2SYM(id)
 #define TOKEN2VAL(t) ID2VAL(TOKEN2ID(t))
 #define KWD2EID(t, v) ripper_new_yylval(p, keyword_##t, get_value(v), 0)
@@ -1502,7 +1503,7 @@ new_array_pattern(struct parser_params *p, VALUE constant, VALUE pre_arg, VALUE
 }
 
 static VALUE
-new_array_pattern_tail(struct parser_params *p, VALUE pre_args, VALUE has_rest, VALUE rest_arg, VALUE post_args, const YYLTYPE *loc)
+new_array_pattern_tail(struct parser_params *p, VALUE pre_args, int has_rest, VALUE rest_arg, VALUE post_args, const YYLTYPE *loc)
 {
     return ripper_new_yylval2(p, pre_args, rest_arg, post_args);
 }
@@ -1555,6 +1556,7 @@ new_hash_pattern_tail(struct parser_params *p, VALUE kw_args, VALUE kw_rest_arg,
 static VALUE heredoc_dedent(struct parser_params*,VALUE);
 
 #else
+#define THINGY(tok) (tok)
 #define ID2VAL(id) (id)
 #define TOKEN2VAL(t) ID2VAL(t)
 #define KWD2EID(t, v) keyword_##t
@@ -3032,7 +3034,7 @@ mlhs_node	: user_variable
                     }
                 | primary_value call_op tIDENTIFIER
                     {
-                        anddot_multiple_assignment_check(p, &@2, $2);
+                        anddot_multiple_assignment_check(p, &@2, (ID)$2);
 #if 0
                         $$ = attrset(p, $1, $2, $3, &@$);
 #endif
@@ -3047,7 +3049,7 @@ mlhs_node	: user_variable
                     }
                 | primary_value call_op tCONSTANT
                     {
-                        anddot_multiple_assignment_check(p, &@2, $2);
+                        anddot_multiple_assignment_check(p, &@2, (ID)$2);
 #if 0
                         $$ = attrset(p, $1, $2, $3, &@$);
 #endif
@@ -3535,10 +3537,10 @@ endless_arg	: arg %prec modifier_rescue
                     }
                 ;
 
-relop		: '>'  {$$ = '>';}
-                | '<'  {$$ = '<';}
-                | tGEQ {$$ = idGE;}
-                | tLEQ {$$ = idLE;}
+relop		: '>'  {$$ = THINGY('>');}
+                | '<'  {$$ = THINGY('<');}
+                | tGEQ {$$ = THINGY(idGE);}
+                | tLEQ {$$ = THINGY(idLE);}
                 ;
 
 rel_expr	: arg relop arg   %prec '>'
@@ -3547,7 +3549,7 @@ rel_expr	: arg relop arg   %prec '>'
                     }
                 | rel_expr relop arg   %prec '>'
                     {
-                        rb_warning1("comparison '%s' after comparison", WARN_ID($2));
+                        rb_warning1("comparison '%s' after comparison", WARN_ID((ID)$2));
                         $$ = call_bin_op(p, $1, $2, $3, &@2, &@$);
                     }
                 ;
@@ -5887,7 +5889,7 @@ regexp_contents: /* none */
                             $$ = list_append(p, head, tail);
                         }
 #endif
-                        VALUE s1 = 1, s2 = 0, n1 = $1, n2 = $2;
+                        VALUE s1 = (VALUE)1, s2 = 0, n1 = $1, n2 = $2;
                         if (ripper_is_node_yylval(p, n1)) {
                             s1 = RNODE_RIPPER(n1)->nd_cval;
                             n1 = RNODE_RIPPER(n1)->nd_rval;
@@ -7413,7 +7415,7 @@ yycompile0(VALUE arg)
     }
     p->ast->body.root = tree;
     if (!p->ast->body.script_lines) p->ast->body.script_lines = INT2FIX(p->line_count);
-    return TRUE;
+    return (VALUE)TRUE;
 }
 
 static rb_ast_t *
@@ -9196,7 +9198,7 @@ formal_argument(struct parser_params *p, VALUE lhs)
 #undef ERR
     }
     shadowing_lvar(p, id);
-    return lhs;
+    return (ID)lhs;
 }
 
 static int
@@ -14656,7 +14658,7 @@ error_duplicate_pattern_variable(struct parser_params *p, ID id, const YYLTYPE *
     if (is_private_local_id(p, id)) {
         return;
     }
-    if (st_is_member(p->pvtbl, id)) {
+    if (st_is_member(p->pvtbl, (st_data_t)id)) {
         yyerror1(loc, "duplicated variable name");
     }
     else {
@@ -14665,12 +14667,12 @@ error_duplicate_pattern_variable(struct parser_params *p, ID id, const YYLTYPE *
 }
 
 static void
-error_duplicate_pattern_key(struct parser_params *p, VALUE key, const YYLTYPE *loc)
+error_duplicate_pattern_key(struct parser_params *p, ID key, const YYLTYPE *loc)
 {
     if (!p->pktbl) {
         p->pktbl = st_init_numtable();
     }
-    else if (st_is_member(p->pktbl, key)) {
+    else if (st_is_member(p->pktbl, (st_data_t)key)) {
         yyerror1(loc, "duplicated key name");
         return;
     }
diff --git a/ext/socket/ipsocket.c b/ext/socket/ipsocket.c
index 0c1362025846..6cb16b7b1293 100644
--- a/ext/socket/ipsocket.c
+++ b/ext/socket/ipsocket.c
@@ -196,10 +196,10 @@ rsock_revlookup_flag(VALUE revlookup, int *norevlookup)
 #define return_norevlookup(x) {*norevlookup = (x); return 1;}
     ID id;
 
-    switch (revlookup) {
-      case Qtrue:  return_norevlookup(0);
-      case Qfalse: return_norevlookup(1);
-      case Qnil: break;
+    switch ((uintptr_t)revlookup) {
+      case (uintptr_t)Qtrue:  return_norevlookup(0);
+      case (uintptr_t)Qfalse: return_norevlookup(1);
+      case (uintptr_t)Qnil: break;
       default:
         Check_Type(revlookup, T_SYMBOL);
         id = SYM2ID(revlookup);
diff --git a/ext/socket/unixsocket.c b/ext/socket/unixsocket.c
index a8475e3e6090..1ee6830b232f 100644
--- a/ext/socket/unixsocket.c
+++ b/ext/socket/unixsocket.c
@@ -212,7 +212,7 @@ static VALUE
 sendmsg_blocking(void *data)
 {
     struct iomsg_arg *arg = data;
-    return sendmsg(arg->fd, &arg->msg, 0);
+    return (VALUE)sendmsg(arg->fd, &arg->msg, 0);
 }
 
 /*
@@ -305,7 +305,7 @@ recvmsg_blocking(void *data)
 {
     struct iomsg_arg *arg = data;
     int flags = 0;
-    return rsock_recvmsg(arg->fd, &arg->msg, flags);
+    return (VALUE)rsock_recvmsg(arg->fd, &arg->msg, flags);
 }
 
 /*
diff --git a/gc.c b/gc.c
index 0346812f42bb..6959f9725c42 100644
--- a/gc.c
+++ b/gc.c
@@ -338,6 +338,2074 @@ size_mul_add_mul_or_raise(size_t x, size_t y, size_t z, size_t w, VALUE exc)
     }
 }
 
+#define nomem_error GET_VM()->special_exceptions[ruby_error_nomemory]
+
+size_t rb_iseq_memsize(const rb_iseq_t *iseq);
+
+typedef int each_obj_callback(void *, void *, size_t, void *);
+
+#define UNEXPECTED_NODE(func) \
+    rb_bug(#func"(): GC does not handle T_NODE 0x%x(%p) 0x%"PRIxVALUE, \
+           BUILTIN_TYPE(obj), (void*)(obj), RBASIC(obj)->flags)
+
+struct gc_raise_tag {
+    VALUE exc;
+    const char *fmt;
+    va_list *ap;
+};
+
+NORETURN(static void *gc_vraise(void *ptr));
+NORETURN(static void gc_raise(VALUE exc, const char *fmt, ...));
+
+static void *
+gc_vraise(void *ptr)
+{
+    struct gc_raise_tag *argv = ptr;
+    rb_vraise(argv->exc, argv->fmt, *argv->ap);
+    UNREACHABLE_RETURN(NULL);
+}
+
+static void
+gc_raise(VALUE exc, const char *fmt, ...)
+{
+    va_list ap;
+    va_start(ap, fmt);
+    struct gc_raise_tag argv = {
+        exc, fmt, &ap,
+    };
+
+    if (ruby_thread_has_gvl_p()) {
+        gc_vraise(&argv);
+        UNREACHABLE;
+    }
+    else if (ruby_native_thread_p()) {
+        rb_thread_call_with_gvl(gc_vraise, &argv);
+        UNREACHABLE;
+    }
+    else {
+        /* Not in a ruby thread */
+        fprintf(stderr, "%s", "[FATAL] ");
+        vfprintf(stderr, fmt, ap);
+    }
+
+    va_end(ap);
+    abort();
+}
+
+VALUE rb_mGC;
+int ruby_disable_gc = 0;
+
+#define CEILDIV(i, mod) roomof(i, mod)
+
+static void gc_finalize_deferred(void *dmy);
+
+static VALUE
+run_single_final(VALUE cmd, VALUE objid)
+{
+    return rb_check_funcall(cmd, idCall, 1, &objid);
+}
+
+static void
+warn_exception_in_finalizer(rb_execution_context_t *ec, VALUE final)
+{
+    if (!UNDEF_P(final) && !NIL_P(ruby_verbose)) {
+        VALUE errinfo = ec->errinfo;
+        rb_warn("Exception in finalizer %+"PRIsVALUE, final);
+        rb_ec_error_print(ec, errinfo);
+    }
+}
+
+static void
+run_finalizer(VALUE obj, VALUE table)
+{
+    long i;
+    enum ruby_tag_type state;
+    volatile struct {
+        VALUE errinfo;
+        VALUE objid;
+        VALUE final;
+        rb_control_frame_t *cfp;
+        VALUE *sp;
+        long finished;
+    } saved;
+
+    rb_execution_context_t * volatile ec = GET_EC();
+#define RESTORE_FINALIZER() (\
+        ec->cfp = saved.cfp, \
+        ec->cfp->sp = saved.sp, \
+        ec->errinfo = saved.errinfo)
+
+    saved.errinfo = ec->errinfo;
+    saved.objid = rb_obj_id(obj);
+    saved.cfp = ec->cfp;
+    saved.sp = ec->cfp->sp;
+    saved.finished = 0;
+    saved.final = Qundef;
+
+    EC_PUSH_TAG(ec);
+    state = EC_EXEC_TAG();
+    if (state != TAG_NONE) {
+        ++saved.finished;	/* skip failed finalizer */
+        warn_exception_in_finalizer(ec, ATOMIC_VALUE_EXCHANGE(saved.final, Qundef));
+    }
+    for (i = saved.finished;
+         RESTORE_FINALIZER(), i<RARRAY_LEN(table);
+         saved.finished = ++i) {
+        run_single_final(saved.final = RARRAY_AREF(table, i), saved.objid);
+    }
+    EC_POP_TAG();
+#undef RESTORE_FINALIZER
+}
+
+#ifdef __FILC__
+
+/* FIXME: I started out writing this chunk thinking that I'd just replace some simple API with calls
+   to malloc. But then I learned that the GC also provides functionality that isn't about GC itself,
+   like telling you the sizes of objects. So, I ended up copy-pasting a decent amount of code from the
+   !defined(__FILC__) case into here.
+
+   That kinda sucks but then again, maybe it's not even as bad as the rest of the carnage I have done
+   to Ruby. */
+
+typedef struct RVALUE {
+    union {
+        struct RBasic  basic;
+        struct RObject object;
+        struct RClass  klass;
+        struct RFloat  flonum;
+        struct RString string;
+        struct RArray  array;
+        struct RRegexp regexp;
+        struct RHash   hash;
+        struct RData   data;
+        struct RTypedData   typeddata;
+        struct RStruct rstruct;
+        struct RBignum bignum;
+        struct RFile   file;
+        struct RMatch  match;
+        struct RRational rational;
+        struct RComplex complex;
+        struct RSymbol symbol;
+        union {
+            rb_cref_t cref;
+            struct vm_svar svar;
+            struct vm_throw_data throw_data;
+            struct vm_ifunc ifunc;
+            struct MEMO memo;
+            struct rb_method_entry_struct ment;
+            const rb_iseq_t iseq;
+            rb_env_t env;
+            struct rb_imemo_tmpbuf_struct alloc;
+            rb_ast_t ast;
+        } imemo;
+        struct {
+            struct RBasic basic;
+            VALUE v1;
+            VALUE v2;
+            VALUE v3;
+        } values;
+    } as;
+} RVALUE;
+
+#define RANY(o) ((RVALUE*)(o))
+
+struct rb_objspace {
+    zweak_map *finalizer_table;
+    zgc_finq *finalizer_queue;
+    rb_postponed_job_handle_t finalize_deferred_pjob;
+    rb_atomic_t finalizing;
+    zgc_cycle_number completed_cycle;
+};
+
+#define get_objspace (*get_objspace_of(GET_VM()))
+#define get_objspace_of(vm) ((vm)->objspace)
+
+struct rb_objspace *
+rb_objspace_alloc(void)
+{
+    struct rb_objspace *result = malloc(sizeof(struct rb_objspace));
+    result->finalizer_table = zweak_map_new();
+    result->finalizer_queue = zgc_finq_new();
+    result->finalize_deferred_pjob = rb_postponed_job_preregister(0, gc_finalize_deferred, result);
+    if (result->finalize_deferred_pjob == POSTPONED_JOB_HANDLE_INVALID) {
+        rb_bug("Could not preregister postponed job for GC");
+    }
+    return result;
+}
+
+void
+rb_objspace_free(struct rb_objspace *objspace)
+{
+    free(objspace);
+}
+
+void
+rb_objspace_set_event_hook(const rb_event_flag_t event)
+{
+}
+
+size_t
+rb_size_pool_slot_size(unsigned char pool_id)
+{
+    ZASSERT(pool_id < SIZE_POOL_COUNT);
+
+    return (1 << pool_id) * sizeof(RVALUE);
+}
+
+bool
+rb_gc_size_allocatable_p(size_t size)
+{
+    return size <= rb_size_pool_slot_size(SIZE_POOL_COUNT - 1);
+}
+
+struct finalizer_box {
+    VALUE object;
+    VALUE table;
+    bool is_file;
+};
+
+static inline VALUE newobj(VALUE klass, uintptr_t flags, VALUE v1, VALUE v2, VALUE v3, size_t size)
+{
+    struct rb_objspace *objspace = &get_objspace;
+    zgc_cycle_number completed_cycle = zgc_completed_cycle();
+    if (completed_cycle != objspace->completed_cycle) {
+        objspace->completed_cycle = completed_cycle;
+        rb_postponed_job_trigger(objspace->finalize_deferred_pjob);
+    }
+    RVALUE *p = malloc(CEILDIV(size, sizeof(RVALUE)) * sizeof(RVALUE));
+    if ((flags & T_MASK) == T_FILE) {
+        struct finalizer_box *box = zgc_finq_alloc(objspace->finalizer_queue,
+                                                   sizeof(struct finalizer_box));
+        box->object = (VALUE)p;
+        box->is_file = true;
+        zweak_map_set(objspace->finalizer_table, p, box);
+    }
+    p->as.basic.flags = flags;
+    *(VALUE*)&p->as.basic.klass = klass;
+    p->as.values.v1 = v1;
+    p->as.values.v2 = v2;
+    p->as.values.v3 = v3;
+    return (VALUE)p;
+}
+
+VALUE
+rb_wb_unprotected_newobj_of(VALUE klass, uintptr_t flags, size_t size)
+{
+    return newobj(klass, flags, 0, 0, 0, size);
+}
+
+VALUE
+rb_wb_protected_newobj_of(rb_execution_context_t *ec, VALUE klass, uintptr_t flags, size_t size)
+{
+    return newobj(klass, flags, 0, 0, 0, size);
+}
+
+VALUE
+rb_newobj(void)
+{
+    return newobj(0, T_NONE, 0, 0, 0, RVALUE_SIZE);
+}
+
+static VALUE
+rb_class_instance_allocate_internal(VALUE klass, uintptr_t flags)
+{
+    ZASSERT((flags & RUBY_T_MASK) == T_OBJECT);
+    ZASSERT(flags & ROBJECT_EMBED);
+
+    size_t size;
+    uint32_t index_tbl_num_entries = RCLASS_EXT(klass)->max_iv_count;
+
+    size = rb_obj_embedded_size(index_tbl_num_entries);
+    if (!rb_gc_size_allocatable_p(size)) {
+        size = sizeof(struct RObject);
+    }
+
+    VALUE obj = newobj(klass, flags, 0, 0, 0, size);
+    RUBY_ASSERT(rb_shape_get_shape(obj)->type == SHAPE_ROOT);
+
+    // Set the shape to the specific T_OBJECT shape which is always
+    // SIZE_POOL_COUNT away from the root shape.
+    ROBJECT_SET_SHAPE_ID(obj, ROBJECT_SHAPE_ID(obj) + SIZE_POOL_COUNT);
+
+    return obj;
+}
+
+VALUE
+rb_newobj_of(VALUE klass, uintptr_t flags)
+{
+    if ((flags & RUBY_T_MASK) == T_OBJECT) {
+        return rb_class_instance_allocate_internal(klass, (flags | ROBJECT_EMBED) & ~FL_WB_PROTECTED);
+    }
+    else {
+        return newobj(klass, flags & ~FL_WB_PROTECTED, 0, 0, 0, sizeof(RVALUE));
+    }
+}
+
+const char *
+rb_imemo_name(enum imemo_type type)
+{
+    // put no default case to get a warning if an imemo type is missing
+    switch (type) {
+#define IMEMO_NAME(x) case imemo_##x: return #x;
+        IMEMO_NAME(env);
+        IMEMO_NAME(cref);
+        IMEMO_NAME(svar);
+        IMEMO_NAME(throw_data);
+        IMEMO_NAME(ifunc);
+        IMEMO_NAME(memo);
+        IMEMO_NAME(ment);
+        IMEMO_NAME(iseq);
+        IMEMO_NAME(tmpbuf);
+        IMEMO_NAME(ast);
+        IMEMO_NAME(parser_strterm);
+        IMEMO_NAME(callinfo);
+        IMEMO_NAME(callcache);
+        IMEMO_NAME(constcache);
+#undef IMEMO_NAME
+    }
+    return "unknown";
+}
+
+VALUE
+rb_imemo_new(enum imemo_type type, VALUE v1, VALUE v2, VALUE v3, VALUE v0)
+{
+    size_t size = sizeof(RVALUE);
+    uintptr_t flags = T_IMEMO | (type << FL_USHIFT);
+    return newobj(v0, flags, v1, v2, v3, size);
+}
+
+static VALUE
+rb_imemo_tmpbuf_new(VALUE v1, VALUE v2, VALUE v3, VALUE v0)
+{
+    size_t size = sizeof(struct rb_imemo_tmpbuf_struct);
+    uintptr_t flags = T_IMEMO | (imemo_tmpbuf << FL_USHIFT);
+    return newobj(v0, flags, v1, v2, v3, size);
+}
+
+static VALUE
+rb_imemo_tmpbuf_auto_free_maybe_mark_buffer(void *buf, size_t cnt)
+{
+    return rb_imemo_tmpbuf_new((VALUE)buf, 0, (VALUE)cnt, 0);
+}
+
+rb_imemo_tmpbuf_t *
+rb_imemo_tmpbuf_parser_heap(void *buf, rb_imemo_tmpbuf_t *old_heap, size_t cnt)
+{
+    return (rb_imemo_tmpbuf_t *)rb_imemo_tmpbuf_new((VALUE)buf, (VALUE)old_heap, (VALUE)cnt, 0);
+}
+
+static size_t
+imemo_memsize(VALUE obj)
+{
+    size_t size = 0;
+    switch (imemo_type(obj)) {
+      case imemo_ment:
+        size += sizeof(RANY(obj)->as.imemo.ment.def);
+        break;
+      case imemo_iseq:
+        size += rb_iseq_memsize((rb_iseq_t *)obj);
+        break;
+      case imemo_env:
+        size += RANY(obj)->as.imemo.env.env_size * sizeof(VALUE);
+        break;
+      case imemo_tmpbuf:
+        size += RANY(obj)->as.imemo.alloc.cnt * sizeof(VALUE);
+        break;
+      case imemo_ast:
+        size += rb_ast_memsize(&RANY(obj)->as.imemo.ast);
+        break;
+      case imemo_cref:
+      case imemo_svar:
+      case imemo_throw_data:
+      case imemo_ifunc:
+      case imemo_memo:
+      case imemo_parser_strterm:
+        break;
+      default:
+        /* unreachable */
+        break;
+    }
+    return size;
+}
+
+VALUE
+rb_class_allocate_instance(VALUE klass)
+{
+    return rb_class_instance_allocate_internal(klass, T_OBJECT | ROBJECT_EMBED);
+}
+
+static inline void
+rb_data_object_check(VALUE klass)
+{
+    if (klass != rb_cObject && (rb_get_alloc_func(klass) == rb_class_allocate_instance)) {
+        rb_undef_alloc_func(klass);
+        rb_warn("undefining the allocator of T_DATA class %"PRIsVALUE, klass);
+    }
+}
+
+VALUE
+rb_data_object_wrap(VALUE klass, void *datap, RUBY_DATA_FUNC dmark, RUBY_DATA_FUNC dfree)
+{
+    RUBY_ASSERT_ALWAYS(dfree != (RUBY_DATA_FUNC)1);
+    if (klass) rb_data_object_check(klass);
+    return newobj(klass, T_DATA, (VALUE)dmark, (VALUE)dfree, (VALUE)datap, sizeof(struct RTypedData));
+}
+
+VALUE
+rb_data_object_zalloc(VALUE klass, size_t size, RUBY_DATA_FUNC dmark, RUBY_DATA_FUNC dfree)
+{
+    VALUE obj = rb_data_object_wrap(klass, 0, dmark, dfree);
+    DATA_PTR(obj) = xcalloc(1, size);
+    return obj;
+}
+
+static VALUE
+typed_data_alloc(VALUE klass, uintptr_t typed_flag, void *datap, const rb_data_type_t *type, size_t size)
+{
+    RBIMPL_NONNULL_ARG(type);
+    if (klass) rb_data_object_check(klass);
+    return newobj(klass, T_DATA, (VALUE)type, (VALUE)(1 | typed_flag), (VALUE)datap, size);
+}
+
+VALUE
+rb_data_typed_object_wrap(VALUE klass, void *datap, const rb_data_type_t *type)
+{
+    if (UNLIKELY(type->flags & RUBY_TYPED_EMBEDDABLE)) {
+        rb_raise(rb_eTypeError, "Cannot wrap an embeddable TypedData");
+    }
+
+    return typed_data_alloc(klass, 0, datap, type, sizeof(struct RTypedData));
+}
+
+VALUE
+rb_data_typed_object_zalloc(VALUE klass, size_t size, const rb_data_type_t *type)
+{
+    if (type->flags & RUBY_TYPED_EMBEDDABLE) {
+        if (!(type->flags & RUBY_TYPED_FREE_IMMEDIATELY)) {
+            rb_raise(rb_eTypeError, "Embeddable TypedData must be freed immediately");
+        }
+
+        size_t embed_size = offsetof(struct RTypedData, data) + size;
+        if (rb_gc_size_allocatable_p(embed_size)) {
+            VALUE obj = typed_data_alloc(klass, TYPED_DATA_EMBEDDED, 0, type, embed_size);
+            memset((char *)obj + offsetof(struct RTypedData, data), 0, size);
+            return obj;
+        }
+    }
+
+    VALUE obj = typed_data_alloc(klass, 0, NULL, type, sizeof(struct RTypedData));
+    DATA_PTR(obj) = xcalloc(1, size);
+    return obj;
+}
+
+size_t
+rb_objspace_data_type_memsize(VALUE obj)
+{
+    size_t size = 0;
+    if (RTYPEDDATA_P(obj)) {
+        const rb_data_type_t *type = RTYPEDDATA_TYPE(obj);
+        const void *ptr = RTYPEDDATA_GET_DATA(obj);
+
+        if (RTYPEDDATA_TYPE(obj)->flags & RUBY_TYPED_EMBEDDABLE && !RTYPEDDATA_EMBEDDED_P(obj)) {
+#ifdef HAVE_MALLOC_USABLE_SIZE
+            size += malloc_usable_size((void *)ptr);
+#endif
+        }
+
+        if (ptr && type->function.dsize) {
+            size += type->function.dsize(ptr);
+        }
+    }
+
+    return size;
+}
+
+const char *
+rb_objspace_data_type_name(VALUE obj)
+{
+    if (RTYPEDDATA_P(obj)) {
+        return RTYPEDDATA_TYPE(obj)->wrap_struct_name;
+    }
+    else {
+        return 0;
+    }
+}
+
+static enum rb_id_table_iterator_result
+free_const_entry_i(VALUE value, void *data)
+{
+    rb_const_entry_t *ce = (rb_const_entry_t *)value;
+    xfree(ce);
+    return ID_TABLE_CONTINUE;
+}
+
+void
+rb_free_const_table(struct rb_id_table *tbl)
+{
+    rb_id_table_foreach_values(tbl, free_const_entry_i, 0);
+    rb_id_table_free(tbl);
+}
+
+static void
+vm_ccs_free(struct rb_class_cc_entries *ccs)
+{
+    if (ccs->entries) {
+        for (int i=0; i<ccs->len; i++) {
+            const struct rb_callcache *cc = ccs->entries[i].cc;
+            VM_ASSERT(!vm_cc_super_p(cc) && !vm_cc_refinement_p(cc));
+            vm_cc_invalidate(cc);
+        }
+        ruby_xfree(ccs->entries);
+    }
+    ruby_xfree(ccs);
+}
+
+void
+rb_vm_ccs_free(struct rb_class_cc_entries *ccs)
+{
+    RB_DEBUG_COUNTER_INC(ccs_free);
+    vm_ccs_free(ccs);
+}
+
+static enum rb_id_table_iterator_result
+cc_table_free_i(VALUE ccs_ptr, void *data_ptr)
+{
+    struct rb_class_cc_entries *ccs = (struct rb_class_cc_entries *)ccs_ptr;
+    VM_ASSERT(vm_ccs_p(ccs));
+    vm_ccs_free(ccs);
+    return ID_TABLE_CONTINUE;
+}
+
+static void
+cc_table_free(VALUE klass)
+{
+    struct rb_id_table *cc_tbl = RCLASS_CC_TBL(klass);
+
+    if (cc_tbl) {
+        rb_id_table_foreach_values(cc_tbl, cc_table_free_i, NULL);
+        rb_id_table_free(cc_tbl);
+    }
+}
+
+static enum rb_id_table_iterator_result
+cvar_table_free_i(VALUE value, void * ctx)
+{
+    xfree((void *) value);
+    return ID_TABLE_CONTINUE;
+}
+
+void
+rb_cc_table_free(VALUE klass)
+{
+    cc_table_free(klass);
+}
+
+void Init_heap(void)
+{
+}
+
+void Init_gc_stress(void)
+{
+}
+
+void
+rb_objspace_each_objects(each_obj_callback *callback, void *data)
+{
+    zerror("rb_objspace_each_objects not implemented");
+}
+
+static int
+internal_object_p(VALUE obj)
+{
+    RVALUE *p = (RVALUE *)obj;
+    void *ptr = obj;
+    bool used_p = p->as.basic.flags;
+
+    if (used_p) {
+        switch (BUILTIN_TYPE(obj)) {
+          case T_NODE:
+            UNEXPECTED_NODE(internal_object_p);
+            break;
+          case T_NONE:
+          case T_MOVED:
+          case T_IMEMO:
+          case T_ICLASS:
+          case T_ZOMBIE:
+            break;
+          case T_CLASS:
+            if (!p->as.basic.klass) break;
+            if (FL_TEST(obj, FL_SINGLETON)) {
+                return rb_singleton_class_internal_p(obj);
+            }
+            return 0;
+          default:
+            if (!p->as.basic.klass) break;
+            return 0;
+        }
+    }
+    return 1;
+}
+
+int
+rb_objspace_internal_object_p(VALUE obj)
+{
+    return internal_object_p(obj);
+}
+
+VALUE
+rb_undefine_finalizer(VALUE obj)
+{
+    struct rb_objspace *objspace = &get_objspace;
+    rb_check_frozen(obj);
+    zweak_map_set(objspace->finalizer_table, obj, NULL);
+    FL_UNSET(obj, FL_FINALIZE);
+    return obj;
+}
+
+static void
+should_be_callable(VALUE block)
+{
+    if (!rb_obj_respond_to(block, idCall, TRUE)) {
+        rb_raise(rb_eArgError, "wrong type argument %"PRIsVALUE" (should be callable)",
+                 rb_obj_class(block));
+    }
+}
+
+static void
+should_be_finalizable(VALUE obj)
+{
+    if (!FL_ABLE(obj)) {
+        rb_raise(rb_eArgError, "cannot define finalizer for %s",
+                 rb_obj_classname(obj));
+    }
+    rb_check_frozen(obj);
+}
+
+VALUE
+rb_define_finalizer_no_check(VALUE obj, VALUE block)
+{
+    struct rb_objspace *objspace = &get_objspace;
+    struct finalizer_box* box;
+
+    RBASIC(obj)->flags |= FL_FINALIZE;
+
+    box = zweak_map_get(objspace->finalizer_table, obj);
+    if (!box) {
+        struct finalizer_box* box = zgc_finq_alloc(objspace->finalizer_queue,
+                                                   sizeof(struct finalizer_box));
+        box->object = obj;
+        zweak_map_set(objspace->finalizer_table, obj, box);
+    }
+
+    if (box->table) {
+        long len = RARRAY_LEN(box->table);
+        long i;
+        for (i = 0; i < len; i++) {
+            VALUE recv = RARRAY_AREF(box->table, i);
+            if (rb_equal(recv, block)) {
+                block = recv;
+                goto end;
+            }
+        }
+        rb_ary_push(box->table, block);
+    } else {
+        box->table = rb_ary_new3(1, block);
+        RBASIC_CLEAR_CLASS(box->table);
+    }
+  end:
+    block = rb_ary_new3(2, INT2FIX(0), block);
+    OBJ_FREEZE(block);
+    return block;
+}
+
+static VALUE
+define_final(int argc, VALUE *argv, VALUE os)
+{
+    VALUE obj, block;
+
+    rb_scan_args(argc, argv, "11", &obj, &block);
+    should_be_finalizable(obj);
+    if (argc == 1) {
+        block = rb_block_proc();
+    }
+    else {
+        should_be_callable(block);
+    }
+
+    if (rb_callable_receiver(block) == obj) {
+        rb_warn("finalizer references object to be finalized");
+    }
+
+    return rb_define_finalizer_no_check(obj, block);
+}
+
+VALUE
+rb_define_finalizer(VALUE obj, VALUE block)
+{
+    should_be_finalizable(obj);
+    should_be_callable(block);
+    return rb_define_finalizer_no_check(obj, block);
+}
+
+void
+rb_gc_copy_finalizer(VALUE dest, VALUE obj)
+{
+    struct rb_objspace *objspace = &get_objspace;
+
+    if (!FL_TEST(obj, FL_FINALIZE)) return;
+
+    struct finalizer_box *box = zweak_map_get(objspace->finalizer_table, obj);
+    if (box) {
+        struct finalizer_box *new_box = zgc_finq_alloc(objspace->finalizer_queue,
+                                                       sizeof(struct finalizer_box));
+        new_box->object = dest;
+        new_box->table = box->table;
+        zweak_map_set(objspace->finalizer_table, dest, new_box);
+    }
+
+    FL_SET(dest, FL_FINALIZE);
+}
+
+void
+rb_objspace_free_objects(struct rb_objspace *objspace)
+{
+}
+
+static void
+finalize_box(struct finalizer_box* box, bool expect_valid)
+{
+    if (expect_valid) {
+        ZASSERT(box->object);
+    } else {
+        if (!box->object) {
+            return;
+        }
+    }
+    if (box->table) {
+        run_finalizer(box->object, box->table);
+    }
+    if (box->is_file) {
+        rb_io_fptr_finalize_internal(RANY(box->object)->as.file.fptr);
+    }
+    box->object = NULL;
+    box->table = NULL;
+    box->is_file = false;
+}
+
+static void
+finalize_deferred(struct rb_objspace *objspace, bool expect_valid)
+{
+    struct finalizer_box* box;
+    while ((box = zgc_finq_poll(objspace->finalizer_queue))) {
+        finalize_box(box, expect_valid);
+    }
+}
+
+static void
+gc_finalize_deferred(void *dmy)
+{
+    struct rb_objspace *objspace = dmy;
+    if (ATOMIC_EXCHANGE(objspace->finalizing, 1)) return;
+    finalize_deferred(objspace, true);
+    ATOMIC_SET(objspace->finalizing, 0);
+}
+
+void
+rb_objspace_call_finalizer(struct rb_objspace *objspace)
+{
+    if (ATOMIC_EXCHANGE(objspace->finalizing, 1)) return;
+    finalize_deferred(objspace, true);
+
+    zweak_map_iter *iter = zweak_map_get_iter(objspace->finalizer_table);
+    while (zweak_map_iter_next(iter)) {
+        finalize_box(zweak_map_iter_value(iter), false);
+    }
+
+    /* If there was a GC that was racing with us, then make sure it finishes, and then process the
+       finalizers one last time. */
+    zgc_wait(zgc_requested_cycle());
+    finalize_deferred(objspace, false);
+    ATOMIC_SET(objspace->finalizing, 0);
+}
+
+int
+rb_objspace_markable_object_p(VALUE obj)
+{
+    zerror("rb_objspace_markable_object_p not implemented");
+    return 0;
+}
+
+int
+rb_objspace_garbage_object_p(VALUE obj)
+{
+    /* FIXME: Any call to this indicates a weak map that isn't weak in the Fil-C port. */
+    return FALSE;
+}
+
+bool
+rb_gc_is_ptr_to_obj(void *ptr)
+{
+    zerror("rb_gc_is_ptr_to_obj not implemented");
+    return false;
+}
+
+VALUE
+rb_gc_id2ref_obj_tbl(VALUE objid)
+{
+    zerror("rb_gc_id2ref_obj_tbl not implemented");
+    return Qnil;
+}
+
+static VALUE
+os_id2ref(VALUE os, VALUE objid)
+{
+    zerror("id2ref not implemented");
+    return Qnil;
+}
+
+static VALUE
+rb_find_object_id(VALUE obj)
+{
+    if (STATIC_SYM_P(obj)) {
+        return (VALUE)((SYM2ID(obj) * sizeof(RVALUE) + (4 << 2)) | FIXNUM_FLAG);
+    }
+    else if (FLONUM_P(obj)) {
+#if SIZEOF_LONG == SIZEOF_VOIDP
+        return LONG2NUM((SIGNED_VALUE)obj);
+#else
+        return LL2NUM((SIGNED_VALUE)obj);
+#endif
+    }
+    else if (SPECIAL_CONST_P(obj)) {
+        return LONG2NUM((SIGNED_VALUE)obj);
+    }
+
+#if SIZEOF_LONG == SIZEOF_VOIDP
+    return (VALUE)((SIGNED_VALUE)(obj)|FIXNUM_FLAG);
+#elif SIZEOF_LONG_LONG == SIZEOF_VOIDP
+    return LL2NUM((SIGNED_VALUE)(obj) / 2);
+#else
+# error not supported
+#endif
+}
+
+VALUE
+rb_memory_id(VALUE obj)
+{
+    return rb_find_object_id(obj);
+}
+
+VALUE
+rb_obj_id(VALUE obj)
+{
+    /*
+     *                32-bit VALUE space
+     *          MSB ------------------------ LSB
+     *  false   00000000000000000000000000000000
+     *  true    00000000000000000000000000000010
+     *  nil     00000000000000000000000000000100
+     *  undef   00000000000000000000000000000110
+     *  symbol  ssssssssssssssssssssssss00001110
+     *  object  oooooooooooooooooooooooooooooo00        = 0 (mod sizeof(RVALUE))
+     *  fixnum  fffffffffffffffffffffffffffffff1
+     *
+     *                    object_id space
+     *                                       LSB
+     *  false   00000000000000000000000000000000
+     *  true    00000000000000000000000000000010
+     *  nil     00000000000000000000000000000100
+     *  undef   00000000000000000000000000000110
+     *  symbol   000SSSSSSSSSSSSSSSSSSSSSSSSSSS0        S...S % A = 4 (S...S = s...s * A + 4)
+     *  object   oooooooooooooooooooooooooooooo0        o...o % A = 0
+     *  fixnum  fffffffffffffffffffffffffffffff1        bignum if required
+     *
+     *  where A = sizeof(RVALUE)/4
+     *
+     *  sizeof(RVALUE) is
+     *  20 if 32-bit, double is 4-byte aligned
+     *  24 if 32-bit, double is 8-byte aligned
+     *  40 if 64-bit
+     */
+
+    return rb_find_object_id(obj);
+}
+
+static enum rb_id_table_iterator_result
+cc_table_memsize_i(VALUE ccs_ptr, void *data_ptr)
+{
+    size_t *total_size = data_ptr;
+    struct rb_class_cc_entries *ccs = (struct rb_class_cc_entries *)ccs_ptr;
+    *total_size += sizeof(*ccs);
+    *total_size += sizeof(ccs->entries[0]) * ccs->capa;
+    return ID_TABLE_CONTINUE;
+}
+
+static size_t
+cc_table_memsize(struct rb_id_table *cc_table)
+{
+    size_t total = rb_id_table_memsize(cc_table);
+    rb_id_table_foreach_values(cc_table, cc_table_memsize_i, &total);
+    return total;
+}
+
+size_t
+rb_gc_obj_slot_size(VALUE obj)
+{
+    return (char*)zgetupper(obj) - (char*)zgetlower(obj);
+}
+
+static size_t
+obj_memsize_of(VALUE obj, int use_all_types)
+{
+    size_t size = 0;
+
+    if (SPECIAL_CONST_P(obj)) {
+        return 0;
+    }
+
+    if (FL_TEST(obj, FL_EXIVAR)) {
+        size += rb_generic_ivar_memsize(obj);
+    }
+
+    switch (BUILTIN_TYPE(obj)) {
+      case T_OBJECT:
+        if (rb_shape_obj_too_complex(obj)) {
+            size += rb_st_memsize(ROBJECT_IV_HASH(obj));
+        }
+        else if (!(RBASIC(obj)->flags & ROBJECT_EMBED)) {
+            size += ROBJECT_IV_CAPACITY(obj) * sizeof(VALUE);
+        }
+        break;
+      case T_MODULE:
+      case T_CLASS:
+        if (RCLASS_M_TBL(obj)) {
+            size += rb_id_table_memsize(RCLASS_M_TBL(obj));
+        }
+        // class IV sizes are allocated as powers of two
+        size += SIZEOF_VALUE << bit_length(RCLASS_IV_COUNT(obj));
+        if (RCLASS_CVC_TBL(obj)) {
+            size += rb_id_table_memsize(RCLASS_CVC_TBL(obj));
+        }
+        if (RCLASS_EXT(obj)->const_tbl) {
+            size += rb_id_table_memsize(RCLASS_EXT(obj)->const_tbl);
+        }
+        if (RCLASS_CC_TBL(obj)) {
+            size += cc_table_memsize(RCLASS_CC_TBL(obj));
+        }
+        if (FL_TEST_RAW(obj, RCLASS_SUPERCLASSES_INCLUDE_SELF)) {
+            size += (RCLASS_SUPERCLASS_DEPTH(obj) + 1) * sizeof(VALUE);
+        }
+        break;
+      case T_ICLASS:
+        if (RICLASS_OWNS_M_TBL_P(obj)) {
+            if (RCLASS_M_TBL(obj)) {
+                size += rb_id_table_memsize(RCLASS_M_TBL(obj));
+            }
+        }
+        if (RCLASS_CC_TBL(obj)) {
+            size += cc_table_memsize(RCLASS_CC_TBL(obj));
+        }
+        break;
+      case T_STRING:
+        size += rb_str_memsize(obj);
+        break;
+      case T_ARRAY:
+        size += rb_ary_memsize(obj);
+        break;
+      case T_HASH:
+        if (RHASH_ST_TABLE_P(obj)) {
+            VM_ASSERT(RHASH_ST_TABLE(obj) != NULL);
+            /* st_table is in the slot */
+            size += st_memsize(RHASH_ST_TABLE(obj)) - sizeof(st_table);
+        }
+        break;
+      case T_REGEXP:
+        if (RREGEXP_PTR(obj)) {
+            size += onig_memsize(RREGEXP_PTR(obj));
+        }
+        break;
+      case T_DATA:
+        if (use_all_types) size += rb_objspace_data_type_memsize(obj);
+        break;
+      case T_MATCH:
+        {
+            rb_matchext_t *rm = RMATCH_EXT(obj);
+            size += onig_region_memsize(&rm->regs);
+            size += sizeof(struct rmatch_offset) * rm->char_offset_num_allocated;
+        }
+        break;
+      case T_FILE:
+        if (RFILE(obj)->fptr) {
+            size += rb_io_memsize(RFILE(obj)->fptr);
+        }
+        break;
+      case T_RATIONAL:
+      case T_COMPLEX:
+        break;
+      case T_IMEMO:
+        size += imemo_memsize(obj);
+        break;
+
+      case T_FLOAT:
+      case T_SYMBOL:
+        break;
+
+      case T_BIGNUM:
+        if (!(RBASIC(obj)->flags & BIGNUM_EMBED_FLAG) && BIGNUM_DIGITS(obj)) {
+            size += BIGNUM_LEN(obj) * sizeof(BDIGIT);
+        }
+        break;
+
+      case T_NODE:
+        UNEXPECTED_NODE(obj_memsize_of);
+        break;
+
+      case T_STRUCT:
+        if ((RBASIC(obj)->flags & RSTRUCT_EMBED_LEN_MASK) == 0 &&
+            RSTRUCT(obj)->as.heap.ptr) {
+            size += sizeof(VALUE) * RSTRUCT_LEN(obj);
+        }
+        break;
+
+      case T_ZOMBIE:
+      case T_MOVED:
+        break;
+
+      default:
+        rb_bug("objspace/memsize_of(): unknown data type 0x%x(%p)",
+               BUILTIN_TYPE(obj), (void*)obj);
+    }
+
+    return size + rb_gc_obj_slot_size(obj);
+}
+
+size_t
+rb_obj_memsize_of(VALUE obj)
+{
+    return obj_memsize_of(obj, TRUE);
+}
+
+static VALUE
+count_objects(int argc, VALUE *argv, VALUE os)
+{
+    return Qnil;
+}
+
+size_t
+ruby_stack_length(VALUE **p)
+{
+    zerror("ruby_stack_length unimplemented");
+    return 0;
+}
+
+int
+rb_ec_stack_check(rb_execution_context_t *ec)
+{
+    return FALSE;
+}
+
+int
+ruby_stack_check(void)
+{
+    return FALSE;
+}
+
+void
+rb_gc_mark_locations(const VALUE *start, const VALUE *end)
+{
+    zerror("rb_gc_mark_locations not supported");
+}
+
+void
+rb_gc_mark_values(long n, const VALUE *values)
+{
+    zerror("rb_gc_mark_values not supported");
+}
+
+void
+rb_gc_mark_vm_stack_values(long n, const VALUE *values)
+{
+    zerror("rb_gc_mark_vm_stack_values not supported");
+}
+
+void
+rb_mark_set(st_table *tbl)
+{
+    zerror("rb_mark_set not supported");
+}
+
+void
+rb_mark_hash(st_table *tbl)
+{
+    zerror("rb_mark_hash not supported");
+}
+
+void
+rb_mark_tbl(st_table *tbl)
+{
+    zerror("rb_mark_tbl not supported");
+}
+
+void
+rb_mark_tbl_no_pin(st_table *tbl)
+{
+    zerror("rb_mark_tbl_no_pin not supported");
+}
+
+void
+rb_gc_mark_maybe(VALUE obj)
+{
+    zerror("rb_gc_mark_maybe not supported");
+}
+
+
+void
+rb_gc_mark_movable(VALUE ptr)
+{
+    zerror("rb_gc_mark_movable not supported");
+}
+
+void
+rb_gc_mark(VALUE ptr)
+{
+    zerror("rb_gc_mark not supported");
+}
+
+void
+rb_gc_mark_and_move(VALUE *ptr)
+{
+    zerror("rb_gc_mark_and_move not supported");
+}
+
+void
+rb_gc_mark_weak(VALUE *ptr)
+{
+    zerror("rb_gc_mark_weak not supported");
+}
+
+void
+rb_gc_remove_weak(VALUE parent_obj, VALUE *ptr)
+{
+    zerror("rb_gc_remove_weak not supported");
+}
+
+int
+rb_objspace_marked_object_p(VALUE obj)
+{
+    zerror("rb_objspace_marked_object_p not supported");
+    return 0;
+}
+
+void
+rb_gc_writebarrier(VALUE a, VALUE b)
+{
+}
+
+void
+rb_gc_writebarrier_unprotect(VALUE obj)
+{
+}
+
+void
+rb_gc_writebarrier_remember(VALUE obj)
+{
+}
+
+void
+rb_copy_wb_protected_attribute(VALUE dest, VALUE obj)
+{
+}
+
+VALUE
+rb_obj_rgengc_writebarrier_protected_p(VALUE obj)
+{
+    return Qfalse;
+}
+
+VALUE
+rb_obj_rgengc_promoted_p(VALUE obj)
+{
+    return Qfalse;
+}
+
+size_t
+rb_obj_gc_flags(VALUE obj, ID* flags, size_t max)
+{
+    return 0;
+}
+
+void
+rb_gc_ractor_newobj_cache_clear(rb_ractor_newobj_cache_t *newobj_cache)
+{
+}
+
+void
+rb_gc_force_recycle(VALUE obj)
+{
+    /* no-op */
+}
+
+void
+rb_gc_register_mark_object(VALUE obj)
+{
+}
+
+void
+rb_gc_register_address(VALUE *addr)
+{
+}
+
+void
+rb_gc_unregister_address(VALUE *addr)
+{
+}
+
+void
+rb_global_variable(VALUE *var)
+{
+}
+
+void
+rb_gc_prepare_heap(void)
+{
+}
+
+void
+rb_gc_ref_update_table_values_only(st_table *tbl)
+{
+    zerror("rb_gc_ref_update_table_values_only not supported");
+}
+
+void
+rb_gc_update_tbl_refs(st_table *ptr)
+{
+    zerror("rb_gc_update_tbl_refs not supported");
+}
+
+void
+rb_gc_update_values(long n, VALUE *values)
+{
+    zerror("rb_gc_update_values not supported");
+}
+
+VALUE
+rb_gc_location(VALUE value)
+{
+    return value;
+}
+
+VALUE
+rb_gc_start(void)
+{
+    zgc_request_fresh();
+    return Qnil;
+}
+
+void
+rb_gc(void)
+{
+    zgc_request_fresh();
+}
+
+int
+rb_during_gc(void)
+{
+    return zgc_requested_cycle() != zgc_completed_cycle();
+}
+
+size_t
+rb_gc_count(void)
+{
+    return zgc_completed_cycle();
+}
+
+static VALUE
+gc_count(rb_execution_context_t *ec, VALUE self)
+{
+    return SIZET2NUM(rb_gc_count());
+}
+
+static VALUE
+gc_info_decode(const VALUE hash_or_key)
+{
+    VALUE hash = Qnil;
+    if (RB_TYPE_P(hash_or_key, T_HASH))
+        hash = hash_or_key;
+    return hash;
+}
+
+VALUE
+rb_gc_latest_gc_info(VALUE key)
+{
+    return gc_info_decode(key);
+}
+
+size_t
+rb_gc_stat(VALUE key)
+{
+    return 0;
+}
+
+VALUE
+rb_gc_enable(void)
+{
+    return Qtrue;
+}
+
+VALUE
+rb_objspace_gc_enable(struct rb_objspace *objspace)
+{
+    return Qtrue;
+}
+
+VALUE
+rb_gc_disable_no_rest(void)
+{
+    return Qtrue;
+}
+
+VALUE
+rb_gc_disable(void)
+{
+    return Qtrue;
+}
+
+void
+ruby_gc_set_params(void)
+{
+}
+
+void
+rb_objspace_reachable_objects_from(VALUE obj, void (func)(VALUE, void *), void *data)
+{
+    zerror("rb_objspace_reachable_objects_from unimplemented");
+}
+
+void
+rb_objspace_reachable_objects_from_root(void (func)(const char *category, VALUE, void *), void *passing_data)
+{
+    zerror("rb_objspace_reachable_objects_from_root unimplemented");
+}
+
+void
+rb_memerror(void)
+{
+    rb_execution_context_t *ec = GET_EC();
+    VALUE exc;
+
+    if (0) {
+        // Print out pid, sleep, so you can attach debugger to see what went wrong:
+        fprintf(stderr, "rb_memerror pid=%"PRI_PIDT_PREFIX"d\n", getpid());
+        sleep(60);
+    }
+
+    exc = nomem_error;
+    if (!exc ||
+        rb_ec_raised_p(ec, RAISED_NOMEMORY)) {
+        fprintf(stderr, "[FATAL] failed to allocate memory\n");
+        exit(EXIT_FAILURE);
+    }
+    if (rb_ec_raised_p(ec, RAISED_NOMEMORY)) {
+        rb_ec_raised_clear(ec);
+    }
+    else {
+        rb_ec_raised_set(ec, RAISED_NOMEMORY);
+        exc = ruby_vm_special_exception_copy(exc);
+    }
+    ec->errinfo = exc;
+    EC_JUMP_TAG(ec, TAG_RAISE);
+}
+
+void *
+rb_aligned_malloc(size_t alignment, size_t size)
+{
+    return zgc_aligned_alloc(alignment, size);
+}
+
+void
+rb_malloc_info_show_results(void)
+{
+}
+
+void *
+ruby_xmalloc_body(size_t size)
+{
+    return malloc(size);
+}
+
+void
+ruby_malloc_size_overflow(size_t count, size_t elsize)
+{
+    rb_raise(rb_eArgError,
+             "malloc: possible integer overflow (%"PRIuSIZE"*%"PRIuSIZE")",
+             count, elsize);
+}
+
+static inline size_t
+xmalloc2_size(const size_t count, const size_t elsize)
+{
+    return size_mul_or_raise(count, elsize, rb_eArgError);
+}
+
+void *
+ruby_xmalloc2_body(size_t n, size_t size)
+{
+    return malloc(xmalloc2_size(n, size));
+}
+
+void *
+ruby_xcalloc_body(size_t n, size_t size)
+{
+    return malloc(xmalloc2_size(n, size));
+}
+
+#ifdef ruby_sized_xrealloc
+#undef ruby_sized_xrealloc
+#endif
+void *
+ruby_sized_xrealloc(void *ptr, size_t new_size, size_t old_size)
+{
+    return realloc(ptr, new_size);
+}
+
+void *
+ruby_xrealloc_body(void *ptr, size_t new_size)
+{
+    return realloc(ptr, new_size);
+}
+
+#ifdef ruby_sized_xrealloc2
+#undef ruby_sized_xrealloc2
+#endif
+void *
+ruby_sized_xrealloc2(void *ptr, size_t n, size_t size, size_t old_n)
+{
+    size_t len = xmalloc2_size(n, size);
+    return realloc(ptr, len);
+}
+
+void *
+ruby_xrealloc2_body(void *ptr, size_t n, size_t size)
+{
+    return ruby_sized_xrealloc2(ptr, n, size, 0);
+}
+
+#ifdef ruby_sized_xfree
+#undef ruby_sized_xfree
+#endif
+void
+ruby_sized_xfree(void *x, size_t size)
+{
+    free(x);
+}
+
+void
+ruby_xfree(void *x)
+{
+    free(x);
+}
+
+void *
+rb_xmalloc_mul_add(size_t x, size_t y, size_t z) /* x * y + z */
+{
+    size_t w = size_mul_add_or_raise(x, y, z, rb_eArgError);
+    return ruby_xmalloc(w);
+}
+
+void *
+rb_xcalloc_mul_add(size_t x, size_t y, size_t z) /* x * y + z */
+{
+    size_t w = size_mul_add_or_raise(x, y, z, rb_eArgError);
+    return ruby_xcalloc(w, 1);
+}
+
+void *
+rb_xrealloc_mul_add(const void *p, size_t x, size_t y, size_t z) /* x * y + z */
+{
+    size_t w = size_mul_add_or_raise(x, y, z, rb_eArgError);
+    return ruby_xrealloc((void *)p, w);
+}
+
+void *
+rb_xmalloc_mul_add_mul(size_t x, size_t y, size_t z, size_t w) /* x * y + z * w */
+{
+    size_t u = size_mul_add_mul_or_raise(x, y, z, w, rb_eArgError);
+    return ruby_xmalloc(u);
+}
+
+void *
+rb_xcalloc_mul_add_mul(size_t x, size_t y, size_t z, size_t w) /* x * y + z * w */
+{
+    size_t u = size_mul_add_mul_or_raise(x, y, z, w, rb_eArgError);
+    return ruby_xcalloc(u, 1);
+}
+
+void *
+ruby_mimmalloc(size_t size)
+{
+    return malloc(size);
+}
+
+void
+ruby_mimfree(void *ptr)
+{
+    free(ptr);
+}
+
+void *
+rb_alloc_tmp_buffer_with_count(volatile VALUE *store, size_t size, size_t cnt)
+{
+    void *ptr;
+    VALUE imemo;
+    rb_imemo_tmpbuf_t *tmpbuf;
+
+    /* Keep the order; allocate an empty imemo first then xmalloc, to
+     * get rid of potential memory leak */
+    imemo = rb_imemo_tmpbuf_auto_free_maybe_mark_buffer(NULL, 0);
+    *store = imemo;
+    ptr = malloc(size);
+    tmpbuf = (rb_imemo_tmpbuf_t *)imemo;
+    tmpbuf->ptr = ptr;
+    tmpbuf->cnt = cnt;
+    return ptr;
+}
+
+void *
+rb_alloc_tmp_buffer(volatile VALUE *store, long len)
+{
+    long cnt;
+
+    if (len < 0 || (cnt = (long)roomof(len, sizeof(VALUE))) < 0) {
+        rb_raise(rb_eArgError, "negative buffer size (or size too big)");
+    }
+
+    return rb_alloc_tmp_buffer_with_count(store, len, cnt);
+}
+
+void
+rb_free_tmp_buffer(volatile VALUE *store)
+{
+    rb_imemo_tmpbuf_t *s = (rb_imemo_tmpbuf_t*)ATOMIC_VALUE_EXCHANGE(*store, 0);
+    if (s) {
+        void *ptr = ATOMIC_PTR_EXCHANGE(s->ptr, 0);
+        s->cnt = 0;
+        ruby_xfree(ptr);
+    }
+}
+
+void
+rb_gc_adjust_memory_usage(ssize_t diff)
+{
+}
+
+const char *
+rb_method_type_name(rb_method_type_t type)
+{
+    switch (type) {
+      case VM_METHOD_TYPE_ISEQ:           return "iseq";
+      case VM_METHOD_TYPE_ATTRSET:        return "attrest";
+      case VM_METHOD_TYPE_IVAR:           return "ivar";
+      case VM_METHOD_TYPE_BMETHOD:        return "bmethod";
+      case VM_METHOD_TYPE_ALIAS:          return "alias";
+      case VM_METHOD_TYPE_REFINED:        return "refined";
+      case VM_METHOD_TYPE_CFUNC:          return "cfunc";
+      case VM_METHOD_TYPE_ZSUPER:         return "zsuper";
+      case VM_METHOD_TYPE_MISSING:        return "missing";
+      case VM_METHOD_TYPE_OPTIMIZED:      return "optimized";
+      case VM_METHOD_TYPE_UNDEF:          return "undef";
+      case VM_METHOD_TYPE_NOTIMPLEMENTED: return "notimplemented";
+    }
+    rb_bug("rb_method_type_name: unreachable (type: %d)", type);
+}
+
+static void
+rb_raw_iseq_info(char *const buff, const size_t buff_size, const rb_iseq_t *iseq)
+{
+    if (buff_size > 0 && ISEQ_BODY(iseq) && ISEQ_BODY(iseq)->location.label && !RB_TYPE_P(ISEQ_BODY(iseq)->location.pathobj, T_MOVED)) {
+        VALUE path = rb_iseq_path(iseq);
+        int n = ISEQ_BODY(iseq)->location.first_lineno;
+        snprintf(buff, buff_size, " %s@%s:%d",
+                 RSTRING_PTR(ISEQ_BODY(iseq)->location.label),
+                 RSTRING_PTR(path), n);
+    }
+}
+
+static const char *
+type_name(int type, VALUE obj)
+{
+    switch (type) {
+#define TYPE_NAME(t) case (t): return #t;
+            TYPE_NAME(T_NONE);
+            TYPE_NAME(T_OBJECT);
+            TYPE_NAME(T_CLASS);
+            TYPE_NAME(T_MODULE);
+            TYPE_NAME(T_FLOAT);
+            TYPE_NAME(T_STRING);
+            TYPE_NAME(T_REGEXP);
+            TYPE_NAME(T_ARRAY);
+            TYPE_NAME(T_HASH);
+            TYPE_NAME(T_STRUCT);
+            TYPE_NAME(T_BIGNUM);
+            TYPE_NAME(T_FILE);
+            TYPE_NAME(T_MATCH);
+            TYPE_NAME(T_COMPLEX);
+            TYPE_NAME(T_RATIONAL);
+            TYPE_NAME(T_NIL);
+            TYPE_NAME(T_TRUE);
+            TYPE_NAME(T_FALSE);
+            TYPE_NAME(T_SYMBOL);
+            TYPE_NAME(T_FIXNUM);
+            TYPE_NAME(T_UNDEF);
+            TYPE_NAME(T_IMEMO);
+            TYPE_NAME(T_ICLASS);
+            TYPE_NAME(T_MOVED);
+            TYPE_NAME(T_ZOMBIE);
+      case T_DATA:
+        if (obj && rb_objspace_data_type_name(obj)) {
+            return rb_objspace_data_type_name(obj);
+        }
+        return "T_DATA";
+#undef TYPE_NAME
+    }
+    return "unknown";
+}
+
+static const char *
+obj_type_name(VALUE obj)
+{
+    return type_name(TYPE(obj), obj);
+}
+
+static int
+str_len_no_raise(VALUE str)
+{
+    long len = RSTRING_LEN(str);
+    if (len < 0) return 0;
+    if (len > INT_MAX) return INT_MAX;
+    return (int)len;
+}
+
+#define BUFF_ARGS buff + pos, buff_size - pos
+#define APPEND_F(...) if ((pos += snprintf(BUFF_ARGS, "" __VA_ARGS__)) >= buff_size) goto end
+#define APPEND_S(s) do { \
+        if ((pos + (int)rb_strlen_lit(s)) >= buff_size) { \
+            goto end; \
+        } \
+        else { \
+            memcpy(buff + pos, (s), rb_strlen_lit(s) + 1); \
+        } \
+    } while (0)
+#define TF(c) ((c) != 0 ? "true" : "false")
+#define C(c, s) ((c) != 0 ? (s) : " ")
+
+static size_t
+rb_raw_obj_info_common(char *const buff, const size_t buff_size, const VALUE obj)
+{
+    size_t pos = 0;
+
+    if (SPECIAL_CONST_P(obj)) {
+        APPEND_F("%s", obj_type_name(obj));
+
+        if (FIXNUM_P(obj)) {
+            APPEND_F(" %ld", FIX2LONG(obj));
+        }
+        else if (SYMBOL_P(obj)) {
+            APPEND_F(" %s", rb_id2name(SYM2ID(obj)));
+        }
+    }
+    else {
+        APPEND_F("%p [%s] %s ",
+                 obj, zptr_to_new_string(obj), obj_type_name(obj));
+        if (internal_object_p(obj)) {
+            /* ignore */
+        }
+        else if (RBASIC(obj)->klass == 0) {
+            APPEND_S("(temporary internal)");
+        }
+        else if (RTEST(RBASIC(obj)->klass)) {
+            VALUE class_path = rb_class_path_cached(RBASIC(obj)->klass);
+            if (!NIL_P(class_path)) {
+                APPEND_F("(%s)", RSTRING_PTR(class_path));
+            }
+        }
+    }
+
+  end:
+    return pos;
+}
+
+static size_t
+rb_raw_obj_info_buitin_type(char *const buff, const size_t buff_size, const VALUE obj, size_t pos)
+{
+    if (LIKELY(pos < buff_size) && !SPECIAL_CONST_P(obj)) {
+        const enum ruby_value_type type = BUILTIN_TYPE(obj);
+
+        switch (type) {
+          case T_NODE:
+            UNEXPECTED_NODE(rb_raw_obj_info);
+            break;
+          case T_ARRAY:
+            if (ARY_SHARED_P(obj)) {
+                APPEND_S("shared -> ");
+                rb_raw_obj_info(BUFF_ARGS, ARY_SHARED_ROOT(obj));
+            }
+            else if (ARY_EMBED_P(obj)) {
+                APPEND_F("[%s%s] len: %ld (embed)",
+                         C(ARY_EMBED_P(obj),  "E"),
+                         C(ARY_SHARED_P(obj), "S"),
+                         RARRAY_LEN(obj));
+            }
+            else {
+                APPEND_F("[%s%s] len: %ld, capa:%ld ptr:%p",
+                         C(ARY_EMBED_P(obj),  "E"),
+                         C(ARY_SHARED_P(obj), "S"),
+                         RARRAY_LEN(obj),
+                         ARY_EMBED_P(obj) ? -1L : RARRAY(obj)->as.heap.aux.capa,
+                         (void *)RARRAY_CONST_PTR(obj));
+            }
+            break;
+          case T_STRING: {
+            if (STR_SHARED_P(obj)) {
+                APPEND_F(" [shared] len: %ld", RSTRING_LEN(obj));
+            }
+            else {
+                if (STR_EMBED_P(obj)) APPEND_S(" [embed]");
+
+                APPEND_F(" len: %ld, capa: %" PRIdSIZE, RSTRING_LEN(obj), rb_str_capacity(obj));
+            }
+            APPEND_F(" \"%.*s\"", str_len_no_raise(obj), RSTRING_PTR(obj));
+            break;
+          }
+          case T_SYMBOL: {
+            VALUE fstr = RSYMBOL(obj)->fstr;
+            ID id = RSYMBOL(obj)->id;
+            if (RB_TYPE_P(fstr, T_STRING)) {
+                APPEND_F(":%s id:%d", RSTRING_PTR(fstr), (unsigned int)id);
+            }
+            else {
+                APPEND_F("(%p) id:%d", (void *)fstr, (unsigned int)id);
+            }
+            break;
+          }
+          case T_MOVED: {
+            APPEND_F("-> %p", (void*)rb_gc_location(obj));
+            break;
+          }
+          case T_HASH: {
+            APPEND_F("[%c] %"PRIdSIZE,
+                     RHASH_AR_TABLE_P(obj) ? 'A' : 'S',
+                     RHASH_SIZE(obj));
+            break;
+          }
+          case T_CLASS:
+          case T_MODULE:
+            {
+                VALUE class_path = rb_class_path_cached(obj);
+                if (!NIL_P(class_path)) {
+                    APPEND_F("%s", RSTRING_PTR(class_path));
+                }
+                else {
+                    APPEND_S("(anon)");
+                }
+                break;
+            }
+          case T_ICLASS:
+            {
+                VALUE class_path = rb_class_path_cached(RBASIC_CLASS(obj));
+                if (!NIL_P(class_path)) {
+                    APPEND_F("src:%s", RSTRING_PTR(class_path));
+                }
+                break;
+            }
+          case T_OBJECT:
+            {
+                if (rb_shape_obj_too_complex(obj)) {
+                    size_t hash_len = rb_st_table_size(ROBJECT_IV_HASH(obj));
+                    APPEND_F("(too_complex) len:%"PRIuSIZE"", hash_len);
+                }
+                else {
+                    uint32_t len = ROBJECT_IV_CAPACITY(obj);
+
+                    if (RANY(obj)->as.basic.flags & ROBJECT_EMBED) {
+                        APPEND_F("(embed) len:%d", len);
+                    }
+                    else {
+                        VALUE *ptr = ROBJECT_IVPTR(obj);
+                        APPEND_F("len:%d ptr:%p", len, (void *)ptr);
+                    }
+                }
+            }
+            break;
+          case T_DATA: {
+            const struct rb_block *block;
+            const rb_iseq_t *iseq;
+            if (rb_obj_is_proc(obj) &&
+                (block = vm_proc_block(obj)) != NULL &&
+                (vm_block_type(block) == block_type_iseq) &&
+                (iseq = vm_block_iseq(block)) != NULL) {
+                rb_raw_iseq_info(BUFF_ARGS, iseq);
+            }
+            else if (rb_ractor_p(obj)) {
+                rb_ractor_t *r = (void *)DATA_PTR(obj);
+                if (r) {
+                    APPEND_F("r:%d", r->pub.id);
+                }
+            }
+            else {
+                const char * const type_name = rb_objspace_data_type_name(obj);
+                if (type_name) {
+                    APPEND_F("%s", type_name);
+                }
+            }
+            break;
+          }
+          case T_IMEMO: {
+            APPEND_F("<%s> ", rb_imemo_name(imemo_type(obj)));
+
+            switch (imemo_type(obj)) {
+              case imemo_ment:
+                {
+                    const rb_method_entry_t *me = &RANY(obj)->as.imemo.ment;
+
+                    APPEND_F(":%s (%s%s%s%s) type:%s aliased:%d owner:%p defined_class:%p",
+                             rb_id2name(me->called_id),
+                             METHOD_ENTRY_VISI(me) == METHOD_VISI_PUBLIC ?  "pub" :
+                             METHOD_ENTRY_VISI(me) == METHOD_VISI_PRIVATE ? "pri" : "pro",
+                             METHOD_ENTRY_COMPLEMENTED(me) ? ",cmp" : "",
+                             METHOD_ENTRY_CACHED(me) ? ",cc" : "",
+                             METHOD_ENTRY_INVALIDATED(me) ? ",inv" : "",
+                             me->def ? rb_method_type_name(me->def->type) : "NULL",
+                             me->def ? me->def->aliased : -1,
+                             (void *)me->owner, // obj_info(me->owner),
+                             (void *)me->defined_class); //obj_info(me->defined_class)));
+
+                    if (me->def) {
+                        switch (me->def->type) {
+                          case VM_METHOD_TYPE_ISEQ:
+                            APPEND_S(" (iseq:");
+                            rb_raw_obj_info(BUFF_ARGS, (VALUE)me->def->body.iseq.iseqptr);
+                            APPEND_S(")");
+                            break;
+                          default:
+                            break;
+                        }
+                    }
+
+                    break;
+                }
+              case imemo_iseq: {
+                const rb_iseq_t *iseq = (const rb_iseq_t *)obj;
+                rb_raw_iseq_info(BUFF_ARGS, iseq);
+                break;
+              }
+              case imemo_callinfo:
+                {
+                    const struct rb_callinfo *ci = (const struct rb_callinfo *)obj;
+                    APPEND_F("(mid:%s, flag:%x argc:%d, kwarg:%s)",
+                             rb_id2name(vm_ci_mid(ci)),
+                             vm_ci_flag(ci),
+                             vm_ci_argc(ci),
+                             vm_ci_kwarg(ci) ? "available" : "NULL");
+                    break;
+                }
+              case imemo_callcache:
+                {
+                    const struct rb_callcache *cc = (const struct rb_callcache *)obj;
+                    VALUE class_path = cc->klass ? rb_class_path_cached(cc->klass) : Qnil;
+                    const rb_callable_method_entry_t *cme = vm_cc_cme(cc);
+
+                    APPEND_F("(klass:%s cme:%s%s (%p) call:%p",
+                             NIL_P(class_path) ? (cc->klass ? "??" : "<NULL>") : RSTRING_PTR(class_path),
+                             cme ? rb_id2name(cme->called_id) : "<NULL>",
+                             cme ? (METHOD_ENTRY_INVALIDATED(cme) ? " [inv]" : "") : "",
+                             (void *)cme,
+                             (void *)vm_cc_call(cc));
+                    break;
+                }
+              default:
+                break;
+            }
+          }
+          default:
+            break;
+        }
+    }
+  end:
+
+    return pos;
+}
+
+#undef TF
+#undef C
+
+const char *
+rb_raw_obj_info(char *const buff, const size_t buff_size, VALUE obj)
+{
+    size_t pos = rb_raw_obj_info_common(buff, buff_size, obj);
+    pos = rb_raw_obj_info_buitin_type(buff, buff_size, obj, pos);
+    if (pos >= buff_size) {} // truncated
+
+    return buff;
+}
+
+#undef APPEND_S
+#undef APPEND_F
+#undef BUFF_ARGS
+
+static const char *
+obj_info(VALUE obj)
+{
+    return obj_type_name(obj);
+}
+
+const char *
+rb_obj_info(VALUE obj)
+{
+    return obj_info(obj);
+}
+
+void
+rb_obj_info_dump(VALUE obj)
+{
+    char buff[0x100];
+    fprintf(stderr, "rb_obj_info_dump: %s\n", rb_raw_obj_info(buff, 0x100, obj));
+}
+
+void
+rb_obj_info_dump_loc(VALUE obj, const char *file, int line, const char *func)
+{
+    char buff[0x100];
+    fprintf(stderr, "<OBJ_INFO:%s@%s:%d> %s\n", func, file, line, rb_raw_obj_info(buff, 0x100, obj));
+}
+
+static VALUE
+gc_profile_clear(VALUE _)
+{
+    return Qnil;
+}
+
+static VALUE
+gc_profile_record_get(VALUE _)
+{
+    return Qnil;
+}
+
+static VALUE
+gc_profile_result(VALUE _)
+{
+    return Qnil;
+}
+
+static VALUE
+gc_profile_report(int argc, VALUE *argv, VALUE self)
+{
+    return Qnil;
+}
+
+static VALUE
+gc_profile_total_time(VALUE self)
+{
+    return DBL2NUM(0);
+}
+
+static VALUE
+gc_profile_enable_get(VALUE self)
+{
+    return Qfalse;
+}
+
+static VALUE
+gc_profile_enable(VALUE _)
+{
+    return Qnil;
+}
+
+static VALUE
+gc_profile_disable(VALUE _)
+{
+    return Qnil;
+}
+
+static VALUE
+gc_verify_internal_consistency_m(VALUE dummy)
+{
+    return Qnil;
+}
+
+static VALUE
+undefine_final(VALUE os, VALUE obj)
+{
+    return rb_undefine_finalizer(obj);
+}
+
+void
+rb_gc_mark_machine_stack(const rb_execution_context_t *ec)
+{
+    zerror("rb_gc_mark_machine_stack not supported");
+}
+
+#include "gc.rbinc"
+
+void
+Init_GC(void)
+{
+#undef rb_intern
+    malloc_offset = gc_compute_malloc_offset();
+
+    VALUE rb_mObjSpace;
+    VALUE rb_mProfiler;
+    VALUE gc_constants;
+
+    rb_mGC = rb_define_module("GC");
+
+    gc_constants = rb_hash_new();
+    rb_hash_aset(gc_constants, ID2SYM(rb_intern("DEBUG")), RBOOL(Qfalse));
+    rb_hash_aset(gc_constants, ID2SYM(rb_intern("BASE_SLOT_SIZE")), SIZET2NUM(sizeof(RVALUE)));
+    rb_hash_aset(gc_constants, ID2SYM(rb_intern("RVALUE_OVERHEAD")), SIZET2NUM(0));
+    rb_hash_aset(gc_constants, ID2SYM(rb_intern("RVALUE_SIZE")), SIZET2NUM(sizeof(RVALUE)));
+    rb_hash_aset(gc_constants, ID2SYM(rb_intern("SIZE_POOL_COUNT")), LONG2FIX(SIZE_POOL_COUNT));
+    rb_hash_aset(gc_constants, ID2SYM(rb_intern("RVARGC_MAX_ALLOCATE_SIZE")), LONG2FIX(rb_size_pool_slot_size(SIZE_POOL_COUNT - 1)));
+    OBJ_FREEZE(gc_constants);
+    /* Internal constants in the garbage collector. */
+    rb_define_const(rb_mGC, "INTERNAL_CONSTANTS", gc_constants);
+
+    rb_mProfiler = rb_define_module_under(rb_mGC, "Profiler");
+    rb_define_singleton_method(rb_mProfiler, "enabled?", gc_profile_enable_get, 0);
+    rb_define_singleton_method(rb_mProfiler, "enable", gc_profile_enable, 0);
+    rb_define_singleton_method(rb_mProfiler, "raw_data", gc_profile_record_get, 0);
+    rb_define_singleton_method(rb_mProfiler, "disable", gc_profile_disable, 0);
+    rb_define_singleton_method(rb_mProfiler, "clear", gc_profile_clear, 0);
+    rb_define_singleton_method(rb_mProfiler, "result", gc_profile_result, 0);
+    rb_define_singleton_method(rb_mProfiler, "report", gc_profile_report, -1);
+    rb_define_singleton_method(rb_mProfiler, "total_time", gc_profile_total_time, 0);
+
+    rb_mObjSpace = rb_define_module("ObjectSpace");
+
+    rb_define_module_function(rb_mObjSpace, "define_finalizer", define_final, -1);
+    rb_define_module_function(rb_mObjSpace, "undefine_finalizer", undefine_final, 1);
+
+    rb_define_module_function(rb_mObjSpace, "_id2ref", os_id2ref, 1);
+
+    rb_vm_register_special_exception(ruby_error_nomemory, rb_eNoMemError, "failed to allocate memory");
+
+    rb_define_method(rb_cBasicObject, "__id__", rb_obj_id, 0);
+    rb_define_method(rb_mKernel, "object_id", rb_obj_id, 0);
+
+    rb_define_module_function(rb_mObjSpace, "count_objects", count_objects, -1);
+
+    /* internal methods */
+    rb_define_singleton_method(rb_mGC, "verify_internal_consistency", gc_verify_internal_consistency_m, 0);
+
+    rb_define_singleton_method(rb_mGC, "compact", rb_f_notimplement, 0);
+    rb_define_singleton_method(rb_mGC, "auto_compact", rb_f_notimplement, 0);
+    rb_define_singleton_method(rb_mGC, "auto_compact=", rb_f_notimplement, 1);
+    rb_define_singleton_method(rb_mGC, "latest_compact_info", rb_f_notimplement, 0);
+    /* When !GC_COMPACTION_SUPPORTED, this method is not defined in gc.rb */
+    rb_define_singleton_method(rb_mGC, "verify_compaction_references", rb_f_notimplement, -1);
+}
+
+#else /* defined(__FILC__) -> so !defined(__FILC__) */
+
 #if defined(HAVE_RB_GC_GUARDED_PTR_VAL) && HAVE_RB_GC_GUARDED_PTR_VAL
 /* trick the compiler into thinking a external signal handler uses this */
 volatile VALUE rb_gc_guarded_val;
@@ -963,7 +3031,6 @@ typedef struct rb_objspace {
 
 #define BASE_SLOT_SIZE sizeof(RVALUE)
 
-#define CEILDIV(i, mod) roomof(i, mod)
 enum {
     HEAP_PAGE_ALIGN = (1UL << HEAP_PAGE_ALIGN_LOG),
     HEAP_PAGE_ALIGN_MASK = (~(~0UL << HEAP_PAGE_ALIGN_LOG)),
@@ -1334,13 +3401,9 @@ struct RZombie {
 
 #define RZOMBIE(o) ((struct RZombie *)(o))
 
-#define nomem_error GET_VM()->special_exceptions[ruby_error_nomemory]
-
 #if RUBY_MARK_FREE_DEBUG
 int ruby_gc_debug_indent = 0;
 #endif
-VALUE rb_mGC;
-int ruby_disable_gc = 0;
 int ruby_enable_autocompact = 0;
 #if RGENGC_CHECK_MODE
 gc_compact_compare_func ruby_autocompact_compare_func;
@@ -1348,13 +3411,10 @@ gc_compact_compare_func ruby_autocompact_compare_func;
 
 void rb_iseq_mark_and_move(rb_iseq_t *iseq, bool referece_updating);
 void rb_iseq_free(const rb_iseq_t *iseq);
-size_t rb_iseq_memsize(const rb_iseq_t *iseq);
 void rb_vm_update_references(void *ptr);
 
 void rb_gcdebug_print_obj_condition(VALUE obj);
 
-NORETURN(static void *gc_vraise(void *ptr));
-NORETURN(static void gc_raise(VALUE exc, const char *fmt, ...));
 NORETURN(static void negative_size_allocation_error(const char *));
 
 static void init_mark_stack(mark_stack_t *stack);
@@ -1429,8 +3489,6 @@ PRINTF_ARGS(static void gc_report_body(int level, rb_objspace_t *objspace, const
 static const char *obj_info(VALUE obj);
 static const char *obj_type_name(VALUE obj);
 
-static void gc_finalize_deferred(void *dmy);
-
 /*
  * 1 - TSC (H/W Time Stamp Counter)
  * 2 - getrusage
@@ -2577,7 +4635,7 @@ gc_event_hook_body(rb_execution_context_t *ec, rb_objspace_t *objspace, const rb
 #define gc_event_hook(objspace, event, data) gc_event_hook_prep(objspace, event, data, (void)0)
 
 static inline VALUE
-newobj_init(VALUE klass, VALUE flags, int wb_protected, rb_objspace_t *objspace, VALUE obj)
+newobj_init(VALUE klass, uintptr_t flags, int wb_protected, rb_objspace_t *objspace, VALUE obj)
 {
 #if !__has_feature(memory_sanitizer)
     GC_ASSERT(BUILTIN_TYPE(obj) == T_NONE);
@@ -2850,10 +4908,10 @@ newobj_zero_slot(VALUE obj)
     memset((char *)obj + sizeof(struct RBasic), 0, rb_gc_obj_slot_size(obj) - sizeof(struct RBasic));
 }
 
-ALWAYS_INLINE(static VALUE newobj_slowpath(VALUE klass, VALUE flags, rb_objspace_t *objspace, rb_ractor_t *cr, int wb_protected, size_t size_pool_idx));
+ALWAYS_INLINE(static VALUE newobj_slowpath(VALUE klass, uintptr_t flags, rb_objspace_t *objspace, rb_ractor_t *cr, int wb_protected, size_t size_pool_idx));
 
 static inline VALUE
-newobj_slowpath(VALUE klass, VALUE flags, rb_objspace_t *objspace, rb_ractor_t *cr, int wb_protected, size_t size_pool_idx)
+newobj_slowpath(VALUE klass, uintptr_t flags, rb_objspace_t *objspace, rb_ractor_t *cr, int wb_protected, size_t size_pool_idx)
 {
     VALUE obj;
     unsigned int lev;
@@ -2884,25 +4942,25 @@ newobj_slowpath(VALUE klass, VALUE flags, rb_objspace_t *objspace, rb_ractor_t *
     return obj;
 }
 
-NOINLINE(static VALUE newobj_slowpath_wb_protected(VALUE klass, VALUE flags,
+NOINLINE(static VALUE newobj_slowpath_wb_protected(VALUE klass, uintptr_t flags,
                                                    rb_objspace_t *objspace, rb_ractor_t *cr, size_t size_pool_idx));
-NOINLINE(static VALUE newobj_slowpath_wb_unprotected(VALUE klass, VALUE flags,
+NOINLINE(static VALUE newobj_slowpath_wb_unprotected(VALUE klass, uintptr_t flags,
                                                      rb_objspace_t *objspace, rb_ractor_t *cr, size_t size_pool_idx));
 
 static VALUE
-newobj_slowpath_wb_protected(VALUE klass, VALUE flags, rb_objspace_t *objspace, rb_ractor_t *cr, size_t size_pool_idx)
+newobj_slowpath_wb_protected(VALUE klass, uintptr_t flags, rb_objspace_t *objspace, rb_ractor_t *cr, size_t size_pool_idx)
 {
     return newobj_slowpath(klass, flags, objspace, cr, TRUE, size_pool_idx);
 }
 
 static VALUE
-newobj_slowpath_wb_unprotected(VALUE klass, VALUE flags, rb_objspace_t *objspace, rb_ractor_t *cr, size_t size_pool_idx)
+newobj_slowpath_wb_unprotected(VALUE klass, uintptr_t flags, rb_objspace_t *objspace, rb_ractor_t *cr, size_t size_pool_idx)
 {
     return newobj_slowpath(klass, flags, objspace, cr, FALSE, size_pool_idx);
 }
 
 static inline VALUE
-newobj_of0(VALUE klass, VALUE flags, int wb_protected, rb_ractor_t *cr, size_t alloc_size)
+newobj_of0(VALUE klass, uintptr_t flags, int wb_protected, rb_ractor_t *cr, size_t alloc_size)
 {
     VALUE obj;
     rb_objspace_t *objspace = &rb_objspace;
@@ -2942,21 +5000,21 @@ newobj_of0(VALUE klass, VALUE flags, int wb_protected, rb_ractor_t *cr, size_t a
 }
 
 static inline VALUE
-newobj_of(rb_ractor_t *cr, VALUE klass, VALUE flags, VALUE v1, VALUE v2, VALUE v3, int wb_protected, size_t alloc_size)
+newobj_of(rb_ractor_t *cr, VALUE klass, uintptr_t flags, VALUE v1, VALUE v2, VALUE v3, int wb_protected, size_t alloc_size)
 {
     VALUE obj = newobj_of0(klass, flags, wb_protected, cr, alloc_size);
     return newobj_fill(obj, v1, v2, v3);
 }
 
 VALUE
-rb_wb_unprotected_newobj_of(VALUE klass, VALUE flags, size_t size)
+rb_wb_unprotected_newobj_of(VALUE klass, uintptr_t flags, size_t size)
 {
     GC_ASSERT((flags & FL_WB_PROTECTED) == 0);
     return newobj_of(GET_RACTOR(), klass, flags, 0, 0, 0, FALSE, size);
 }
 
 VALUE
-rb_wb_protected_newobj_of(rb_execution_context_t *ec, VALUE klass, VALUE flags, size_t size)
+rb_wb_protected_newobj_of(rb_execution_context_t *ec, VALUE klass, uintptr_t flags, size_t size)
 {
     GC_ASSERT((flags & FL_WB_PROTECTED) == 0);
     return newobj_of(rb_ec_ractor_ptr(ec), klass, flags, 0, 0, 0, TRUE, size);
@@ -2971,7 +5029,7 @@ rb_newobj(void)
 }
 
 static VALUE
-rb_class_instance_allocate_internal(VALUE klass, VALUE flags, bool wb_protected)
+rb_class_instance_allocate_internal(VALUE klass, uintptr_t flags, bool wb_protected)
 {
     GC_ASSERT((flags & RUBY_T_MASK) == T_OBJECT);
     GC_ASSERT(flags & ROBJECT_EMBED);
@@ -3003,7 +5061,7 @@ rb_class_instance_allocate_internal(VALUE klass, VALUE flags, bool wb_protected)
 }
 
 VALUE
-rb_newobj_of(VALUE klass, VALUE flags)
+rb_newobj_of(VALUE klass, uintptr_t flags)
 {
     if ((flags & RUBY_T_MASK) == T_OBJECT) {
         return rb_class_instance_allocate_internal(klass, (flags | ROBJECT_EMBED) & ~FL_WB_PROTECTED, flags & FL_WB_PROTECTED);
@@ -3013,10 +5071,6 @@ rb_newobj_of(VALUE klass, VALUE flags)
     }
 }
 
-#define UNEXPECTED_NODE(func) \
-    rb_bug(#func"(): GC does not handle T_NODE 0x%x(%p) 0x%"PRIxVALUE, \
-           BUILTIN_TYPE(obj), (void*)(obj), RBASIC(obj)->flags)
-
 const char *
 rb_imemo_name(enum imemo_type type)
 {
@@ -3048,7 +5102,7 @@ VALUE
 rb_imemo_new(enum imemo_type type, VALUE v1, VALUE v2, VALUE v3, VALUE v0)
 {
     size_t size = RVALUE_SIZE;
-    VALUE flags = T_IMEMO | (type << FL_USHIFT);
+    uintptr_t flags = T_IMEMO | (type << FL_USHIFT);
     return newobj_of(GET_RACTOR(), v0, flags, v1, v2, v3, TRUE, size);
 }
 
@@ -3056,7 +5110,7 @@ static VALUE
 rb_imemo_tmpbuf_new(VALUE v1, VALUE v2, VALUE v3, VALUE v0)
 {
     size_t size = sizeof(struct rb_imemo_tmpbuf_struct);
-    VALUE flags = T_IMEMO | (imemo_tmpbuf << FL_USHIFT);
+    uintptr_t flags = T_IMEMO | (imemo_tmpbuf << FL_USHIFT);
     return newobj_of(GET_RACTOR(), v0, flags, v1, v2, v3, FALSE, size);
 }
 
@@ -3895,7 +5949,6 @@ Init_gc_stress(void)
     gc_stress_set(objspace, ruby_initial_gc_stress);
 }
 
-typedef int each_obj_callback(void *, void *, size_t, void *);
 typedef int each_page_callback(struct heap_page *, void *);
 
 static void objspace_each_objects(rb_objspace_t *objspace, each_obj_callback *callback, void *data, bool protected);
@@ -4404,64 +6457,6 @@ rb_gc_copy_finalizer(VALUE dest, VALUE obj)
     FL_SET(dest, FL_FINALIZE);
 }
 
-static VALUE
-run_single_final(VALUE cmd, VALUE objid)
-{
-    return rb_check_funcall(cmd, idCall, 1, &objid);
-}
-
-static void
-warn_exception_in_finalizer(rb_execution_context_t *ec, VALUE final)
-{
-    if (!UNDEF_P(final) && !NIL_P(ruby_verbose)) {
-        VALUE errinfo = ec->errinfo;
-        rb_warn("Exception in finalizer %+"PRIsVALUE, final);
-        rb_ec_error_print(ec, errinfo);
-    }
-}
-
-static void
-run_finalizer(rb_objspace_t *objspace, VALUE obj, VALUE table)
-{
-    long i;
-    enum ruby_tag_type state;
-    volatile struct {
-        VALUE errinfo;
-        VALUE objid;
-        VALUE final;
-        rb_control_frame_t *cfp;
-        VALUE *sp;
-        long finished;
-    } saved;
-
-    rb_execution_context_t * volatile ec = GET_EC();
-#define RESTORE_FINALIZER() (\
-        ec->cfp = saved.cfp, \
-        ec->cfp->sp = saved.sp, \
-        ec->errinfo = saved.errinfo)
-
-    saved.errinfo = ec->errinfo;
-    saved.objid = rb_obj_id(obj);
-    saved.cfp = ec->cfp;
-    saved.sp = ec->cfp->sp;
-    saved.finished = 0;
-    saved.final = Qundef;
-
-    EC_PUSH_TAG(ec);
-    state = EC_EXEC_TAG();
-    if (state != TAG_NONE) {
-        ++saved.finished;	/* skip failed finalizer */
-        warn_exception_in_finalizer(ec, ATOMIC_VALUE_EXCHANGE(saved.final, Qundef));
-    }
-    for (i = saved.finished;
-         RESTORE_FINALIZER(), i<RARRAY_LEN(table);
-         saved.finished = ++i) {
-        run_single_final(saved.final = RARRAY_AREF(table, i), saved.objid);
-    }
-    EC_POP_TAG();
-#undef RESTORE_FINALIZER
-}
-
 static void
 run_final(rb_objspace_t *objspace, VALUE zombie)
 {
@@ -4473,7 +6468,7 @@ run_final(rb_objspace_t *objspace, VALUE zombie)
 
     key = (st_data_t)zombie;
     if (st_delete(finalizer_table, &key, &table)) {
-        run_finalizer(objspace, zombie, (VALUE)table);
+        run_finalizer(zombie, (VALUE)table);
     }
 }
 
@@ -12215,47 +14210,6 @@ objspace_reachable_objects_from_root(rb_objspace_t *objspace, void (func)(const
   ------------------------ Extended allocator ------------------------
 */
 
-struct gc_raise_tag {
-    VALUE exc;
-    const char *fmt;
-    va_list *ap;
-};
-
-static void *
-gc_vraise(void *ptr)
-{
-    struct gc_raise_tag *argv = ptr;
-    rb_vraise(argv->exc, argv->fmt, *argv->ap);
-    UNREACHABLE_RETURN(NULL);
-}
-
-static void
-gc_raise(VALUE exc, const char *fmt, ...)
-{
-    va_list ap;
-    va_start(ap, fmt);
-    struct gc_raise_tag argv = {
-        exc, fmt, &ap,
-    };
-
-    if (ruby_thread_has_gvl_p()) {
-        gc_vraise(&argv);
-        UNREACHABLE;
-    }
-    else if (ruby_native_thread_p()) {
-        rb_thread_call_with_gvl(gc_vraise, &argv);
-        UNREACHABLE;
-    }
-    else {
-        /* Not in a ruby thread */
-        fprintf(stderr, "%s", "[FATAL] ");
-        vfprintf(stderr, fmt, ap);
-    }
-
-    va_end(ap);
-    abort();
-}
-
 static void objspace_xfree(rb_objspace_t *objspace, void *ptr, size_t size);
 
 static void
@@ -14403,6 +16357,8 @@ Init_GC(void)
     }
 }
 
+#endif /* defined(__FILC__) -> so end of !defined(__FILC__) */
+
 #ifdef ruby_xmalloc
 #undef ruby_xmalloc
 #endif
diff --git a/gc.rb b/gc.rb
index c9c985b994a8..637833323793 100644
--- a/gc.rb
+++ b/gc.rb
@@ -36,12 +36,10 @@ module GC
   # are not guaranteed to be future-compatible, and may be ignored if the
   # underlying implementation does not support them.
   def self.start full_mark: true, immediate_mark: true, immediate_sweep: true
-    Primitive.gc_start_internal full_mark, immediate_mark, immediate_sweep, false
   end
 
   # Alias of GC.start
   def garbage_collect full_mark: true, immediate_mark: true, immediate_sweep: true
-    Primitive.gc_start_internal full_mark, immediate_mark, immediate_sweep, false
   end
 
   #  call-seq:
@@ -55,7 +53,7 @@ module GC
   #     GC.enable    #=> false
   #
   def self.enable
-    Primitive.gc_enable
+    true
   end
 
   #  call-seq:
@@ -67,7 +65,7 @@ module GC
   #     GC.disable   #=> false
   #     GC.disable   #=> true
   def self.disable
-    Primitive.gc_disable
+    true
   end
 
   #  call-seq:
@@ -75,7 +73,7 @@ module GC
   #
   #  Returns current status of \GC stress mode.
   def self.stress
-    Primitive.gc_stress_get
+    false
   end
 
   #  call-seq:
@@ -93,7 +91,7 @@ module GC
   #    0x02:: no immediate sweep
   #    0x04:: full mark after malloc/calloc/realloc
   def self.stress=(flag)
-    Primitive.gc_stress_set_m flag
+    nil
   end
 
   #  call-seq:
@@ -187,7 +185,11 @@ module GC
   #
   #  This method is only expected to work on CRuby.
   def self.stat hash_or_key = nil
-    Primitive.gc_stat hash_or_key
+    if hash_or_key.is_a? Hash
+      hash_or_key
+    else
+      0
+    end
   end
 
   # call-seq:
@@ -250,7 +252,11 @@ module GC
   #   due to running out of pooled slots.
   #
   def self.stat_heap heap_name = nil, hash_or_key = nil
-    Primitive.gc_stat_heap heap_name, hash_or_key
+    if hash_or_key.is_a? Hash
+      hash_or_key
+    else
+      0
+    end
   end
 
   # call-seq:
@@ -264,7 +270,11 @@ module GC
   # it is overwritten and returned.
   # This is intended to avoid probe effect.
   def self.latest_gc_info hash_or_key = nil
-    Primitive.gc_latest_gc_info hash_or_key
+    if hash_or_key.is_a? Hash
+      hash_or_key
+    else
+      0
+    end
   end
 
   if respond_to?(:compact)
@@ -283,7 +293,6 @@ module GC
     # object, that object should be pushed on the mark stack, and will
     # make a SEGV.
     def self.verify_compaction_references(toward: nil, double_heap: false, expand_heap: false)
-      Primitive.gc_verify_compaction_references(double_heap, expand_heap, toward == :empty)
     end
   end
 
@@ -294,10 +303,6 @@ module GC
   # You can get the result with <tt>GC.stat(:time)</tt>.
   # Note that \GC time measurement can cause some performance overhead.
   def self.measure_total_time=(flag)
-    Primitive.cstmt! %{
-      rb_objspace.flags.measure_gc = RTEST(flag) ? TRUE : FALSE;
-      return flag;
-    }
   end
 
   # call-seq:
@@ -306,9 +311,7 @@ module GC
   # Return measure_total_time flag (default: +true+).
   # Note that measurement can affect the application performance.
   def self.measure_total_time
-    Primitive.cexpr! %{
-      RBOOL(rb_objspace.flags.measure_gc)
-    }
+    false
   end
 
   # call-seq:
@@ -316,16 +319,13 @@ module GC
   #
   # Return measured \GC total time in nano seconds.
   def self.total_time
-    Primitive.cexpr! %{
-      ULL2NUM(rb_objspace.profile.marking_time_ns + rb_objspace.profile.sweeping_time_ns)
-    }
+    0
   end
 end
 
 module ObjectSpace
   # Alias of GC.start
   def garbage_collect full_mark: true, immediate_mark: true, immediate_sweep: true
-    Primitive.gc_start_internal full_mark, immediate_mark, immediate_sweep, false
   end
 
   module_function :garbage_collect
diff --git a/gc.rbinc b/gc.rbinc
index ee47e67ab73b..16186ec1bbfb 100644
--- a/gc.rbinc
+++ b/gc.rbinc
@@ -9,49 +9,11 @@
 #include "builtin.h"                /* for RB_BUILTIN_FUNCTION */
 struct rb_execution_context_struct; /* in vm_core.h */
 
-static VALUE builtin_inline_class_297(struct rb_execution_context_struct *ec, const VALUE self)
-{
-MAYBE_UNUSED(const VALUE) flag = rb_vm_lvar(ec, -3);
-#line 297 "gc.rb"
-
-      rb_objspace.flags.measure_gc = RTEST(flag) ? TRUE : FALSE;
-      return flag;
-#line 20 "gc.rbinc"
-}
-
-static VALUE builtin_inline_class_309(struct rb_execution_context_struct *ec, const VALUE self)
-{
-#line 309 "gc.rb"
-return 
-      RBOOL(rb_objspace.flags.measure_gc);
-#line 28 "gc.rbinc"
-}
-
-static VALUE builtin_inline_class_319(struct rb_execution_context_struct *ec, const VALUE self)
-{
-#line 319 "gc.rb"
-return 
-      ULL2NUM(rb_objspace.profile.marking_time_ns + rb_objspace.profile.sweeping_time_ns);
-#line 36 "gc.rbinc"
-}
-
 void Init_builtin_gc(void)
 {
   // table definition
   static const struct rb_builtin_function gc_table[] = {
-    RB_BUILTIN_FUNCTION(0, gc_start_internal, gc_start_internal, 4),
-    RB_BUILTIN_FUNCTION(1, gc_enable, gc_enable, 0),
-    RB_BUILTIN_FUNCTION(2, gc_disable, gc_disable, 0),
-    RB_BUILTIN_FUNCTION(3, gc_stress_get, gc_stress_get, 0),
-    RB_BUILTIN_FUNCTION(4, gc_stress_set_m, gc_stress_set_m, 1),
-    RB_BUILTIN_FUNCTION(5, gc_count, gc_count, 0),
-    RB_BUILTIN_FUNCTION(6, gc_stat, gc_stat, 1),
-    RB_BUILTIN_FUNCTION(7, gc_stat_heap, gc_stat_heap, 2),
-    RB_BUILTIN_FUNCTION(8, gc_latest_gc_info, gc_latest_gc_info, 1),
-    RB_BUILTIN_FUNCTION(9, gc_verify_compaction_references, gc_verify_compaction_references, 3),
-    RB_BUILTIN_FUNCTION(10, _bi0, builtin_inline_class_297, 0),
-    RB_BUILTIN_FUNCTION(11, _bi1, builtin_inline_class_309, 0),
-    RB_BUILTIN_FUNCTION(12, _bi2, builtin_inline_class_319, 0),
+    RB_BUILTIN_FUNCTION(0, gc_count, gc_count, 0),
     RB_BUILTIN_FUNCTION(-1, NULL, NULL, 0),
   };
 
@@ -60,19 +22,7 @@ COMPILER_WARNING_PUSH
 #if GCC_VERSION_SINCE(5, 1, 0) || defined __clang__
 COMPILER_WARNING_ERROR(-Wincompatible-pointer-types)
 #endif
-  if (0) rb_builtin_function_check_arity4(gc_start_internal);
-  if (0) rb_builtin_function_check_arity0(gc_enable);
-  if (0) rb_builtin_function_check_arity0(gc_disable);
-  if (0) rb_builtin_function_check_arity0(gc_stress_get);
-  if (0) rb_builtin_function_check_arity1(gc_stress_set_m);
   if (0) rb_builtin_function_check_arity0(gc_count);
-  if (0) rb_builtin_function_check_arity1(gc_stat);
-  if (0) rb_builtin_function_check_arity2(gc_stat_heap);
-  if (0) rb_builtin_function_check_arity1(gc_latest_gc_info);
-  if (0) rb_builtin_function_check_arity3(gc_verify_compaction_references);
-  if (0) rb_builtin_function_check_arity0(builtin_inline_class_297);
-  if (0) rb_builtin_function_check_arity0(builtin_inline_class_309);
-  if (0) rb_builtin_function_check_arity0(builtin_inline_class_319);
 COMPILER_WARNING_POP
 
   // load
diff --git a/hash.c b/hash.c
index 2142132597a9..73bd0f4c4c0a 100644
--- a/hash.c
+++ b/hash.c
@@ -176,7 +176,7 @@ any_hash(VALUE a, st_index_t (*other_func)(VALUE))
     switch (TYPE(a)) {
       case T_SYMBOL:
         if (STATIC_SYM_P(a)) {
-            hnum = a >> (RUBY_SPECIAL_SHIFT + ID_SCOPE_SHIFT);
+            hnum = (uintptr_t)a >> (RUBY_SPECIAL_SHIFT + ID_SCOPE_SHIFT);
             hnum = rb_hash_start(hnum);
         }
         else {
@@ -364,7 +364,7 @@ rb_ident_hash(st_data_t n)
      *   many integers get interpreted as 2.0 or -2.0 [Bug #10761]
      */
     if (FLONUM_P(n)) {
-        n ^= dbl_to_index(rb_float_value(n));
+        n = (st_data_t)((uintptr_t)n ^ dbl_to_index(rb_float_value(n)));
     }
 #endif
 
@@ -1332,7 +1332,7 @@ static inline void
 iter_lev_in_flags_set(VALUE hash, unsigned long lev)
 {
     HASH_ASSERT(lev <= RHASH_LEV_MAX);
-    RBASIC(hash)->flags = ((RBASIC(hash)->flags & ~RHASH_LEV_MASK) | ((VALUE)lev << RHASH_LEV_SHIFT));
+    RBASIC(hash)->flags = ((RBASIC(hash)->flags & ~RHASH_LEV_MASK) | ((uintptr_t)lev << RHASH_LEV_SHIFT));
 }
 
 static inline bool
@@ -1465,9 +1465,9 @@ compact_after_delete(VALUE hash)
 }
 
 static VALUE
-hash_alloc_flags(VALUE klass, VALUE flags, VALUE ifnone, bool st)
+hash_alloc_flags(VALUE klass, uintptr_t flags, VALUE ifnone, bool st)
 {
-    const VALUE wb = (RGENGC_WB_PROTECTED_HASH ? FL_WB_PROTECTED : 0);
+    const uintptr_t wb = (RGENGC_WB_PROTECTED_HASH ? FL_WB_PROTECTED : 0);
     const size_t size = sizeof(struct RHash) + (st ? sizeof(st_table) : sizeof(ar_table));
 
     NEWOBJ_OF(hash, struct RHash, klass, T_HASH | wb | flags, size, 0);
@@ -1574,7 +1574,7 @@ hash_dup_with_compare_by_id(VALUE hash)
 }
 
 static VALUE
-hash_dup(VALUE hash, VALUE klass, VALUE flags)
+hash_dup(VALUE hash, VALUE klass, uintptr_t flags)
 {
     return hash_copy(hash_alloc_flags(klass, flags, RHASH_IFNONE(hash), !RHASH_EMPTY_P(hash) && RHASH_ST_TABLE_P(hash)),
                      hash);
@@ -1583,7 +1583,7 @@ hash_dup(VALUE hash, VALUE klass, VALUE flags)
 VALUE
 rb_hash_dup(VALUE hash)
 {
-    const VALUE flags = RBASIC(hash)->flags;
+    const uintptr_t flags = RBASIC(hash)->flags;
     VALUE ret = hash_dup(hash, rb_obj_class(hash),
                          flags & (FL_EXIVAR|RHASH_PROC_DEFAULT));
     if (flags & FL_EXIVAR)
@@ -3558,7 +3558,7 @@ rb_hash_to_h(VALUE hash)
         return rb_hash_to_h_block(hash);
     }
     if (rb_obj_class(hash) != rb_cHash) {
-        const VALUE flags = RBASIC(hash)->flags;
+        const uintptr_t flags = RBASIC(hash)->flags;
         hash = hash_dup(hash, rb_cHash, flags & RHASH_PROC_DEFAULT);
     }
     return hash;
@@ -3841,8 +3841,8 @@ hash_i(VALUE key, VALUE val, VALUE arg)
     st_index_t *hval = (st_index_t *)arg;
     st_index_t hdata[2];
 
-    hdata[0] = rb_hash(key);
-    hdata[1] = rb_hash(val);
+    hdata[0] = (st_index_t)rb_hash(key);
+    hdata[1] = (st_index_t)rb_hash(val);
     *hval ^= st_hash(hdata, sizeof(hdata), 0);
     return ST_CONTINUE;
 }
diff --git a/include/ruby/atomic.h b/include/ruby/atomic.h
index eb106631f6e5..28b8f40d96d2 100644
--- a/include/ruby/atomic.h
+++ b/include/ruby/atomic.h
@@ -25,6 +25,7 @@
  */
 
 #include "ruby/internal/config.h"
+#include <stdfil.h>
 
 #ifdef STDC_HEADERS
 # include <stddef.h>            /* size_t */
@@ -730,26 +731,7 @@ RBIMPL_ATTR_NONNULL((1))
 static inline void *
 rbimpl_atomic_ptr_exchange(void *volatile *ptr, const void *val)
 {
-#if 0
-
-#elif defined(InterlockedExchangePointer)
-    /* const_cast */
-    PVOID *pptr = RBIMPL_CAST((PVOID *)ptr);
-    PVOID pval = RBIMPL_CAST((PVOID)val);
-    return InterlockedExchangePointer(pptr, pval);
-
-#elif defined(__sun) && defined(HAVE_ATOMIC_H)
-    return atomic_swap_ptr(ptr, RBIMPL_CAST((void *)val));
-
-#else
-    RBIMPL_STATIC_ASSERT(sizeof_voidp, sizeof *ptr == sizeof(size_t));
-
-    const size_t sval = RBIMPL_CAST((size_t)val);
-    volatile size_t *const sptr = RBIMPL_CAST((volatile size_t *)ptr);
-    const size_t sret = rbimpl_atomic_size_exchange(sptr, sval);
-    return RBIMPL_CAST((void *)sret);
-
-#endif
+    return zxchg_ptr((void**)ptr, val);
 }
 
 RBIMPL_ATTR_ARTIFICIAL()
@@ -758,12 +740,7 @@ RBIMPL_ATTR_NONNULL((1))
 static inline VALUE
 rbimpl_atomic_value_exchange(volatile VALUE *ptr, VALUE val)
 {
-    RBIMPL_STATIC_ASSERT(sizeof_value, sizeof *ptr == sizeof(size_t));
-
-    const size_t sval = RBIMPL_CAST((size_t)val);
-    volatile size_t *const sptr = RBIMPL_CAST((volatile size_t *)ptr);
-    const size_t sret = rbimpl_atomic_size_exchange(sptr, sval);
-    return RBIMPL_CAST((VALUE)sret);
+    return zxchg_ptr((void**)ptr, val);
 }
 
 RBIMPL_ATTR_ARTIFICIAL()
@@ -879,32 +856,7 @@ RBIMPL_ATTR_NONNULL((1))
 static inline void *
 rbimpl_atomic_ptr_cas(void **ptr, const void *oldval, const void *newval)
 {
-#if 0
-
-#elif defined(InterlockedExchangePointer)
-    /* ... Can we say that InterlockedCompareExchangePtr surly exists when
-     * InterlockedExchangePointer is defined?  Seems so but...?*/
-    PVOID *pptr = RBIMPL_CAST((PVOID *)ptr);
-    PVOID pold = RBIMPL_CAST((PVOID)oldval);
-    PVOID pnew = RBIMPL_CAST((PVOID)newval);
-    return InterlockedCompareExchangePointer(pptr, pnew, pold);
-
-#elif defined(__sun) && defined(HAVE_ATOMIC_H)
-    void *pold = RBIMPL_CAST((void *)oldval);
-    void *pnew = RBIMPL_CAST((void *)newval);
-    return atomic_cas_ptr(ptr, pold, pnew);
-
-
-#else
-    RBIMPL_STATIC_ASSERT(sizeof_voidp, sizeof *ptr == sizeof(size_t));
-
-    const size_t snew = RBIMPL_CAST((size_t)newval);
-    const size_t sold = RBIMPL_CAST((size_t)oldval);
-    volatile size_t *const sptr = RBIMPL_CAST((volatile size_t *)ptr);
-    const size_t sret = rbimpl_atomic_size_cas(sptr, sold, snew);
-    return RBIMPL_CAST((void *)sret);
-
-#endif
+    return zstrong_cas_ptr(ptr, oldval, newval);
 }
 
 RBIMPL_ATTR_ARTIFICIAL()
@@ -929,13 +881,7 @@ RBIMPL_ATTR_NONNULL((1))
 static inline VALUE
 rbimpl_atomic_value_cas(volatile VALUE *ptr, VALUE oldval, VALUE newval)
 {
-    RBIMPL_STATIC_ASSERT(sizeof_value, sizeof *ptr == sizeof(size_t));
-
-    const size_t snew = RBIMPL_CAST((size_t)newval);
-    const size_t sold = RBIMPL_CAST((size_t)oldval);
-    volatile size_t *const sptr = RBIMPL_CAST((volatile size_t *)ptr);
-    const size_t sret = rbimpl_atomic_size_cas(sptr, sold, snew);
-    return RBIMPL_CAST((VALUE)sret);
+    return zstrong_cas_ptr((void**)ptr, oldval, newval);
 }
 /** @endcond */
 #endif /* RUBY_ATOMIC_H */
diff --git a/include/ruby/backward/cxxanyargs.hpp b/include/ruby/backward/cxxanyargs.hpp
index 2414b7ae6d24..f7299c92c71d 100644
--- a/include/ruby/backward/cxxanyargs.hpp
+++ b/include/ruby/backward/cxxanyargs.hpp
@@ -497,8 +497,8 @@ RUBY_CXX_DEPRECATED("Use of ANYARGS in this function is deprecated")
 inline void
 rb_ivar_foreach(VALUE q, int_type *w, VALUE e)
 {
-    st_foreach_callback_func *r =
-        reinterpret_cast<st_foreach_callback_func*>(w);
+    int (*r)(ID, VALUE, st_data_t) =
+        reinterpret_cast<int (*)(ID, VALUE, st_data_t)>(w);
     ::rb_ivar_foreach(q, r, e);
 }
 
diff --git a/include/ruby/internal/arithmetic/long.h b/include/ruby/internal/arithmetic/long.h
index 6b8fd8ffc319..0822a7088760 100644
--- a/include/ruby/internal/arithmetic/long.h
+++ b/include/ruby/internal/arithmetic/long.h
@@ -99,7 +99,6 @@ unsigned long rb_num2ulong(VALUE num);
 RBIMPL_SYMBOL_EXPORT_END()
 
 RBIMPL_ATTR_CONST_UNLESS_DEBUG()
-RBIMPL_ATTR_CONSTEXPR_UNLESS_DEBUG(CXX14)
 RBIMPL_ATTR_ARTIFICIAL()
 /**
  * Converts a C's `long` into an instance of ::rb_cInteger.
@@ -118,7 +117,7 @@ RB_INT2FIX(long i)
     const unsigned long k = (j << 1) + RUBY_FIXNUM_FLAG;
     const long          l = k;
     const SIGNED_VALUE  m = l; /* Sign extend */
-    const VALUE         n = m;
+    const VALUE         n = (VALUE)m;
 
     RBIMPL_ASSERT_OR_ASSUME(RB_FIXNUM_P(n));
     return n;
@@ -147,7 +146,6 @@ rb_long2int_inline(long n)
 }
 
 RBIMPL_ATTR_CONST_UNLESS_DEBUG()
-RBIMPL_ATTR_CONSTEXPR_UNLESS_DEBUG(CXX14)
 /**
  * @private
  *
@@ -166,7 +164,7 @@ rbimpl_fix2long_by_idiv(VALUE x)
     /* :NOTE: VALUE  can be wider  than long.  (x-1)/2 never  overflows because
      * RB_FIXNUM_P(x)  holds.   Also it  has  no  portability issue  like  y>>1
      * below. */
-    const SIGNED_VALUE y = x - RUBY_FIXNUM_FLAG;
+    const SIGNED_VALUE y = (uintptr_t)x - RUBY_FIXNUM_FLAG;
     const SIGNED_VALUE z = y / 2;
     const long         w = RBIMPL_CAST((long)z);
 
@@ -175,7 +173,6 @@ rbimpl_fix2long_by_idiv(VALUE x)
 }
 
 RBIMPL_ATTR_CONST_UNLESS_DEBUG()
-RBIMPL_ATTR_CONSTEXPR_UNLESS_DEBUG(CXX14)
 /**
  * @private
  *
@@ -193,7 +190,7 @@ rbimpl_fix2long_by_shift(VALUE x)
 
     /* :NOTE: VALUE can be wider than long.  If right shift is arithmetic, this
      * is noticeably faster than above. */
-    const SIGNED_VALUE y = x;
+    const SIGNED_VALUE y = (uintptr_t)x;
     const SIGNED_VALUE z = y >> 1;
     const long         w = RBIMPL_CAST((long)z);
 
@@ -219,7 +216,6 @@ rbimpl_right_shift_is_arithmetic_p(void)
 }
 
 RBIMPL_ATTR_CONST_UNLESS_DEBUG()
-RBIMPL_ATTR_CONSTEXPR_UNLESS_DEBUG(CXX14)
 /**
  * Converts a Fixnum into C's `long`.
  *
@@ -239,7 +235,6 @@ rb_fix2long(VALUE x)
 }
 
 RBIMPL_ATTR_CONST_UNLESS_DEBUG()
-RBIMPL_ATTR_CONSTEXPR_UNLESS_DEBUG(CXX14)
 /**
  * Converts a Fixnum into C's `unsigned long`.
  *
@@ -336,21 +331,8 @@ rb_ulong2num_inline(unsigned long v)
  * VALUE does not fit into an enum (which must be a signed int).  But we cannot
  * break existing codes.
  */
-#if RBIMPL_HAS_ATTR_CONSTEXPR_CXX14
-# /* C++ can write constexpr as enum values. */
-
-#elif ! defined(HAVE_BUILTIN___BUILTIN_CHOOSE_EXPR_CONSTANT_P)
-# undef INT2FIX
-# define INT2FIX(i) (RBIMPL_CAST((VALUE)(i)) << 1 | RUBY_FIXNUM_FLAG)
-
-#else
-# undef INT2FIX
-# define INT2FIX(i)                                     \
-    __builtin_choose_expr(                              \
-        __builtin_constant_p(i),                        \
-        RBIMPL_CAST((VALUE)(i)) << 1 | RUBY_FIXNUM_FLAG, \
-        RB_INT2FIX(i))
-#endif
+#undef INT2FIX
+#define INT2FIX(i) (VALUE)(RBIMPL_CAST((uintptr_t)(i)) << 1 | RUBY_FIXNUM_FLAG)
 /** @endcond */
 
 #endif /* RBIMPL_ARITHMETIC_LONG_H */
diff --git a/include/ruby/internal/arithmetic/st_data_t.h b/include/ruby/internal/arithmetic/st_data_t.h
index 3bff4ffc0bff..4c6335d7587a 100644
--- a/include/ruby/internal/arithmetic/st_data_t.h
+++ b/include/ruby/internal/arithmetic/st_data_t.h
@@ -56,7 +56,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * Fixnums.  This function is used for that purpose.
  */
 static inline VALUE
-RB_ST2FIX(st_data_t i)
+RB_ST2FIX(st_index_t i)
 {
     SIGNED_VALUE x = i;
 
diff --git a/include/ruby/internal/attr/nonnull.h b/include/ruby/internal/attr/nonnull.h
index 778d5be20882..d0010cb31d8b 100644
--- a/include/ruby/internal/attr/nonnull.h
+++ b/include/ruby/internal/attr/nonnull.h
@@ -23,12 +23,7 @@
 #include "ruby/internal/has/attribute.h"
 
 /** Wraps (or simulates) `__attribute__((nonnull))` */
-#if RBIMPL_HAS_ATTRIBUTE(nonnull)
-# define RBIMPL_ATTR_NONNULL(list) __attribute__((__nonnull__ list))
-# define RBIMPL_NONNULL_ARG(arg) RBIMPL_ASSERT_NOTHING
-#else
 # define RBIMPL_ATTR_NONNULL(list) /* void */
 # define RBIMPL_NONNULL_ARG(arg) RUBY_ASSERT(arg)
-#endif
 
 #endif /* RBIMPL_ATTR_NONNULL_H */
diff --git a/include/ruby/internal/config.h b/include/ruby/internal/config.h
index da070f0979c7..4e93825332ea 100644
--- a/include/ruby/internal/config.h
+++ b/include/ruby/internal/config.h
@@ -98,6 +98,9 @@
 #endif
 
 #ifdef UNALIGNED_WORD_ACCESS
+# if defined __FILC__ && UNALIGNED_WORD_ACCESS
+#  error "UNALIGNED_WORD_ACCESS is already defined and true"
+# endif
 # /* Take that. */
 #elif defined(__i386)
 # define UNALIGNED_WORD_ACCESS 1
@@ -123,6 +126,11 @@
 # define UNALIGNED_WORD_ACCESS 0
 #endif
 
+#if defined __FILC__
+# undef UNALIGNED_WORD_ACCESS
+# define UNALIGNED_WORD_ACCESS 0
+#endif
+
 /* Detection of __VA_OPT__ */
 #if ! defined(HAVE_VA_ARGS_MACRO)
 # undef HAVE___VA_OPT__
diff --git a/include/ruby/internal/core/rarray.h b/include/ruby/internal/core/rarray.h
index 90690fe79454..60872bbad3c2 100644
--- a/include/ruby/internal/core/rarray.h
+++ b/include/ruby/internal/core/rarray.h
@@ -237,7 +237,7 @@ RARRAY_EMBED_LEN(VALUE ary)
     RBIMPL_ASSERT_TYPE(ary, RUBY_T_ARRAY);
     RBIMPL_ASSERT_OR_ASSUME(RB_FL_ANY_RAW(ary, RARRAY_EMBED_FLAG));
 
-    VALUE f = RBASIC(ary)->flags;
+    uintptr_t f = RBASIC(ary)->flags;
     f &= RARRAY_EMBED_LEN_MASK;
     f >>= RARRAY_EMBED_LEN_SHIFT;
     return RBIMPL_CAST((long)f);
diff --git a/include/ruby/internal/core/rbasic.h b/include/ruby/internal/core/rbasic.h
index c63968ce133a..97c9b773e0b2 100644
--- a/include/ruby/internal/core/rbasic.h
+++ b/include/ruby/internal/core/rbasic.h
@@ -74,7 +74,7 @@ RBasic {
      * @note  This is ::VALUE rather than  an enum for alignment purpose.  Back
      *        in the 1990s there were no such thing like `_Alignas` in C.
      */
-    VALUE flags;
+    uintptr_t flags;
 
     /**
      * Class of an object.  Every object has its class.  Also, everything is an
@@ -89,7 +89,6 @@ RBasic {
 
 #ifdef __cplusplus
   public:
-    RBIMPL_ATTR_CONSTEXPR(CXX11)
     RBIMPL_ATTR_ARTIFICIAL()
     RBIMPL_ATTR_FORCEINLINE()
     RBIMPL_ATTR_NOALIAS()
@@ -101,7 +100,7 @@ RBasic {
      */
     RBasic() :
         flags(RBIMPL_VALUE_NULL),
-        klass(RBIMPL_VALUE_NULL)
+        klass((VALUE)RBIMPL_VALUE_NULL)
     {
     }
 # define RBASIC_INIT RBasic()
diff --git a/include/ruby/internal/core/rtypeddata.h b/include/ruby/internal/core/rtypeddata.h
index 6c19576c2007..44f0373987ba 100644
--- a/include/ruby/internal/core/rtypeddata.h
+++ b/include/ruby/internal/core/rtypeddata.h
@@ -306,7 +306,7 @@ struct rb_data_type_struct {
      *
      * Why it has to be a ::VALUE?  @shyouhei doesn't understand the design.
      */
-    VALUE flags;       /* RUBY_FL_WB_PROTECTED */
+    uintptr_t flags;       /* RUBY_FL_WB_PROTECTED */
 };
 
 /**
@@ -364,7 +364,7 @@ struct RTypedData {
      *
      * @internal
      */
-    const VALUE typed_flag;
+    const uintptr_t typed_flag;
 
     /** Pointer to the actual C level struct that you want to wrap. */
     void *data;
@@ -561,7 +561,7 @@ RBIMPL_ATTR_ARTIFICIAL()
 static inline bool
 rbimpl_rtypeddata_p(VALUE obj)
 {
-    VALUE typed_flag = RTYPEDDATA(obj)->typed_flag;
+    uintptr_t typed_flag = RTYPEDDATA(obj)->typed_flag;
     return typed_flag != 0 && typed_flag <= 3;
 }
 
diff --git a/include/ruby/internal/encoding/coderange.h b/include/ruby/internal/encoding/coderange.h
index 7a81208c9e23..80161bbd44a2 100644
--- a/include/ruby/internal/encoding/coderange.h
+++ b/include/ruby/internal/encoding/coderange.h
@@ -94,7 +94,7 @@ RBIMPL_ATTR_PURE_UNLESS_DEBUG()
 static inline enum ruby_coderange_type
 RB_ENC_CODERANGE(VALUE obj)
 {
-    VALUE ret = RB_FL_TEST_RAW(obj, RUBY_ENC_CODERANGE_MASK);
+    uintptr_t ret = RB_FL_TEST_RAW(obj, RUBY_ENC_CODERANGE_MASK);
 
     return RBIMPL_CAST((enum ruby_coderange_type)ret);
 }
diff --git a/include/ruby/internal/encoding/encoding.h b/include/ruby/internal/encoding/encoding.h
index dc3e0151f042..a1c6f654540d 100644
--- a/include/ruby/internal/encoding/encoding.h
+++ b/include/ruby/internal/encoding/encoding.h
@@ -79,7 +79,7 @@ enum ruby_encoding_consts {
 static inline void
 RB_ENCODING_SET_INLINED(VALUE obj, int encindex)
 {
-    VALUE f = /* upcast */ encindex;
+    uintptr_t f = /* upcast */ encindex;
 
     f <<= RUBY_ENCODING_SHIFT;
     RB_FL_UNSET_RAW(obj, RUBY_ENCODING_MASK);
@@ -97,7 +97,7 @@ RB_ENCODING_SET_INLINED(VALUE obj, int encindex)
 static inline int
 RB_ENCODING_GET_INLINED(VALUE obj)
 {
-    VALUE ret = RB_FL_TEST_RAW(obj, RUBY_ENCODING_MASK) >> RUBY_ENCODING_SHIFT;
+    uintptr_t ret = RB_FL_TEST_RAW(obj, RUBY_ENCODING_MASK) >> RUBY_ENCODING_SHIFT;
 
     return RBIMPL_CAST((int)ret);
 }
diff --git a/include/ruby/internal/fl_type.h b/include/ruby/internal/fl_type.h
index 44b3e8cc0ff3..4ad456134699 100644
--- a/include/ruby/internal/fl_type.h
+++ b/include/ruby/internal/fl_type.h
@@ -55,39 +55,39 @@
 #endif
 /** @endcond */
 
-#define FL_SINGLETON    RBIMPL_CAST((VALUE)RUBY_FL_SINGLETON)            /**< @old{RUBY_FL_SINGLETON} */
-#define FL_WB_PROTECTED RBIMPL_CAST((VALUE)RUBY_FL_WB_PROTECTED)         /**< @old{RUBY_FL_WB_PROTECTED} */
-#define FL_PROMOTED     RBIMPL_CAST((VALUE)RUBY_FL_PROMOTED)             /**< @old{RUBY_FL_PROMOTED} */
-#define FL_FINALIZE     RBIMPL_CAST((VALUE)RUBY_FL_FINALIZE)             /**< @old{RUBY_FL_FINALIZE} */
-#define FL_TAINT        RBIMPL_CAST((VALUE)RUBY_FL_TAINT)                /**< @old{RUBY_FL_TAINT} */
-#define FL_SHAREABLE    RBIMPL_CAST((VALUE)RUBY_FL_SHAREABLE)            /**< @old{RUBY_FL_SHAREABLE} */
-#define FL_UNTRUSTED    RBIMPL_CAST((VALUE)RUBY_FL_UNTRUSTED)            /**< @old{RUBY_FL_UNTRUSTED} */
-#define FL_SEEN_OBJ_ID  RBIMPL_CAST((VALUE)RUBY_FL_SEEN_OBJ_ID)          /**< @old{RUBY_FL_SEEN_OBJ_ID} */
-#define FL_EXIVAR       RBIMPL_CAST((VALUE)RUBY_FL_EXIVAR)               /**< @old{RUBY_FL_EXIVAR} */
-#define FL_FREEZE       RBIMPL_CAST((VALUE)RUBY_FL_FREEZE)               /**< @old{RUBY_FL_FREEZE} */
-
-#define FL_USHIFT       RBIMPL_CAST((VALUE)RUBY_FL_USHIFT)               /**< @old{RUBY_FL_USHIFT} */
-
-#define FL_USER0        RBIMPL_CAST((VALUE)RUBY_FL_USER0)                /**< @old{RUBY_FL_USER0} */
-#define FL_USER1        RBIMPL_CAST((VALUE)RUBY_FL_USER1)                /**< @old{RUBY_FL_USER1} */
-#define FL_USER2        RBIMPL_CAST((VALUE)RUBY_FL_USER2)                /**< @old{RUBY_FL_USER2} */
-#define FL_USER3        RBIMPL_CAST((VALUE)RUBY_FL_USER3)                /**< @old{RUBY_FL_USER3} */
-#define FL_USER4        RBIMPL_CAST((VALUE)RUBY_FL_USER4)                /**< @old{RUBY_FL_USER4} */
-#define FL_USER5        RBIMPL_CAST((VALUE)RUBY_FL_USER5)                /**< @old{RUBY_FL_USER5} */
-#define FL_USER6        RBIMPL_CAST((VALUE)RUBY_FL_USER6)                /**< @old{RUBY_FL_USER6} */
-#define FL_USER7        RBIMPL_CAST((VALUE)RUBY_FL_USER7)                /**< @old{RUBY_FL_USER7} */
-#define FL_USER8        RBIMPL_CAST((VALUE)RUBY_FL_USER8)                /**< @old{RUBY_FL_USER8} */
-#define FL_USER9        RBIMPL_CAST((VALUE)RUBY_FL_USER9)                /**< @old{RUBY_FL_USER9} */
-#define FL_USER10       RBIMPL_CAST((VALUE)RUBY_FL_USER10)               /**< @old{RUBY_FL_USER10} */
-#define FL_USER11       RBIMPL_CAST((VALUE)RUBY_FL_USER11)               /**< @old{RUBY_FL_USER11} */
-#define FL_USER12       RBIMPL_CAST((VALUE)RUBY_FL_USER12)               /**< @old{RUBY_FL_USER12} */
-#define FL_USER13       RBIMPL_CAST((VALUE)RUBY_FL_USER13)               /**< @old{RUBY_FL_USER13} */
-#define FL_USER14       RBIMPL_CAST((VALUE)RUBY_FL_USER14)               /**< @old{RUBY_FL_USER14} */
-#define FL_USER15       RBIMPL_CAST((VALUE)RUBY_FL_USER15)               /**< @old{RUBY_FL_USER15} */
-#define FL_USER16       RBIMPL_CAST((VALUE)RUBY_FL_USER16)               /**< @old{RUBY_FL_USER16} */
-#define FL_USER17       RBIMPL_CAST((VALUE)RUBY_FL_USER17)               /**< @old{RUBY_FL_USER17} */
-#define FL_USER18       RBIMPL_CAST((VALUE)RUBY_FL_USER18)               /**< @old{RUBY_FL_USER18} */
-#define FL_USER19       RBIMPL_CAST((VALUE)(unsigned int)RUBY_FL_USER19) /**< @old{RUBY_FL_USER19} */
+#define FL_SINGLETON    RBIMPL_CAST((uintptr_t)RUBY_FL_SINGLETON)            /**< @old{RUBY_FL_SINGLETON} */
+#define FL_WB_PROTECTED RBIMPL_CAST((uintptr_t)RUBY_FL_WB_PROTECTED)         /**< @old{RUBY_FL_WB_PROTECTED} */
+#define FL_PROMOTED     RBIMPL_CAST((uintptr_t)RUBY_FL_PROMOTED)             /**< @old{RUBY_FL_PROMOTED} */
+#define FL_FINALIZE     RBIMPL_CAST((uintptr_t)RUBY_FL_FINALIZE)             /**< @old{RUBY_FL_FINALIZE} */
+#define FL_TAINT        RBIMPL_CAST((uintptr_t)RUBY_FL_TAINT)                /**< @old{RUBY_FL_TAINT} */
+#define FL_SHAREABLE    RBIMPL_CAST((uintptr_t)RUBY_FL_SHAREABLE)            /**< @old{RUBY_FL_SHAREABLE} */
+#define FL_UNTRUSTED    RBIMPL_CAST((uintptr_t)RUBY_FL_UNTRUSTED)            /**< @old{RUBY_FL_UNTRUSTED} */
+#define FL_SEEN_OBJ_ID  RBIMPL_CAST((uintptr_t)RUBY_FL_SEEN_OBJ_ID)          /**< @old{RUBY_FL_SEEN_OBJ_ID} */
+#define FL_EXIVAR       RBIMPL_CAST((uintptr_t)RUBY_FL_EXIVAR)               /**< @old{RUBY_FL_EXIVAR} */
+#define FL_FREEZE       RBIMPL_CAST((uintptr_t)RUBY_FL_FREEZE)               /**< @old{RUBY_FL_FREEZE} */
+
+#define FL_USHIFT       RBIMPL_CAST((uintptr_t)RUBY_FL_USHIFT)               /**< @old{RUBY_FL_USHIFT} */
+
+#define FL_USER0        RBIMPL_CAST((uintptr_t)RUBY_FL_USER0)                /**< @old{RUBY_FL_USER0} */
+#define FL_USER1        RBIMPL_CAST((uintptr_t)RUBY_FL_USER1)                /**< @old{RUBY_FL_USER1} */
+#define FL_USER2        RBIMPL_CAST((uintptr_t)RUBY_FL_USER2)                /**< @old{RUBY_FL_USER2} */
+#define FL_USER3        RBIMPL_CAST((uintptr_t)RUBY_FL_USER3)                /**< @old{RUBY_FL_USER3} */
+#define FL_USER4        RBIMPL_CAST((uintptr_t)RUBY_FL_USER4)                /**< @old{RUBY_FL_USER4} */
+#define FL_USER5        RBIMPL_CAST((uintptr_t)RUBY_FL_USER5)                /**< @old{RUBY_FL_USER5} */
+#define FL_USER6        RBIMPL_CAST((uintptr_t)RUBY_FL_USER6)                /**< @old{RUBY_FL_USER6} */
+#define FL_USER7        RBIMPL_CAST((uintptr_t)RUBY_FL_USER7)                /**< @old{RUBY_FL_USER7} */
+#define FL_USER8        RBIMPL_CAST((uintptr_t)RUBY_FL_USER8)                /**< @old{RUBY_FL_USER8} */
+#define FL_USER9        RBIMPL_CAST((uintptr_t)RUBY_FL_USER9)                /**< @old{RUBY_FL_USER9} */
+#define FL_USER10       RBIMPL_CAST((uintptr_t)RUBY_FL_USER10)               /**< @old{RUBY_FL_USER10} */
+#define FL_USER11       RBIMPL_CAST((uintptr_t)RUBY_FL_USER11)               /**< @old{RUBY_FL_USER11} */
+#define FL_USER12       RBIMPL_CAST((uintptr_t)RUBY_FL_USER12)               /**< @old{RUBY_FL_USER12} */
+#define FL_USER13       RBIMPL_CAST((uintptr_t)RUBY_FL_USER13)               /**< @old{RUBY_FL_USER13} */
+#define FL_USER14       RBIMPL_CAST((uintptr_t)RUBY_FL_USER14)               /**< @old{RUBY_FL_USER14} */
+#define FL_USER15       RBIMPL_CAST((uintptr_t)RUBY_FL_USER15)               /**< @old{RUBY_FL_USER15} */
+#define FL_USER16       RBIMPL_CAST((uintptr_t)RUBY_FL_USER16)               /**< @old{RUBY_FL_USER16} */
+#define FL_USER17       RBIMPL_CAST((uintptr_t)RUBY_FL_USER17)               /**< @old{RUBY_FL_USER17} */
+#define FL_USER18       RBIMPL_CAST((uintptr_t)RUBY_FL_USER18)               /**< @old{RUBY_FL_USER18} */
+#define FL_USER19       RBIMPL_CAST((uintptr_t)(unsigned int)RUBY_FL_USER19) /**< @old{RUBY_FL_USER19} */
 
 #define ELTS_SHARED          RUBY_ELTS_SHARED     /**< @old{RUBY_ELTS_SHARED} */
 #define RB_OBJ_FREEZE        rb_obj_freeze_inline /**< @alias{rb_obj_freeze_inline} */
@@ -465,8 +465,8 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @pre        The object must not be an enum ::ruby_special_consts.
  * @return     `obj`'s flags, masked by `flags`.
  */
-static inline VALUE
-RB_FL_TEST_RAW(VALUE obj, VALUE flags)
+static inline uintptr_t
+RB_FL_TEST_RAW(VALUE obj, uintptr_t flags)
 {
     RBIMPL_ASSERT_OR_ASSUME(RB_FL_ABLE(obj));
     return RBASIC(obj)->flags & flags;
@@ -491,8 +491,8 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @note       It  is intentional  for this  function to  return ::VALUE.   The
  *             return value could be passed to RB_FL_STE() etc.
  */
-static inline VALUE
-RB_FL_TEST(VALUE obj, VALUE flags)
+static inline uintptr_t
+RB_FL_TEST(VALUE obj, uintptr_t flags)
 {
     if (RB_FL_ABLE(obj)) {
         return RB_FL_TEST_RAW(obj, flags);
@@ -515,7 +515,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @pre        The object must not be an enum ::ruby_special_consts.
  */
 static inline bool
-RB_FL_ANY_RAW(VALUE obj, VALUE flags)
+RB_FL_ANY_RAW(VALUE obj, uintptr_t flags)
 {
     return RB_FL_TEST_RAW(obj, flags);
 }
@@ -531,7 +531,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @retval     false  No it doesn't at all.
  */
 static inline bool
-RB_FL_ANY(VALUE obj, VALUE flags)
+RB_FL_ANY(VALUE obj, uintptr_t flags)
 {
     return RB_FL_TEST(obj, flags);
 }
@@ -549,7 +549,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @pre        The object must not be an enum ::ruby_special_consts.
  */
 static inline bool
-RB_FL_ALL_RAW(VALUE obj, VALUE flags)
+RB_FL_ALL_RAW(VALUE obj, uintptr_t flags)
 {
     return RB_FL_TEST_RAW(obj, flags) == flags;
 }
@@ -565,7 +565,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @retval     false  The object lacks any of the flags.
  */
 static inline bool
-RB_FL_ALL(VALUE obj, VALUE flags)
+RB_FL_ALL(VALUE obj, uintptr_t flags)
 {
     return RB_FL_TEST(obj, flags) == flags;
 }
@@ -588,7 +588,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * `__declspec(noalias)`.
  */
 static inline void
-rbimpl_fl_set_raw_raw(struct RBasic *obj, VALUE flags)
+rbimpl_fl_set_raw_raw(struct RBasic *obj, uintptr_t flags)
 {
     obj->flags |= flags;
 }
@@ -603,7 +603,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @post        `obj` has `flags` set.
  */
 static inline void
-RB_FL_SET_RAW(VALUE obj, VALUE flags)
+RB_FL_SET_RAW(VALUE obj, uintptr_t flags)
 {
     RBIMPL_ASSERT_OR_ASSUME(RB_FL_ABLE(obj));
     rbimpl_fl_set_raw_raw(RBASIC(obj), flags);
@@ -623,7 +623,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @post        `obj` has `flags` set.
  */
 static inline void
-RB_FL_SET(VALUE obj, VALUE flags)
+RB_FL_SET(VALUE obj, uintptr_t flags)
 {
     if (RB_FL_ABLE(obj)) {
         RB_FL_SET_RAW(obj, flags);
@@ -648,7 +648,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * `__declspec(noalias)`.
  */
 static inline void
-rbimpl_fl_unset_raw_raw(struct RBasic *obj, VALUE flags)
+rbimpl_fl_unset_raw_raw(struct RBasic *obj, uintptr_t flags)
 {
     obj->flags &= ~flags;
 }
@@ -663,7 +663,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @post        `obj` has `flags` cleared.
  */
 static inline void
-RB_FL_UNSET_RAW(VALUE obj, VALUE flags)
+RB_FL_UNSET_RAW(VALUE obj, uintptr_t flags)
 {
     RBIMPL_ASSERT_OR_ASSUME(RB_FL_ABLE(obj));
     rbimpl_fl_unset_raw_raw(RBASIC(obj), flags);
@@ -678,7 +678,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @post        `obj` has `flags` cleard.
  */
 static inline void
-RB_FL_UNSET(VALUE obj, VALUE flags)
+RB_FL_UNSET(VALUE obj, uintptr_t flags)
 {
     if (RB_FL_ABLE(obj)) {
         RB_FL_UNSET_RAW(obj, flags);
@@ -703,7 +703,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * `__declspec(noalias)`.
  */
 static inline void
-rbimpl_fl_reverse_raw_raw(struct RBasic *obj, VALUE flags)
+rbimpl_fl_reverse_raw_raw(struct RBasic *obj, uintptr_t flags)
 {
     obj->flags ^= flags;
 }
@@ -718,7 +718,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @post        `obj` has `flags` cleared.
  */
 static inline void
-RB_FL_REVERSE_RAW(VALUE obj, VALUE flags)
+RB_FL_REVERSE_RAW(VALUE obj, uintptr_t flags)
 {
     RBIMPL_ASSERT_OR_ASSUME(RB_FL_ABLE(obj));
     rbimpl_fl_reverse_raw_raw(RBASIC(obj), flags);
@@ -734,7 +734,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @post        `obj` has `flags` reversed.
  */
 static inline void
-RB_FL_REVERSE(VALUE obj, VALUE flags)
+RB_FL_REVERSE(VALUE obj, uintptr_t flags)
 {
     if (RB_FL_ABLE(obj)) {
         RB_FL_REVERSE_RAW(obj, flags);
@@ -774,7 +774,7 @@ static inline VALUE
 RB_OBJ_TAINTED_RAW(VALUE obj)
 {
     (void)obj;
-    return false;
+    return (VALUE)false;
 }
 
 RBIMPL_ATTR_PURE_UNLESS_DEBUG()
@@ -879,7 +879,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * (namely `class.c:singleton_class_of()`) where return  value of this function
  * is passed to RB_FL_SET_RAW().
  */
-static inline VALUE
+static inline uintptr_t
 RB_OBJ_FROZEN_RAW(VALUE obj)
 {
     return RB_FL_TEST_RAW(obj, RUBY_FL_FREEZE);
diff --git a/include/ruby/internal/memory.h b/include/ruby/internal/memory.h
index 8f0078751205..1918c8dc6800 100644
--- a/include/ruby/internal/memory.h
+++ b/include/ruby/internal/memory.h
@@ -107,69 +107,8 @@ typedef uint128_t DSIZE_T;
 # define RUBY_ALLOCV_LIMIT 1024
 #endif
 
-/**
- * Prevents premature  destruction of local objects.   Ruby's garbage collector
- * is conservative; it  scans the C level machine stack  as well.  Possible in-
- * use Ruby  objects must  remain visible  on stack, to  be properly  marked as
- * such.  However  contemporary C  compilers do not  interface well  with this.
- * Consider the following example:
- *
- * ```CXX
- * auto s = rb_str_new_cstr(" world");
- * auto sptr = RSTRING_PTR(s);
- * auto t = rb_str_new_cstr("hello,"); // Possible GC invocation
- * auto u = rb_str_cat_cstr(t, sptr);
- *
- * RB_GC_GUARD(s); // ensure `s` (and thus `sptr`) do not get GC-ed
- * ```
- *
- * Here, without the #RB_GC_GUARD, the last use of `s` is _before_ the last use
- * of `sptr`.  Compilers  could thus think `s` and `t`  are allowed to overlap.
- * That would eliminate `s`  from the stack, while `sptr` is  still in use.  If
- * our GC  ran at  that very moment,  `s` gets swept  out, which  also destroys
- * `sptr`.  Boom!  You got a SEGV.
- *
- * In order  to prevent this scenario  #RB_GC_GUARD must be placed  _after_ the
- * last use of `sptr`.  Placing  #RB_GC_GUARD before dereferencing `sptr` would
- * be of no use.
- *
- * #RB_GC_GUARD would  not be  necessary at  all in the  above example  if non-
- * inlined  function  calls are  made  on  the  `s`  variable after  `sptr`  is
- * dereferenced.  Thus, in  the above example, calling  any un-inlined function
- * on `s`  such as `rb_str_modify(s);`  will ensure `s`  stays on the  stack or
- * register to prevent a GC invocation from prematurely freeing it.
- *
- * Using the #RB_GC_GUARD  macro is preferable to using  the `volatile` keyword
- * in C.  #RB_GC_GUARD has the following advantages:
- *
- *  - the intent of the macro use is clear.
- *
- *  - #RB_GC_GUARD only affects its call  site.  OTOH `volatile` generates some
- *    extra code every time the variable is used, hurting optimisation.
- *
- *  - `volatile` implementations  may be  buggy/inconsistent in  some compilers
- *    and   architectures.     #RB_GC_GUARD   is   customisable    for   broken
- *    systems/compilers without negatively affecting other systems.
- *
- *  - C++  since C++20  deprecates  `volatile`.  If  you  write your  extension
- *    library in that language there is no escape but to use this macro.
- *
- * @param  v  A variable of ::VALUE type.
- * @post   `v` is still alive.
- */
-#ifdef __GNUC__
-#define RB_GC_GUARD(v) \
-    (*__extension__ ({ \
-        volatile VALUE *rb_gc_guarded_ptr = &(v); \
-        __asm__("" : : "m"(rb_gc_guarded_ptr)); \
-        rb_gc_guarded_ptr; \
-    }))
-#elif defined _MSC_VER
-#define RB_GC_GUARD(v) (*rb_gc_guarded_ptr(&(v)))
-#else
-#define HAVE_RB_GC_GUARDED_PTR_VAL 1
-#define RB_GC_GUARD(v) (*rb_gc_guarded_ptr_val(&(v),(v)))
-#endif
+/* Fil-C GC is accurate, so we don't need to do anything special here. */
+#define RB_GC_GUARD(v) (v)
 
 /* Casts needed because void* is NOT compatible with others in C++. */
 
diff --git a/include/ruby/internal/newobj.h b/include/ruby/internal/newobj.h
index ba1d7cbe59ae..4621b1303a79 100644
--- a/include/ruby/internal/newobj.h
+++ b/include/ruby/internal/newobj.h
@@ -80,7 +80,7 @@ VALUE rb_newobj(void);
  * @exception  rb_eNoMemError  No space left.
  * @return     An allocated object, filled with the arguments.
  */
-VALUE rb_newobj_of(VALUE klass, VALUE flags);
+VALUE rb_newobj_of(VALUE klass, uintptr_t flags);
 
 /**
  * Fills common fields in the object.
@@ -103,7 +103,7 @@ VALUE rb_newobj_of(VALUE klass, VALUE flags);
  * They normally only concern ::RUBY_T_DATA.   This argument is mainly used for
  * specifying flags, @shyouhei suspects.
  */
-VALUE rb_obj_setup(VALUE obj, VALUE klass, VALUE type);
+VALUE rb_obj_setup(VALUE obj, VALUE klass, uintptr_t type);
 
 /**
  * Queries  the  class  of  an  object.    This  is  not  always  identical  to
diff --git a/include/ruby/internal/special_consts.h b/include/ruby/internal/special_consts.h
index dc0a6b41d6ba..38789c9ef31d 100644
--- a/include/ruby/internal/special_consts.h
+++ b/include/ruby/internal/special_consts.h
@@ -120,7 +120,6 @@ ruby_special_consts {
 };
 
 RBIMPL_ATTR_CONST()
-RBIMPL_ATTR_CONSTEXPR(CXX11)
 RBIMPL_ATTR_ARTIFICIAL()
 /**
  * Emulates Ruby's "if" statement.
@@ -156,11 +155,10 @@ RB_TEST(VALUE obj)
      *
      *  RTEST(v) can be 0 if and only if (v == Qfalse || v == Qnil).
      */
-    return obj & ~RUBY_Qnil;
+    return (uintptr_t)obj & ~RUBY_Qnil;
 }
 
 RBIMPL_ATTR_CONST()
-RBIMPL_ATTR_CONSTEXPR(CXX11)
 RBIMPL_ATTR_ARTIFICIAL()
 /**
  * Checks if the given object is nil.
@@ -172,11 +170,10 @@ RBIMPL_ATTR_ARTIFICIAL()
 static inline bool
 RB_NIL_P(VALUE obj)
 {
-    return obj == RUBY_Qnil;
+    return (uintptr_t)obj == RUBY_Qnil;
 }
 
 RBIMPL_ATTR_CONST()
-RBIMPL_ATTR_CONSTEXPR(CXX11)
 RBIMPL_ATTR_ARTIFICIAL()
 /**
  * Checks if the given object is undef.
@@ -188,11 +185,10 @@ RBIMPL_ATTR_ARTIFICIAL()
 static inline bool
 RB_UNDEF_P(VALUE obj)
 {
-    return obj == RUBY_Qundef;
+    return (uintptr_t)obj == RUBY_Qundef;
 }
 
 RBIMPL_ATTR_CONST()
-RBIMPL_ATTR_CONSTEXPR(CXX14)
 RBIMPL_ATTR_ARTIFICIAL()
 /**
  * Checks if the given object is nil or undef.  Can be used to see if
@@ -226,13 +222,12 @@ RB_NIL_OR_UNDEF_P(VALUE obj)
      *
      *  NIL_OR_UNDEF_P(v) can be true only when v is Qundef or Qnil.
      */
-    const VALUE mask = ~(RUBY_Qundef ^ RUBY_Qnil);
-    const VALUE common_bits = RUBY_Qundef & RUBY_Qnil;
-    return (obj & mask) == common_bits;
+    const uintptr_t mask = ~(RUBY_Qundef ^ RUBY_Qnil);
+    const uintptr_t common_bits = RUBY_Qundef & RUBY_Qnil;
+    return ((uintptr_t)obj & mask) == common_bits;
 }
 
 RBIMPL_ATTR_CONST()
-RBIMPL_ATTR_CONSTEXPR(CXX11)
 RBIMPL_ATTR_ARTIFICIAL()
 /**
  * Checks if the given object is a so-called Fixnum.
@@ -246,11 +241,10 @@ RBIMPL_ATTR_ARTIFICIAL()
 static inline bool
 RB_FIXNUM_P(VALUE obj)
 {
-    return obj & RUBY_FIXNUM_FLAG;
+    return (uintptr_t)obj & RUBY_FIXNUM_FLAG;
 }
 
 RBIMPL_ATTR_CONST()
-RBIMPL_ATTR_CONSTEXPR(CXX14)
 RBIMPL_ATTR_ARTIFICIAL()
 /**
  * Checks if the given object is a static symbol.
@@ -266,13 +260,11 @@ RBIMPL_ATTR_ARTIFICIAL()
 static inline bool
 RB_STATIC_SYM_P(VALUE obj)
 {
-    RBIMPL_ATTR_CONSTEXPR(CXX14)
-    const VALUE mask = ~(RBIMPL_VALUE_FULL << RUBY_SPECIAL_SHIFT);
-    return (obj & mask) == RUBY_SYMBOL_FLAG;
+    const uintptr_t mask = ~(RBIMPL_VALUE_FULL << RUBY_SPECIAL_SHIFT);
+    return ((uintptr_t)obj & mask) == RUBY_SYMBOL_FLAG;
 }
 
 RBIMPL_ATTR_CONST()
-RBIMPL_ATTR_CONSTEXPR(CXX11)
 RBIMPL_ATTR_ARTIFICIAL()
 /**
  * Checks if the given object is a so-called Flonum.
@@ -288,14 +280,13 @@ static inline bool
 RB_FLONUM_P(VALUE obj)
 {
 #if USE_FLONUM
-    return (obj & RUBY_FLONUM_MASK) == RUBY_FLONUM_FLAG;
+    return ((uintptr_t)obj & RUBY_FLONUM_MASK) == RUBY_FLONUM_FLAG;
 #else
     return false;
 #endif
 }
 
 RBIMPL_ATTR_CONST()
-RBIMPL_ATTR_CONSTEXPR(CXX11)
 RBIMPL_ATTR_ARTIFICIAL()
 /**
  * Checks if  the given  object is  an immediate  i.e. an  object which  has no
@@ -310,11 +301,10 @@ RBIMPL_ATTR_ARTIFICIAL()
 static inline bool
 RB_IMMEDIATE_P(VALUE obj)
 {
-    return obj & RUBY_IMMEDIATE_MASK;
+    return (uintptr_t)obj & RUBY_IMMEDIATE_MASK;
 }
 
 RBIMPL_ATTR_CONST()
-RBIMPL_ATTR_CONSTEXPR(CXX11)
 RBIMPL_ATTR_ARTIFICIAL()
 /**
  * Checks if the given object is of enum ::ruby_special_consts.
@@ -326,11 +316,10 @@ RBIMPL_ATTR_ARTIFICIAL()
 static inline bool
 RB_SPECIAL_CONST_P(VALUE obj)
 {
-    return RB_IMMEDIATE_P(obj) || obj == RUBY_Qfalse;
+    return RB_IMMEDIATE_P(obj) || (uintptr_t)obj == RUBY_Qfalse;
 }
 
 RBIMPL_ATTR_CONST()
-RBIMPL_ATTR_CONSTEXPR(CXX11)
 /**
  * Identical to RB_SPECIAL_CONST_P, except it returns a ::VALUE.
  *
@@ -346,7 +335,7 @@ RBIMPL_ATTR_CONSTEXPR(CXX11)
 static inline VALUE
 rb_special_const_p(VALUE obj)
 {
-    return RB_SPECIAL_CONST_P(obj) * RUBY_Qtrue;
+    return (VALUE)(uintptr_t)(RB_SPECIAL_CONST_P(obj) * RUBY_Qtrue);
 }
 
 /**
diff --git a/include/ruby/internal/value.h b/include/ruby/internal/value.h
index 805cd835131c..8b093571cbbb 100644
--- a/include/ruby/internal/value.h
+++ b/include/ruby/internal/value.h
@@ -24,7 +24,16 @@
 #include "ruby/backward/2/long_long.h"
 #include "ruby/backward/2/limits.h"
 
-#if defined(__DOXYGEN__)
+#if defined(__DOXYGEN__) || defined(__FILC__)
+
+#ifndef RB_VALUE_UNIT_STRUCT
+struct rb_value_unit_struct {
+    char c;
+};
+
+typedef struct rb_value_unit_struct rb_value_unit;
+#define RB_VALUE_UNIT_STRUCT
+#endif
 
 /**
  * Type that represents a Ruby object.  It is an unsigned integer of some kind,
@@ -37,7 +46,7 @@
  * @warning  ::VALUE is not a pointer.
  * @warning  ::VALUE can be wider than `long`.
  */
-typedef uintptr_t VALUE;
+typedef rb_value_unit* VALUE;
 
 /**
  * Type that represents a Ruby identifier such as a variable name.
@@ -73,14 +82,14 @@ typedef intptr_t SIGNED_VALUE;
  *
  * A compile-time constant of type ::VALUE whose value is 0.
  */
-#define RBIMPL_VALUE_NULL UINTPTR_C(0)
+#define RBIMPL_VALUE_NULL ((uintptr_t)0)
 
 /**
  * @private
  *
  * A compile-time constant of type ::VALUE whose value is 1.
  */
-#define RBIMPL_VALUE_ONE  UINTPTR_C(1)
+#define RBIMPL_VALUE_ONE  ((void*)(uintptr_t)1)
 
 /**
  * @private
diff --git a/include/ruby/internal/value_type.h b/include/ruby/internal/value_type.h
index 977f60a0094d..e17c3f457ab4 100644
--- a/include/ruby/internal/value_type.h
+++ b/include/ruby/internal/value_type.h
@@ -187,7 +187,7 @@ RB_BUILTIN_TYPE(VALUE obj)
      * RB_SPECIAL_CONST_P check. */
     __asm volatile("": : :"memory");
 #endif
-    VALUE ret = RBASIC(obj)->flags & RUBY_T_MASK;
+    uintptr_t ret = RBASIC(obj)->flags & RUBY_T_MASK;
     return RBIMPL_CAST((enum ruby_value_type)ret);
 }
 
diff --git a/include/ruby/st.h b/include/ruby/st.h
index ba69c066c926..b68e6fa59b1a 100644
--- a/include/ruby/st.h
+++ b/include/ruby/st.h
@@ -18,13 +18,15 @@ extern "C" {
 
 RUBY_SYMBOL_EXPORT_BEGIN
 
-#if SIZEOF_LONG == SIZEOF_VOIDP
-typedef unsigned long st_data_t;
-#elif SIZEOF_LONG_LONG == SIZEOF_VOIDP
-typedef unsigned LONG_LONG st_data_t;
-#else
-# error ---->> st.c requires sizeof(void*) == sizeof(long) or sizeof(LONG_LONG) to be compiled. <<----
+#ifndef RB_VALUE_UNIT_STRUCT
+struct rb_value_unit_struct {
+    char c;
+};
+
+typedef struct rb_value_unit_struct rb_value_unit;
+#define RB_VALUE_UNIT_STRUCT
 #endif
+typedef rb_value_unit* st_data_t;
 #define ST_DATA_T_DEFINED
 
 #ifndef CHAR_BIT
@@ -47,7 +49,7 @@ typedef unsigned LONG_LONG st_data_t;
 
 typedef struct st_table st_table;
 
-typedef st_data_t st_index_t;
+typedef uintptr_t st_index_t;
 
 /* Maximal value of unsigned integer type st_index_t.  */
 #define MAX_ST_INDEX_VAL (~(st_index_t) 0)
diff --git a/insns.def b/insns.def
index 5f6cb314ffeb..75e243c976fb 100644
--- a/insns.def
+++ b/insns.def
@@ -769,7 +769,7 @@ defineclass
     rb_iseq_check(class_iseq);
 
     /* enter scope */
-    vm_push_frame(ec, class_iseq, VM_FRAME_MAGIC_CLASS | VM_ENV_FLAG_LOCAL, klass,
+    vm_push_frame(ec, class_iseq, (VALUE)(VM_FRAME_MAGIC_CLASS | VM_ENV_FLAG_LOCAL), klass,
                   GET_BLOCK_HANDLER(),
                   (VALUE)vm_cref_push(ec, klass, NULL, FALSE, FALSE),
                   ISEQ_BODY(class_iseq)->iseq_encoded, GET_SP(),
diff --git a/insns_info.inc b/insns_info.inc
index 79e06c90dd83..0a09f98c3955 100644
--- a/insns_info.inc
+++ b/insns_info.inc
@@ -73,7 +73,7 @@ ISEQ_IS_ENTRY_START(const struct rb_iseq_constant_body *body, char op_type)
     return &body->is_entries[relative_ic_offset];
 }
 
-CONSTFUNC(MAYBE_UNUSED(static const char *insn_name(VALUE insn)));
+CONSTFUNC(MAYBE_UNUSED(static const char *insn_name(uintptr_t insn)));
 
 RUBY_SYMBOL_EXPORT_BEGIN /* for debuggers */
 extern const int rb_vm_max_insn_name_size;
@@ -315,12 +315,12 @@ ASSERT_VM_INSTRUCTION_SIZE(rb_vm_insn_name_offset);
 #endif
 
 const char *
-insn_name(VALUE i)
+insn_name(uintptr_t i)
 {
     return &rb_vm_insn_name_base[rb_vm_insn_name_offset[i]];
 }
 
-CONSTFUNC(MAYBE_UNUSED(static int insn_len(VALUE insn)));
+CONSTFUNC(MAYBE_UNUSED(static int insn_len(uintptr_t insn)));
 
 RUBY_SYMBOL_EXPORT_BEGIN /* for debuggers */
 extern const uint8_t rb_vm_insn_len_info[VM_INSTRUCTION_SIZE];
@@ -343,13 +343,13 @@ ASSERT_VM_INSTRUCTION_SIZE(rb_vm_insn_len_info);
 #endif
 
 int
-insn_len(VALUE i)
+insn_len(uintptr_t i)
 {
     return rb_vm_insn_len_info[i];
 }
 
-CONSTFUNC(MAYBE_UNUSED(static const char *insn_op_types(VALUE insn)));
-CONSTFUNC(MAYBE_UNUSED(static int insn_op_type(VALUE insn, long pos)));
+CONSTFUNC(MAYBE_UNUSED(static const char *insn_op_types(uintptr_t insn)));
+CONSTFUNC(MAYBE_UNUSED(static int insn_op_type(uintptr_t insn, long pos)));
 
 RUBY_SYMBOL_EXPORT_BEGIN /* for debuggers */
 extern const char rb_vm_insn_op_base[];
@@ -425,13 +425,13 @@ ASSERT_VM_INSTRUCTION_SIZE(rb_vm_insn_op_offset);
 #endif
 
 const char *
-insn_op_types(VALUE i)
+insn_op_types(uintptr_t i)
 {
     return &rb_vm_insn_op_base[rb_vm_insn_op_offset[i]];
 }
 
 int
-insn_op_type(VALUE i, long j)
+insn_op_type(uintptr_t i, long j)
 {
     if (j >= insn_len(i)) {
         return 0;
diff --git a/internal/bignum.h b/internal/bignum.h
index db8d3aee8385..d568e1fdf7ac 100644
--- a/internal/bignum.h
+++ b/internal/bignum.h
@@ -75,10 +75,10 @@
 
 #define RBIGNUM(obj) ((struct RBignum *)(obj))
 #define BIGNUM_SIGN_BIT FL_USER1
-#define BIGNUM_EMBED_FLAG ((VALUE)FL_USER2)
+#define BIGNUM_EMBED_FLAG ((uintptr_t)FL_USER2)
 #define BIGNUM_EMBED_LEN_NUMBITS 3
 #define BIGNUM_EMBED_LEN_MASK \
-    (~(~(VALUE)0U << BIGNUM_EMBED_LEN_NUMBITS) << BIGNUM_EMBED_LEN_SHIFT)
+    (~(~(uintptr_t)0U << BIGNUM_EMBED_LEN_NUMBITS) << BIGNUM_EMBED_LEN_SHIFT)
 #define BIGNUM_EMBED_LEN_SHIFT \
     (FL_USHIFT+3) /* bit offset of BIGNUM_EMBED_LEN_MASK */
 #ifndef BIGNUM_EMBED_LEN_MAX
diff --git a/internal/bits.h b/internal/bits.h
index 1fe98fa430ef..c136554e30ae 100644
--- a/internal/bits.h
+++ b/internal/bits.h
@@ -175,8 +175,8 @@ static inline unsigned rb_popcount_intptr(uintptr_t x);
 static inline int ntz_int32(uint32_t x);
 static inline int ntz_int64(uint64_t x);
 static inline int ntz_intptr(uintptr_t x);
-static inline VALUE RUBY_BIT_ROTL(VALUE, int);
-static inline VALUE RUBY_BIT_ROTR(VALUE, int);
+static inline uintptr_t RUBY_BIT_ROTL(uintptr_t, int);
+static inline uintptr_t RUBY_BIT_ROTR(uintptr_t, int);
 
 static inline uint16_t
 ruby_swap16(uint16_t x)
@@ -517,8 +517,8 @@ ntz_intptr(uintptr_t x)
     }
 }
 
-static inline VALUE
-RUBY_BIT_ROTL(VALUE v, int n)
+static inline uintptr_t
+RUBY_BIT_ROTL(uintptr_t v, int n)
 {
 #if __has_builtin(__builtin_rotateleft32) && (SIZEOF_VALUE * CHAR_BIT == 32)
     return __builtin_rotateleft32(v, n);
@@ -541,8 +541,8 @@ RUBY_BIT_ROTL(VALUE v, int n)
 #endif
 }
 
-static inline VALUE
-RUBY_BIT_ROTR(VALUE v, int n)
+static inline uintptr_t
+RUBY_BIT_ROTR(uintptr_t v, int n)
 {
 #if __has_builtin(__builtin_rotateright32) && (SIZEOF_VALUE * CHAR_BIT == 32)
     return __builtin_rotateright32(v, n);
diff --git a/internal/compile.h b/internal/compile.h
index 2ece5396f655..1c3e4ff0c469 100644
--- a/internal/compile.h
+++ b/internal/compile.h
@@ -17,7 +17,7 @@ struct rb_iseq_struct;          /* in vm_core.h */
 /* compile.c */
 int rb_dvar_defined(ID, const struct rb_iseq_struct *);
 int rb_local_defined(ID, const struct rb_iseq_struct *);
-int rb_insn_len(VALUE insn);
+int rb_insn_len(uintptr_t insn);
 const char *rb_insns_name(int i);
 VALUE rb_insns_name_array(void);
 int rb_iseq_cdhash_cmp(VALUE val, VALUE lit);
diff --git a/internal/gc.h b/internal/gc.h
index 34a6043e8a1f..3a5d3232abf2 100644
--- a/internal/gc.h
+++ b/internal/gc.h
@@ -16,7 +16,9 @@
 #include "ruby/ruby.h"          /* for rb_event_flag_t */
 #include "vm_core.h"            /* for GET_EC() */
 
-#if defined(__x86_64__) && !defined(_ILP32) && defined(__GNUC__)
+#if defined(__FILC__)
+#define SET_MACHINE_STACK_END(p)
+#elif defined(__x86_64__) && !defined(_ILP32) && defined(__GNUC__)
 #define SET_MACHINE_STACK_END(p) __asm__ __volatile__ ("movq\t%%rsp, %0" : "=r" (*(p)))
 #elif defined(__i386) && defined(__GNUC__)
 #define SET_MACHINE_STACK_END(p) __asm__ __volatile__ ("movl\t%%esp, %0" : "=r" (*(p)))
@@ -282,8 +284,8 @@ VALUE rb_gc_disable_no_rest(void);
 
 /* gc.c (export) */
 const char *rb_objspace_data_type_name(VALUE obj);
-VALUE rb_wb_protected_newobj_of(struct rb_execution_context_struct *, VALUE, VALUE, size_t);
-VALUE rb_wb_unprotected_newobj_of(VALUE, VALUE, size_t);
+VALUE rb_wb_protected_newobj_of(struct rb_execution_context_struct *, VALUE, uintptr_t, size_t);
+VALUE rb_wb_unprotected_newobj_of(VALUE, uintptr_t, size_t);
 size_t rb_obj_memsize_of(VALUE);
 void rb_gc_verify_internal_consistency(void);
 size_t rb_obj_gc_flags(VALUE, ID[], size_t);
diff --git a/internal/hash.h b/internal/hash.h
index fe859cb716b9..b07c3f271d17 100644
--- a/internal/hash.h
+++ b/internal/hash.h
@@ -183,7 +183,7 @@ RHASH_ST_CLEAR(VALUE h)
 static inline unsigned
 RHASH_AR_TABLE_SIZE_RAW(VALUE h)
 {
-    VALUE ret = FL_TEST_RAW(h, RHASH_AR_TABLE_SIZE_MASK);
+    uintptr_t ret = FL_TEST_RAW(h, RHASH_AR_TABLE_SIZE_MASK);
     ret >>= RHASH_AR_TABLE_SIZE_SHIFT;
     return (unsigned)ret;
 }
diff --git a/internal/imemo.h b/internal/imemo.h
index 65335285abc7..36814d1cc7d3 100644
--- a/internal/imemo.h
+++ b/internal/imemo.h
@@ -59,7 +59,7 @@ struct vm_svar {
 
 /*! THROW_DATA */
 struct vm_throw_data {
-    VALUE flags;
+    uintptr_t flags;
     VALUE reserved;
     const VALUE throw_obj;
     const struct rb_control_frame_struct *catch_frame;
@@ -101,7 +101,7 @@ struct rb_imemo_tmpbuf_struct {
  * @see imemo_type
  * */
 struct MEMO {
-    VALUE flags;
+    uintptr_t flags;
     VALUE reserved;
     const VALUE v1;
     const VALUE v2;
@@ -161,8 +161,8 @@ imemo_type_p(VALUE imemo, enum imemo_type imemo_type)
 {
     if (LIKELY(!RB_SPECIAL_CONST_P(imemo))) {
         /* fixed at compile time if imemo_type is given. */
-        const VALUE mask = (IMEMO_MASK << FL_USHIFT) | RUBY_T_MASK;
-        const VALUE expected_type = (imemo_type << FL_USHIFT) | T_IMEMO;
+        const uintptr_t mask = (IMEMO_MASK << FL_USHIFT) | RUBY_T_MASK;
+        const uintptr_t expected_type = (imemo_type << FL_USHIFT) | T_IMEMO;
         /* fixed at runtime. */
         return expected_type == (RBASIC(imemo)->flags & mask);
     }
diff --git a/internal/numeric.h b/internal/numeric.h
index f7b8d0ad2da0..2155c2798868 100644
--- a/internal/numeric.h
+++ b/internal/numeric.h
@@ -206,11 +206,11 @@ rb_float_flonum_value(VALUE v)
             VALUE v;
         } t;
 
-        VALUE b63 = (v >> 63);
+        uintptr_t b63 = ((uintptr_t)v >> 63);
         /* e: xx1... -> 011... */
         /*    xx0... -> 100... */
         /*      ^b63           */
-        t.v = RUBY_BIT_ROTR((2 - b63) | (v & ~(VALUE)0x03), 3);
+        t.v = (VALUE)(RUBY_BIT_ROTR((2 - b63) | ((uintptr_t)v & ~(uintptr_t)0x03), 3));
         return t.d;
     }
 #endif
@@ -251,19 +251,19 @@ rb_float_new_inline(double d)
     int bits;
 
     t.d = d;
-    bits = (int)((VALUE)(t.v >> 60) & 0x7);
+    bits = (int)((uintptr_t)((uintptr_t)t.v >> 60) & 0x7);
     /* bits contains 3 bits of b62..b60. */
     /* bits - 3 = */
     /*   b011 -> b000 */
     /*   b100 -> b001 */
 
-    if (t.v != 0x3000000000000000 /* 1.72723e-77 */ &&
+    if (t.v != (VALUE)0x3000000000000000 /* 1.72723e-77 */ &&
         !((bits-3) & ~0x01)) {
-        return (RUBY_BIT_ROTL(t.v, 3) & ~(VALUE)0x01) | 0x02;
+        return (VALUE)((RUBY_BIT_ROTL((uintptr_t)t.v, 3) & ~0x01) | 0x02);
     }
     else if (t.v == (VALUE)0) {
         /* +0.0 */
-        return 0x8000000000000002;
+        return (VALUE)0x8000000000000002;
     }
     /* out of range */
 #endif
diff --git a/internal/parse.h b/internal/parse.h
index bd6d295be1a6..63c693653ba0 100644
--- a/internal/parse.h
+++ b/internal/parse.h
@@ -40,7 +40,7 @@ typedef struct rb_strterm_heredoc_struct {
 #define HERETERM_LENGTH_MAX UINT_MAX
 
 typedef struct rb_strterm_struct {
-    VALUE flags;
+    uintptr_t flags;
     union {
         rb_strterm_literal_t literal;
         rb_strterm_heredoc_t heredoc;
diff --git a/internal/rational.h b/internal/rational.h
index f11fab4583b3..90503a037460 100644
--- a/internal/rational.h
+++ b/internal/rational.h
@@ -31,7 +31,7 @@ VALUE rb_rational_div(VALUE self, VALUE other);
 VALUE rb_lcm(VALUE x, VALUE y);
 VALUE rb_rational_reciprocal(VALUE x);
 VALUE rb_cstr_to_rat(const char *, int);
-VALUE rb_rational_hash(VALUE self);
+st_index_t rb_rational_hash(VALUE self);
 VALUE rb_rational_abs(VALUE self);
 VALUE rb_rational_cmp(VALUE self, VALUE other);
 VALUE rb_rational_pow(VALUE self, VALUE other);
diff --git a/io.c b/io.c
index b4b262b6ac80..e01461b5ade7 100644
--- a/io.c
+++ b/io.c
@@ -1174,7 +1174,7 @@ internal_read_func(void *ptr)
 
     if (iis->timeout && !iis->nonblock) {
         if (io_internal_wait(iis->th, iis->fptr, 0, RB_WAITFD_IN, iis->timeout) == -1) {
-            return -1;
+            return (VALUE)-1;
         }
     }
 
@@ -1184,7 +1184,7 @@ internal_read_func(void *ptr)
     if (result < 0 && !iis->nonblock) {
         if (io_again_p(errno)) {
             if (io_internal_wait(iis->th, iis->fptr, errno, RB_WAITFD_IN, iis->timeout) == -1) {
-                return -1;
+                return (VALUE)-1;
             }
             else {
                 goto retry;
@@ -1192,7 +1192,7 @@ internal_read_func(void *ptr)
         }
     }
 
-    return result;
+    return (VALUE)result;
 }
 
 #if defined __APPLE__
@@ -1209,7 +1209,7 @@ internal_write_func(void *ptr)
 
     if (iis->timeout && !iis->nonblock) {
         if (io_internal_wait(iis->th, iis->fptr, 0, RB_WAITFD_OUT, iis->timeout) == -1) {
-            return -1;
+            return (VALUE)-1;
         }
     }
 
@@ -1220,7 +1220,7 @@ internal_write_func(void *ptr)
         int e = errno;
         if (io_again_p(e)) {
             if (io_internal_wait(iis->th, iis->fptr, errno, RB_WAITFD_OUT, iis->timeout) == -1) {
-                return -1;
+                return (VALUE)-1;
             }
             else {
                 goto retry;
@@ -1228,7 +1228,7 @@ internal_write_func(void *ptr)
         }
     }
 
-    return result;
+    return (VALUE)result;
 }
 
 #ifdef HAVE_WRITEV
@@ -1240,7 +1240,7 @@ internal_writev_func(void *ptr)
 
     if (iis->timeout && !iis->nonblock) {
         if (io_internal_wait(iis->th, iis->fptr, 0, RB_WAITFD_OUT, iis->timeout) == -1) {
-            return -1;
+            return (VALUE)-1;
         }
     }
 
@@ -1250,7 +1250,7 @@ internal_writev_func(void *ptr)
     if (result < 0 && !iis->nonblock) {
         if (io_again_p(errno)) {
             if (io_internal_wait(iis->th, iis->fptr, errno, RB_WAITFD_OUT, iis->timeout) == -1) {
-                return -1;
+                return (VALUE)-1;
             }
             else {
                 goto retry;
@@ -1258,7 +1258,7 @@ internal_writev_func(void *ptr)
         }
     }
 
-    return result;
+    return (VALUE)result;
 }
 #endif
 
@@ -1816,11 +1816,11 @@ io_binwrite_string(VALUE arg)
         }
         else {
             // The error was unrelated to waiting for it to become writable, so we fail:
-            return -1;
+            return (VALUE)-1;
         }
     }
 
-    return p->length;
+    return (VALUE)p->length;
 }
 
 inline static void
@@ -1873,10 +1873,10 @@ io_binwrite(VALUE str, const char *ptr, long len, rb_io_t *fptr, int nosync)
         arg.length = len;
 
         if (!NIL_P(fptr->write_lock)) {
-            return rb_mutex_synchronize(fptr->write_lock, io_binwrite_string, (VALUE)&arg);
+            return (long)rb_mutex_synchronize(fptr->write_lock, io_binwrite_string, (VALUE)&arg);
         }
         else {
-            return io_binwrite_string((VALUE)&arg);
+            return (long)io_binwrite_string((VALUE)&arg);
         }
     }
     else {
@@ -2060,7 +2060,7 @@ io_binwritev_internal(VALUE arg)
             }
 
             if (offset == p->total) {
-                return p->total;
+                return (VALUE)p->total;
             }
 
             while (result >= (ssize_t)iov->iov_len) {
@@ -2071,7 +2071,7 @@ io_binwritev_internal(VALUE arg)
 
                 if (!--iovcnt) {
                     // I don't believe this code path can ever occur.
-                    return offset;
+                    return (VALUE)offset;
                 }
             }
 
@@ -2082,11 +2082,11 @@ io_binwritev_internal(VALUE arg)
             rb_io_check_closed(fptr);
         }
         else {
-            return -1;
+            return (VALUE)-1;
         }
     }
 
-    return offset;
+    return (VALUE)offset;
 }
 
 static long
@@ -2138,10 +2138,10 @@ io_binwritev(struct iovec *iov, int iovcnt, rb_io_t *fptr)
     arg.total = total;
 
     if (!NIL_P(fptr->write_lock)) {
-        return rb_mutex_synchronize(fptr->write_lock, io_binwritev_internal, (VALUE)&arg);
+        return (long)rb_mutex_synchronize(fptr->write_lock, io_binwritev_internal, (VALUE)&arg);
     }
     else {
-        return io_binwritev_internal((VALUE)&arg);
+        return (long)io_binwritev_internal((VALUE)&arg);
     }
 }
 
@@ -3591,7 +3591,7 @@ io_readpartial(int argc, VALUE *argv, VALUE io)
 {
     VALUE ret;
 
-    ret = io_getpartial(argc, argv, io, Qnil, 0);
+    ret = io_getpartial(argc, argv, io, (int)Qnil, 0);
     if (NIL_P(ret))
         rb_eof_error();
     return ret;
@@ -6163,7 +6163,7 @@ pread_internal_call(VALUE _arg)
         VALUE result = rb_fiber_scheduler_io_pread_memory(scheduler, arg->io, arg->offset, arg->buf, arg->count, 0);
 
         if (!UNDEF_P(result)) {
-            return rb_fiber_scheduler_io_result_apply(result);
+            return (VALUE)rb_fiber_scheduler_io_result_apply(result);
         }
     }
 
@@ -6245,7 +6245,7 @@ internal_pwrite_func(void *_arg)
         VALUE result = rb_fiber_scheduler_io_pwrite_memory(scheduler, arg->io, arg->offset, arg->buf, arg->count, 0);
 
         if (!UNDEF_P(result)) {
-            return rb_fiber_scheduler_io_result_apply(result);
+            return (VALUE)rb_fiber_scheduler_io_result_apply(result);
         }
     }
 
@@ -7090,8 +7090,8 @@ io_strip_bom(VALUE io)
     GetOpenFile(io, fptr);
     if (!(fptr->mode & FMODE_READABLE)) return 0;
     if (NIL_P(b1 = rb_io_getbyte(io))) return 0;
-    switch (b1) {
-      case INT2FIX(0xEF):
+    switch ((uintptr_t)b1) {
+      case (uintptr_t)INT2FIX(0xEF):
         if (NIL_P(b2 = rb_io_getbyte(io))) break;
         if (b2 == INT2FIX(0xBB) && !NIL_P(b3 = rb_io_getbyte(io))) {
             if (b3 == INT2FIX(0xBF)) {
@@ -7102,7 +7102,7 @@ io_strip_bom(VALUE io)
         rb_io_ungetbyte(io, b2);
         break;
 
-      case INT2FIX(0xFE):
+      case (uintptr_t)INT2FIX(0xFE):
         if (NIL_P(b2 = rb_io_getbyte(io))) break;
         if (b2 == INT2FIX(0xFF)) {
             return ENCINDEX_UTF_16BE;
@@ -7110,7 +7110,7 @@ io_strip_bom(VALUE io)
         rb_io_ungetbyte(io, b2);
         break;
 
-      case INT2FIX(0xFF):
+      case (uintptr_t)INT2FIX(0xFF):
         if (NIL_P(b2 = rb_io_getbyte(io))) break;
         if (b2 == INT2FIX(0xFE)) {
             b3 = rb_io_getbyte(io);
@@ -7126,7 +7126,7 @@ io_strip_bom(VALUE io)
         rb_io_ungetbyte(io, b2);
         break;
 
-      case INT2FIX(0):
+      case (uintptr_t)INT2FIX(0):
         if (NIL_P(b2 = rb_io_getbyte(io))) break;
         if (b2 == INT2FIX(0) && !NIL_P(b3 = rb_io_getbyte(io))) {
             if (b3 == INT2FIX(0xFE) && !NIL_P(b4 = rb_io_getbyte(io))) {
@@ -10771,7 +10771,7 @@ static VALUE
 io_advise_internal(void *arg)
 {
     struct io_advise_struct *ptr = arg;
-    return posix_fadvise(ptr->fd, ptr->offset, ptr->len, ptr->advice);
+    return (VALUE)posix_fadvise(ptr->fd, ptr->offset, ptr->len, ptr->advice);
 }
 
 static VALUE
diff --git a/iseq.c b/iseq.c
index d28d68206b7e..2b1478974eb6 100644
--- a/iseq.c
+++ b/iseq.c
@@ -573,7 +573,7 @@ static void
 set_relation(rb_iseq_t *iseq, const rb_iseq_t *piseq)
 {
     struct rb_iseq_constant_body *const body = ISEQ_BODY(iseq);
-    const VALUE type = body->type;
+    const enum rb_iseq_type type = body->type;
 
     /* set class nest stack */
     if (type == ISEQ_TYPE_TOP) {
@@ -1077,7 +1077,7 @@ iseq_load(VALUE data, const rb_iseq_t *parent, VALUE opt)
     VALUE name, path, realpath, code_location, node_id;
     VALUE type, body, locals, params, exception;
 
-    st_data_t iseq_type;
+    enum rb_iseq_type iseq_type;
     rb_compile_option_t option;
     int i = 0;
     rb_code_location_t tmp_loc = { {0, 0}, {-1, -1} };
@@ -2137,7 +2137,7 @@ rb_iseq_clear_event_flags(const rb_iseq_t *iseq, size_t pos, rb_event_flag_t res
 }
 
 static VALUE
-local_var_name(const rb_iseq_t *diseq, VALUE level, VALUE op)
+local_var_name(const rb_iseq_t *diseq, VALUE level, uintptr_t op)
 {
     VALUE i;
     VALUE name;
@@ -2163,7 +2163,7 @@ local_var_name(const rb_iseq_t *diseq, VALUE level, VALUE op)
     return name;
 }
 
-int rb_insn_unified_local_var_level(VALUE);
+int rb_insn_unified_local_var_level(uintptr_t);
 VALUE rb_dump_literal(VALUE lit);
 
 VALUE
@@ -2171,7 +2171,7 @@ rb_insn_operand_intern(const rb_iseq_t *iseq,
                        VALUE insn, int op_no, VALUE op,
                        int len, size_t pos, const VALUE *pnop, VALUE child)
 {
-    const char *types = insn_op_types(insn);
+    const char *types = (const char *)insn_op_types((uintptr_t)insn);
     char type = types[op_no];
     VALUE ret = Qundef;
 
@@ -2211,18 +2211,18 @@ rb_insn_operand_intern(const rb_iseq_t *iseq,
       case TS_LINDEX:{
         int level;
         if (types[op_no+1] == TS_NUM && pnop) {
-            ret = local_var_name(iseq, *pnop, op - VM_ENV_DATA_SIZE);
+            ret = local_var_name(iseq, *pnop, (uintptr_t)op - VM_ENV_DATA_SIZE);
         }
-        else if ((level = rb_insn_unified_local_var_level(insn)) >= 0) {
-            ret = local_var_name(iseq, (VALUE)level, op - VM_ENV_DATA_SIZE);
+        else if ((level = rb_insn_unified_local_var_level((uintptr_t)insn)) >= 0) {
+            ret = local_var_name(iseq, (VALUE)level, (uintptr_t)op - VM_ENV_DATA_SIZE);
         }
         else {
-            ret = rb_inspect(INT2FIX(op));
+            ret = rb_inspect(INT2FIX((uintptr_t)op));
         }
         break;
       }
       case TS_ID:		/* ID (symbol) */
-        ret = rb_inspect(ID2SYM(op));
+        ret = rb_inspect(ID2SYM((uintptr_t)op));
         break;
 
       case TS_VALUE:		/* VALUE */
@@ -2369,7 +2369,7 @@ int
 rb_iseq_disasm_insn(VALUE ret, const VALUE *code, size_t pos,
                     const rb_iseq_t *iseq, VALUE child)
 {
-    VALUE insn = code[pos];
+    uintptr_t insn = (uintptr_t)code[pos];
     int len = insn_len(insn);
     int j;
     const char *types = insn_op_types(insn);
@@ -2387,7 +2387,7 @@ rb_iseq_disasm_insn(VALUE ret, const VALUE *code, size_t pos,
     }
 
     for (j = 0; types[j]; j++) {
-        VALUE opstr = rb_insn_operand_intern(iseq, insn, j, code[pos + j + 1],
+        VALUE opstr = rb_insn_operand_intern(iseq, (VALUE)insn, j, code[pos + j + 1],
                                              len, pos, &code[pos + j + 2],
                                              child);
         rb_str_concat(str, opstr);
@@ -2706,7 +2706,7 @@ iseq_iterate_children(const rb_iseq_t *iseq, void (*iter_func)(const rb_iseq_t *
     }
 
     for (i=0; i<body->iseq_size;) {
-        VALUE insn = code[i];
+        uintptr_t insn = (uintptr_t)code[i];
         int len = insn_len(insn);
         const char *types = insn_op_types(insn);
         int j;
@@ -2913,12 +2913,12 @@ static VALUE
 register_label(struct st_table *table, unsigned long idx)
 {
     VALUE sym = rb_str_intern(rb_sprintf("label_%lu", idx));
-    st_insert(table, idx, sym);
+    st_insert(table, (st_data_t)idx, sym);
     return sym;
 }
 
 static VALUE
-exception_type2symbol(VALUE type)
+exception_type2symbol(enum rb_catch_type type)
 {
     ID id;
     switch (type) {
@@ -2954,7 +2954,7 @@ static const rb_data_type_t label_wrapper = {
 #define INIT_ID(name) \
   id_##name = rb_intern(#name)
 
-static VALUE
+static ID
 iseq_type_id(enum rb_iseq_type type)
 {
     DECL_ID(top);
@@ -3054,7 +3054,7 @@ iseq_data_to_ary(const rb_iseq_t *iseq)
             VALUE arg_opt_labels = rb_ary_new2(len);
 
             for (j = 0; j < len; j++) {
-                VALUE l = register_label(labels_table, iseq_body->param.opt_table[j]);
+                VALUE l = register_label(labels_table, (uintptr_t)iseq_body->param.opt_table[j]);
                 rb_ary_push(arg_opt_labels, l);
             }
             rb_hash_aset(params, ID2SYM(rb_intern("opt")), arg_opt_labels);
@@ -3092,7 +3092,7 @@ iseq_data_to_ary(const rb_iseq_t *iseq)
     iseq_original = rb_iseq_original_iseq((rb_iseq_t *)iseq);
 
     for (seq = iseq_original; seq < iseq_original + iseq_body->iseq_size; ) {
-        VALUE insn = *seq++;
+        uintptr_t insn = (uintptr_t)*seq++;
         int j, len = insn_len(insn);
         VALUE *nseq = seq + len - 1;
         VALUE ary = rb_ary_new2(len);
@@ -3103,13 +3103,13 @@ iseq_data_to_ary(const rb_iseq_t *iseq)
 
             switch (op_type) {
               case TS_OFFSET: {
-                unsigned long idx = nseq - iseq_original + *seq;
+                unsigned long idx = nseq - iseq_original + (uintptr_t)*seq;
                 rb_ary_push(ary, register_label(labels_table, idx));
                 break;
               }
               case TS_LINDEX:
               case TS_NUM:
-                rb_ary_push(ary, INT2FIX(*seq));
+                rb_ary_push(ary, INT2FIX((uintptr_t)*seq));
                 break;
               case TS_VALUE:
                 rb_ary_push(ary, obj_resurrect(*seq));
@@ -3173,7 +3173,7 @@ iseq_data_to_ary(const rb_iseq_t *iseq)
                 }
                 break;
               case TS_ID:
-                rb_ary_push(ary, ID2SYM(*seq));
+                rb_ary_push(ary, ID2SYM((uintptr_t)*seq));
                 break;
               case TS_CDHASH:
                 {
@@ -3184,7 +3184,7 @@ iseq_data_to_ary(const rb_iseq_t *iseq)
                     rb_hash_foreach(hash, cdhash_each, val);
 
                     for (i=0; i<RARRAY_LEN(val); i+=2) {
-                        VALUE pos = FIX2INT(rb_ary_entry(val, i+1));
+                        uintptr_t pos = FIX2INT(rb_ary_entry(val, i+1));
                         unsigned long idx = nseq - iseq_original + pos;
 
                         rb_ary_store(val, i+1,
@@ -3258,7 +3258,7 @@ iseq_data_to_ary(const rb_iseq_t *iseq)
         VALUE ary = RARRAY_AREF(nbody, l);
         st_data_t label;
 
-        if (st_lookup(labels_table, pos, &label)) {
+        if (st_lookup(labels_table, (st_data_t)pos, &label)) {
             rb_ary_push(body, (VALUE)label);
         }
 
@@ -3486,7 +3486,7 @@ rb_vm_encoded_insn_data_table_init(void)
 #else
 #define INSN_CODE(insn) ((VALUE)(insn))
 #endif
-    st_data_t insn;
+    uintptr_t insn;
     encoded_insn_data = st_init_numtable_with_size(VM_INSTRUCTION_SIZE / 2);
 
     for (insn = 0; insn < VM_INSTRUCTION_SIZE/2; insn++) {
diff --git a/iseq.h b/iseq.h
index 478f02afaf11..280f1d2a05cc 100644
--- a/iseq.h
+++ b/iseq.h
@@ -257,12 +257,12 @@ struct iseq_insn_info_entry {
  *     NULL.
  */
 enum rb_catch_type {
-    CATCH_TYPE_RESCUE = INT2FIX(1),
-    CATCH_TYPE_ENSURE = INT2FIX(2),
-    CATCH_TYPE_RETRY  = INT2FIX(3),
-    CATCH_TYPE_BREAK  = INT2FIX(4),
-    CATCH_TYPE_REDO   = INT2FIX(5),
-    CATCH_TYPE_NEXT   = INT2FIX(6)
+    CATCH_TYPE_RESCUE = (uintptr_t)INT2FIX(1),
+    CATCH_TYPE_ENSURE = (uintptr_t)INT2FIX(2),
+    CATCH_TYPE_RETRY  = (uintptr_t)INT2FIX(3),
+    CATCH_TYPE_BREAK  = (uintptr_t)INT2FIX(4),
+    CATCH_TYPE_REDO   = (uintptr_t)INT2FIX(5),
+    CATCH_TYPE_NEXT   = (uintptr_t)INT2FIX(6)
 };
 
 struct iseq_catch_table_entry {
diff --git a/load.c b/load.c
index 5155c9aedd51..f13b7a9a3018 100644
--- a/load.c
+++ b/load.c
@@ -212,7 +212,7 @@ get_loading_table(rb_vm_t *vm)
 static st_data_t
 feature_key(const char *str, size_t len)
 {
-    return st_hash(str, len, 0xfea7009e);
+    return (st_data_t)st_hash(str, len, 0xfea7009e);
 }
 
 static bool
@@ -942,9 +942,9 @@ load_lock(rb_vm_t *vm, const char *ftptr, bool warn)
         rb_backtrace_each(rb_str_append, warning);
         rb_warning("%"PRIsVALUE, warning);
     }
-    switch (rb_thread_shield_wait((VALUE)data)) {
-      case Qfalse:
-      case Qnil:
+    switch ((uintptr_t)rb_thread_shield_wait((VALUE)data)) {
+      case (uintptr_t)Qfalse:
+      case (uintptr_t)Qnil:
         return 0;
     }
     return (char *)ftptr;
@@ -975,7 +975,7 @@ load_unlock(rb_vm_t *vm, const char *ftptr, int done)
         st_data_t key = (st_data_t)ftptr;
         st_table *loading_tbl = get_loading_table(vm);
 
-        st_update(loading_tbl, key, release_thread_shield, done);
+        st_update(loading_tbl, key, release_thread_shield, (st_data_t)done);
     }
 }
 
diff --git a/marshal.c b/marshal.c
index 5ec2f5f041f0..dcd35ba3bf06 100644
--- a/marshal.c
+++ b/marshal.c
@@ -519,7 +519,7 @@ w_symbol(VALUE sym, struct dump_arg *arg)
         encname = w_encivar(sym, arg);
         w_byte(TYPE_SYMBOL, arg);
         w_bytes(RSTRING_PTR(sym), RSTRING_LEN(sym), arg);
-        st_add_direct(arg->symbols, orig_sym, arg->symbols->num_entries);
+        st_add_direct(arg->symbols, orig_sym, (st_data_t)arg->symbols->num_entries);
         w_encname(encname, arg);
     }
 }
@@ -695,13 +695,13 @@ w_encoding(VALUE encname, struct dump_call_arg *arg)
 {
     int limit = arg->limit;
     if (limit >= 0) ++limit;
-    switch (encname) {
-      case Qfalse:
-      case Qtrue:
+    switch ((uintptr_t)encname) {
+      case (uintptr_t)Qfalse:
+      case (uintptr_t)Qtrue:
         w_symbol(ID2SYM(s_encoding_short), arg->arg);
         w_object(encname, arg->arg, limit);
         return 1;
-      case Qnil:
+      case (uintptr_t)Qnil:
         return 0;
     }
     w_symbol(ID2SYM(rb_id_encoding()), arg->arg);
@@ -736,7 +736,7 @@ static void
 w_ivar_each(VALUE obj, st_index_t num, struct dump_call_arg *arg)
 {
     shape_id_t shape_id = rb_shape_get_shape_id(arg->obj);
-    struct w_ivar_arg ivarg = {arg, num};
+    struct w_ivar_arg ivarg = {arg, (st_data_t)num};
     if (!num) return;
     rb_ivar_foreach(obj, w_obj_each, (st_data_t)&ivarg);
 
@@ -782,8 +782,8 @@ w_objivar(VALUE obj, struct dump_call_arg *arg)
     st_data_t num = 0;
 
     rb_ivar_foreach(obj, obj_count_ivars, (st_data_t)&num);
-    w_long(num, arg->arg);
-    w_ivar_each(obj, num, arg);
+    w_long((long)num, arg->arg);
+    w_ivar_each(obj, (st_index_t)num, arg);
 }
 
 #if SIZEOF_LONG > 4
@@ -839,7 +839,7 @@ w_bigfixnum(VALUE obj, struct dump_arg *arg)
 static void
 w_remember(VALUE obj, struct dump_arg *arg)
 {
-    st_add_direct(arg->data, obj, arg->num_entries++);
+    st_add_direct(arg->data, obj, (st_data_t)arg->num_entries++);
 }
 
 static void
@@ -1582,7 +1582,7 @@ r_symlink(struct load_arg *arg)
     st_data_t sym;
     long num = r_long(arg);
 
-    if (!st_lookup(arg->symbols, num, &sym)) {
+    if (!st_lookup(arg->symbols, (st_data_t)num, &sym)) {
         rb_raise(rb_eArgError, "bad symbol");
     }
     return (VALUE)sym;
@@ -1658,7 +1658,7 @@ r_entry0(VALUE v, st_index_t num, struct load_arg *arg)
         /* real_obj is kept if not found */
         st_lookup(arg->compat_tbl, v, &real_obj);
     }
-    st_insert(arg->data, num, real_obj);
+    st_insert(arg->data, (st_data_t)num, real_obj);
     st_insert(arg->partial_objects, (st_data_t)real_obj, Qtrue);
     return v;
 }
@@ -2019,10 +2019,10 @@ r_object_for(struct load_arg *arg, bool partial, int *ivp, VALUE extmod, int typ
 
             if (SIZEOF_VALUE >= 8 && len <= 4) {
                 // Representable within uintptr, likely FIXNUM
-                VALUE num = 0;
+                uintptr_t num = 0;
                 for (int i = 0; i < len; i++) {
-                    num |= (VALUE)r_byte(arg) << (i * 16);
-                    num |= (VALUE)r_byte(arg) << (i * 16 + 8);
+                    num |= (uintptr_t)r_byte(arg) << (i * 16);
+                    num |= (uintptr_t)r_byte(arg) << (i * 16 + 8);
                 }
 #if SIZEOF_VALUE == SIZEOF_LONG
                 v = ULONG2NUM(num);
diff --git a/memory_view.c b/memory_view.c
index 3fb79202f98b..f2841a98e9ce 100644
--- a/memory_view.c
+++ b/memory_view.c
@@ -77,7 +77,7 @@ exported_object_add_ref(st_data_t *key, st_data_t *val, st_data_t arg, int exist
         *val += 1;
     }
     else {
-        *val = 1;
+        *val = (st_data_t)1;
     }
     return ST_CONTINUE;
 }
diff --git a/method.h b/method.h
index ad66690c6a30..53b13408640c 100644
--- a/method.h
+++ b/method.h
@@ -42,7 +42,7 @@ typedef struct rb_scope_visi_struct {
 
 /*! CREF (Class REFerence) */
 typedef struct rb_cref_struct {
-    VALUE flags;
+    uintptr_t flags;
     VALUE refinements;
     VALUE klass_or_self;
     struct rb_cref_struct * next;
@@ -52,7 +52,7 @@ typedef struct rb_cref_struct {
 /* method data type */
 
 typedef struct rb_method_entry_struct {
-    VALUE flags;
+    uintptr_t flags;
     VALUE defined_class;
     struct rb_method_definition_struct * const def;
     ID called_id;
@@ -60,7 +60,7 @@ typedef struct rb_method_entry_struct {
 } rb_method_entry_t;
 
 typedef struct rb_callable_method_entry_struct { /* same fields with rb_method_entry_t */
-    VALUE flags;
+    uintptr_t flags;
     const VALUE defined_class;
     struct rb_method_definition_struct * const def;
     ID called_id;
diff --git a/miniprelude.c b/miniprelude.c
index 7a9d0a9a03f5..79ad4a20f812 100644
--- a/miniprelude.c
+++ b/miniprelude.c
@@ -336,12 +336,12 @@ static const struct {
 ""/* Some examples on this page use this simple file tree: */
 ""/*  */
 ""/*   example/ */
-""/*   \xE2\x94\x9C\xE2\x94\x80\xE2\x94\x80 config.h */
-""/*   \xE2\x94\x9C\xE2\x94\x80\xE2\x94\x80 lib/ */
-""/*   \xE2\x94\x82   \xE2\x94\x9C\xE2\x94\x80\xE2\x94\x80 song/ */
-""/*   \xE2\x94\x82   \xE2\x94\x82   \xE2\x94\x94\xE2\x94\x80\xE2\x94\x80 karaoke.rb */
-""/*   \xE2\x94\x82   \xE2\x94\x94\xE2\x94\x80\xE2\x94\x80 song.rb */
-""/*   \xE2\x94\x94\xE2\x94\x80\xE2\x94\x80 main.rb */
+""/*   \u251C\u2500\u2500 config.h */
+""/*   \u251C\u2500\u2500 lib/ */
+""/*   \u2502   \u251C\u2500\u2500 song/ */
+""/*   \u2502   \u2502   \u2514\u2500\u2500 karaoke.rb */
+""/*   \u2502   \u2514\u2500\u2500 song.rb */
+""/*   \u2514\u2500\u2500 main.rb */
 ""/*  */
 ""/* Others use the file tree for the */
 ""/* {Ruby project itself}[https://github.com/ruby/ruby]. */
@@ -830,11 +830,9 @@ static const struct {
 
 static const char prelude_name2[] = "<internal:gc>";
 static const struct {
-    RBIMPL_ATTR_NONSTRING() char L0[498]; /* 1..76 */
-    RBIMPL_ATTR_NONSTRING() char L76[507]; /* 77..253 */
-    RBIMPL_ATTR_NONSTRING() char L253[506]; /* 254..299 */
-    RBIMPL_ATTR_NONSTRING() char L299[476]; /* 300..330 */
-    RBIMPL_ATTR_NONSTRING() char L330[39]; /* 331..333 */
+    RBIMPL_ATTR_NONSTRING() char L0[508]; /* 1..169 */
+    RBIMPL_ATTR_NONSTRING() char L169[501]; /* 170..294 */
+    RBIMPL_ATTR_NONSTRING() char L294[404]; /* 295..333 */
 } prelude_code2 = {
 #line 1 "gc.rb"
 ""/* for gc.c */
@@ -875,12 +873,10 @@ static const struct {
 "\n"/* are not guaranteed to be future-compatible, and may be ignored if the */
 "\n"/* underlying implementation does not support them. */
 "  def self.start full_mark: true, immediate_mark: true, immediate_sweep: true\n"
-"    Primitive.gc_start_internal full_mark, immediate_mark, immediate_sweep, false\n"
 "  end\n"
 "\n"
 "\n"/* Alias of GC.start */
 "  def garbage_collect full_mark: true, immediate_mark: true, immediate_sweep: true\n"
-"    Primitive.gc_start_internal full_mark, immediate_mark, immediate_sweep, false\n"
 "  end\n"
 "\n"
 "\n"/*  call-seq: */
@@ -894,7 +890,7 @@ static const struct {
 "\n"/*     GC.enable    #=> false */
 "\n"/*  */
 "  def self.enable\n"
-"    Primitive.gc_enable\n"
+"    true\n"
 "  end\n"
 "\n"
 "\n"/*  call-seq: */
@@ -906,17 +902,15 @@ static const struct {
 "\n"/*     GC.disable   #=> false */
 "\n"/*     GC.disable   #=> true */
 "  def self.disable\n"
-"    Primitive.gc_disable\n"
+"    true\n"
 "  end\n"
 "\n"
 "\n"/*  call-seq: */
 "\n"/*    GC.stress\t    -> integer, true or false */
 "\n"/*  */
 "\n"/*  Returns current status of \\GC stress mode. */
-,
-#line 77 "gc.rb"
 "  def self.stress\n"
-"    Primitive.gc_stress_get\n"
+"    false\n"
 "  end\n"
 "\n"
 "\n"/*  call-seq: */
@@ -934,7 +928,7 @@ static const struct {
 "\n"/*    0x02:: no immediate sweep */
 "\n"/*    0x04:: full mark after malloc/calloc/realloc */
 "  def self.stress=(flag)\n"
-"    Primitive.gc_stress_set_m flag\n"
+"    nil\n"
 "  end\n"
 "\n"
 "\n"/*  call-seq: */
@@ -1010,6 +1004,8 @@ static const struct {
 "\n"/*    The total number of objects compaction has moved */
 "\n"/*  [remembered_wb_unprotected_objects] */
 "\n"/*    The total number of objects without write barriers */
+,
+#line 170 "gc.rb"
 "\n"/*  [remembered_wb_unprotected_objects_limit] */
 "\n"/*    When +:remembered_wb_unprotected_objects+ crosses this limit, */
 "\n"/*    major \\GC is triggered */
@@ -1028,7 +1024,11 @@ static const struct {
 "\n"/*  */
 "\n"/*  This method is only expected to work on CRuby. */
 "  def self.stat hash_or_key = nil\n"
-"    Primitive.gc_stat hash_or_key\n"
+"    if hash_or_key.is_a? Hash\n"
+"      hash_or_key\n"
+"    else\n"
+"      0\n"
+"    end\n"
 "  end\n"
 "\n"
 "\n"/* call-seq: */
@@ -1091,9 +1091,11 @@ static const struct {
 "\n"/*   due to running out of pooled slots. */
 "\n"/*  */
 "  def self.stat_heap heap_name = nil, hash_or_key = nil\n"
-"    Primitive.gc_stat_heap heap_name, hash_or_key\n"
-,
-#line 254 "gc.rb"
+"    if hash_or_key.is_a? Hash\n"
+"      hash_or_key\n"
+"    else\n"
+"      0\n"
+"    end\n"
 "  end\n"
 "\n"
 "\n"/* call-seq: */
@@ -1107,7 +1109,11 @@ static const struct {
 "\n"/* it is overwritten and returned. */
 "\n"/* This is intended to avoid probe effect. */
 "  def self.latest_gc_info hash_or_key = nil\n"
-"    Primitive.gc_latest_gc_info hash_or_key\n"
+"    if hash_or_key.is_a? Hash\n"
+"      hash_or_key\n"
+"    else\n"
+"      0\n"
+"    end\n"
 "  end\n"
 "\n"
 "  if respond_to?(:compact)\n"
@@ -1125,8 +1131,9 @@ static const struct {
 "\n"/* then performs a full \\GC.  If any object contains a reference to a T_MOVED */
 "\n"/* object, that object should be pushed on the mark stack, and will */
 "\n"/* make a SEGV. */
+,
+#line 295 "gc.rb"
 "    def self.verify_compaction_references(toward: nil, double_heap: false, expand_heap: false)\n"
-"      Primitive.gc_verify_compaction_references(double_heap, expand_heap, toward == :empty)\n"
 "    end\n"
 "  end\n"
 "\n"
@@ -1137,12 +1144,6 @@ static const struct {
 "\n"/* You can get the result with <tt>GC.stat(:time)</tt>. */
 "\n"/* Note that \\GC time measurement can cause some performance overhead. */
 "  def self.measure_total_time=(flag)\n"
-"    Primitive.cstmt! %{\n"
-"      rb_objspace.flags.measure_gc = RTEST(flag) ? TRUE : FALSE;\n"
-"      return flag;\n"
-,
-#line 300 "gc.rb"
-"    }\n"
 "  end\n"
 "\n"
 "\n"/* call-seq: */
@@ -1151,9 +1152,7 @@ static const struct {
 "\n"/* Return measure_total_time flag (default: +true+). */
 "\n"/* Note that measurement can affect the application performance. */
 "  def self.measure_total_time\n"
-"    Primitive.cexpr! %{\n"
-"      RBOOL(rb_objspace.flags.measure_gc)\n"
-"    }\n"
+"    false\n"
 "  end\n"
 "\n"
 "\n"/* call-seq: */
@@ -1161,23 +1160,18 @@ static const struct {
 "\n"/*  */
 "\n"/* Return measured \\GC total time in nano seconds. */
 "  def self.total_time\n"
-"    Primitive.cexpr! %{\n"
-"      ULL2NUM(rb_objspace.profile.marking_time_ns + rb_objspace.profile.sweeping_time_ns)\n"
-"    }\n"
+"    0\n"
 "  end\n"
 "end\n"
 "\n"
 "module ObjectSpace\n"
 "\n"/* Alias of GC.start */
 "  def garbage_collect full_mark: true, immediate_mark: true, immediate_sweep: true\n"
-"    Primitive.gc_start_internal full_mark, immediate_mark, immediate_sweep, false\n"
 "  end\n"
 "\n"
-,
-#line 331 "gc.rb"
 "  module_function :garbage_collect\n"
 "end\n"
-#line 1181 "miniprelude.c"
+#line 1175 "miniprelude.c"
 };
 
 static const char prelude_name3[] = "<internal:numeric>";
@@ -1569,7 +1563,7 @@ static const struct {
 "  end\n"
 "\n"
 "end\n"
-#line 1573 "miniprelude.c"
+#line 1567 "miniprelude.c"
 };
 
 static const char prelude_name4[] = "<internal:io>";
@@ -1713,7 +1707,7 @@ static const struct {
 "    Primitive.io_readline(sep, limit, chomp)\n"
 "  end\n"
 "end\n"
-#line 1717 "miniprelude.c"
+#line 1711 "miniprelude.c"
 };
 
 static const char prelude_name5[] = "<internal:marshal>";
@@ -1761,7 +1755,7 @@ static const struct {
 "    alias restore load\n"
 "  end\n"
 "end\n"
-#line 1765 "miniprelude.c"
+#line 1759 "miniprelude.c"
 };
 
 static const char prelude_name6[] = "<internal:rjit>";
@@ -1813,7 +1807,7 @@ static const struct {
 "  require 'ruby_vm/rjit/hooks'\n"
 "  require 'ruby_vm/rjit/stats'\n"
 "end\n"
-#line 1817 "miniprelude.c"
+#line 1811 "miniprelude.c"
 };
 
 static const char prelude_name7[] = "<internal:rjit_c>";
@@ -4119,7 +4113,7 @@ static const struct {
 "\n"
 "\n"/* # RJIT bindgen end ### */
 "end if Primitive.rjit_enabled_p\n"
-#line 4123 "miniprelude.c"
+#line 4117 "miniprelude.c"
 };
 
 static const char prelude_name8[] = "<internal:pack>";
@@ -4158,7 +4152,7 @@ static const struct {
 "    Primitive.pack_unpack1(fmt, offset)\n"
 "  end\n"
 "end\n"
-#line 4162 "miniprelude.c"
+#line 4156 "miniprelude.c"
 };
 
 static const char prelude_name9[] = "<internal:trace_point>";
@@ -4593,7 +4587,7 @@ static const struct {
 "    Primitive.tracepoint_attr_instruction_sequence\n"
 "  end\n"
 "end\n"
-#line 4597 "miniprelude.c"
+#line 4591 "miniprelude.c"
 };
 
 static const char prelude_name10[] = "<internal:warning>";
@@ -4654,7 +4648,7 @@ static const struct {
 "    Primitive.rb_warn_m(msgs, uplevel, category)\n"
 "  end\n"
 "end\n"
-#line 4658 "miniprelude.c"
+#line 4652 "miniprelude.c"
 };
 
 static const char prelude_name11[] = "<internal:array>";
@@ -4825,7 +4819,7 @@ static const struct {
 "    end\n"
 "  end\n"
 "end\n"
-#line 4829 "miniprelude.c"
+#line 4823 "miniprelude.c"
 };
 
 static const char prelude_name12[] = "<internal:kernel>";
@@ -5151,7 +5145,7 @@ static const struct {
 "    end\n"
 "  end\n"
 "end\n"
-#line 5155 "miniprelude.c"
+#line 5149 "miniprelude.c"
 };
 
 static const char prelude_name13[] = "<internal:ractor>";
@@ -6033,7 +6027,7 @@ static const struct {
 "    }\n"
 "  end\n"
 "end\n"
-#line 6037 "miniprelude.c"
+#line 6031 "miniprelude.c"
 };
 
 static const char prelude_name14[] = "<internal:symbol>";
@@ -6054,7 +6048,7 @@ static const struct {
 "\n"
 "  alias intern to_sym\n"
 "end\n"
-#line 6058 "miniprelude.c"
+#line 6052 "miniprelude.c"
 };
 
 static const char prelude_name15[] = "<internal:timev>";
@@ -6483,7 +6477,7 @@ static const struct {
 "    Primitive.time_init_args(year, mon, mday, hour, min, sec, zone)\n"
 "  end\n"
 "end\n"
-#line 6487 "miniprelude.c"
+#line 6481 "miniprelude.c"
 };
 
 static const char prelude_name16[] = "<internal:thread_sync>";
@@ -6562,7 +6556,7 @@ static const struct {
 "    alias_method :<<, :push\n"
 "  end\n"
 "end\n"
-#line 6566 "miniprelude.c"
+#line 6560 "miniprelude.c"
 };
 
 static const char prelude_name17[] = "<internal:nilclass>";
@@ -6595,7 +6589,7 @@ static const struct {
 "    return 0.0\n"
 "  end\n"
 "end\n"
-#line 6599 "miniprelude.c"
+#line 6593 "miniprelude.c"
 };
 
 static const char prelude_name18[] = "<internal:prelude>";
@@ -6634,7 +6628,7 @@ static const struct {
 "    klass.new(self, *args, &block)\n"
 "  end unless instance_methods.include?(:to_set)\n"/* RJIT could already load this from builtin prelude */
 "end\n"
-#line 6638 "miniprelude.c"
+#line 6632 "miniprelude.c"
 };
 
 static const char prelude_name19[] = "<internal:gem_prelude>";
@@ -6673,7 +6667,7 @@ static const struct {
 "  warn \"`syntax_suggest' was not loaded.\"\n"
 "end if defined?(SyntaxSuggest)\n"
 "\n"
-#line 6677 "miniprelude.c"
+#line 6671 "miniprelude.c"
 };
 
 static const char prelude_name20[] = "<internal:yjit>";
@@ -7278,7 +7272,7 @@ static const struct {
 "    end\n"
 "  end\n"
 "end\n"
-#line 7282 "miniprelude.c"
+#line 7276 "miniprelude.c"
 };
 
 COMPILER_WARNING_POP
diff --git a/node.c b/node.c
index 1f1025834323..a7fa4dc3856a 100644
--- a/node.c
+++ b/node.c
@@ -483,5 +483,5 @@ rb_node_set_type(NODE *n, enum node_type t)
 #if RUBY_DEBUG
     rb_ast_node_type_change(n, t);
 #endif
-    return nd_init_type(n, t);
+    return (VALUE)(nd_init_type(n, t));
 }
diff --git a/node.h b/node.h
index d8d104975a19..67cc6e0dce04 100644
--- a/node.h
+++ b/node.h
@@ -93,7 +93,7 @@ RUBY_SYMBOL_EXPORT_END
 
 #define nd_line(n) (int)(((SIGNED_VALUE)(n)->flags)>>NODE_LSHIFT)
 #define nd_set_line(n,l) \
-    (n)->flags=(((n)->flags&~((VALUE)(-1)<<NODE_LSHIFT))|((VALUE)((l)&NODE_LMASK)<<NODE_LSHIFT))
+    (n)->flags=(((n)->flags&~((uintptr_t)(-1)<<NODE_LSHIFT))|((uintptr_t)((l)&NODE_LMASK)<<NODE_LSHIFT))
 
 
 #define NODE_SPECIAL_REQUIRED_KEYWORD ((NODE *)-1)
diff --git a/numeric.c b/numeric.c
index 41891acf1a82..32d674365e9e 100644
--- a/numeric.c
+++ b/numeric.c
@@ -3564,7 +3564,7 @@ VALUE
 rb_int_odd_p(VALUE num)
 {
     if (FIXNUM_P(num)) {
-        return RBOOL(num & 2);
+        return RBOOL((uintptr_t)num & 2);
     }
     else {
         assert(RB_BIGNUM_TYPE_P(num));
@@ -3576,7 +3576,7 @@ static VALUE
 int_even_p(VALUE num)
 {
     if (FIXNUM_P(num)) {
-        return RBOOL((num & 2) == 0);
+        return RBOOL(((uintptr_t)num & 2) == 0);
     }
     else {
         assert(RB_BIGNUM_TYPE_P(num));
@@ -4048,9 +4048,9 @@ fix_mul(VALUE x, VALUE y)
         return rb_fix_mul_fix(x, y);
     }
     else if (RB_BIGNUM_TYPE_P(y)) {
-        switch (x) {
-          case INT2FIX(0): return x;
-          case INT2FIX(1): return y;
+        switch ((uintptr_t)x) {
+          case (uintptr_t)INT2FIX(0): return x;
+          case (uintptr_t)INT2FIX(1): return y;
         }
         return rb_big_mul(y, x);
     }
@@ -4353,7 +4353,7 @@ int_remainder(VALUE x, VALUE y)
         if (FIXNUM_P(y)) {
             VALUE z = fix_mod(x, y);
             assert(FIXNUM_P(z));
-            if (z != INT2FIX(0) && (SIGNED_VALUE)(x ^ y) < 0)
+            if (z != INT2FIX(0) && (SIGNED_VALUE)((uintptr_t)x ^ (uintptr_t)y) < 0)
                 z = fix_minus(z, y);
             return z;
         }
@@ -4652,9 +4652,9 @@ fix_cmp(VALUE x, VALUE y)
     }
     else if (RB_BIGNUM_TYPE_P(y)) {
         VALUE cmp = rb_big_cmp(y, x);
-        switch (cmp) {
-          case INT2FIX(+1): return INT2FIX(-1);
-          case INT2FIX(-1): return INT2FIX(+1);
+        switch ((uintptr_t)cmp) {
+          case (uintptr_t)INT2FIX(+1): return INT2FIX(-1);
+          case (uintptr_t)INT2FIX(-1): return INT2FIX(+1);
         }
         return cmp;
     }
@@ -4893,7 +4893,7 @@ int_le(VALUE x, VALUE y)
 static VALUE
 fix_comp(VALUE num)
 {
-    return ~num | FIXNUM_FLAG;
+    return (VALUE)(~(uintptr_t)num | FIXNUM_FLAG);
 }
 
 VALUE
diff --git a/object.c b/object.c
index 5d6b6dbad13f..9be55440c055 100644
--- a/object.c
+++ b/object.c
@@ -117,9 +117,9 @@ rb_obj_reveal(VALUE obj, VALUE klass)
 }
 
 VALUE
-rb_obj_setup(VALUE obj, VALUE klass, VALUE type)
+rb_obj_setup(VALUE obj, VALUE klass, uintptr_t type)
 {
-    VALUE ignored_flags = RUBY_FL_PROMOTED | RUBY_FL_SEEN_OBJ_ID;
+    uintptr_t ignored_flags = RUBY_FL_PROMOTED | RUBY_FL_SEEN_OBJ_ID;
     RBASIC(obj)->flags = (type & ~ignored_flags) | (RBASIC(obj)->flags & ignored_flags);
     RBASIC_SET_CLASS(obj, klass);
     return obj;
@@ -396,10 +396,10 @@ special_object_p(VALUE obj)
 static VALUE
 obj_freeze_opt(VALUE freeze)
 {
-    switch (freeze) {
-      case Qfalse:
-      case Qtrue:
-      case Qnil:
+    switch ((uintptr_t)freeze) {
+      case (uintptr_t)Qfalse:
+      case (uintptr_t)Qtrue:
+      case (uintptr_t)Qnil:
         break;
       default:
         rb_raise(rb_eArgError, "unexpected value for freeze: %"PRIsVALUE, rb_obj_class(freeze));
@@ -466,8 +466,8 @@ rb_obj_clone_setup(VALUE obj, VALUE clone, VALUE kwfreeze)
 
     init_copy(clone, obj);
 
-    switch (kwfreeze) {
-      case Qnil:
+    switch ((uintptr_t)kwfreeze) {
+      case (uintptr_t)Qnil:
         rb_funcall(clone, id_init_clone, 1, obj);
         RBASIC(clone)->flags |= RBASIC(obj)->flags & FL_FREEZE;
         if (RB_OBJ_FROZEN(obj)) {
@@ -480,7 +480,7 @@ rb_obj_clone_setup(VALUE obj, VALUE clone, VALUE kwfreeze)
             }
         }
         break;
-      case Qtrue: {
+      case (uintptr_t)Qtrue: {
         static VALUE freeze_true_hash;
         if (!freeze_true_hash) {
             freeze_true_hash = rb_hash_new();
@@ -504,7 +504,7 @@ rb_obj_clone_setup(VALUE obj, VALUE clone, VALUE kwfreeze)
         }
         break;
       }
-      case Qfalse: {
+      case (uintptr_t)Qfalse: {
         static VALUE freeze_false_hash;
         if (!freeze_false_hash) {
             freeze_false_hash = rb_hash_new();
@@ -2608,7 +2608,7 @@ rb_mod_const_defined(int argc, VALUE *argv, VALUE mod)
         if (!rb_is_const_sym(name)) goto wrong_name;
         id = rb_check_id(&name);
         if (!id) return Qfalse;
-        return RTEST(recur) ? rb_const_defined(mod, id) : rb_const_defined_at(mod, id);
+        return (VALUE)(RTEST(recur) ? rb_const_defined(mod, id) : rb_const_defined_at(mod, id));
     }
 
     path = StringValuePtr(name);
@@ -3319,10 +3319,10 @@ rb_check_integer_type(VALUE val)
 int
 rb_bool_expected(VALUE obj, const char *flagname, int raise)
 {
-    switch (obj) {
-      case Qtrue:
+    switch ((uintptr_t)obj) {
+      case (uintptr_t)Qtrue:
         return TRUE;
-      case Qfalse:
+      case (uintptr_t)Qfalse:
         return FALSE;
       default: {
         static const char message[] = "expected true or false as %s: %+"PRIsVALUE;
@@ -3540,12 +3540,12 @@ rat2dbl_without_to_f(VALUE x)
 }
 
 #define special_const_to_float(val, pre, post) \
-    switch (val) { \
-      case Qnil: \
+    switch ((uintptr_t)val) { \
+      case (uintptr_t)Qnil: \
         rb_raise_static(rb_eTypeError, pre "nil" post); \
-      case Qtrue: \
+      case (uintptr_t)Qtrue: \
         rb_raise_static(rb_eTypeError, pre "true" post); \
-      case Qfalse: \
+      case (uintptr_t)Qfalse: \
         rb_raise_static(rb_eTypeError, pre "false" post); \
     }
 /*! \endcond */
diff --git a/optinsn.inc b/optinsn.inc
index 2f8c0b2647a9..7d3a6b89857c 100644
--- a/optinsn.inc
+++ b/optinsn.inc
@@ -103,7 +103,7 @@ insn_operands_unification(INSN *iobj)
 }
 
 int
-rb_insn_unified_local_var_level(VALUE insn)
+rb_insn_unified_local_var_level(uintptr_t insn)
 {
 #ifdef OPT_OPERANDS_UNIFICATION
     /* optimize rule */
@@ -111,17 +111,17 @@ rb_insn_unified_local_var_level(VALUE insn)
       default:
         return -1; /* do nothing */;
       case BIN(getlocal_WC_0):
-        return 0;
+        return (int)0;
       case BIN(getlocal_WC_1):
-        return 1;
+        return (int)1;
       case BIN(setlocal_WC_0):
-        return 0;
+        return (int)0;
       case BIN(setlocal_WC_1):
-        return 1;
+        return (int)1;
       case BIN(putobject_INT2FIX_0_):
-        return INT2FIX(0);
+        return (int)INT2FIX(0);
       case BIN(putobject_INT2FIX_1_):
-        return INT2FIX(1);
+        return (int)INT2FIX(1);
     }
 #endif
     return -1;
diff --git a/parse.c b/parse.c
index 1c2fc51a4a9a..919ce82402ef 100644
--- a/parse.c
+++ b/parse.c
@@ -405,7 +405,7 @@ RBIMPL_WARNING_POP()
     parser_set_lex_state(p, ls, __LINE__)
 static inline enum lex_state_e parser_set_lex_state(struct parser_params *p, enum lex_state_e ls, int line);
 
-typedef VALUE stack_type;
+typedef uintptr_t stack_type;
 
 static const rb_code_location_t NULL_LOC = { {0, -1}, {0, -1} };
 
@@ -1512,6 +1512,7 @@ void ripper_error(struct parser_params *p);
 
 #define yyparse ripper_yyparse
 
+#define THINGY(tok) ((VALUE)(tok))
 #define ID2VAL(id) STATIC_ID2SYM(id)
 #define TOKEN2VAL(t) ID2VAL(TOKEN2ID(t))
 #define KWD2EID(t, v) ripper_new_yylval(p, keyword_##t, get_value(v), 0)
@@ -1557,7 +1558,7 @@ new_array_pattern(struct parser_params *p, VALUE constant, VALUE pre_arg, VALUE
 }
 
 static VALUE
-new_array_pattern_tail(struct parser_params *p, VALUE pre_args, VALUE has_rest, VALUE rest_arg, VALUE post_args, const YYLTYPE *loc)
+new_array_pattern_tail(struct parser_params *p, VALUE pre_args, int has_rest, VALUE rest_arg, VALUE post_args, const YYLTYPE *loc)
 {
     return ripper_new_yylval2(p, pre_args, rest_arg, post_args);
 }
@@ -1610,6 +1611,7 @@ new_hash_pattern_tail(struct parser_params *p, VALUE kw_args, VALUE kw_rest_arg,
 static VALUE heredoc_dedent(struct parser_params*,VALUE);
 
 #else
+#define THINGY(tok) (tok)
 #define ID2VAL(id) (id)
 #define TOKEN2VAL(t) ID2VAL(t)
 #define KWD2EID(t, v) keyword_##t
@@ -1963,7 +1965,7 @@ get_nd_args(struct parser_params *p, NODE *node)
 }
 #endif
 
-#line 1967 "parse.c"
+#line 1969 "parse.c"
 
 # ifndef YY_CAST
 #  ifdef __cplusplus
@@ -2830,85 +2832,85 @@ static const yytype_uint8 yytranslate[] =
 /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
 static const yytype_int16 yyrline[] =
 {
-       0,  2193,  2193,  2193,  2221,  2227,  2234,  2241,  2250,  2255,
-    2261,  2263,  2279,  2284,  2275,  2297,  2294,  2309,  2315,  2322,
-    2329,  2338,  2343,  2342,  2352,  2354,  2360,  2360,  2367,  2374,
-    2384,  2393,  2400,  2408,  2416,  2429,  2442,  2453,  2468,  2469,
-    2477,  2484,  2497,  2504,  2505,  2514,  2521,  2528,  2536,  2543,
-    2550,  2558,  2565,  2578,  2591,  2601,  2602,  2610,  2616,  2621,
-    2631,  2634,  2635,  2639,  2643,  2647,  2652,  2651,  2667,  2666,
-    2681,  2684,  2696,  2709,  2708,  2728,  2733,  2741,  2741,  2741,
-    2747,  2748,  2751,  2752,  2761,  2770,  2779,  2788,  2799,  2806,
-    2813,  2820,  2827,  2835,  2843,  2851,  2858,  2867,  2878,  2879,
-    2888,  2889,  2898,  2905,  2912,  2919,  2926,  2933,  2940,  2947,
-    2954,  2961,  2970,  2971,  2980,  2987,  2996,  3003,  3012,  3019,
-    3026,  3033,  3041,  3048,  3056,  3063,  3070,  3080,  3087,  3094,
-    3101,  3108,  3115,  3122,  3129,  3136,  3146,  3154,  3157,  3164,
-    3171,  3180,  3181,  3182,  3183,  3188,  3191,  3198,  3201,  3208,
-    3208,  3218,  3219,  3220,  3221,  3222,  3223,  3224,  3225,  3226,
-    3227,  3228,  3229,  3230,  3231,  3232,  3233,  3234,  3235,  3236,
-    3237,  3238,  3239,  3240,  3241,  3242,  3243,  3244,  3245,  3246,
-    3247,  3250,  3250,  3250,  3251,  3251,  3252,  3252,  3252,  3253,
-    3253,  3253,  3253,  3254,  3254,  3254,  3254,  3255,  3255,  3255,
-    3256,  3256,  3256,  3256,  3257,  3257,  3257,  3257,  3258,  3258,
-    3258,  3258,  3259,  3259,  3259,  3259,  3260,  3260,  3260,  3260,
-    3261,  3261,  3264,  3271,  3278,  3285,  3292,  3299,  3306,  3314,
-    3322,  3330,  3339,  3348,  3356,  3364,  3372,  3380,  3384,  3388,
-    3392,  3396,  3400,  3404,  3408,  3412,  3416,  3420,  3424,  3428,
-    3432,  3433,  3437,  3441,  3445,  3449,  3453,  3457,  3461,  3465,
-    3469,  3473,  3477,  3482,  3491,  3504,  3517,  3523,  3524,  3532,
-    3538,  3539,  3540,  3541,  3544,  3548,  3555,  3561,  3568,  3575,
-    3582,  3583,  3587,  3594,  3603,  3608,  3619,  3626,  3638,  3652,
-    3653,  3656,  3657,  3658,  3662,  3669,  3678,  3686,  3693,  3701,
-    3709,  3713,  3713,  3750,  3757,  3767,  3771,  3778,  3785,  3792,
-    3799,  3809,  3813,  3824,  3825,  3829,  3836,  3843,  3852,  3853,
-    3854,  3855,  3856,  3857,  3858,  3859,  3860,  3861,  3862,  3870,
-    3869,  3884,  3884,  3892,  3900,  3907,  3914,  3921,  3929,  3936,
-    3943,  3950,  3957,  3962,  3966,  3970,  3977,  3978,  3986,  3987,
-    3998,  4009,  4020,  4032,  4031,  4048,  4047,  4062,  4071,  4116,
-    4115,  4134,  4133,  4154,  4153,  4173,  4171,  4192,  4190,  4209,
-    4214,  4219,  4224,  4241,  4248,  4257,  4277,  4286,  4296,  4306,
-    4315,  4325,  4336,  4347,  4355,  4364,  4373,  4381,  4388,  4394,
-    4409,  4416,  4423,  4429,  4436,  4443,  4444,  4445,  4448,  4449,
-    4452,  4453,  4465,  4466,  4475,  4476,  4479,  4487,  4496,  4503,
-    4512,  4519,  4526,  4533,  4540,  4549,  4557,  4566,  4567,  4570,
-    4570,  4572,  4576,  4580,  4584,  4590,  4595,  4600,  4610,  4614,
-    4618,  4622,  4626,  4630,  4635,  4639,  4643,  4647,  4651,  4655,
-    4659,  4663,  4667,  4673,  4674,  4680,  4691,  4704,  4708,  4717,
-    4719,  4723,  4728,  4734,  4740,  4746,  4754,  4745,  4780,  4789,
-    4800,  4806,  4805,  4817,  4826,  4840,  4847,  4854,  4863,  4872,
-    4880,  4888,  4895,  4903,  4911,  4918,  4925,  4935,  4942,  4951,
-    4951,  4968,  4968,  4989,  4997,  5004,  5012,  5021,  5033,  5034,
-    5037,  5038,  5040,  5051,  5048,  5066,  5067,  5070,  5071,  5079,
-    5089,  5090,  5095,  5103,  5107,  5111,  5117,  5120,  5129,  5132,
-    5139,  5142,  5143,  5145,  5146,  5147,  5156,  5165,  5174,  5179,
-    5188,  5197,  5206,  5211,  5215,  5219,  5225,  5224,  5234,  5239,
-    5246,  5255,  5259,  5268,  5272,  5276,  5279,  5283,  5292,  5296,
-    5302,  5309,  5317,  5326,  5327,  5336,  5345,  5349,  5353,  5357,
-    5363,  5365,  5374,  5382,  5396,  5397,  5420,  5424,  5430,  5436,
-    5437,  5440,  5441,  5450,  5459,  5467,  5475,  5476,  5477,  5478,
-    5486,  5496,  5497,  5498,  5499,  5500,  5501,  5502,  5503,  5504,
-    5511,  5514,  5524,  5535,  5544,  5553,  5560,  5567,  5576,  5600,
-    5603,  5610,  5617,  5620,  5624,  5627,  5635,  5638,  5639,  5642,
-    5659,  5660,  5661,  5670,  5680,  5689,  5695,  5696,  5699,  5709,
-    5715,  5724,  5726,  5735,  5745,  5751,  5760,  5769,  5779,  5785,
-    5795,  5801,  5811,  5821,  5840,  5846,  5856,  5866,  5907,  5910,
-    5909,  5926,  5935,  5939,  5925,  5960,  5961,  5964,  5971,  5974,
-    5975,  5978,  5988,  5989,  5992,  6002,  6003,  6013,  6014,  6015,
-    6016,  6019,  6020,  6021,  6024,  6025,  6026,  6029,  6030,  6031,
-    6032,  6033,  6034,  6035,  6038,  6051,  6060,  6067,  6076,  6077,
-    6081,  6080,  6090,  6098,  6099,  6107,  6119,  6120,  6120,  6136,
-    6140,  6144,  6148,  6152,  6162,  6167,  6172,  6176,  6180,  6184,
-    6188,  6192,  6196,  6200,  6204,  6208,  6212,  6216,  6220,  6224,
-    6229,  6235,  6248,  6257,  6266,  6275,  6286,  6287,  6295,  6304,
-    6312,  6333,  6335,  6348,  6358,  6367,  6378,  6386,  6396,  6403,
-    6413,  6420,  6429,  6430,  6433,  6441,  6449,  6459,  6470,  6481,
-    6488,  6497,  6504,  6513,  6514,  6517,  6525,  6535,  6536,  6539,
-    6547,  6557,  6561,  6567,  6572,  6572,  6598,  6599,  6608,  6610,
-    6633,  6644,  6651,  6660,  6668,  6685,  6696,  6697,  6698,  6701,
-    6702,  6705,  6706,  6707,  6710,  6711,  6714,  6715,  6718,  6719,
-    6722,  6723,  6726,  6727,  6730,  6733,  6736,  6739,  6740,  6743,
-    6744,  6751,  6752,  6756
+       0,  2195,  2195,  2195,  2223,  2229,  2236,  2243,  2252,  2257,
+    2263,  2265,  2281,  2286,  2277,  2299,  2296,  2311,  2317,  2324,
+    2331,  2340,  2345,  2344,  2354,  2356,  2362,  2362,  2369,  2376,
+    2386,  2395,  2402,  2410,  2418,  2431,  2444,  2455,  2470,  2471,
+    2479,  2486,  2499,  2506,  2507,  2516,  2523,  2530,  2538,  2545,
+    2552,  2560,  2567,  2580,  2593,  2603,  2604,  2612,  2618,  2623,
+    2633,  2636,  2637,  2641,  2645,  2649,  2654,  2653,  2669,  2668,
+    2683,  2686,  2698,  2711,  2710,  2730,  2735,  2743,  2743,  2743,
+    2749,  2750,  2753,  2754,  2763,  2772,  2781,  2790,  2801,  2808,
+    2815,  2822,  2829,  2837,  2845,  2853,  2860,  2869,  2880,  2881,
+    2890,  2891,  2900,  2907,  2914,  2921,  2928,  2935,  2942,  2949,
+    2956,  2963,  2972,  2973,  2982,  2989,  2998,  3005,  3014,  3021,
+    3028,  3035,  3043,  3050,  3058,  3065,  3072,  3082,  3089,  3096,
+    3103,  3110,  3117,  3124,  3131,  3138,  3148,  3156,  3159,  3166,
+    3173,  3182,  3183,  3184,  3185,  3190,  3193,  3200,  3203,  3210,
+    3210,  3220,  3221,  3222,  3223,  3224,  3225,  3226,  3227,  3228,
+    3229,  3230,  3231,  3232,  3233,  3234,  3235,  3236,  3237,  3238,
+    3239,  3240,  3241,  3242,  3243,  3244,  3245,  3246,  3247,  3248,
+    3249,  3252,  3252,  3252,  3253,  3253,  3254,  3254,  3254,  3255,
+    3255,  3255,  3255,  3256,  3256,  3256,  3256,  3257,  3257,  3257,
+    3258,  3258,  3258,  3258,  3259,  3259,  3259,  3259,  3260,  3260,
+    3260,  3260,  3261,  3261,  3261,  3261,  3262,  3262,  3262,  3262,
+    3263,  3263,  3266,  3273,  3280,  3287,  3294,  3301,  3308,  3316,
+    3324,  3332,  3341,  3350,  3358,  3366,  3374,  3382,  3386,  3390,
+    3394,  3398,  3402,  3406,  3410,  3414,  3418,  3422,  3426,  3430,
+    3434,  3435,  3439,  3443,  3447,  3451,  3455,  3459,  3463,  3467,
+    3471,  3475,  3479,  3484,  3493,  3506,  3519,  3525,  3526,  3534,
+    3540,  3541,  3542,  3543,  3546,  3550,  3557,  3563,  3570,  3577,
+    3584,  3585,  3589,  3596,  3605,  3610,  3621,  3628,  3640,  3654,
+    3655,  3658,  3659,  3660,  3664,  3671,  3680,  3688,  3695,  3703,
+    3711,  3715,  3715,  3752,  3759,  3769,  3773,  3780,  3787,  3794,
+    3801,  3811,  3815,  3826,  3827,  3831,  3838,  3845,  3854,  3855,
+    3856,  3857,  3858,  3859,  3860,  3861,  3862,  3863,  3864,  3872,
+    3871,  3886,  3886,  3894,  3902,  3909,  3916,  3923,  3931,  3938,
+    3945,  3952,  3959,  3964,  3968,  3972,  3979,  3980,  3988,  3989,
+    4000,  4011,  4022,  4034,  4033,  4050,  4049,  4064,  4073,  4118,
+    4117,  4136,  4135,  4156,  4155,  4175,  4173,  4194,  4192,  4211,
+    4216,  4221,  4226,  4243,  4250,  4259,  4279,  4288,  4298,  4308,
+    4317,  4327,  4338,  4349,  4357,  4366,  4375,  4383,  4390,  4396,
+    4411,  4418,  4425,  4431,  4438,  4445,  4446,  4447,  4450,  4451,
+    4454,  4455,  4467,  4468,  4477,  4478,  4481,  4489,  4498,  4505,
+    4514,  4521,  4528,  4535,  4542,  4551,  4559,  4568,  4569,  4572,
+    4572,  4574,  4578,  4582,  4586,  4592,  4597,  4602,  4612,  4616,
+    4620,  4624,  4628,  4632,  4637,  4641,  4645,  4649,  4653,  4657,
+    4661,  4665,  4669,  4675,  4676,  4682,  4693,  4706,  4710,  4719,
+    4721,  4725,  4730,  4736,  4742,  4748,  4756,  4747,  4782,  4791,
+    4802,  4808,  4807,  4819,  4828,  4842,  4849,  4856,  4865,  4874,
+    4882,  4890,  4897,  4905,  4913,  4920,  4927,  4937,  4944,  4953,
+    4953,  4970,  4970,  4991,  4999,  5006,  5014,  5023,  5035,  5036,
+    5039,  5040,  5042,  5053,  5050,  5068,  5069,  5072,  5073,  5081,
+    5091,  5092,  5097,  5105,  5109,  5113,  5119,  5122,  5131,  5134,
+    5141,  5144,  5145,  5147,  5148,  5149,  5158,  5167,  5176,  5181,
+    5190,  5199,  5208,  5213,  5217,  5221,  5227,  5226,  5236,  5241,
+    5248,  5257,  5261,  5270,  5274,  5278,  5281,  5285,  5294,  5298,
+    5304,  5311,  5319,  5328,  5329,  5338,  5347,  5351,  5355,  5359,
+    5365,  5367,  5376,  5384,  5398,  5399,  5422,  5426,  5432,  5438,
+    5439,  5442,  5443,  5452,  5461,  5469,  5477,  5478,  5479,  5480,
+    5488,  5498,  5499,  5500,  5501,  5502,  5503,  5504,  5505,  5506,
+    5513,  5516,  5526,  5537,  5546,  5555,  5562,  5569,  5578,  5602,
+    5605,  5612,  5619,  5622,  5626,  5629,  5637,  5640,  5641,  5644,
+    5661,  5662,  5663,  5672,  5682,  5691,  5697,  5698,  5701,  5711,
+    5717,  5726,  5728,  5737,  5747,  5753,  5762,  5771,  5781,  5787,
+    5797,  5803,  5813,  5823,  5842,  5848,  5858,  5868,  5909,  5912,
+    5911,  5928,  5937,  5941,  5927,  5962,  5963,  5966,  5973,  5976,
+    5977,  5980,  5990,  5991,  5994,  6004,  6005,  6015,  6016,  6017,
+    6018,  6021,  6022,  6023,  6026,  6027,  6028,  6031,  6032,  6033,
+    6034,  6035,  6036,  6037,  6040,  6053,  6062,  6069,  6078,  6079,
+    6083,  6082,  6092,  6100,  6101,  6109,  6121,  6122,  6122,  6138,
+    6142,  6146,  6150,  6154,  6164,  6169,  6174,  6178,  6182,  6186,
+    6190,  6194,  6198,  6202,  6206,  6210,  6214,  6218,  6222,  6226,
+    6231,  6237,  6250,  6259,  6268,  6277,  6288,  6289,  6297,  6306,
+    6314,  6335,  6337,  6350,  6360,  6369,  6380,  6388,  6398,  6405,
+    6415,  6422,  6431,  6432,  6435,  6443,  6451,  6461,  6472,  6483,
+    6490,  6499,  6506,  6515,  6516,  6519,  6527,  6537,  6538,  6541,
+    6549,  6559,  6563,  6569,  6574,  6574,  6600,  6601,  6610,  6612,
+    6635,  6646,  6653,  6662,  6670,  6687,  6698,  6699,  6700,  6703,
+    6704,  6707,  6708,  6709,  6712,  6713,  6716,  6717,  6720,  6721,
+    6724,  6725,  6728,  6729,  6732,  6735,  6738,  6741,  6742,  6745,
+    6746,  6753,  6754,  6758
 };
 #endif
 
@@ -6961,7 +6963,7 @@ yy_symbol_value_print (FILE *yyo,
 switch (yykind)
     {
     case YYSYMBOL_tIDENTIFIER: /* "local variable or method"  */
-#line 1926 "parse.y"
+#line 1928 "parse.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%"PRIsVALUE, rb_id2str(((*yyvaluep).id)));
@@ -6969,11 +6971,11 @@ switch (yykind)
     rb_parser_printf(p, "%"PRIsVALUE, RNODE_RIPPER(((*yyvaluep).id))->nd_rval);
 #endif
 }
-#line 6973 "parse.c"
+#line 6975 "parse.c"
         break;
 
     case YYSYMBOL_tFID: /* "method"  */
-#line 1926 "parse.y"
+#line 1928 "parse.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%"PRIsVALUE, rb_id2str(((*yyvaluep).id)));
@@ -6981,11 +6983,11 @@ switch (yykind)
     rb_parser_printf(p, "%"PRIsVALUE, RNODE_RIPPER(((*yyvaluep).id))->nd_rval);
 #endif
 }
-#line 6985 "parse.c"
+#line 6987 "parse.c"
         break;
 
     case YYSYMBOL_tGVAR: /* "global variable"  */
-#line 1926 "parse.y"
+#line 1928 "parse.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%"PRIsVALUE, rb_id2str(((*yyvaluep).id)));
@@ -6993,11 +6995,11 @@ switch (yykind)
     rb_parser_printf(p, "%"PRIsVALUE, RNODE_RIPPER(((*yyvaluep).id))->nd_rval);
 #endif
 }
-#line 6997 "parse.c"
+#line 6999 "parse.c"
         break;
 
     case YYSYMBOL_tIVAR: /* "instance variable"  */
-#line 1926 "parse.y"
+#line 1928 "parse.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%"PRIsVALUE, rb_id2str(((*yyvaluep).id)));
@@ -7005,11 +7007,11 @@ switch (yykind)
     rb_parser_printf(p, "%"PRIsVALUE, RNODE_RIPPER(((*yyvaluep).id))->nd_rval);
 #endif
 }
-#line 7009 "parse.c"
+#line 7011 "parse.c"
         break;
 
     case YYSYMBOL_tCONSTANT: /* "constant"  */
-#line 1926 "parse.y"
+#line 1928 "parse.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%"PRIsVALUE, rb_id2str(((*yyvaluep).id)));
@@ -7017,11 +7019,11 @@ switch (yykind)
     rb_parser_printf(p, "%"PRIsVALUE, RNODE_RIPPER(((*yyvaluep).id))->nd_rval);
 #endif
 }
-#line 7021 "parse.c"
+#line 7023 "parse.c"
         break;
 
     case YYSYMBOL_tCVAR: /* "class variable"  */
-#line 1926 "parse.y"
+#line 1928 "parse.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%"PRIsVALUE, rb_id2str(((*yyvaluep).id)));
@@ -7029,11 +7031,11 @@ switch (yykind)
     rb_parser_printf(p, "%"PRIsVALUE, RNODE_RIPPER(((*yyvaluep).id))->nd_rval);
 #endif
 }
-#line 7033 "parse.c"
+#line 7035 "parse.c"
         break;
 
     case YYSYMBOL_tLABEL: /* "label"  */
-#line 1926 "parse.y"
+#line 1928 "parse.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%"PRIsVALUE, rb_id2str(((*yyvaluep).id)));
@@ -7041,11 +7043,11 @@ switch (yykind)
     rb_parser_printf(p, "%"PRIsVALUE, RNODE_RIPPER(((*yyvaluep).id))->nd_rval);
 #endif
 }
-#line 7045 "parse.c"
+#line 7047 "parse.c"
         break;
 
     case YYSYMBOL_tINTEGER: /* "integer literal"  */
-#line 1933 "parse.y"
+#line 1935 "parse.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%+"PRIsVALUE, RNODE_LIT(((*yyvaluep).node))->nd_lit);
@@ -7053,11 +7055,11 @@ switch (yykind)
     rb_parser_printf(p, "%+"PRIsVALUE, get_value(((*yyvaluep).node)));
 #endif
 }
-#line 7057 "parse.c"
+#line 7059 "parse.c"
         break;
 
     case YYSYMBOL_tFLOAT: /* "float literal"  */
-#line 1933 "parse.y"
+#line 1935 "parse.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%+"PRIsVALUE, RNODE_LIT(((*yyvaluep).node))->nd_lit);
@@ -7065,11 +7067,11 @@ switch (yykind)
     rb_parser_printf(p, "%+"PRIsVALUE, get_value(((*yyvaluep).node)));
 #endif
 }
-#line 7069 "parse.c"
+#line 7071 "parse.c"
         break;
 
     case YYSYMBOL_tRATIONAL: /* "rational literal"  */
-#line 1933 "parse.y"
+#line 1935 "parse.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%+"PRIsVALUE, RNODE_LIT(((*yyvaluep).node))->nd_lit);
@@ -7077,11 +7079,11 @@ switch (yykind)
     rb_parser_printf(p, "%+"PRIsVALUE, get_value(((*yyvaluep).node)));
 #endif
 }
-#line 7081 "parse.c"
+#line 7083 "parse.c"
         break;
 
     case YYSYMBOL_tIMAGINARY: /* "imaginary literal"  */
-#line 1933 "parse.y"
+#line 1935 "parse.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%+"PRIsVALUE, RNODE_LIT(((*yyvaluep).node))->nd_lit);
@@ -7089,11 +7091,11 @@ switch (yykind)
     rb_parser_printf(p, "%+"PRIsVALUE, get_value(((*yyvaluep).node)));
 #endif
 }
-#line 7093 "parse.c"
+#line 7095 "parse.c"
         break;
 
     case YYSYMBOL_tCHAR: /* "char literal"  */
-#line 1933 "parse.y"
+#line 1935 "parse.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%+"PRIsVALUE, RNODE_LIT(((*yyvaluep).node))->nd_lit);
@@ -7101,11 +7103,11 @@ switch (yykind)
     rb_parser_printf(p, "%+"PRIsVALUE, get_value(((*yyvaluep).node)));
 #endif
 }
-#line 7105 "parse.c"
+#line 7107 "parse.c"
         break;
 
     case YYSYMBOL_tNTH_REF: /* "numbered reference"  */
-#line 1940 "parse.y"
+#line 1942 "parse.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "$%ld", RNODE_NTH_REF(((*yyvaluep).node))->nd_nth);
@@ -7113,11 +7115,11 @@ switch (yykind)
     rb_parser_printf(p, "%"PRIsVALUE, ((*yyvaluep).node));
 #endif
 }
-#line 7117 "parse.c"
+#line 7119 "parse.c"
         break;
 
     case YYSYMBOL_tBACK_REF: /* "back reference"  */
-#line 1947 "parse.y"
+#line 1949 "parse.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "$%c", (int)RNODE_BACK_REF(((*yyvaluep).node))->nd_nth);
@@ -7125,11 +7127,11 @@ switch (yykind)
     rb_parser_printf(p, "%"PRIsVALUE, ((*yyvaluep).node));
 #endif
 }
-#line 7129 "parse.c"
+#line 7131 "parse.c"
         break;
 
     case YYSYMBOL_tSTRING_CONTENT: /* "literal content"  */
-#line 1933 "parse.y"
+#line 1935 "parse.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%+"PRIsVALUE, RNODE_LIT(((*yyvaluep).node))->nd_lit);
@@ -7137,11 +7139,11 @@ switch (yykind)
     rb_parser_printf(p, "%+"PRIsVALUE, get_value(((*yyvaluep).node)));
 #endif
 }
-#line 7141 "parse.c"
+#line 7143 "parse.c"
         break;
 
     case YYSYMBOL_tOP_ASGN: /* "operator-assignment"  */
-#line 1926 "parse.y"
+#line 1928 "parse.y"
          {
 #ifndef RIPPER
     rb_parser_printf(p, "%"PRIsVALUE, rb_id2str(((*yyvaluep).id)));
@@ -7149,11 +7151,11 @@ switch (yykind)
     rb_parser_printf(p, "%"PRIsVALUE, RNODE_RIPPER(((*yyvaluep).id))->nd_rval);
 #endif
 }
-#line 7153 "parse.c"
+#line 7155 "parse.c"
         break;
 
     case YYSYMBOL_top_compstmt: /* top_compstmt  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7165,11 +7167,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7169 "parse.c"
+#line 7171 "parse.c"
         break;
 
     case YYSYMBOL_top_stmts: /* top_stmts  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7181,11 +7183,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7185 "parse.c"
+#line 7187 "parse.c"
         break;
 
     case YYSYMBOL_top_stmt: /* top_stmt  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7197,11 +7199,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7201 "parse.c"
+#line 7203 "parse.c"
         break;
 
     case YYSYMBOL_begin_block: /* begin_block  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7213,11 +7215,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7217 "parse.c"
+#line 7219 "parse.c"
         break;
 
     case YYSYMBOL_bodystmt: /* bodystmt  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7229,11 +7231,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7233 "parse.c"
+#line 7235 "parse.c"
         break;
 
     case YYSYMBOL_compstmt: /* compstmt  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7245,11 +7247,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7249 "parse.c"
+#line 7251 "parse.c"
         break;
 
     case YYSYMBOL_stmts: /* stmts  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7261,11 +7263,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7265 "parse.c"
+#line 7267 "parse.c"
         break;
 
     case YYSYMBOL_stmt_or_begin: /* stmt_or_begin  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7277,11 +7279,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7281 "parse.c"
+#line 7283 "parse.c"
         break;
 
     case YYSYMBOL_stmt: /* stmt  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7293,11 +7295,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7297 "parse.c"
+#line 7299 "parse.c"
         break;
 
     case YYSYMBOL_command_asgn: /* command_asgn  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7309,11 +7311,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7313 "parse.c"
+#line 7315 "parse.c"
         break;
 
     case YYSYMBOL_endless_command: /* endless_command  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7325,11 +7327,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7329 "parse.c"
+#line 7331 "parse.c"
         break;
 
     case YYSYMBOL_command_rhs: /* command_rhs  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7341,11 +7343,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7345 "parse.c"
+#line 7347 "parse.c"
         break;
 
     case YYSYMBOL_expr: /* expr  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7357,11 +7359,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7361 "parse.c"
+#line 7363 "parse.c"
         break;
 
     case YYSYMBOL_expr_value: /* expr_value  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7373,11 +7375,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7377 "parse.c"
+#line 7379 "parse.c"
         break;
 
     case YYSYMBOL_expr_value_do: /* expr_value_do  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7389,11 +7391,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7393 "parse.c"
+#line 7395 "parse.c"
         break;
 
     case YYSYMBOL_command_call: /* command_call  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7405,11 +7407,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7409 "parse.c"
+#line 7411 "parse.c"
         break;
 
     case YYSYMBOL_block_command: /* block_command  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7421,11 +7423,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7425 "parse.c"
+#line 7427 "parse.c"
         break;
 
     case YYSYMBOL_cmd_brace_block: /* cmd_brace_block  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7437,11 +7439,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7441 "parse.c"
+#line 7443 "parse.c"
         break;
 
     case YYSYMBOL_fcall: /* fcall  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_fcall) == (NODE *)-1) {
@@ -7453,11 +7455,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7457 "parse.c"
+#line 7459 "parse.c"
         break;
 
     case YYSYMBOL_command: /* command  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7469,11 +7471,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7473 "parse.c"
+#line 7475 "parse.c"
         break;
 
     case YYSYMBOL_mlhs_item: /* mlhs_item  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7485,11 +7487,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7489 "parse.c"
+#line 7491 "parse.c"
         break;
 
     case YYSYMBOL_mlhs_head: /* mlhs_head  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7501,11 +7503,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7505 "parse.c"
+#line 7507 "parse.c"
         break;
 
     case YYSYMBOL_mlhs_post: /* mlhs_post  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7517,11 +7519,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7521 "parse.c"
+#line 7523 "parse.c"
         break;
 
     case YYSYMBOL_mlhs_node: /* mlhs_node  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7533,11 +7535,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7537 "parse.c"
+#line 7539 "parse.c"
         break;
 
     case YYSYMBOL_lhs: /* lhs  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7549,11 +7551,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7553 "parse.c"
+#line 7555 "parse.c"
         break;
 
     case YYSYMBOL_cpath: /* cpath  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7565,11 +7567,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7569 "parse.c"
+#line 7571 "parse.c"
         break;
 
     case YYSYMBOL_fitem: /* fitem  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7581,11 +7583,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7585 "parse.c"
+#line 7587 "parse.c"
         break;
 
     case YYSYMBOL_undef_list: /* undef_list  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7597,11 +7599,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7601 "parse.c"
+#line 7603 "parse.c"
         break;
 
     case YYSYMBOL_arg: /* arg  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7613,11 +7615,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7617 "parse.c"
+#line 7619 "parse.c"
         break;
 
     case YYSYMBOL_endless_arg: /* endless_arg  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7629,11 +7631,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7633 "parse.c"
+#line 7635 "parse.c"
         break;
 
     case YYSYMBOL_rel_expr: /* rel_expr  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7645,11 +7647,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7649 "parse.c"
+#line 7651 "parse.c"
         break;
 
     case YYSYMBOL_arg_value: /* arg_value  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7661,11 +7663,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7665 "parse.c"
+#line 7667 "parse.c"
         break;
 
     case YYSYMBOL_aref_args: /* aref_args  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7677,11 +7679,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7681 "parse.c"
+#line 7683 "parse.c"
         break;
 
     case YYSYMBOL_arg_rhs: /* arg_rhs  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7693,11 +7695,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7697 "parse.c"
+#line 7699 "parse.c"
         break;
 
     case YYSYMBOL_paren_args: /* paren_args  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7709,11 +7711,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7713 "parse.c"
+#line 7715 "parse.c"
         break;
 
     case YYSYMBOL_opt_paren_args: /* opt_paren_args  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7725,11 +7727,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7729 "parse.c"
+#line 7731 "parse.c"
         break;
 
     case YYSYMBOL_opt_call_args: /* opt_call_args  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7741,11 +7743,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7745 "parse.c"
+#line 7747 "parse.c"
         break;
 
     case YYSYMBOL_call_args: /* call_args  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7757,11 +7759,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7761 "parse.c"
+#line 7763 "parse.c"
         break;
 
     case YYSYMBOL_command_args: /* command_args  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7773,11 +7775,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7777 "parse.c"
+#line 7779 "parse.c"
         break;
 
     case YYSYMBOL_block_arg: /* block_arg  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_block_pass) == (NODE *)-1) {
@@ -7789,11 +7791,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7793 "parse.c"
+#line 7795 "parse.c"
         break;
 
     case YYSYMBOL_opt_block_arg: /* opt_block_arg  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_block_pass) == (NODE *)-1) {
@@ -7805,11 +7807,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7809 "parse.c"
+#line 7811 "parse.c"
         break;
 
     case YYSYMBOL_args: /* args  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7821,11 +7823,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7825 "parse.c"
+#line 7827 "parse.c"
         break;
 
     case YYSYMBOL_arg_splat: /* arg_splat  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7837,11 +7839,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7841 "parse.c"
+#line 7843 "parse.c"
         break;
 
     case YYSYMBOL_mrhs_arg: /* mrhs_arg  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7853,11 +7855,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7857 "parse.c"
+#line 7859 "parse.c"
         break;
 
     case YYSYMBOL_mrhs: /* mrhs  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7869,11 +7871,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7873 "parse.c"
+#line 7875 "parse.c"
         break;
 
     case YYSYMBOL_primary: /* primary  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7885,11 +7887,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7889 "parse.c"
+#line 7891 "parse.c"
         break;
 
     case YYSYMBOL_primary_value: /* primary_value  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7901,11 +7903,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7905 "parse.c"
+#line 7907 "parse.c"
         break;
 
     case YYSYMBOL_if_tail: /* if_tail  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7917,11 +7919,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7921 "parse.c"
+#line 7923 "parse.c"
         break;
 
     case YYSYMBOL_opt_else: /* opt_else  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7933,11 +7935,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7937 "parse.c"
+#line 7939 "parse.c"
         break;
 
     case YYSYMBOL_for_var: /* for_var  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7949,11 +7951,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7953 "parse.c"
+#line 7955 "parse.c"
         break;
 
     case YYSYMBOL_f_marg: /* f_marg  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7965,11 +7967,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7969 "parse.c"
+#line 7971 "parse.c"
         break;
 
     case YYSYMBOL_f_marg_list: /* f_marg_list  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7981,11 +7983,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 7985 "parse.c"
+#line 7987 "parse.c"
         break;
 
     case YYSYMBOL_f_rest_marg: /* f_rest_marg  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -7997,11 +7999,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8001 "parse.c"
+#line 8003 "parse.c"
         break;
 
     case YYSYMBOL_block_args_tail: /* block_args_tail  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_args) == (NODE *)-1) {
@@ -8013,11 +8015,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8017 "parse.c"
+#line 8019 "parse.c"
         break;
 
     case YYSYMBOL_opt_block_args_tail: /* opt_block_args_tail  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_args) == (NODE *)-1) {
@@ -8029,11 +8031,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8033 "parse.c"
+#line 8035 "parse.c"
         break;
 
     case YYSYMBOL_block_param: /* block_param  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_args) == (NODE *)-1) {
@@ -8045,11 +8047,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8049 "parse.c"
+#line 8051 "parse.c"
         break;
 
     case YYSYMBOL_opt_block_param: /* opt_block_param  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_args) == (NODE *)-1) {
@@ -8061,11 +8063,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8065 "parse.c"
+#line 8067 "parse.c"
         break;
 
     case YYSYMBOL_block_param_def: /* block_param_def  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_args) == (NODE *)-1) {
@@ -8077,11 +8079,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8081 "parse.c"
+#line 8083 "parse.c"
         break;
 
     case YYSYMBOL_opt_bv_decl: /* opt_bv_decl  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8093,11 +8095,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8097 "parse.c"
+#line 8099 "parse.c"
         break;
 
     case YYSYMBOL_bv_decls: /* bv_decls  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8109,11 +8111,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8113 "parse.c"
+#line 8115 "parse.c"
         break;
 
     case YYSYMBOL_bvar: /* bvar  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8125,11 +8127,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8129 "parse.c"
+#line 8131 "parse.c"
         break;
 
     case YYSYMBOL_numparam: /* numparam  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8141,11 +8143,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8145 "parse.c"
+#line 8147 "parse.c"
         break;
 
     case YYSYMBOL_lambda: /* lambda  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8157,11 +8159,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8161 "parse.c"
+#line 8163 "parse.c"
         break;
 
     case YYSYMBOL_f_larglist: /* f_larglist  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_args) == (NODE *)-1) {
@@ -8173,11 +8175,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8177 "parse.c"
+#line 8179 "parse.c"
         break;
 
     case YYSYMBOL_lambda_body: /* lambda_body  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8189,11 +8191,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8193 "parse.c"
+#line 8195 "parse.c"
         break;
 
     case YYSYMBOL_do_block: /* do_block  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8205,11 +8207,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8209 "parse.c"
+#line 8211 "parse.c"
         break;
 
     case YYSYMBOL_block_call: /* block_call  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8221,11 +8223,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8225 "parse.c"
+#line 8227 "parse.c"
         break;
 
     case YYSYMBOL_method_call: /* method_call  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8237,11 +8239,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8241 "parse.c"
+#line 8243 "parse.c"
         break;
 
     case YYSYMBOL_brace_block: /* brace_block  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8253,11 +8255,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8257 "parse.c"
+#line 8259 "parse.c"
         break;
 
     case YYSYMBOL_brace_body: /* brace_body  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8269,11 +8271,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8273 "parse.c"
+#line 8275 "parse.c"
         break;
 
     case YYSYMBOL_do_body: /* do_body  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8285,11 +8287,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8289 "parse.c"
+#line 8291 "parse.c"
         break;
 
     case YYSYMBOL_case_args: /* case_args  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8301,11 +8303,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8305 "parse.c"
+#line 8307 "parse.c"
         break;
 
     case YYSYMBOL_case_body: /* case_body  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8317,11 +8319,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8321 "parse.c"
+#line 8323 "parse.c"
         break;
 
     case YYSYMBOL_cases: /* cases  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8333,11 +8335,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8337 "parse.c"
+#line 8339 "parse.c"
         break;
 
     case YYSYMBOL_p_case_body: /* p_case_body  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8349,11 +8351,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8353 "parse.c"
+#line 8355 "parse.c"
         break;
 
     case YYSYMBOL_p_cases: /* p_cases  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8365,11 +8367,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8369 "parse.c"
+#line 8371 "parse.c"
         break;
 
     case YYSYMBOL_p_top_expr: /* p_top_expr  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8381,11 +8383,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8385 "parse.c"
+#line 8387 "parse.c"
         break;
 
     case YYSYMBOL_p_top_expr_body: /* p_top_expr_body  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8397,11 +8399,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8401 "parse.c"
+#line 8403 "parse.c"
         break;
 
     case YYSYMBOL_p_expr: /* p_expr  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8413,11 +8415,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8417 "parse.c"
+#line 8419 "parse.c"
         break;
 
     case YYSYMBOL_p_as: /* p_as  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8429,11 +8431,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8433 "parse.c"
+#line 8435 "parse.c"
         break;
 
     case YYSYMBOL_p_alt: /* p_alt  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8445,11 +8447,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8449 "parse.c"
+#line 8451 "parse.c"
         break;
 
     case YYSYMBOL_p_expr_basic: /* p_expr_basic  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8461,11 +8463,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8465 "parse.c"
+#line 8467 "parse.c"
         break;
 
     case YYSYMBOL_p_args: /* p_args  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8477,11 +8479,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8481 "parse.c"
+#line 8483 "parse.c"
         break;
 
     case YYSYMBOL_p_args_head: /* p_args_head  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8493,11 +8495,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8497 "parse.c"
+#line 8499 "parse.c"
         break;
 
     case YYSYMBOL_p_args_tail: /* p_args_tail  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8509,11 +8511,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8513 "parse.c"
+#line 8515 "parse.c"
         break;
 
     case YYSYMBOL_p_find: /* p_find  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8525,11 +8527,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8529 "parse.c"
+#line 8531 "parse.c"
         break;
 
     case YYSYMBOL_p_rest: /* p_rest  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8541,11 +8543,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8545 "parse.c"
+#line 8547 "parse.c"
         break;
 
     case YYSYMBOL_p_args_post: /* p_args_post  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8557,11 +8559,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8561 "parse.c"
+#line 8563 "parse.c"
         break;
 
     case YYSYMBOL_p_arg: /* p_arg  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8573,11 +8575,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8577 "parse.c"
+#line 8579 "parse.c"
         break;
 
     case YYSYMBOL_p_kwargs: /* p_kwargs  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8589,11 +8591,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8593 "parse.c"
+#line 8595 "parse.c"
         break;
 
     case YYSYMBOL_p_kwarg: /* p_kwarg  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8605,11 +8607,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8609 "parse.c"
+#line 8611 "parse.c"
         break;
 
     case YYSYMBOL_p_kw: /* p_kw  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8621,11 +8623,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8625 "parse.c"
+#line 8627 "parse.c"
         break;
 
     case YYSYMBOL_p_value: /* p_value  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8637,11 +8639,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8641 "parse.c"
+#line 8643 "parse.c"
         break;
 
     case YYSYMBOL_p_primitive: /* p_primitive  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8653,11 +8655,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8657 "parse.c"
+#line 8659 "parse.c"
         break;
 
     case YYSYMBOL_p_variable: /* p_variable  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8669,11 +8671,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8673 "parse.c"
+#line 8675 "parse.c"
         break;
 
     case YYSYMBOL_p_var_ref: /* p_var_ref  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8685,11 +8687,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8689 "parse.c"
+#line 8691 "parse.c"
         break;
 
     case YYSYMBOL_p_expr_ref: /* p_expr_ref  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8701,11 +8703,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8705 "parse.c"
+#line 8707 "parse.c"
         break;
 
     case YYSYMBOL_p_const: /* p_const  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8717,11 +8719,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8721 "parse.c"
+#line 8723 "parse.c"
         break;
 
     case YYSYMBOL_opt_rescue: /* opt_rescue  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8733,11 +8735,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8737 "parse.c"
+#line 8739 "parse.c"
         break;
 
     case YYSYMBOL_exc_list: /* exc_list  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8749,11 +8751,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8753 "parse.c"
+#line 8755 "parse.c"
         break;
 
     case YYSYMBOL_exc_var: /* exc_var  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8765,11 +8767,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8769 "parse.c"
+#line 8771 "parse.c"
         break;
 
     case YYSYMBOL_opt_ensure: /* opt_ensure  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8781,11 +8783,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8785 "parse.c"
+#line 8787 "parse.c"
         break;
 
     case YYSYMBOL_literal: /* literal  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8797,11 +8799,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8801 "parse.c"
+#line 8803 "parse.c"
         break;
 
     case YYSYMBOL_strings: /* strings  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8813,11 +8815,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8817 "parse.c"
+#line 8819 "parse.c"
         break;
 
     case YYSYMBOL_string: /* string  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8829,11 +8831,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8833 "parse.c"
+#line 8835 "parse.c"
         break;
 
     case YYSYMBOL_string1: /* string1  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8845,11 +8847,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8849 "parse.c"
+#line 8851 "parse.c"
         break;
 
     case YYSYMBOL_xstring: /* xstring  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8861,11 +8863,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8865 "parse.c"
+#line 8867 "parse.c"
         break;
 
     case YYSYMBOL_regexp: /* regexp  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8877,11 +8879,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8881 "parse.c"
+#line 8883 "parse.c"
         break;
 
     case YYSYMBOL_words: /* words  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8893,11 +8895,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8897 "parse.c"
+#line 8899 "parse.c"
         break;
 
     case YYSYMBOL_word_list: /* word_list  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8909,11 +8911,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8913 "parse.c"
+#line 8915 "parse.c"
         break;
 
     case YYSYMBOL_word: /* word  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8925,11 +8927,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8929 "parse.c"
+#line 8931 "parse.c"
         break;
 
     case YYSYMBOL_symbols: /* symbols  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8941,11 +8943,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8945 "parse.c"
+#line 8947 "parse.c"
         break;
 
     case YYSYMBOL_symbol_list: /* symbol_list  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8957,11 +8959,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8961 "parse.c"
+#line 8963 "parse.c"
         break;
 
     case YYSYMBOL_qwords: /* qwords  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8973,11 +8975,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8977 "parse.c"
+#line 8979 "parse.c"
         break;
 
     case YYSYMBOL_qsymbols: /* qsymbols  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -8989,11 +8991,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 8993 "parse.c"
+#line 8995 "parse.c"
         break;
 
     case YYSYMBOL_qword_list: /* qword_list  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -9005,11 +9007,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9009 "parse.c"
+#line 9011 "parse.c"
         break;
 
     case YYSYMBOL_qsym_list: /* qsym_list  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -9021,11 +9023,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9025 "parse.c"
+#line 9027 "parse.c"
         break;
 
     case YYSYMBOL_string_contents: /* string_contents  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -9037,11 +9039,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9041 "parse.c"
+#line 9043 "parse.c"
         break;
 
     case YYSYMBOL_xstring_contents: /* xstring_contents  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -9053,11 +9055,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9057 "parse.c"
+#line 9059 "parse.c"
         break;
 
     case YYSYMBOL_regexp_contents: /* regexp_contents  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -9069,11 +9071,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9073 "parse.c"
+#line 9075 "parse.c"
         break;
 
     case YYSYMBOL_string_content: /* string_content  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -9085,11 +9087,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9089 "parse.c"
+#line 9091 "parse.c"
         break;
 
     case YYSYMBOL_string_dvar: /* string_dvar  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -9101,11 +9103,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9105 "parse.c"
+#line 9107 "parse.c"
         break;
 
     case YYSYMBOL_symbol: /* symbol  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -9117,11 +9119,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9121 "parse.c"
+#line 9123 "parse.c"
         break;
 
     case YYSYMBOL_ssym: /* ssym  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -9133,11 +9135,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9137 "parse.c"
+#line 9139 "parse.c"
         break;
 
     case YYSYMBOL_dsym: /* dsym  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -9149,11 +9151,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9153 "parse.c"
+#line 9155 "parse.c"
         break;
 
     case YYSYMBOL_numeric: /* numeric  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -9165,11 +9167,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9169 "parse.c"
+#line 9171 "parse.c"
         break;
 
     case YYSYMBOL_simple_numeric: /* simple_numeric  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -9181,11 +9183,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9185 "parse.c"
+#line 9187 "parse.c"
         break;
 
     case YYSYMBOL_var_ref: /* var_ref  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -9197,11 +9199,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9201 "parse.c"
+#line 9203 "parse.c"
         break;
 
     case YYSYMBOL_var_lhs: /* var_lhs  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -9213,11 +9215,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9217 "parse.c"
+#line 9219 "parse.c"
         break;
 
     case YYSYMBOL_backref: /* backref  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -9229,11 +9231,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9233 "parse.c"
+#line 9235 "parse.c"
         break;
 
     case YYSYMBOL_superclass: /* superclass  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -9245,11 +9247,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9249 "parse.c"
+#line 9251 "parse.c"
         break;
 
     case YYSYMBOL_f_opt_paren_args: /* f_opt_paren_args  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_args) == (NODE *)-1) {
@@ -9261,11 +9263,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9265 "parse.c"
+#line 9267 "parse.c"
         break;
 
     case YYSYMBOL_f_paren_args: /* f_paren_args  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_args) == (NODE *)-1) {
@@ -9277,11 +9279,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9281 "parse.c"
+#line 9283 "parse.c"
         break;
 
     case YYSYMBOL_f_arglist: /* f_arglist  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_args) == (NODE *)-1) {
@@ -9293,11 +9295,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9297 "parse.c"
+#line 9299 "parse.c"
         break;
 
     case YYSYMBOL_args_tail: /* args_tail  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_args) == (NODE *)-1) {
@@ -9309,11 +9311,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9313 "parse.c"
+#line 9315 "parse.c"
         break;
 
     case YYSYMBOL_opt_args_tail: /* opt_args_tail  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_args) == (NODE *)-1) {
@@ -9325,11 +9327,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9329 "parse.c"
+#line 9331 "parse.c"
         break;
 
     case YYSYMBOL_f_args: /* f_args  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_args) == (NODE *)-1) {
@@ -9341,11 +9343,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9345 "parse.c"
+#line 9347 "parse.c"
         break;
 
     case YYSYMBOL_f_arg_item: /* f_arg_item  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_args_aux) == (NODE *)-1) {
@@ -9357,11 +9359,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9361 "parse.c"
+#line 9363 "parse.c"
         break;
 
     case YYSYMBOL_f_arg: /* f_arg  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_args_aux) == (NODE *)-1) {
@@ -9373,11 +9375,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9377 "parse.c"
+#line 9379 "parse.c"
         break;
 
     case YYSYMBOL_f_kw: /* f_kw  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_kw_arg) == (NODE *)-1) {
@@ -9389,11 +9391,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9393 "parse.c"
+#line 9395 "parse.c"
         break;
 
     case YYSYMBOL_f_block_kw: /* f_block_kw  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_kw_arg) == (NODE *)-1) {
@@ -9405,11 +9407,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9409 "parse.c"
+#line 9411 "parse.c"
         break;
 
     case YYSYMBOL_f_block_kwarg: /* f_block_kwarg  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_kw_arg) == (NODE *)-1) {
@@ -9421,11 +9423,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9425 "parse.c"
+#line 9427 "parse.c"
         break;
 
     case YYSYMBOL_f_kwarg: /* f_kwarg  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_kw_arg) == (NODE *)-1) {
@@ -9437,11 +9439,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9441 "parse.c"
+#line 9443 "parse.c"
         break;
 
     case YYSYMBOL_f_opt: /* f_opt  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_opt_arg) == (NODE *)-1) {
@@ -9453,11 +9455,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9457 "parse.c"
+#line 9459 "parse.c"
         break;
 
     case YYSYMBOL_f_block_opt: /* f_block_opt  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_opt_arg) == (NODE *)-1) {
@@ -9469,11 +9471,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9473 "parse.c"
+#line 9475 "parse.c"
         break;
 
     case YYSYMBOL_f_block_optarg: /* f_block_optarg  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_opt_arg) == (NODE *)-1) {
@@ -9485,11 +9487,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9489 "parse.c"
+#line 9491 "parse.c"
         break;
 
     case YYSYMBOL_f_optarg: /* f_optarg  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node_opt_arg) == (NODE *)-1) {
@@ -9501,11 +9503,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9505 "parse.c"
+#line 9507 "parse.c"
         break;
 
     case YYSYMBOL_singleton: /* singleton  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -9517,11 +9519,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9521 "parse.c"
+#line 9523 "parse.c"
         break;
 
     case YYSYMBOL_assoc_list: /* assoc_list  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -9533,11 +9535,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9537 "parse.c"
+#line 9539 "parse.c"
         break;
 
     case YYSYMBOL_assocs: /* assocs  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -9549,11 +9551,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9553 "parse.c"
+#line 9555 "parse.c"
         break;
 
     case YYSYMBOL_assoc: /* assoc  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -9565,11 +9567,11 @@ switch (yykind)
 #else
 #endif
 }
-#line 9569 "parse.c"
+#line 9571 "parse.c"
         break;
 
     case YYSYMBOL_none: /* none  */
-#line 1915 "parse.y"
+#line 1917 "parse.y"
          {
 #ifndef RIPPER
     if ((NODE *)((*yyvaluep).node) == (NODE *)-1) {
@@ -9581,7 +9583,7 @@ switch (yykind)
 #else
 #endif
 }
-#line 9585 "parse.c"
+#line 9587 "parse.c"
         break;
 
       default:
@@ -10074,12 +10076,12 @@ YYLTYPE yylloc = yyloc_default;
 
 
         /* User initialization code.  */
-#line 1958 "parse.y"
+#line 1960 "parse.y"
         {
     RUBY_SET_YYLLOC_OF_NONE(yylloc);
 }
 
-#line 10083 "parse.c"
+#line 10085 "parse.c"
 
   yylsp[0] = yylloc;
   goto yysetstate;
@@ -10290,18 +10292,18 @@ yyreduce:
   switch (yyn)
     {
   case 2: /* $@1: %empty  */
-#line 2193 "parse.y"
+#line 2195 "parse.y"
           {
                         SET_LEX_STATE(EXPR_BEG);
                         local_push(p, ifndef_ripper(1)+0);
                         /* jumps are possible in the top-level loop. */
                         if (!ifndef_ripper(p->do_loop) + 0) init_block_exit(p);
                     }
-#line 10301 "parse.c"
+#line 10303 "parse.c"
     break;
 
   case 3: /* program: $@1 top_compstmt  */
-#line 2200 "parse.y"
+#line 2202 "parse.y"
                   {
                     /*%%%*/
                         if ((yyvsp[0].node) && !compile_for_eval) {
@@ -10321,75 +10323,75 @@ yyreduce:
                     /*% ripper[final]: program!($2) %*/
                         local_pop(p);
                     }
-#line 10325 "parse.c"
+#line 10327 "parse.c"
     break;
 
   case 4: /* top_compstmt: top_stmts opt_terms  */
-#line 2222 "parse.y"
+#line 2224 "parse.y"
                   {
                         (yyval.node) = void_stmts(p, (yyvsp[-1].node));
                     }
-#line 10333 "parse.c"
+#line 10335 "parse.c"
     break;
 
   case 5: /* top_stmts: none  */
-#line 2228 "parse.y"
+#line 2230 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_BEGIN(0, &(yyloc));
                     /*% %*/
                     /*% ripper: stmts_add!(stmts_new!, void_stmt!) %*/
                     }
-#line 10344 "parse.c"
+#line 10346 "parse.c"
     break;
 
   case 6: /* top_stmts: top_stmt  */
-#line 2235 "parse.y"
+#line 2237 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = newline_node((yyvsp[0].node));
                     /*% %*/
                     /*% ripper: stmts_add!(stmts_new!, $1) %*/
                     }
-#line 10355 "parse.c"
+#line 10357 "parse.c"
     break;
 
   case 7: /* top_stmts: top_stmts terms top_stmt  */
-#line 2242 "parse.y"
+#line 2244 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = block_append(p, (yyvsp[-2].node), newline_node((yyvsp[0].node)));
                     /*% %*/
                     /*% ripper: stmts_add!($1, $3) %*/
                     }
-#line 10366 "parse.c"
+#line 10368 "parse.c"
     break;
 
   case 8: /* top_stmt: stmt  */
-#line 2251 "parse.y"
+#line 2253 "parse.y"
                   {
                         clear_block_exit(p, true);
                         (yyval.node) = (yyvsp[0].node);
                     }
-#line 10375 "parse.c"
+#line 10377 "parse.c"
     break;
 
   case 9: /* top_stmt: "`BEGIN'" begin_block  */
-#line 2256 "parse.y"
+#line 2258 "parse.y"
                   {
                         (yyval.node) = (yyvsp[0].node);
                     }
-#line 10383 "parse.c"
+#line 10385 "parse.c"
     break;
 
   case 10: /* block_open: '{'  */
-#line 2261 "parse.y"
+#line 2263 "parse.y"
                {(yyval.node_exits) = init_block_exit(p);}
-#line 10389 "parse.c"
+#line 10391 "parse.c"
     break;
 
   case 11: /* begin_block: block_open top_compstmt '}'  */
-#line 2264 "parse.y"
+#line 2266 "parse.y"
                   {
                         restore_block_exit(p, (yyvsp[-2].node_exits));
                     /*%%%*/
@@ -10399,166 +10401,166 @@ yyreduce:
                     /*% %*/
                     /*% ripper: BEGIN!($2) %*/
                     }
-#line 10403 "parse.c"
+#line 10405 "parse.c"
     break;
 
   case 12: /* $@2: %empty  */
-#line 2279 "parse.y"
+#line 2281 "parse.y"
                   {
                         if (!(yyvsp[-1].node)) yyerror1(&(yylsp[0]), "else without rescue is useless");
                         next_rescue_context(&p->ctxt, &(yyvsp[-2].ctxt), after_else);
                     }
-#line 10412 "parse.c"
+#line 10414 "parse.c"
     break;
 
   case 13: /* $@3: %empty  */
-#line 2284 "parse.y"
+#line 2286 "parse.y"
                   {
                         next_rescue_context(&p->ctxt, &(yyvsp[-4].ctxt), after_ensure);
                     }
-#line 10420 "parse.c"
+#line 10422 "parse.c"
     break;
 
   case 14: /* bodystmt: compstmt lex_ctxt opt_rescue k_else $@2 compstmt $@3 opt_ensure  */
-#line 2288 "parse.y"
+#line 2290 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_bodystmt(p, (yyvsp[-7].node), (yyvsp[-5].node), (yyvsp[-2].node), (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: bodystmt!($body, $opt_rescue, $elsebody, $opt_ensure) %*/
                     }
-#line 10431 "parse.c"
+#line 10433 "parse.c"
     break;
 
   case 15: /* $@4: %empty  */
-#line 2297 "parse.y"
+#line 2299 "parse.y"
                   {
                         next_rescue_context(&p->ctxt, &(yyvsp[-1].ctxt), after_ensure);
                     }
-#line 10439 "parse.c"
+#line 10441 "parse.c"
     break;
 
   case 16: /* bodystmt: compstmt lex_ctxt opt_rescue $@4 opt_ensure  */
-#line 2301 "parse.y"
+#line 2303 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_bodystmt(p, (yyvsp[-4].node), (yyvsp[-2].node), 0, (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: bodystmt!($body, $opt_rescue, Qnil, $opt_ensure) %*/
                     }
-#line 10450 "parse.c"
+#line 10452 "parse.c"
     break;
 
   case 17: /* compstmt: stmts opt_terms  */
-#line 2310 "parse.y"
+#line 2312 "parse.y"
                   {
                         (yyval.node) = void_stmts(p, (yyvsp[-1].node));
                     }
-#line 10458 "parse.c"
+#line 10460 "parse.c"
     break;
 
   case 18: /* stmts: none  */
-#line 2316 "parse.y"
+#line 2318 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_BEGIN(0, &(yyloc));
                     /*% %*/
                     /*% ripper: stmts_add!(stmts_new!, void_stmt!) %*/
                     }
-#line 10469 "parse.c"
+#line 10471 "parse.c"
     break;
 
   case 19: /* stmts: stmt_or_begin  */
-#line 2323 "parse.y"
+#line 2325 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = newline_node((yyvsp[0].node));
                     /*% %*/
                     /*% ripper: stmts_add!(stmts_new!, $1) %*/
                     }
-#line 10480 "parse.c"
+#line 10482 "parse.c"
     break;
 
   case 20: /* stmts: stmts terms stmt_or_begin  */
-#line 2330 "parse.y"
+#line 2332 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = block_append(p, (yyvsp[-2].node), newline_node((yyvsp[0].node)));
                     /*% %*/
                     /*% ripper: stmts_add!($1, $3) %*/
                     }
-#line 10491 "parse.c"
+#line 10493 "parse.c"
     break;
 
   case 21: /* stmt_or_begin: stmt  */
-#line 2339 "parse.y"
+#line 2341 "parse.y"
                   {
                         (yyval.node) = (yyvsp[0].node);
                     }
-#line 10499 "parse.c"
+#line 10501 "parse.c"
     break;
 
   case 22: /* $@5: %empty  */
-#line 2343 "parse.y"
+#line 2345 "parse.y"
                   {
                         yyerror1(&(yylsp[0]), "BEGIN is permitted only at toplevel");
                     }
-#line 10507 "parse.c"
+#line 10509 "parse.c"
     break;
 
   case 23: /* stmt_or_begin: "`BEGIN'" $@5 begin_block  */
-#line 2347 "parse.y"
+#line 2349 "parse.y"
                   {
                         (yyval.node) = (yyvsp[0].node);
                     }
-#line 10515 "parse.c"
+#line 10517 "parse.c"
     break;
 
   case 24: /* allow_exits: %empty  */
-#line 2352 "parse.y"
+#line 2354 "parse.y"
             {(yyval.node_exits) = allow_block_exit(p);}
-#line 10521 "parse.c"
+#line 10523 "parse.c"
     break;
 
   case 25: /* k_END: "`END'" lex_ctxt  */
-#line 2355 "parse.y"
+#line 2357 "parse.y"
                   {
                         (yyval.ctxt) = (yyvsp[0].ctxt);
                         p->ctxt.in_rescue = before_rescue;
                     }
-#line 10530 "parse.c"
+#line 10532 "parse.c"
     break;
 
   case 26: /* $@6: %empty  */
-#line 2360 "parse.y"
+#line 2362 "parse.y"
                           {SET_LEX_STATE(EXPR_FNAME|EXPR_FITEM);}
-#line 10536 "parse.c"
+#line 10538 "parse.c"
     break;
 
   case 27: /* stmt: "`alias'" fitem $@6 fitem  */
-#line 2361 "parse.y"
+#line 2363 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_ALIAS((yyvsp[-2].node), (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: alias!($2, $4) %*/
                     }
-#line 10547 "parse.c"
+#line 10549 "parse.c"
     break;
 
   case 28: /* stmt: "`alias'" "global variable" "global variable"  */
-#line 2368 "parse.y"
+#line 2370 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_VALIAS((yyvsp[-1].id), (yyvsp[0].id), &(yyloc));
                     /*% %*/
                     /*% ripper: var_alias!($2, $3) %*/
                     }
-#line 10558 "parse.c"
+#line 10560 "parse.c"
     break;
 
   case 29: /* stmt: "`alias'" "global variable" "back reference"  */
-#line 2375 "parse.y"
+#line 2377 "parse.y"
                   {
                     /*%%%*/
                         char buf[2];
@@ -10568,11 +10570,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: var_alias!($2, $3) %*/
                     }
-#line 10572 "parse.c"
+#line 10574 "parse.c"
     break;
 
   case 30: /* stmt: "`alias'" "global variable" "numbered reference"  */
-#line 2385 "parse.y"
+#line 2387 "parse.y"
                   {
                         static const char mesg[] = "can't make alias for the number variables";
                     /*%%%*/
@@ -10581,22 +10583,22 @@ yyreduce:
                     /*% %*/
                     /*% ripper[error]: alias_error!(ERR_MESG(), $3) %*/
                     }
-#line 10585 "parse.c"
+#line 10587 "parse.c"
     break;
 
   case 31: /* stmt: "`undef'" undef_list  */
-#line 2394 "parse.y"
+#line 2396 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = (yyvsp[0].node);
                     /*% %*/
                     /*% ripper: undef!($2) %*/
                     }
-#line 10596 "parse.c"
+#line 10598 "parse.c"
     break;
 
   case 32: /* stmt: stmt "`if' modifier" expr_value  */
-#line 2401 "parse.y"
+#line 2403 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_if(p, (yyvsp[0].node), remove_begin((yyvsp[-2].node)), 0, &(yyloc));
@@ -10604,11 +10606,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: if_mod!($3, $1) %*/
                     }
-#line 10608 "parse.c"
+#line 10610 "parse.c"
     break;
 
   case 33: /* stmt: stmt "`unless' modifier" expr_value  */
-#line 2409 "parse.y"
+#line 2411 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_unless(p, (yyvsp[0].node), remove_begin((yyvsp[-2].node)), 0, &(yyloc));
@@ -10616,11 +10618,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: unless_mod!($3, $1) %*/
                     }
-#line 10620 "parse.c"
+#line 10622 "parse.c"
     break;
 
   case 34: /* stmt: stmt "`while' modifier" expr_value  */
-#line 2417 "parse.y"
+#line 2419 "parse.y"
                   {
                         clear_block_exit(p, false);
                     /*%%%*/
@@ -10633,11 +10635,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: while_mod!($3, $1) %*/
                     }
-#line 10637 "parse.c"
+#line 10639 "parse.c"
     break;
 
   case 35: /* stmt: stmt "`until' modifier" expr_value  */
-#line 2430 "parse.y"
+#line 2432 "parse.y"
                   {
                         clear_block_exit(p, false);
                     /*%%%*/
@@ -10650,11 +10652,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: until_mod!($3, $1) %*/
                     }
-#line 10654 "parse.c"
+#line 10656 "parse.c"
     break;
 
   case 36: /* stmt: stmt "`rescue' modifier" after_rescue stmt  */
-#line 2443 "parse.y"
+#line 2445 "parse.y"
                   {
                         p->ctxt.in_rescue = (yyvsp[-1].ctxt).in_rescue;
                     /*%%%*/
@@ -10665,11 +10667,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: rescue_mod!($1, $4) %*/
                     }
-#line 10669 "parse.c"
+#line 10671 "parse.c"
     break;
 
   case 37: /* stmt: k_END allow_exits '{' compstmt '}'  */
-#line 2454 "parse.y"
+#line 2456 "parse.y"
                   {
                         if (p->ctxt.in_def) {
                             rb_warn0("END in method; use at_exit");
@@ -10684,11 +10686,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: END!($compstmt) %*/
                     }
-#line 10688 "parse.c"
+#line 10690 "parse.c"
     break;
 
   case 39: /* stmt: mlhs '=' lex_ctxt command_call  */
-#line 2470 "parse.y"
+#line 2472 "parse.y"
                   {
                     /*%%%*/
                         value_expr((yyvsp[0].node));
@@ -10696,22 +10698,22 @@ yyreduce:
                     /*% %*/
                     /*% ripper: massign!($1, $4) %*/
                     }
-#line 10700 "parse.c"
+#line 10702 "parse.c"
     break;
 
   case 40: /* stmt: lhs '=' lex_ctxt mrhs  */
-#line 2478 "parse.y"
+#line 2480 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = node_assign(p, (yyvsp[-3].node), (yyvsp[0].node), (yyvsp[-1].ctxt), &(yyloc));
                     /*% %*/
                     /*% ripper: assign!($1, $4) %*/
                     }
-#line 10711 "parse.c"
+#line 10713 "parse.c"
     break;
 
   case 41: /* stmt: mlhs '=' lex_ctxt mrhs_arg "`rescue' modifier" after_rescue stmt  */
-#line 2486 "parse.y"
+#line 2488 "parse.y"
                   {
                         p->ctxt.in_rescue = (yyvsp[-4].ctxt).in_rescue;
                     /*%%%*/
@@ -10723,55 +10725,55 @@ yyreduce:
                     /*% %*/
                     /*% ripper: massign!($1, rescue_mod!($4, $7)) %*/
                     }
-#line 10727 "parse.c"
+#line 10729 "parse.c"
     break;
 
   case 42: /* stmt: mlhs '=' lex_ctxt mrhs_arg  */
-#line 2498 "parse.y"
+#line 2500 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = node_assign(p, (NODE *)(yyvsp[-3].node_masgn), (yyvsp[0].node), (yyvsp[-1].ctxt), &(yyloc));
                     /*% %*/
                     /*% ripper: massign!($1, $4) %*/
                     }
-#line 10738 "parse.c"
+#line 10740 "parse.c"
     break;
 
   case 44: /* stmt: error  */
-#line 2506 "parse.y"
+#line 2508 "parse.y"
                   {
                         (void)yynerrs;
                     /*%%%*/
                         (yyval.node) = NEW_ERROR(&(yyloc));
                     /*% %*/
                     }
-#line 10749 "parse.c"
+#line 10751 "parse.c"
     break;
 
   case 45: /* command_asgn: lhs '=' lex_ctxt command_rhs  */
-#line 2515 "parse.y"
+#line 2517 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = node_assign(p, (yyvsp[-3].node), (yyvsp[0].node), (yyvsp[-1].ctxt), &(yyloc));
                     /*% %*/
                     /*% ripper: assign!($1, $4) %*/
                     }
-#line 10760 "parse.c"
+#line 10762 "parse.c"
     break;
 
   case 46: /* command_asgn: var_lhs "operator-assignment" lex_ctxt command_rhs  */
-#line 2522 "parse.y"
+#line 2524 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_op_assign(p, (yyvsp[-3].node), (yyvsp[-2].id), (yyvsp[0].node), (yyvsp[-1].ctxt), &(yyloc));
                     /*% %*/
                     /*% ripper: opassign!($1, $2, $4) %*/
                     }
-#line 10771 "parse.c"
+#line 10773 "parse.c"
     break;
 
   case 47: /* command_asgn: primary_value '[' opt_call_args rbracket "operator-assignment" lex_ctxt command_rhs  */
-#line 2529 "parse.y"
+#line 2531 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_ary_op_assign(p, (yyvsp[-6].node), (yyvsp[-4].node), (yyvsp[-2].id), (yyvsp[0].node), &(yylsp[-4]), &(yyloc));
@@ -10779,33 +10781,33 @@ yyreduce:
                     /*% ripper: opassign!(aref_field!($1, $3), $5, $7) %*/
 
                     }
-#line 10783 "parse.c"
+#line 10785 "parse.c"
     break;
 
   case 48: /* command_asgn: primary_value call_op "local variable or method" "operator-assignment" lex_ctxt command_rhs  */
-#line 2537 "parse.y"
+#line 2539 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_attr_op_assign(p, (yyvsp[-5].node), (yyvsp[-4].id), (yyvsp[-3].id), (yyvsp[-2].id), (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: opassign!(field!($1, $2, $3), $4, $6) %*/
                     }
-#line 10794 "parse.c"
+#line 10796 "parse.c"
     break;
 
   case 49: /* command_asgn: primary_value call_op "constant" "operator-assignment" lex_ctxt command_rhs  */
-#line 2544 "parse.y"
+#line 2546 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_attr_op_assign(p, (yyvsp[-5].node), (yyvsp[-4].id), (yyvsp[-3].id), (yyvsp[-2].id), (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: opassign!(field!($1, $2, $3), $4, $6) %*/
                     }
-#line 10805 "parse.c"
+#line 10807 "parse.c"
     break;
 
   case 50: /* command_asgn: primary_value "::" "constant" "operator-assignment" lex_ctxt command_rhs  */
-#line 2551 "parse.y"
+#line 2553 "parse.y"
                   {
                     /*%%%*/
                         YYLTYPE loc = code_loc_gen(&(yylsp[-5]), &(yylsp[-3]));
@@ -10813,22 +10815,22 @@ yyreduce:
                     /*% %*/
                     /*% ripper: opassign!(const_path_field!($1, $3), $4, $6) %*/
                     }
-#line 10817 "parse.c"
+#line 10819 "parse.c"
     break;
 
   case 51: /* command_asgn: primary_value "::" "local variable or method" "operator-assignment" lex_ctxt command_rhs  */
-#line 2559 "parse.y"
+#line 2561 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_attr_op_assign(p, (yyvsp[-5].node), ID2VAL(idCOLON2), (yyvsp[-3].id), (yyvsp[-2].id), (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: opassign!(field!($1, $2, $3), $4, $6) %*/
                     }
-#line 10828 "parse.c"
+#line 10830 "parse.c"
     break;
 
   case 52: /* command_asgn: defn_head f_opt_paren_args '=' endless_command  */
-#line 2566 "parse.y"
+#line 2568 "parse.y"
                   {
                         endless_method_name(p, get_id((yyvsp[-3].node_def_temp)->nd_mid), &(yylsp[-3]));
                         restore_defun(p, (yyvsp[-3].node_def_temp));
@@ -10841,11 +10843,11 @@ yyreduce:
                     /*% ripper: def!($head->nd_mid, $args, $bodystmt) %*/
                         local_pop(p);
                     }
-#line 10845 "parse.c"
+#line 10847 "parse.c"
     break;
 
   case 53: /* command_asgn: defs_head f_opt_paren_args '=' endless_command  */
-#line 2579 "parse.y"
+#line 2581 "parse.y"
                   {
                         endless_method_name(p, get_id((yyvsp[-3].node_def_temp)->nd_mid), &(yylsp[-3]));
                         restore_defun(p, (yyvsp[-3].node_def_temp));
@@ -10858,11 +10860,11 @@ yyreduce:
                     /*% ripper: defs!($head->nd_recv, $head->dot_or_colon, $head->nd_mid, $args, $bodystmt) %*/
                         local_pop(p);
                     }
-#line 10862 "parse.c"
+#line 10864 "parse.c"
     break;
 
   case 54: /* command_asgn: backref "operator-assignment" lex_ctxt command_rhs  */
-#line 2592 "parse.y"
+#line 2594 "parse.y"
                   {
                     /*%%%*/
                         rb_backref_error(p, (yyvsp[-3].node));
@@ -10870,11 +10872,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper[error]: backref_error(p, RNODE($1), assign!(var_field(p, $1), $4)) %*/
                     }
-#line 10874 "parse.c"
+#line 10876 "parse.c"
     break;
 
   case 56: /* endless_command: endless_command "`rescue' modifier" after_rescue arg  */
-#line 2603 "parse.y"
+#line 2605 "parse.y"
                   {
                         p->ctxt.in_rescue = (yyvsp[-1].ctxt).in_rescue;
                     /*%%%*/
@@ -10882,28 +10884,28 @@ yyreduce:
                     /*% %*/
                     /*% ripper: rescue_mod!($1, $4) %*/
                     }
-#line 10886 "parse.c"
+#line 10888 "parse.c"
     break;
 
   case 57: /* endless_command: "`not'" opt_nl endless_command  */
-#line 2611 "parse.y"
+#line 2613 "parse.y"
                   {
                         (yyval.node) = call_uni_op(p, method_cond(p, (yyvsp[0].node), &(yylsp[0])), METHOD_NOT, &(yylsp[-2]), &(yyloc));
                     }
-#line 10894 "parse.c"
+#line 10896 "parse.c"
     break;
 
   case 58: /* command_rhs: command_call  */
-#line 2617 "parse.y"
+#line 2619 "parse.y"
                   {
                         value_expr((yyvsp[0].node));
                         (yyval.node) = (yyvsp[0].node);
                     }
-#line 10903 "parse.c"
+#line 10905 "parse.c"
     break;
 
   case 59: /* command_rhs: command_call "`rescue' modifier" after_rescue stmt  */
-#line 2622 "parse.y"
+#line 2624 "parse.y"
                   {
                         p->ctxt.in_rescue = (yyvsp[-1].ctxt).in_rescue;
                     /*%%%*/
@@ -10913,51 +10915,51 @@ yyreduce:
                     /*% %*/
                     /*% ripper: rescue_mod!($1, $4) %*/
                     }
-#line 10917 "parse.c"
+#line 10919 "parse.c"
     break;
 
   case 62: /* expr: expr "`and'" expr  */
-#line 2636 "parse.y"
+#line 2638 "parse.y"
                   {
                         (yyval.node) = logop(p, idAND, (yyvsp[-2].node), (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     }
-#line 10925 "parse.c"
+#line 10927 "parse.c"
     break;
 
   case 63: /* expr: expr "`or'" expr  */
-#line 2640 "parse.y"
+#line 2642 "parse.y"
                   {
                         (yyval.node) = logop(p, idOR, (yyvsp[-2].node), (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     }
-#line 10933 "parse.c"
+#line 10935 "parse.c"
     break;
 
   case 64: /* expr: "`not'" opt_nl expr  */
-#line 2644 "parse.y"
+#line 2646 "parse.y"
                   {
                         (yyval.node) = call_uni_op(p, method_cond(p, (yyvsp[0].node), &(yylsp[0])), METHOD_NOT, &(yylsp[-2]), &(yyloc));
                     }
-#line 10941 "parse.c"
+#line 10943 "parse.c"
     break;
 
   case 65: /* expr: '!' command_call  */
-#line 2648 "parse.y"
+#line 2650 "parse.y"
                   {
                         (yyval.node) = call_uni_op(p, method_cond(p, (yyvsp[0].node), &(yylsp[0])), '!', &(yylsp[-1]), &(yyloc));
                     }
-#line 10949 "parse.c"
+#line 10951 "parse.c"
     break;
 
   case 66: /* $@7: %empty  */
-#line 2652 "parse.y"
+#line 2654 "parse.y"
                   {
                         value_expr((yyvsp[-1].node));
                     }
-#line 10957 "parse.c"
+#line 10959 "parse.c"
     break;
 
   case 67: /* expr: arg "=>" $@7 p_in_kwarg p_pvtbl p_pktbl p_top_expr_body  */
-#line 2657 "parse.y"
+#line 2659 "parse.y"
                   {
                         pop_pktbl(p, (yyvsp[-1].tbl));
                         pop_pvtbl(p, (yyvsp[-2].tbl));
@@ -10967,19 +10969,19 @@ yyreduce:
                     /*% %*/
                     /*% ripper: case!($arg, in!($body, Qnil, Qnil)) %*/
                     }
-#line 10971 "parse.c"
+#line 10973 "parse.c"
     break;
 
   case 68: /* $@8: %empty  */
-#line 2667 "parse.y"
+#line 2669 "parse.y"
                   {
                         value_expr((yyvsp[-1].node));
                     }
-#line 10979 "parse.c"
+#line 10981 "parse.c"
     break;
 
   case 69: /* expr: arg "`in'" $@8 p_in_kwarg p_pvtbl p_pktbl p_top_expr_body  */
-#line 2672 "parse.y"
+#line 2674 "parse.y"
                   {
                         pop_pktbl(p, (yyvsp[-1].tbl));
                         pop_pvtbl(p, (yyvsp[-2].tbl));
@@ -10989,11 +10991,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: case!($arg, in!($body, Qnil, Qnil)) %*/
                     }
-#line 10993 "parse.c"
+#line 10995 "parse.c"
     break;
 
   case 71: /* def_name: fname  */
-#line 2685 "parse.y"
+#line 2687 "parse.y"
                   {
                         ID fname = get_id((yyvsp[0].id));
                         numparam_name(p, fname);
@@ -11003,11 +11005,11 @@ yyreduce:
                         p->ctxt.in_rescue = before_rescue;
                         (yyval.id) = (yyvsp[0].id);
                     }
-#line 11007 "parse.c"
+#line 11009 "parse.c"
     break;
 
   case 72: /* defn_head: k_def def_name  */
-#line 2697 "parse.y"
+#line 2699 "parse.y"
                   {
                         (yyval.node_def_temp) = def_head_save(p, (yyvsp[-1].node_def_temp));
                         (yyval.node_def_temp)->nd_mid = (yyvsp[0].id);
@@ -11017,20 +11019,20 @@ yyreduce:
                         add_mark_object(p, $def_name);
                     %*/
                     }
-#line 11021 "parse.c"
+#line 11023 "parse.c"
     break;
 
   case 73: /* $@9: %empty  */
-#line 2709 "parse.y"
+#line 2711 "parse.y"
                   {
                         SET_LEX_STATE(EXPR_FNAME);
                         p->ctxt.in_argdef = 1;
                     }
-#line 11030 "parse.c"
+#line 11032 "parse.c"
     break;
 
   case 74: /* defs_head: k_def singleton dot_or_colon $@9 def_name  */
-#line 2714 "parse.y"
+#line 2716 "parse.y"
                   {
                         SET_LEX_STATE(EXPR_ENDFN|EXPR_LABEL); /* force for args */
                         (yyval.node_def_temp) = def_head_save(p, (yyvsp[-4].node_def_temp));
@@ -11043,83 +11045,83 @@ yyreduce:
                         $$->dot_or_colon = add_mark_object(p, $dot_or_colon);
                     %*/
                     }
-#line 11047 "parse.c"
+#line 11049 "parse.c"
     break;
 
   case 75: /* expr_value: expr  */
-#line 2729 "parse.y"
+#line 2731 "parse.y"
                   {
                         value_expr((yyvsp[0].node));
                         (yyval.node) = (yyvsp[0].node);
                     }
-#line 11056 "parse.c"
+#line 11058 "parse.c"
     break;
 
   case 76: /* expr_value: error  */
-#line 2734 "parse.y"
+#line 2736 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_ERROR(&(yyloc));
                     /*% %*/
                     }
-#line 11066 "parse.c"
+#line 11068 "parse.c"
     break;
 
   case 77: /* $@10: %empty  */
-#line 2741 "parse.y"
+#line 2743 "parse.y"
               {COND_PUSH(1);}
-#line 11072 "parse.c"
+#line 11074 "parse.c"
     break;
 
   case 78: /* $@11: %empty  */
-#line 2741 "parse.y"
+#line 2743 "parse.y"
                                             {COND_POP();}
-#line 11078 "parse.c"
+#line 11080 "parse.c"
     break;
 
   case 79: /* expr_value_do: $@10 expr_value do $@11  */
-#line 2742 "parse.y"
+#line 2744 "parse.y"
                   {
                         (yyval.node) = (yyvsp[-2].node);
                     }
-#line 11086 "parse.c"
+#line 11088 "parse.c"
     break;
 
   case 83: /* block_command: block_call call_op2 operation2 command_args  */
-#line 2753 "parse.y"
+#line 2755 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_qcall(p, (yyvsp[-2].id), (yyvsp[-3].node), (yyvsp[-1].id), (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     /*% %*/
                     /*% ripper: method_add_arg!(call!($1, $2, $3), $4) %*/
                     }
-#line 11097 "parse.c"
+#line 11099 "parse.c"
     break;
 
   case 84: /* cmd_brace_block: "{ arg" brace_body '}'  */
-#line 2762 "parse.y"
+#line 2764 "parse.y"
                   {
                         (yyval.node) = (yyvsp[-1].node);
                     /*%%%*/
                         set_embraced_location((yyval.node), &(yylsp[-2]), &(yylsp[0]));
                     /*% %*/
                     }
-#line 11108 "parse.c"
+#line 11110 "parse.c"
     break;
 
   case 85: /* fcall: operation  */
-#line 2771 "parse.y"
+#line 2773 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_fcall) = NEW_FCALL((yyvsp[0].id), 0, &(yyloc));
                     /*% %*/
                     /*% ripper: $1 %*/
                     }
-#line 11119 "parse.c"
+#line 11121 "parse.c"
     break;
 
   case 86: /* command: fcall command_args  */
-#line 2780 "parse.y"
+#line 2782 "parse.y"
                   {
                     /*%%%*/
                         (yyvsp[-1].node_fcall)->nd_args = (yyvsp[0].node);
@@ -11128,11 +11130,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: command!($1, $2) %*/
                     }
-#line 11132 "parse.c"
+#line 11134 "parse.c"
     break;
 
   case 87: /* command: fcall command_args cmd_brace_block  */
-#line 2789 "parse.y"
+#line 2791 "parse.y"
                   {
                     /*%%%*/
                         block_dup_check(p, (yyvsp[-1].node), (yyvsp[0].node));
@@ -11143,55 +11145,55 @@ yyreduce:
                     /*% %*/
                     /*% ripper: method_add_block!(command!($1, $2), $3) %*/
                     }
-#line 11147 "parse.c"
+#line 11149 "parse.c"
     break;
 
   case 88: /* command: primary_value call_op operation2 command_args  */
-#line 2800 "parse.y"
+#line 2802 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_command_qcall(p, (yyvsp[-2].id), (yyvsp[-3].node), (yyvsp[-1].id), (yyvsp[0].node), Qnull, &(yylsp[-1]), &(yyloc));
                     /*% %*/
                     /*% ripper: command_call!($1, $2, $3, $4) %*/
                     }
-#line 11158 "parse.c"
+#line 11160 "parse.c"
     break;
 
   case 89: /* command: primary_value call_op operation2 command_args cmd_brace_block  */
-#line 2807 "parse.y"
+#line 2809 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_command_qcall(p, (yyvsp[-3].id), (yyvsp[-4].node), (yyvsp[-2].id), (yyvsp[-1].node), (yyvsp[0].node), &(yylsp[-2]), &(yyloc));
                     /*% %*/
                     /*% ripper: method_add_block!(command_call!($1, $2, $3, $4), $5) %*/
                     }
-#line 11169 "parse.c"
+#line 11171 "parse.c"
     break;
 
   case 90: /* command: primary_value "::" operation2 command_args  */
-#line 2814 "parse.y"
+#line 2816 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_command_qcall(p, ID2VAL(idCOLON2), (yyvsp[-3].node), (yyvsp[-1].id), (yyvsp[0].node), Qnull, &(yylsp[-1]), &(yyloc));
                     /*% %*/
                     /*% ripper: command_call!($1, $2, $3, $4) %*/
                     }
-#line 11180 "parse.c"
+#line 11182 "parse.c"
     break;
 
   case 91: /* command: primary_value "::" operation2 command_args cmd_brace_block  */
-#line 2821 "parse.y"
+#line 2823 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_command_qcall(p, ID2VAL(idCOLON2), (yyvsp[-4].node), (yyvsp[-2].id), (yyvsp[-1].node), (yyvsp[0].node), &(yylsp[-2]), &(yyloc));
                     /*% %*/
                     /*% ripper: method_add_block!(command_call!($1, $2, $3, $4), $5) %*/
                    }
-#line 11191 "parse.c"
+#line 11193 "parse.c"
     break;
 
   case 92: /* command: primary_value "::" "constant" '{' brace_body '}'  */
-#line 2828 "parse.y"
+#line 2830 "parse.y"
                   {
                     /*%%%*/
                         set_embraced_location((yyvsp[-1].node), &(yylsp[-2]), &(yylsp[0]));
@@ -11199,11 +11201,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: method_add_block!(command_call!($1, $2, $3, Qnull), $5) %*/
                    }
-#line 11203 "parse.c"
+#line 11205 "parse.c"
     break;
 
   case 93: /* command: "`super'" command_args  */
-#line 2836 "parse.y"
+#line 2838 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_SUPER((yyvsp[0].node), &(yyloc));
@@ -11211,11 +11213,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: super!($2) %*/
                     }
-#line 11215 "parse.c"
+#line 11217 "parse.c"
     break;
 
   case 94: /* command: k_yield command_args  */
-#line 2844 "parse.y"
+#line 2846 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_yield(p, (yyvsp[0].node), &(yyloc));
@@ -11223,22 +11225,22 @@ yyreduce:
                     /*% %*/
                     /*% ripper: yield!($2) %*/
                     }
-#line 11227 "parse.c"
+#line 11229 "parse.c"
     break;
 
   case 95: /* command: k_return call_args  */
-#line 2852 "parse.y"
+#line 2854 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_RETURN(ret_args(p, (yyvsp[0].node)), &(yyloc));
                     /*% %*/
                     /*% ripper: return!($2) %*/
                     }
-#line 11238 "parse.c"
+#line 11240 "parse.c"
     break;
 
   case 96: /* command: "`break'" call_args  */
-#line 2859 "parse.y"
+#line 2861 "parse.y"
                   {
                         NODE *args = 0;
                     /*%%%*/
@@ -11247,11 +11249,11 @@ yyreduce:
                         (yyval.node) = add_block_exit(p, NEW_BREAK(args, &(yyloc)));
                     /*% ripper: break!($2) %*/
                     }
-#line 11251 "parse.c"
+#line 11253 "parse.c"
     break;
 
   case 97: /* command: "`next'" call_args  */
-#line 2868 "parse.y"
+#line 2870 "parse.y"
                   {
                         NODE *args = 0;
                     /*%%%*/
@@ -11260,288 +11262,288 @@ yyreduce:
                         (yyval.node) = add_block_exit(p, NEW_NEXT(args, &(yyloc)));
                     /*% ripper: next!($2) %*/
                     }
-#line 11264 "parse.c"
+#line 11266 "parse.c"
     break;
 
   case 99: /* mlhs: "(" mlhs_inner rparen  */
-#line 2880 "parse.y"
+#line 2882 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_masgn) = (yyvsp[-1].node_masgn);
                     /*% %*/
                     /*% ripper: mlhs_paren!($2) %*/
                     }
-#line 11275 "parse.c"
+#line 11277 "parse.c"
     break;
 
   case 101: /* mlhs_inner: "(" mlhs_inner rparen  */
-#line 2890 "parse.y"
+#line 2892 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_masgn) = NEW_MASGN(NEW_LIST((NODE *)(yyvsp[-1].node_masgn), &(yyloc)), 0, &(yyloc));
                     /*% %*/
                     /*% ripper: mlhs_paren!($2) %*/
                     }
-#line 11286 "parse.c"
+#line 11288 "parse.c"
     break;
 
   case 102: /* mlhs_basic: mlhs_head  */
-#line 2899 "parse.y"
+#line 2901 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_masgn) = NEW_MASGN((yyvsp[0].node), 0, &(yyloc));
                     /*% %*/
                     /*% ripper: $1 %*/
                     }
-#line 11297 "parse.c"
+#line 11299 "parse.c"
     break;
 
   case 103: /* mlhs_basic: mlhs_head mlhs_item  */
-#line 2906 "parse.y"
+#line 2908 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_masgn) = NEW_MASGN(list_append(p, (yyvsp[-1].node), (yyvsp[0].node)), 0, &(yyloc));
                     /*% %*/
                     /*% ripper: mlhs_add!($1, $2) %*/
                     }
-#line 11308 "parse.c"
+#line 11310 "parse.c"
     break;
 
   case 104: /* mlhs_basic: mlhs_head "*" mlhs_node  */
-#line 2913 "parse.y"
+#line 2915 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_masgn) = NEW_MASGN((yyvsp[-2].node), (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: mlhs_add_star!($1, $3) %*/
                     }
-#line 11319 "parse.c"
+#line 11321 "parse.c"
     break;
 
   case 105: /* mlhs_basic: mlhs_head "*" mlhs_node ',' mlhs_post  */
-#line 2920 "parse.y"
+#line 2922 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_masgn) = NEW_MASGN((yyvsp[-4].node), NEW_POSTARG((yyvsp[-2].node),(yyvsp[0].node),&(yyloc)), &(yyloc));
                     /*% %*/
                     /*% ripper: mlhs_add_post!(mlhs_add_star!($1, $3), $5) %*/
                     }
-#line 11330 "parse.c"
+#line 11332 "parse.c"
     break;
 
   case 106: /* mlhs_basic: mlhs_head "*"  */
-#line 2927 "parse.y"
+#line 2929 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_masgn) = NEW_MASGN((yyvsp[-1].node), NODE_SPECIAL_NO_NAME_REST, &(yyloc));
                     /*% %*/
                     /*% ripper: mlhs_add_star!($1, Qnil) %*/
                     }
-#line 11341 "parse.c"
+#line 11343 "parse.c"
     break;
 
   case 107: /* mlhs_basic: mlhs_head "*" ',' mlhs_post  */
-#line 2934 "parse.y"
+#line 2936 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_masgn) = NEW_MASGN((yyvsp[-3].node), NEW_POSTARG(NODE_SPECIAL_NO_NAME_REST, (yyvsp[0].node), &(yyloc)), &(yyloc));
                     /*% %*/
                     /*% ripper: mlhs_add_post!(mlhs_add_star!($1, Qnil), $4) %*/
                     }
-#line 11352 "parse.c"
+#line 11354 "parse.c"
     break;
 
   case 108: /* mlhs_basic: "*" mlhs_node  */
-#line 2941 "parse.y"
+#line 2943 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_masgn) = NEW_MASGN(0, (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: mlhs_add_star!(mlhs_new!, $2) %*/
                     }
-#line 11363 "parse.c"
+#line 11365 "parse.c"
     break;
 
   case 109: /* mlhs_basic: "*" mlhs_node ',' mlhs_post  */
-#line 2948 "parse.y"
+#line 2950 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_masgn) = NEW_MASGN(0, NEW_POSTARG((yyvsp[-2].node),(yyvsp[0].node),&(yyloc)), &(yyloc));
                     /*% %*/
                     /*% ripper: mlhs_add_post!(mlhs_add_star!(mlhs_new!, $2), $4) %*/
                     }
-#line 11374 "parse.c"
+#line 11376 "parse.c"
     break;
 
   case 110: /* mlhs_basic: "*"  */
-#line 2955 "parse.y"
+#line 2957 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_masgn) = NEW_MASGN(0, NODE_SPECIAL_NO_NAME_REST, &(yyloc));
                     /*% %*/
                     /*% ripper: mlhs_add_star!(mlhs_new!, Qnil) %*/
                     }
-#line 11385 "parse.c"
+#line 11387 "parse.c"
     break;
 
   case 111: /* mlhs_basic: "*" ',' mlhs_post  */
-#line 2962 "parse.y"
+#line 2964 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_masgn) = NEW_MASGN(0, NEW_POSTARG(NODE_SPECIAL_NO_NAME_REST, (yyvsp[0].node), &(yyloc)), &(yyloc));
                     /*% %*/
                     /*% ripper: mlhs_add_post!(mlhs_add_star!(mlhs_new!, Qnil), $3) %*/
                     }
-#line 11396 "parse.c"
+#line 11398 "parse.c"
     break;
 
   case 113: /* mlhs_item: "(" mlhs_inner rparen  */
-#line 2972 "parse.y"
+#line 2974 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = (NODE *)(yyvsp[-1].node_masgn);
                     /*% %*/
                     /*% ripper: mlhs_paren!($2) %*/
                     }
-#line 11407 "parse.c"
+#line 11409 "parse.c"
     break;
 
   case 114: /* mlhs_head: mlhs_item ','  */
-#line 2981 "parse.y"
+#line 2983 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_LIST((yyvsp[-1].node), &(yylsp[-1]));
                     /*% %*/
                     /*% ripper: mlhs_add!(mlhs_new!, $1) %*/
                     }
-#line 11418 "parse.c"
+#line 11420 "parse.c"
     break;
 
   case 115: /* mlhs_head: mlhs_head mlhs_item ','  */
-#line 2988 "parse.y"
+#line 2990 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = list_append(p, (yyvsp[-2].node), (yyvsp[-1].node));
                     /*% %*/
                     /*% ripper: mlhs_add!($1, $2) %*/
                     }
-#line 11429 "parse.c"
+#line 11431 "parse.c"
     break;
 
   case 116: /* mlhs_post: mlhs_item  */
-#line 2997 "parse.y"
+#line 2999 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_LIST((yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: mlhs_add!(mlhs_new!, $1) %*/
                     }
-#line 11440 "parse.c"
+#line 11442 "parse.c"
     break;
 
   case 117: /* mlhs_post: mlhs_post ',' mlhs_item  */
-#line 3004 "parse.y"
+#line 3006 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = list_append(p, (yyvsp[-2].node), (yyvsp[0].node));
                     /*% %*/
                     /*% ripper: mlhs_add!($1, $3) %*/
                     }
-#line 11451 "parse.c"
+#line 11453 "parse.c"
     break;
 
   case 118: /* mlhs_node: user_variable  */
-#line 3013 "parse.y"
+#line 3015 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = assignable(p, (yyvsp[0].id), 0, &(yyloc));
                     /*% %*/
                     /*% ripper: assignable(p, var_field(p, $1)) %*/
                     }
-#line 11462 "parse.c"
+#line 11464 "parse.c"
     break;
 
   case 119: /* mlhs_node: keyword_variable  */
-#line 3020 "parse.y"
+#line 3022 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = assignable(p, (yyvsp[0].id), 0, &(yyloc));
                     /*% %*/
                     /*% ripper: assignable(p, var_field(p, $1)) %*/
                     }
-#line 11473 "parse.c"
+#line 11475 "parse.c"
     break;
 
   case 120: /* mlhs_node: primary_value '[' opt_call_args rbracket  */
-#line 3027 "parse.y"
+#line 3029 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = aryset(p, (yyvsp[-3].node), (yyvsp[-1].node), &(yyloc));
                     /*% %*/
                     /*% ripper: aref_field!($1, $3) %*/
                     }
-#line 11484 "parse.c"
+#line 11486 "parse.c"
     break;
 
   case 121: /* mlhs_node: primary_value call_op "local variable or method"  */
-#line 3034 "parse.y"
+#line 3036 "parse.y"
                   {
-                        anddot_multiple_assignment_check(p, &(yylsp[-1]), (yyvsp[-1].id));
+                        anddot_multiple_assignment_check(p, &(yylsp[-1]), (ID)(yyvsp[-1].id));
                     /*%%%*/
                         (yyval.node) = attrset(p, (yyvsp[-2].node), (yyvsp[-1].id), (yyvsp[0].id), &(yyloc));
                     /*% %*/
                     /*% ripper: field!($1, $2, $3) %*/
                     }
-#line 11496 "parse.c"
+#line 11498 "parse.c"
     break;
 
   case 122: /* mlhs_node: primary_value "::" "local variable or method"  */
-#line 3042 "parse.y"
+#line 3044 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = attrset(p, (yyvsp[-2].node), idCOLON2, (yyvsp[0].id), &(yyloc));
                     /*% %*/
                     /*% ripper: const_path_field!($1, $3) %*/
                     }
-#line 11507 "parse.c"
+#line 11509 "parse.c"
     break;
 
   case 123: /* mlhs_node: primary_value call_op "constant"  */
-#line 3049 "parse.y"
+#line 3051 "parse.y"
                   {
-                        anddot_multiple_assignment_check(p, &(yylsp[-1]), (yyvsp[-1].id));
+                        anddot_multiple_assignment_check(p, &(yylsp[-1]), (ID)(yyvsp[-1].id));
                     /*%%%*/
                         (yyval.node) = attrset(p, (yyvsp[-2].node), (yyvsp[-1].id), (yyvsp[0].id), &(yyloc));
                     /*% %*/
                     /*% ripper: field!($1, $2, $3) %*/
                     }
-#line 11519 "parse.c"
+#line 11521 "parse.c"
     break;
 
   case 124: /* mlhs_node: primary_value "::" "constant"  */
-#line 3057 "parse.y"
+#line 3059 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = const_decl(p, NEW_COLON2((yyvsp[-2].node), (yyvsp[0].id), &(yyloc)), &(yyloc));
                     /*% %*/
                     /*% ripper: const_decl(p, const_path_field!($1, $3)) %*/
                     }
-#line 11530 "parse.c"
+#line 11532 "parse.c"
     break;
 
   case 125: /* mlhs_node: ":: at EXPR_BEG" "constant"  */
-#line 3064 "parse.y"
+#line 3066 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = const_decl(p, NEW_COLON3((yyvsp[0].id), &(yyloc)), &(yyloc));
                     /*% %*/
                     /*% ripper: const_decl(p, top_const_field!($2)) %*/
                     }
-#line 11541 "parse.c"
+#line 11543 "parse.c"
     break;
 
   case 126: /* mlhs_node: backref  */
-#line 3071 "parse.y"
+#line 3073 "parse.y"
                   {
                     /*%%%*/
                         rb_backref_error(p, (yyvsp[0].node));
@@ -11549,99 +11551,99 @@ yyreduce:
                     /*% %*/
                     /*% ripper[error]: backref_error(p, RNODE($1), var_field(p, $1)) %*/
                     }
-#line 11553 "parse.c"
+#line 11555 "parse.c"
     break;
 
   case 127: /* lhs: user_variable  */
-#line 3081 "parse.y"
+#line 3083 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = assignable(p, (yyvsp[0].id), 0, &(yyloc));
                     /*% %*/
                     /*% ripper: assignable(p, var_field(p, $1)) %*/
                     }
-#line 11564 "parse.c"
+#line 11566 "parse.c"
     break;
 
   case 128: /* lhs: keyword_variable  */
-#line 3088 "parse.y"
+#line 3090 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = assignable(p, (yyvsp[0].id), 0, &(yyloc));
                     /*% %*/
                     /*% ripper: assignable(p, var_field(p, $1)) %*/
                     }
-#line 11575 "parse.c"
+#line 11577 "parse.c"
     break;
 
   case 129: /* lhs: primary_value '[' opt_call_args rbracket  */
-#line 3095 "parse.y"
+#line 3097 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = aryset(p, (yyvsp[-3].node), (yyvsp[-1].node), &(yyloc));
                     /*% %*/
                     /*% ripper: aref_field!($1, $3) %*/
                     }
-#line 11586 "parse.c"
+#line 11588 "parse.c"
     break;
 
   case 130: /* lhs: primary_value call_op "local variable or method"  */
-#line 3102 "parse.y"
+#line 3104 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = attrset(p, (yyvsp[-2].node), (yyvsp[-1].id), (yyvsp[0].id), &(yyloc));
                     /*% %*/
                     /*% ripper: field!($1, $2, $3) %*/
                     }
-#line 11597 "parse.c"
+#line 11599 "parse.c"
     break;
 
   case 131: /* lhs: primary_value "::" "local variable or method"  */
-#line 3109 "parse.y"
+#line 3111 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = attrset(p, (yyvsp[-2].node), idCOLON2, (yyvsp[0].id), &(yyloc));
                     /*% %*/
                     /*% ripper: field!($1, $2, $3) %*/
                     }
-#line 11608 "parse.c"
+#line 11610 "parse.c"
     break;
 
   case 132: /* lhs: primary_value call_op "constant"  */
-#line 3116 "parse.y"
+#line 3118 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = attrset(p, (yyvsp[-2].node), (yyvsp[-1].id), (yyvsp[0].id), &(yyloc));
                     /*% %*/
                     /*% ripper: field!($1, $2, $3) %*/
                     }
-#line 11619 "parse.c"
+#line 11621 "parse.c"
     break;
 
   case 133: /* lhs: primary_value "::" "constant"  */
-#line 3123 "parse.y"
+#line 3125 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = const_decl(p, NEW_COLON2((yyvsp[-2].node), (yyvsp[0].id), &(yyloc)), &(yyloc));
                     /*% %*/
                     /*% ripper: const_decl(p, const_path_field!($1, $3)) %*/
                     }
-#line 11630 "parse.c"
+#line 11632 "parse.c"
     break;
 
   case 134: /* lhs: ":: at EXPR_BEG" "constant"  */
-#line 3130 "parse.y"
+#line 3132 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = const_decl(p, NEW_COLON3((yyvsp[0].id), &(yyloc)), &(yyloc));
                     /*% %*/
                     /*% ripper: const_decl(p, top_const_field!($2)) %*/
                     }
-#line 11641 "parse.c"
+#line 11643 "parse.c"
     break;
 
   case 135: /* lhs: backref  */
-#line 3137 "parse.y"
+#line 3139 "parse.y"
                   {
                     /*%%%*/
                         rb_backref_error(p, (yyvsp[0].node));
@@ -11649,11 +11651,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper[error]: backref_error(p, RNODE($1), var_field(p, $1)) %*/
                     }
-#line 11653 "parse.c"
+#line 11655 "parse.c"
     break;
 
   case 136: /* cname: "local variable or method"  */
-#line 3147 "parse.y"
+#line 3149 "parse.y"
                   {
                         static const char mesg[] = "class/module name must be CONSTANT";
                     /*%%%*/
@@ -11661,81 +11663,81 @@ yyreduce:
                     /*% %*/
                     /*% ripper[error]: class_name_error!(ERR_MESG(), $1) %*/
                     }
-#line 11665 "parse.c"
+#line 11667 "parse.c"
     break;
 
   case 138: /* cpath: ":: at EXPR_BEG" cname  */
-#line 3158 "parse.y"
+#line 3160 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_COLON3((yyvsp[0].id), &(yyloc));
                     /*% %*/
                     /*% ripper: top_const_ref!($2) %*/
                     }
-#line 11676 "parse.c"
+#line 11678 "parse.c"
     break;
 
   case 139: /* cpath: cname  */
-#line 3165 "parse.y"
+#line 3167 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_COLON2(0, (yyvsp[0].id), &(yyloc));
                     /*% %*/
                     /*% ripper: const_ref!($1) %*/
                     }
-#line 11687 "parse.c"
+#line 11689 "parse.c"
     break;
 
   case 140: /* cpath: primary_value "::" cname  */
-#line 3172 "parse.y"
+#line 3174 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_COLON2((yyvsp[-2].node), (yyvsp[0].id), &(yyloc));
                     /*% %*/
                     /*% ripper: const_path_ref!($1, $3) %*/
                     }
-#line 11698 "parse.c"
+#line 11700 "parse.c"
     break;
 
   case 144: /* fname: op  */
-#line 3184 "parse.y"
+#line 3186 "parse.y"
                   {
                         SET_LEX_STATE(EXPR_ENDFN);
                         (yyval.id) = (yyvsp[0].id);
                     }
-#line 11707 "parse.c"
+#line 11709 "parse.c"
     break;
 
   case 146: /* fitem: fname  */
-#line 3192 "parse.y"
+#line 3194 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_LIT(ID2SYM((yyvsp[0].id)), &(yyloc));
                     /*% %*/
                     /*% ripper: symbol_literal!($1) %*/
                     }
-#line 11718 "parse.c"
+#line 11720 "parse.c"
     break;
 
   case 148: /* undef_list: fitem  */
-#line 3202 "parse.y"
+#line 3204 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_UNDEF((yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: rb_ary_new3(1, get_value($1)) %*/
                     }
-#line 11729 "parse.c"
+#line 11731 "parse.c"
     break;
 
   case 149: /* $@12: %empty  */
-#line 3208 "parse.y"
+#line 3210 "parse.y"
                                {SET_LEX_STATE(EXPR_FNAME|EXPR_FITEM);}
-#line 11735 "parse.c"
+#line 11737 "parse.c"
     break;
 
   case 150: /* undef_list: undef_list ',' $@12 fitem  */
-#line 3209 "parse.y"
+#line 3211 "parse.y"
                   {
                     /*%%%*/
                         NODE *undef = NEW_UNDEF((yyvsp[0].node), &(yylsp[0]));
@@ -11743,257 +11745,257 @@ yyreduce:
                     /*% %*/
                     /*% ripper: rb_ary_push($1, get_value($4)) %*/
                     }
-#line 11747 "parse.c"
+#line 11749 "parse.c"
     break;
 
   case 151: /* op: '|'  */
-#line 3218 "parse.y"
+#line 3220 "parse.y"
          { ifndef_ripper((yyval.id) = '|'); }
-#line 11753 "parse.c"
+#line 11755 "parse.c"
     break;
 
   case 152: /* op: '^'  */
-#line 3219 "parse.y"
+#line 3221 "parse.y"
                      { ifndef_ripper((yyval.id) = '^'); }
-#line 11759 "parse.c"
+#line 11761 "parse.c"
     break;
 
   case 153: /* op: '&'  */
-#line 3220 "parse.y"
+#line 3222 "parse.y"
                      { ifndef_ripper((yyval.id) = '&'); }
-#line 11765 "parse.c"
+#line 11767 "parse.c"
     break;
 
   case 154: /* op: "<=>"  */
-#line 3221 "parse.y"
+#line 3223 "parse.y"
                       { ifndef_ripper((yyval.id) = tCMP); }
-#line 11771 "parse.c"
+#line 11773 "parse.c"
     break;
 
   case 155: /* op: "=="  */
-#line 3222 "parse.y"
+#line 3224 "parse.y"
                      { ifndef_ripper((yyval.id) = tEQ); }
-#line 11777 "parse.c"
+#line 11779 "parse.c"
     break;
 
   case 156: /* op: "==="  */
-#line 3223 "parse.y"
+#line 3225 "parse.y"
                       { ifndef_ripper((yyval.id) = tEQQ); }
-#line 11783 "parse.c"
+#line 11785 "parse.c"
     break;
 
   case 157: /* op: "=~"  */
-#line 3224 "parse.y"
+#line 3226 "parse.y"
                        { ifndef_ripper((yyval.id) = tMATCH); }
-#line 11789 "parse.c"
+#line 11791 "parse.c"
     break;
 
   case 158: /* op: "!~"  */
-#line 3225 "parse.y"
+#line 3227 "parse.y"
                         { ifndef_ripper((yyval.id) = tNMATCH); }
-#line 11795 "parse.c"
+#line 11797 "parse.c"
     break;
 
   case 159: /* op: '>'  */
-#line 3226 "parse.y"
+#line 3228 "parse.y"
                      { ifndef_ripper((yyval.id) = '>'); }
-#line 11801 "parse.c"
+#line 11803 "parse.c"
     break;
 
   case 160: /* op: ">="  */
-#line 3227 "parse.y"
+#line 3229 "parse.y"
                       { ifndef_ripper((yyval.id) = tGEQ); }
-#line 11807 "parse.c"
+#line 11809 "parse.c"
     break;
 
   case 161: /* op: '<'  */
-#line 3228 "parse.y"
+#line 3230 "parse.y"
                      { ifndef_ripper((yyval.id) = '<'); }
-#line 11813 "parse.c"
+#line 11815 "parse.c"
     break;
 
   case 162: /* op: "<="  */
-#line 3229 "parse.y"
+#line 3231 "parse.y"
                       { ifndef_ripper((yyval.id) = tLEQ); }
-#line 11819 "parse.c"
+#line 11821 "parse.c"
     break;
 
   case 163: /* op: "!="  */
-#line 3230 "parse.y"
+#line 3232 "parse.y"
                       { ifndef_ripper((yyval.id) = tNEQ); }
-#line 11825 "parse.c"
+#line 11827 "parse.c"
     break;
 
   case 164: /* op: "<<"  */
-#line 3231 "parse.y"
+#line 3233 "parse.y"
                        { ifndef_ripper((yyval.id) = tLSHFT); }
-#line 11831 "parse.c"
+#line 11833 "parse.c"
     break;
 
   case 165: /* op: ">>"  */
-#line 3232 "parse.y"
+#line 3234 "parse.y"
                        { ifndef_ripper((yyval.id) = tRSHFT); }
-#line 11837 "parse.c"
+#line 11839 "parse.c"
     break;
 
   case 166: /* op: '+'  */
-#line 3233 "parse.y"
+#line 3235 "parse.y"
                      { ifndef_ripper((yyval.id) = '+'); }
-#line 11843 "parse.c"
+#line 11845 "parse.c"
     break;
 
   case 167: /* op: '-'  */
-#line 3234 "parse.y"
+#line 3236 "parse.y"
                      { ifndef_ripper((yyval.id) = '-'); }
-#line 11849 "parse.c"
+#line 11851 "parse.c"
     break;
 
   case 168: /* op: '*'  */
-#line 3235 "parse.y"
+#line 3237 "parse.y"
                      { ifndef_ripper((yyval.id) = '*'); }
-#line 11855 "parse.c"
+#line 11857 "parse.c"
     break;
 
   case 169: /* op: "*"  */
-#line 3236 "parse.y"
+#line 3238 "parse.y"
                        { ifndef_ripper((yyval.id) = '*'); }
-#line 11861 "parse.c"
+#line 11863 "parse.c"
     break;
 
   case 170: /* op: '/'  */
-#line 3237 "parse.y"
+#line 3239 "parse.y"
                      { ifndef_ripper((yyval.id) = '/'); }
-#line 11867 "parse.c"
+#line 11869 "parse.c"
     break;
 
   case 171: /* op: '%'  */
-#line 3238 "parse.y"
+#line 3240 "parse.y"
                      { ifndef_ripper((yyval.id) = '%'); }
-#line 11873 "parse.c"
+#line 11875 "parse.c"
     break;
 
   case 172: /* op: "**"  */
-#line 3239 "parse.y"
+#line 3241 "parse.y"
                       { ifndef_ripper((yyval.id) = tPOW); }
-#line 11879 "parse.c"
+#line 11881 "parse.c"
     break;
 
   case 173: /* op: "**arg"  */
-#line 3240 "parse.y"
+#line 3242 "parse.y"
                        { ifndef_ripper((yyval.id) = tDSTAR); }
-#line 11885 "parse.c"
+#line 11887 "parse.c"
     break;
 
   case 174: /* op: '!'  */
-#line 3241 "parse.y"
+#line 3243 "parse.y"
                      { ifndef_ripper((yyval.id) = '!'); }
-#line 11891 "parse.c"
+#line 11893 "parse.c"
     break;
 
   case 175: /* op: '~'  */
-#line 3242 "parse.y"
+#line 3244 "parse.y"
                      { ifndef_ripper((yyval.id) = '~'); }
-#line 11897 "parse.c"
+#line 11899 "parse.c"
     break;
 
   case 176: /* op: "unary+"  */
-#line 3243 "parse.y"
+#line 3245 "parse.y"
                        { ifndef_ripper((yyval.id) = tUPLUS); }
-#line 11903 "parse.c"
+#line 11905 "parse.c"
     break;
 
   case 177: /* op: "unary-"  */
-#line 3244 "parse.y"
+#line 3246 "parse.y"
                         { ifndef_ripper((yyval.id) = tUMINUS); }
-#line 11909 "parse.c"
+#line 11911 "parse.c"
     break;
 
   case 178: /* op: "[]"  */
-#line 3245 "parse.y"
+#line 3247 "parse.y"
                        { ifndef_ripper((yyval.id) = tAREF); }
-#line 11915 "parse.c"
+#line 11917 "parse.c"
     break;
 
   case 179: /* op: "[]="  */
-#line 3246 "parse.y"
+#line 3248 "parse.y"
                        { ifndef_ripper((yyval.id) = tASET); }
-#line 11921 "parse.c"
+#line 11923 "parse.c"
     break;
 
   case 180: /* op: '`'  */
-#line 3247 "parse.y"
+#line 3249 "parse.y"
                      { ifndef_ripper((yyval.id) = '`'); }
-#line 11927 "parse.c"
+#line 11929 "parse.c"
     break;
 
   case 222: /* arg: lhs '=' lex_ctxt arg_rhs  */
-#line 3265 "parse.y"
+#line 3267 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = node_assign(p, (yyvsp[-3].node), (yyvsp[0].node), (yyvsp[-1].ctxt), &(yyloc));
                     /*% %*/
                     /*% ripper: assign!($1, $4) %*/
                     }
-#line 11938 "parse.c"
+#line 11940 "parse.c"
     break;
 
   case 223: /* arg: var_lhs "operator-assignment" lex_ctxt arg_rhs  */
-#line 3272 "parse.y"
+#line 3274 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_op_assign(p, (yyvsp[-3].node), (yyvsp[-2].id), (yyvsp[0].node), (yyvsp[-1].ctxt), &(yyloc));
                     /*% %*/
                     /*% ripper: opassign!($1, $2, $4) %*/
                     }
-#line 11949 "parse.c"
+#line 11951 "parse.c"
     break;
 
   case 224: /* arg: primary_value '[' opt_call_args rbracket "operator-assignment" lex_ctxt arg_rhs  */
-#line 3279 "parse.y"
+#line 3281 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_ary_op_assign(p, (yyvsp[-6].node), (yyvsp[-4].node), (yyvsp[-2].id), (yyvsp[0].node), &(yylsp[-4]), &(yyloc));
                     /*% %*/
                     /*% ripper: opassign!(aref_field!($1, $3), $5, $7) %*/
                     }
-#line 11960 "parse.c"
+#line 11962 "parse.c"
     break;
 
   case 225: /* arg: primary_value call_op "local variable or method" "operator-assignment" lex_ctxt arg_rhs  */
-#line 3286 "parse.y"
+#line 3288 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_attr_op_assign(p, (yyvsp[-5].node), (yyvsp[-4].id), (yyvsp[-3].id), (yyvsp[-2].id), (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: opassign!(field!($1, $2, $3), $4, $6) %*/
                     }
-#line 11971 "parse.c"
+#line 11973 "parse.c"
     break;
 
   case 226: /* arg: primary_value call_op "constant" "operator-assignment" lex_ctxt arg_rhs  */
-#line 3293 "parse.y"
+#line 3295 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_attr_op_assign(p, (yyvsp[-5].node), (yyvsp[-4].id), (yyvsp[-3].id), (yyvsp[-2].id), (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: opassign!(field!($1, $2, $3), $4, $6) %*/
                     }
-#line 11982 "parse.c"
+#line 11984 "parse.c"
     break;
 
   case 227: /* arg: primary_value "::" "local variable or method" "operator-assignment" lex_ctxt arg_rhs  */
-#line 3300 "parse.y"
+#line 3302 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_attr_op_assign(p, (yyvsp[-5].node), ID2VAL(idCOLON2), (yyvsp[-3].id), (yyvsp[-2].id), (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: opassign!(field!($1, $2, $3), $4, $6) %*/
                     }
-#line 11993 "parse.c"
+#line 11995 "parse.c"
     break;
 
   case 228: /* arg: primary_value "::" "constant" "operator-assignment" lex_ctxt arg_rhs  */
-#line 3307 "parse.y"
+#line 3309 "parse.y"
                   {
                     /*%%%*/
                         YYLTYPE loc = code_loc_gen(&(yylsp[-5]), &(yylsp[-3]));
@@ -12001,11 +12003,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: opassign!(const_path_field!($1, $3), $4, $6) %*/
                     }
-#line 12005 "parse.c"
+#line 12007 "parse.c"
     break;
 
   case 229: /* arg: ":: at EXPR_BEG" "constant" "operator-assignment" lex_ctxt arg_rhs  */
-#line 3315 "parse.y"
+#line 3317 "parse.y"
                   {
                     /*%%%*/
                         YYLTYPE loc = code_loc_gen(&(yylsp[-4]), &(yylsp[-3]));
@@ -12013,11 +12015,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: opassign!(top_const_field!($2), $3, $5) %*/
                     }
-#line 12017 "parse.c"
+#line 12019 "parse.c"
     break;
 
   case 230: /* arg: backref "operator-assignment" lex_ctxt arg_rhs  */
-#line 3323 "parse.y"
+#line 3325 "parse.y"
                   {
                     /*%%%*/
                         rb_backref_error(p, (yyvsp[-3].node));
@@ -12025,11 +12027,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper[error]: backref_error(p, RNODE($1), opassign!(var_field(p, $1), $2, $4)) %*/
                     }
-#line 12029 "parse.c"
+#line 12031 "parse.c"
     break;
 
   case 231: /* arg: arg ".." arg  */
-#line 3331 "parse.y"
+#line 3333 "parse.y"
                   {
                     /*%%%*/
                         value_expr((yyvsp[-2].node));
@@ -12038,11 +12040,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: dot2!($1, $3) %*/
                     }
-#line 12042 "parse.c"
+#line 12044 "parse.c"
     break;
 
   case 232: /* arg: arg "..." arg  */
-#line 3340 "parse.y"
+#line 3342 "parse.y"
                   {
                     /*%%%*/
                         value_expr((yyvsp[-2].node));
@@ -12051,11 +12053,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: dot3!($1, $3) %*/
                     }
-#line 12055 "parse.c"
+#line 12057 "parse.c"
     break;
 
   case 233: /* arg: arg ".."  */
-#line 3349 "parse.y"
+#line 3351 "parse.y"
                   {
                     /*%%%*/
                         value_expr((yyvsp[-1].node));
@@ -12063,11 +12065,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: dot2!($1, Qnil) %*/
                     }
-#line 12067 "parse.c"
+#line 12069 "parse.c"
     break;
 
   case 234: /* arg: arg "..."  */
-#line 3357 "parse.y"
+#line 3359 "parse.y"
                   {
                     /*%%%*/
                         value_expr((yyvsp[-1].node));
@@ -12075,11 +12077,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: dot3!($1, Qnil) %*/
                     }
-#line 12079 "parse.c"
+#line 12081 "parse.c"
     break;
 
   case 235: /* arg: "(.." arg  */
-#line 3365 "parse.y"
+#line 3367 "parse.y"
                   {
                     /*%%%*/
                         value_expr((yyvsp[0].node));
@@ -12087,11 +12089,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: dot2!(Qnil, $2) %*/
                     }
-#line 12091 "parse.c"
+#line 12093 "parse.c"
     break;
 
   case 236: /* arg: "(..." arg  */
-#line 3373 "parse.y"
+#line 3375 "parse.y"
                   {
                     /*%%%*/
                         value_expr((yyvsp[0].node));
@@ -12099,212 +12101,212 @@ yyreduce:
                     /*% %*/
                     /*% ripper: dot3!(Qnil, $2) %*/
                     }
-#line 12103 "parse.c"
+#line 12105 "parse.c"
     break;
 
   case 237: /* arg: arg '+' arg  */
-#line 3381 "parse.y"
+#line 3383 "parse.y"
                   {
                         (yyval.node) = call_bin_op(p, (yyvsp[-2].node), '+', (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     }
-#line 12111 "parse.c"
+#line 12113 "parse.c"
     break;
 
   case 238: /* arg: arg '-' arg  */
-#line 3385 "parse.y"
+#line 3387 "parse.y"
                   {
                         (yyval.node) = call_bin_op(p, (yyvsp[-2].node), '-', (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     }
-#line 12119 "parse.c"
+#line 12121 "parse.c"
     break;
 
   case 239: /* arg: arg '*' arg  */
-#line 3389 "parse.y"
+#line 3391 "parse.y"
                   {
                         (yyval.node) = call_bin_op(p, (yyvsp[-2].node), '*', (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     }
-#line 12127 "parse.c"
+#line 12129 "parse.c"
     break;
 
   case 240: /* arg: arg '/' arg  */
-#line 3393 "parse.y"
+#line 3395 "parse.y"
                   {
                         (yyval.node) = call_bin_op(p, (yyvsp[-2].node), '/', (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     }
-#line 12135 "parse.c"
+#line 12137 "parse.c"
     break;
 
   case 241: /* arg: arg '%' arg  */
-#line 3397 "parse.y"
+#line 3399 "parse.y"
                   {
                         (yyval.node) = call_bin_op(p, (yyvsp[-2].node), '%', (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     }
-#line 12143 "parse.c"
+#line 12145 "parse.c"
     break;
 
   case 242: /* arg: arg "**" arg  */
-#line 3401 "parse.y"
+#line 3403 "parse.y"
                   {
                         (yyval.node) = call_bin_op(p, (yyvsp[-2].node), idPow, (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     }
-#line 12151 "parse.c"
+#line 12153 "parse.c"
     break;
 
   case 243: /* arg: tUMINUS_NUM simple_numeric "**" arg  */
-#line 3405 "parse.y"
+#line 3407 "parse.y"
                   {
                         (yyval.node) = call_uni_op(p, call_bin_op(p, (yyvsp[-2].node), idPow, (yyvsp[0].node), &(yylsp[-2]), &(yyloc)), idUMinus, &(yylsp[-3]), &(yyloc));
                     }
-#line 12159 "parse.c"
+#line 12161 "parse.c"
     break;
 
   case 244: /* arg: "unary+" arg  */
-#line 3409 "parse.y"
+#line 3411 "parse.y"
                   {
                         (yyval.node) = call_uni_op(p, (yyvsp[0].node), idUPlus, &(yylsp[-1]), &(yyloc));
                     }
-#line 12167 "parse.c"
+#line 12169 "parse.c"
     break;
 
   case 245: /* arg: "unary-" arg  */
-#line 3413 "parse.y"
+#line 3415 "parse.y"
                   {
                         (yyval.node) = call_uni_op(p, (yyvsp[0].node), idUMinus, &(yylsp[-1]), &(yyloc));
                     }
-#line 12175 "parse.c"
+#line 12177 "parse.c"
     break;
 
   case 246: /* arg: arg '|' arg  */
-#line 3417 "parse.y"
+#line 3419 "parse.y"
                   {
                         (yyval.node) = call_bin_op(p, (yyvsp[-2].node), '|', (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     }
-#line 12183 "parse.c"
+#line 12185 "parse.c"
     break;
 
   case 247: /* arg: arg '^' arg  */
-#line 3421 "parse.y"
+#line 3423 "parse.y"
                   {
                         (yyval.node) = call_bin_op(p, (yyvsp[-2].node), '^', (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     }
-#line 12191 "parse.c"
+#line 12193 "parse.c"
     break;
 
   case 248: /* arg: arg '&' arg  */
-#line 3425 "parse.y"
+#line 3427 "parse.y"
                   {
                         (yyval.node) = call_bin_op(p, (yyvsp[-2].node), '&', (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     }
-#line 12199 "parse.c"
+#line 12201 "parse.c"
     break;
 
   case 249: /* arg: arg "<=>" arg  */
-#line 3429 "parse.y"
+#line 3431 "parse.y"
                   {
                         (yyval.node) = call_bin_op(p, (yyvsp[-2].node), idCmp, (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     }
-#line 12207 "parse.c"
+#line 12209 "parse.c"
     break;
 
   case 251: /* arg: arg "==" arg  */
-#line 3434 "parse.y"
+#line 3436 "parse.y"
                   {
                         (yyval.node) = call_bin_op(p, (yyvsp[-2].node), idEq, (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     }
-#line 12215 "parse.c"
+#line 12217 "parse.c"
     break;
 
   case 252: /* arg: arg "===" arg  */
-#line 3438 "parse.y"
+#line 3440 "parse.y"
                   {
                         (yyval.node) = call_bin_op(p, (yyvsp[-2].node), idEqq, (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     }
-#line 12223 "parse.c"
+#line 12225 "parse.c"
     break;
 
   case 253: /* arg: arg "!=" arg  */
-#line 3442 "parse.y"
+#line 3444 "parse.y"
                   {
                         (yyval.node) = call_bin_op(p, (yyvsp[-2].node), idNeq, (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     }
-#line 12231 "parse.c"
+#line 12233 "parse.c"
     break;
 
   case 254: /* arg: arg "=~" arg  */
-#line 3446 "parse.y"
+#line 3448 "parse.y"
                   {
                         (yyval.node) = match_op(p, (yyvsp[-2].node), (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     }
-#line 12239 "parse.c"
+#line 12241 "parse.c"
     break;
 
   case 255: /* arg: arg "!~" arg  */
-#line 3450 "parse.y"
+#line 3452 "parse.y"
                   {
                         (yyval.node) = call_bin_op(p, (yyvsp[-2].node), idNeqTilde, (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     }
-#line 12247 "parse.c"
+#line 12249 "parse.c"
     break;
 
   case 256: /* arg: '!' arg  */
-#line 3454 "parse.y"
+#line 3456 "parse.y"
                   {
                         (yyval.node) = call_uni_op(p, method_cond(p, (yyvsp[0].node), &(yylsp[0])), '!', &(yylsp[-1]), &(yyloc));
                     }
-#line 12255 "parse.c"
+#line 12257 "parse.c"
     break;
 
   case 257: /* arg: '~' arg  */
-#line 3458 "parse.y"
+#line 3460 "parse.y"
                   {
                         (yyval.node) = call_uni_op(p, (yyvsp[0].node), '~', &(yylsp[-1]), &(yyloc));
                     }
-#line 12263 "parse.c"
+#line 12265 "parse.c"
     break;
 
   case 258: /* arg: arg "<<" arg  */
-#line 3462 "parse.y"
+#line 3464 "parse.y"
                   {
                         (yyval.node) = call_bin_op(p, (yyvsp[-2].node), idLTLT, (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     }
-#line 12271 "parse.c"
+#line 12273 "parse.c"
     break;
 
   case 259: /* arg: arg ">>" arg  */
-#line 3466 "parse.y"
+#line 3468 "parse.y"
                   {
                         (yyval.node) = call_bin_op(p, (yyvsp[-2].node), idGTGT, (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     }
-#line 12279 "parse.c"
+#line 12281 "parse.c"
     break;
 
   case 260: /* arg: arg "&&" arg  */
-#line 3470 "parse.y"
+#line 3472 "parse.y"
                   {
                         (yyval.node) = logop(p, idANDOP, (yyvsp[-2].node), (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     }
-#line 12287 "parse.c"
+#line 12289 "parse.c"
     break;
 
   case 261: /* arg: arg "||" arg  */
-#line 3474 "parse.y"
+#line 3476 "parse.y"
                   {
                         (yyval.node) = logop(p, idOROP, (yyvsp[-2].node), (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     }
-#line 12295 "parse.c"
+#line 12297 "parse.c"
     break;
 
   case 262: /* arg: "`defined?'" opt_nl begin_defined arg  */
-#line 3478 "parse.y"
+#line 3480 "parse.y"
                   {
                         p->ctxt.in_defined = (yyvsp[-1].ctxt).in_defined;
                         (yyval.node) = new_defined(p, (yyvsp[0].node), &(yyloc));
                     }
-#line 12304 "parse.c"
+#line 12306 "parse.c"
     break;
 
   case 263: /* arg: arg '?' arg opt_nl ':' arg  */
-#line 3483 "parse.y"
+#line 3485 "parse.y"
                   {
                     /*%%%*/
                         value_expr((yyvsp[-5].node));
@@ -12313,11 +12315,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: ifop!($1, $3, $6) %*/
                     }
-#line 12317 "parse.c"
+#line 12319 "parse.c"
     break;
 
   case 264: /* arg: defn_head f_opt_paren_args '=' endless_arg  */
-#line 3492 "parse.y"
+#line 3494 "parse.y"
                   {
                         endless_method_name(p, get_id((yyvsp[-3].node_def_temp)->nd_mid), &(yylsp[-3]));
                         restore_defun(p, (yyvsp[-3].node_def_temp));
@@ -12330,11 +12332,11 @@ yyreduce:
                     /*% ripper: def!($head->nd_mid, $args, $bodystmt) %*/
                         local_pop(p);
                     }
-#line 12334 "parse.c"
+#line 12336 "parse.c"
     break;
 
   case 265: /* arg: defs_head f_opt_paren_args '=' endless_arg  */
-#line 3505 "parse.y"
+#line 3507 "parse.y"
                   {
                         endless_method_name(p, get_id((yyvsp[-3].node_def_temp)->nd_mid), &(yylsp[-3]));
                         restore_defun(p, (yyvsp[-3].node_def_temp));
@@ -12347,19 +12349,19 @@ yyreduce:
                     /*% ripper: defs!($head->nd_recv, $head->dot_or_colon, $head->nd_mid, $args, $bodystmt) %*/
                         local_pop(p);
                     }
-#line 12351 "parse.c"
+#line 12353 "parse.c"
     break;
 
   case 266: /* arg: primary  */
-#line 3518 "parse.y"
+#line 3520 "parse.y"
                   {
                         (yyval.node) = (yyvsp[0].node);
                     }
-#line 12359 "parse.c"
+#line 12361 "parse.c"
     break;
 
   case 268: /* endless_arg: endless_arg "`rescue' modifier" after_rescue arg  */
-#line 3525 "parse.y"
+#line 3527 "parse.y"
                   {
                         p->ctxt.in_rescue = (yyvsp[-1].ctxt).in_rescue;
                     /*%%%*/
@@ -12367,134 +12369,134 @@ yyreduce:
                     /*% %*/
                     /*% ripper: rescue_mod!($1, $4) %*/
                     }
-#line 12371 "parse.c"
+#line 12373 "parse.c"
     break;
 
   case 269: /* endless_arg: "`not'" opt_nl endless_arg  */
-#line 3533 "parse.y"
+#line 3535 "parse.y"
                   {
                         (yyval.node) = call_uni_op(p, method_cond(p, (yyvsp[0].node), &(yylsp[0])), METHOD_NOT, &(yylsp[-2]), &(yyloc));
                     }
-#line 12379 "parse.c"
+#line 12381 "parse.c"
     break;
 
   case 270: /* relop: '>'  */
-#line 3538 "parse.y"
-            {(yyval.id) = '>';}
-#line 12385 "parse.c"
+#line 3540 "parse.y"
+            {(yyval.id) = THINGY('>');}
+#line 12387 "parse.c"
     break;
 
   case 271: /* relop: '<'  */
-#line 3539 "parse.y"
-                     {(yyval.id) = '<';}
-#line 12391 "parse.c"
+#line 3541 "parse.y"
+                     {(yyval.id) = THINGY('<');}
+#line 12393 "parse.c"
     break;
 
   case 272: /* relop: ">="  */
-#line 3540 "parse.y"
-                     {(yyval.id) = idGE;}
-#line 12397 "parse.c"
+#line 3542 "parse.y"
+                     {(yyval.id) = THINGY(idGE);}
+#line 12399 "parse.c"
     break;
 
   case 273: /* relop: "<="  */
-#line 3541 "parse.y"
-                     {(yyval.id) = idLE;}
-#line 12403 "parse.c"
+#line 3543 "parse.y"
+                     {(yyval.id) = THINGY(idLE);}
+#line 12405 "parse.c"
     break;
 
   case 274: /* rel_expr: arg relop arg  */
-#line 3545 "parse.y"
+#line 3547 "parse.y"
                   {
                         (yyval.node) = call_bin_op(p, (yyvsp[-2].node), (yyvsp[-1].id), (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     }
-#line 12411 "parse.c"
+#line 12413 "parse.c"
     break;
 
   case 275: /* rel_expr: rel_expr relop arg  */
-#line 3549 "parse.y"
+#line 3551 "parse.y"
                   {
-                        rb_warning1("comparison '%s' after comparison", WARN_ID((yyvsp[-1].id)));
+                        rb_warning1("comparison '%s' after comparison", WARN_ID((ID)(yyvsp[-1].id)));
                         (yyval.node) = call_bin_op(p, (yyvsp[-2].node), (yyvsp[-1].id), (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     }
-#line 12420 "parse.c"
+#line 12422 "parse.c"
     break;
 
   case 276: /* lex_ctxt: none  */
-#line 3556 "parse.y"
+#line 3558 "parse.y"
                   {
                         (yyval.ctxt) = p->ctxt;
                     }
-#line 12428 "parse.c"
+#line 12430 "parse.c"
     break;
 
   case 277: /* begin_defined: lex_ctxt  */
-#line 3562 "parse.y"
+#line 3564 "parse.y"
                   {
                         p->ctxt.in_defined = 1;
                         (yyval.ctxt) = (yyvsp[0].ctxt);
                     }
-#line 12437 "parse.c"
+#line 12439 "parse.c"
     break;
 
   case 278: /* after_rescue: lex_ctxt  */
-#line 3569 "parse.y"
+#line 3571 "parse.y"
                   {
                         p->ctxt.in_rescue = after_rescue;
                         (yyval.ctxt) = (yyvsp[0].ctxt);
                     }
-#line 12446 "parse.c"
+#line 12448 "parse.c"
     break;
 
   case 279: /* arg_value: arg  */
-#line 3576 "parse.y"
+#line 3578 "parse.y"
                   {
                         value_expr((yyvsp[0].node));
                         (yyval.node) = (yyvsp[0].node);
                     }
-#line 12455 "parse.c"
+#line 12457 "parse.c"
     break;
 
   case 281: /* aref_args: args trailer  */
-#line 3584 "parse.y"
+#line 3586 "parse.y"
                   {
                         (yyval.node) = (yyvsp[-1].node);
                     }
-#line 12463 "parse.c"
+#line 12465 "parse.c"
     break;
 
   case 282: /* aref_args: args ',' assocs trailer  */
-#line 3588 "parse.y"
+#line 3590 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = (yyvsp[-1].node) ? arg_append(p, (yyvsp[-3].node), new_hash(p, (yyvsp[-1].node), &(yylsp[-1])), &(yyloc)) : (yyvsp[-3].node);
                     /*% %*/
                     /*% ripper: args_add!($1, bare_assoc_hash!($3)) %*/
                     }
-#line 12474 "parse.c"
+#line 12476 "parse.c"
     break;
 
   case 283: /* aref_args: assocs trailer  */
-#line 3595 "parse.y"
+#line 3597 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = (yyvsp[-1].node) ? NEW_LIST(new_hash(p, (yyvsp[-1].node), &(yylsp[-1])), &(yyloc)) : 0;
                     /*% %*/
                     /*% ripper: args_add!(args_new!, bare_assoc_hash!($1)) %*/
                     }
-#line 12485 "parse.c"
+#line 12487 "parse.c"
     break;
 
   case 284: /* arg_rhs: arg  */
-#line 3604 "parse.y"
+#line 3606 "parse.y"
                   {
                         value_expr((yyvsp[0].node));
                         (yyval.node) = (yyvsp[0].node);
                     }
-#line 12494 "parse.c"
+#line 12496 "parse.c"
     break;
 
   case 285: /* arg_rhs: arg "`rescue' modifier" after_rescue arg  */
-#line 3609 "parse.y"
+#line 3611 "parse.y"
                   {
                         p->ctxt.in_rescue = (yyvsp[-1].ctxt).in_rescue;
                     /*%%%*/
@@ -12503,22 +12505,22 @@ yyreduce:
                     /*% %*/
                     /*% ripper: rescue_mod!($1, $4) %*/
                     }
-#line 12507 "parse.c"
+#line 12509 "parse.c"
     break;
 
   case 286: /* paren_args: '(' opt_call_args rparen  */
-#line 3620 "parse.y"
+#line 3622 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = (yyvsp[-1].node);
                     /*% %*/
                     /*% ripper: arg_paren!($2) %*/
                     }
-#line 12518 "parse.c"
+#line 12520 "parse.c"
     break;
 
   case 287: /* paren_args: '(' args ',' args_forward rparen  */
-#line 3627 "parse.y"
+#line 3629 "parse.y"
                   {
                         if (!check_forwarding_args(p)) {
                             (yyval.node) = Qnone;
@@ -12530,11 +12532,11 @@ yyreduce:
                         /*% ripper: arg_paren!(args_add!($2, $4)) %*/
                         }
                     }
-#line 12534 "parse.c"
+#line 12536 "parse.c"
     break;
 
   case 288: /* paren_args: '(' args_forward rparen  */
-#line 3639 "parse.y"
+#line 3641 "parse.y"
                   {
                         if (!check_forwarding_args(p)) {
                             (yyval.node) = Qnone;
@@ -12546,41 +12548,41 @@ yyreduce:
                         /*% ripper: arg_paren!($2) %*/
                         }
                     }
-#line 12550 "parse.c"
+#line 12552 "parse.c"
     break;
 
   case 293: /* opt_call_args: args ','  */
-#line 3659 "parse.y"
+#line 3661 "parse.y"
                   {
                       (yyval.node) = (yyvsp[-1].node);
                     }
-#line 12558 "parse.c"
+#line 12560 "parse.c"
     break;
 
   case 294: /* opt_call_args: args ',' assocs ','  */
-#line 3663 "parse.y"
+#line 3665 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = (yyvsp[-1].node) ? arg_append(p, (yyvsp[-3].node), new_hash(p, (yyvsp[-1].node), &(yylsp[-1])), &(yyloc)) : (yyvsp[-3].node);
                     /*% %*/
                     /*% ripper: args_add!($1, bare_assoc_hash!($3)) %*/
                     }
-#line 12569 "parse.c"
+#line 12571 "parse.c"
     break;
 
   case 295: /* opt_call_args: assocs ','  */
-#line 3670 "parse.y"
+#line 3672 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = (yyvsp[-1].node) ? NEW_LIST(new_hash(p, (yyvsp[-1].node), &(yylsp[-1])), &(yylsp[-1])) : 0;
                     /*% %*/
                     /*% ripper: args_add!(args_new!, bare_assoc_hash!($1)) %*/
                     }
-#line 12580 "parse.c"
+#line 12582 "parse.c"
     break;
 
   case 296: /* call_args: command  */
-#line 3679 "parse.y"
+#line 3681 "parse.y"
                   {
                     /*%%%*/
                         value_expr((yyvsp[0].node));
@@ -12588,22 +12590,22 @@ yyreduce:
                     /*% %*/
                     /*% ripper: args_add!(args_new!, $1) %*/
                     }
-#line 12592 "parse.c"
+#line 12594 "parse.c"
     break;
 
   case 297: /* call_args: args opt_block_arg  */
-#line 3687 "parse.y"
+#line 3689 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = arg_blk_pass((yyvsp[-1].node), (yyvsp[0].node_block_pass));
                     /*% %*/
                     /*% ripper: args_add_block!($1, $2) %*/
                     }
-#line 12603 "parse.c"
+#line 12605 "parse.c"
     break;
 
   case 298: /* call_args: assocs opt_block_arg  */
-#line 3694 "parse.y"
+#line 3696 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = (yyvsp[-1].node) ? NEW_LIST(new_hash(p, (yyvsp[-1].node), &(yylsp[-1])), &(yylsp[-1])) : 0;
@@ -12611,11 +12613,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: args_add_block!(args_add!(args_new!, bare_assoc_hash!($1)), $2) %*/
                     }
-#line 12615 "parse.c"
+#line 12617 "parse.c"
     break;
 
   case 299: /* call_args: args ',' assocs opt_block_arg  */
-#line 3702 "parse.y"
+#line 3704 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = (yyvsp[-1].node) ? arg_append(p, (yyvsp[-3].node), new_hash(p, (yyvsp[-1].node), &(yylsp[-1])), &(yyloc)) : (yyvsp[-3].node);
@@ -12623,11 +12625,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: args_add_block!(args_add!($1, bare_assoc_hash!($3)), $4) %*/
                     }
-#line 12627 "parse.c"
+#line 12629 "parse.c"
     break;
 
   case 301: /* $@13: %empty  */
-#line 3713 "parse.y"
+#line 3715 "parse.y"
                {
                         /* If call_args starts with a open paren '(' or '[',
                          * look-ahead reading of the letters calls CMDARG_PUSH(0),
@@ -12645,11 +12647,11 @@ yyreduce:
                         CMDARG_PUSH(1);
                         if (lookahead) CMDARG_PUSH(0);
                     }
-#line 12649 "parse.c"
+#line 12651 "parse.c"
     break;
 
   case 302: /* command_args: $@13 call_args  */
-#line 3731 "parse.y"
+#line 3733 "parse.y"
                   {
                         /* call_args can be followed by tLBRACE_ARG (that does CMDARG_PUSH(0) in the lexer)
                          * but the push must be done after CMDARG_POP() in the parser.
@@ -12667,22 +12669,22 @@ yyreduce:
                         if (lookahead) CMDARG_PUSH(0);
                         (yyval.node) = (yyvsp[0].node);
                     }
-#line 12671 "parse.c"
+#line 12673 "parse.c"
     break;
 
   case 303: /* block_arg: "&" arg_value  */
-#line 3751 "parse.y"
+#line 3753 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_block_pass) = NEW_BLOCK_PASS((yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: $2 %*/
                     }
-#line 12682 "parse.c"
+#line 12684 "parse.c"
     break;
 
   case 304: /* block_arg: "&"  */
-#line 3758 "parse.y"
+#line 3760 "parse.y"
                   {
                         forwarding_arg_check(p, idFWD_BLOCK, 0, "block");
                     /*%%%*/
@@ -12690,79 +12692,79 @@ yyreduce:
                     /*% %*/
                     /*% ripper: Qnil %*/
                     }
-#line 12694 "parse.c"
+#line 12696 "parse.c"
     break;
 
   case 305: /* opt_block_arg: ',' block_arg  */
-#line 3768 "parse.y"
+#line 3770 "parse.y"
                   {
                         (yyval.node_block_pass) = (yyvsp[0].node_block_pass);
                     }
-#line 12702 "parse.c"
+#line 12704 "parse.c"
     break;
 
   case 306: /* opt_block_arg: none  */
-#line 3772 "parse.y"
+#line 3774 "parse.y"
                   {
                         (yyval.node_block_pass) = 0;
                     }
-#line 12710 "parse.c"
+#line 12712 "parse.c"
     break;
 
   case 307: /* args: arg_value  */
-#line 3779 "parse.y"
+#line 3781 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_LIST((yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: args_add!(args_new!, $1) %*/
                     }
-#line 12721 "parse.c"
+#line 12723 "parse.c"
     break;
 
   case 308: /* args: arg_splat  */
-#line 3786 "parse.y"
+#line 3788 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_SPLAT((yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: args_add_star!(args_new!, $arg_splat) %*/
                     }
-#line 12732 "parse.c"
+#line 12734 "parse.c"
     break;
 
   case 309: /* args: args ',' arg_value  */
-#line 3793 "parse.y"
+#line 3795 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = last_arg_append(p, (yyvsp[-2].node), (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: args_add!($1, $3) %*/
                     }
-#line 12743 "parse.c"
+#line 12745 "parse.c"
     break;
 
   case 310: /* args: args ',' arg_splat  */
-#line 3800 "parse.y"
+#line 3802 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = rest_arg_append(p, (yyvsp[-2].node), (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: args_add_star!($1, $3) %*/
                     }
-#line 12754 "parse.c"
+#line 12756 "parse.c"
     break;
 
   case 311: /* arg_splat: "*" arg_value  */
-#line 3810 "parse.y"
+#line 3812 "parse.y"
                   {
                         (yyval.node) = (yyvsp[0].node);
                     }
-#line 12762 "parse.c"
+#line 12764 "parse.c"
     break;
 
   case 312: /* arg_splat: "*"  */
-#line 3814 "parse.y"
+#line 3816 "parse.y"
                   {
                         forwarding_arg_check(p, idFWD_REST, idFWD_ALL, "rest");
                     /*%%%*/
@@ -12770,63 +12772,63 @@ yyreduce:
                     /*% %*/
                     /*% ripper: Qnil %*/
                     }
-#line 12774 "parse.c"
+#line 12776 "parse.c"
     break;
 
   case 315: /* mrhs: args ',' arg_value  */
-#line 3830 "parse.y"
+#line 3832 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = last_arg_append(p, (yyvsp[-2].node), (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: mrhs_add!(mrhs_new_from_args!($1), $3) %*/
                     }
-#line 12785 "parse.c"
+#line 12787 "parse.c"
     break;
 
   case 316: /* mrhs: args ',' "*" arg_value  */
-#line 3837 "parse.y"
+#line 3839 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = rest_arg_append(p, (yyvsp[-3].node), (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: mrhs_add_star!(mrhs_new_from_args!($1), $4) %*/
                     }
-#line 12796 "parse.c"
+#line 12798 "parse.c"
     break;
 
   case 317: /* mrhs: "*" arg_value  */
-#line 3844 "parse.y"
+#line 3846 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_SPLAT((yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: mrhs_add_star!(mrhs_new!, $2) %*/
                     }
-#line 12807 "parse.c"
+#line 12809 "parse.c"
     break;
 
   case 328: /* primary: "method"  */
-#line 3863 "parse.y"
+#line 3865 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = (NODE *)NEW_FCALL((yyvsp[0].id), 0, &(yyloc));
                     /*% %*/
                     /*% ripper: method_add_arg!(fcall!($1), args_new!) %*/
                     }
-#line 12818 "parse.c"
+#line 12820 "parse.c"
     break;
 
   case 329: /* $@14: %empty  */
-#line 3870 "parse.y"
+#line 3872 "parse.y"
                   {
                         CMDARG_PUSH(0);
                     }
-#line 12826 "parse.c"
+#line 12828 "parse.c"
     break;
 
   case 330: /* primary: k_begin $@14 bodystmt k_end  */
-#line 3875 "parse.y"
+#line 3877 "parse.y"
                   {
                         CMDARG_POP();
                     /*%%%*/
@@ -12836,17 +12838,17 @@ yyreduce:
                     /*% %*/
                     /*% ripper: begin!($3) %*/
                     }
-#line 12840 "parse.c"
+#line 12842 "parse.c"
     break;
 
   case 331: /* $@15: %empty  */
-#line 3884 "parse.y"
+#line 3886 "parse.y"
                                      {SET_LEX_STATE(EXPR_ENDARG);}
-#line 12846 "parse.c"
+#line 12848 "parse.c"
     break;
 
   case 332: /* primary: "( arg" compstmt $@15 ')'  */
-#line 3885 "parse.y"
+#line 3887 "parse.y"
                   {
                     /*%%%*/
                         if (nd_type_p((yyvsp[-2].node), NODE_SELF)) RNODE_SELF((yyvsp[-2].node))->nd_state = 0;
@@ -12854,11 +12856,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: paren!($2) %*/
                     }
-#line 12858 "parse.c"
+#line 12860 "parse.c"
     break;
 
   case 333: /* primary: "(" compstmt ')'  */
-#line 3893 "parse.y"
+#line 3895 "parse.y"
                   {
                     /*%%%*/
                         if (nd_type_p((yyvsp[-1].node), NODE_SELF)) RNODE_SELF((yyvsp[-1].node))->nd_state = 0;
@@ -12866,44 +12868,44 @@ yyreduce:
                     /*% %*/
                     /*% ripper: paren!($2) %*/
                     }
-#line 12870 "parse.c"
+#line 12872 "parse.c"
     break;
 
   case 334: /* primary: primary_value "::" "constant"  */
-#line 3901 "parse.y"
+#line 3903 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_COLON2((yyvsp[-2].node), (yyvsp[0].id), &(yyloc));
                     /*% %*/
                     /*% ripper: const_path_ref!($1, $3) %*/
                     }
-#line 12881 "parse.c"
+#line 12883 "parse.c"
     break;
 
   case 335: /* primary: ":: at EXPR_BEG" "constant"  */
-#line 3908 "parse.y"
+#line 3910 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_COLON3((yyvsp[0].id), &(yyloc));
                     /*% %*/
                     /*% ripper: top_const_ref!($2) %*/
                     }
-#line 12892 "parse.c"
+#line 12894 "parse.c"
     break;
 
   case 336: /* primary: "[" aref_args ']'  */
-#line 3915 "parse.y"
+#line 3917 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = make_list((yyvsp[-1].node), &(yyloc));
                     /*% %*/
                     /*% ripper: array!($2) %*/
                     }
-#line 12903 "parse.c"
+#line 12905 "parse.c"
     break;
 
   case 337: /* primary: "{" assoc_list '}'  */
-#line 3922 "parse.y"
+#line 3924 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_hash(p, (yyvsp[-1].node), &(yyloc));
@@ -12911,91 +12913,91 @@ yyreduce:
                     /*% %*/
                     /*% ripper: hash!($2) %*/
                     }
-#line 12915 "parse.c"
+#line 12917 "parse.c"
     break;
 
   case 338: /* primary: k_return  */
-#line 3930 "parse.y"
+#line 3932 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_RETURN(0, &(yyloc));
                     /*% %*/
                     /*% ripper: return0! %*/
                     }
-#line 12926 "parse.c"
+#line 12928 "parse.c"
     break;
 
   case 339: /* primary: k_yield '(' call_args rparen  */
-#line 3937 "parse.y"
+#line 3939 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_yield(p, (yyvsp[-1].node), &(yyloc));
                     /*% %*/
                     /*% ripper: yield!(paren!($3)) %*/
                     }
-#line 12937 "parse.c"
+#line 12939 "parse.c"
     break;
 
   case 340: /* primary: k_yield '(' rparen  */
-#line 3944 "parse.y"
+#line 3946 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_YIELD(0, &(yyloc));
                     /*% %*/
                     /*% ripper: yield!(paren!(args_new!)) %*/
                     }
-#line 12948 "parse.c"
+#line 12950 "parse.c"
     break;
 
   case 341: /* primary: k_yield  */
-#line 3951 "parse.y"
+#line 3953 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_YIELD(0, &(yyloc));
                     /*% %*/
                     /*% ripper: yield0! %*/
                     }
-#line 12959 "parse.c"
+#line 12961 "parse.c"
     break;
 
   case 342: /* primary: "`defined?'" opt_nl '(' begin_defined expr rparen  */
-#line 3958 "parse.y"
+#line 3960 "parse.y"
                   {
                         p->ctxt.in_defined = (yyvsp[-2].ctxt).in_defined;
                         (yyval.node) = new_defined(p, (yyvsp[-1].node), &(yyloc));
                     }
-#line 12968 "parse.c"
+#line 12970 "parse.c"
     break;
 
   case 343: /* primary: "`not'" '(' expr rparen  */
-#line 3963 "parse.y"
+#line 3965 "parse.y"
                   {
                         (yyval.node) = call_uni_op(p, method_cond(p, (yyvsp[-1].node), &(yylsp[-1])), METHOD_NOT, &(yylsp[-3]), &(yyloc));
                     }
-#line 12976 "parse.c"
+#line 12978 "parse.c"
     break;
 
   case 344: /* primary: "`not'" '(' rparen  */
-#line 3967 "parse.y"
+#line 3969 "parse.y"
                   {
                         (yyval.node) = call_uni_op(p, method_cond(p, new_nil(&(yylsp[-1])), &(yylsp[-1])), METHOD_NOT, &(yylsp[-2]), &(yyloc));
                     }
-#line 12984 "parse.c"
+#line 12986 "parse.c"
     break;
 
   case 345: /* primary: fcall brace_block  */
-#line 3971 "parse.y"
+#line 3973 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = method_add_block(p, (NODE *)(yyvsp[-1].node_fcall), (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: method_add_block!(method_add_arg!(fcall!($1), args_new!), $2) %*/
                     }
-#line 12995 "parse.c"
+#line 12997 "parse.c"
     break;
 
   case 347: /* primary: method_call brace_block  */
-#line 3979 "parse.y"
+#line 3981 "parse.y"
                   {
                     /*%%%*/
                         block_dup_check(p, get_nd_args(p, (yyvsp[-1].node)), (yyvsp[0].node));
@@ -13003,11 +13005,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: method_add_block!($1, $2) %*/
                     }
-#line 13007 "parse.c"
+#line 13009 "parse.c"
     break;
 
   case 349: /* primary: k_if expr_value then compstmt if_tail k_end  */
-#line 3991 "parse.y"
+#line 3993 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_if(p, (yyvsp[-4].node), (yyvsp[-2].node), (yyvsp[-1].node), &(yyloc));
@@ -13015,11 +13017,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: if!($2, $4, $5) %*/
                     }
-#line 13019 "parse.c"
+#line 13021 "parse.c"
     break;
 
   case 350: /* primary: k_unless expr_value then compstmt opt_else k_end  */
-#line 4002 "parse.y"
+#line 4004 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_unless(p, (yyvsp[-4].node), (yyvsp[-2].node), (yyvsp[-1].node), &(yyloc));
@@ -13027,11 +13029,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: unless!($2, $4, $5) %*/
                     }
-#line 13031 "parse.c"
+#line 13033 "parse.c"
     break;
 
   case 351: /* primary: k_while expr_value_do compstmt k_end  */
-#line 4012 "parse.y"
+#line 4014 "parse.y"
                   {
                         restore_block_exit(p, (yyvsp[-3].node_exits));
                     /*%%%*/
@@ -13040,11 +13042,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: while!($2, $3) %*/
                     }
-#line 13044 "parse.c"
+#line 13046 "parse.c"
     break;
 
   case 352: /* primary: k_until expr_value_do compstmt k_end  */
-#line 4023 "parse.y"
+#line 4025 "parse.y"
                   {
                         restore_block_exit(p, (yyvsp[-3].node_exits));
                     /*%%%*/
@@ -13053,20 +13055,20 @@ yyreduce:
                     /*% %*/
                     /*% ripper: until!($2, $3) %*/
                     }
-#line 13057 "parse.c"
+#line 13059 "parse.c"
     break;
 
   case 353: /* @16: %empty  */
-#line 4032 "parse.y"
+#line 4034 "parse.y"
                   {
                         (yyval.val) = p->case_labels;
                         p->case_labels = Qnil;
                     }
-#line 13066 "parse.c"
+#line 13068 "parse.c"
     break;
 
   case 354: /* primary: k_case expr_value opt_terms @16 case_body k_end  */
-#line 4038 "parse.y"
+#line 4040 "parse.y"
                   {
                         if (RTEST(p->case_labels)) rb_hash_clear(p->case_labels);
                         p->case_labels = (yyvsp[-2].val);
@@ -13076,20 +13078,20 @@ yyreduce:
                     /*% %*/
                     /*% ripper: case!($2, $5) %*/
                     }
-#line 13080 "parse.c"
+#line 13082 "parse.c"
     break;
 
   case 355: /* @17: %empty  */
-#line 4048 "parse.y"
+#line 4050 "parse.y"
                   {
                         (yyval.val) = p->case_labels;
                         p->case_labels = 0;
                     }
-#line 13089 "parse.c"
+#line 13091 "parse.c"
     break;
 
   case 356: /* primary: k_case opt_terms @17 case_body k_end  */
-#line 4054 "parse.y"
+#line 4056 "parse.y"
                   {
                         if (RTEST(p->case_labels)) rb_hash_clear(p->case_labels);
                         p->case_labels = (yyvsp[-2].val);
@@ -13098,22 +13100,22 @@ yyreduce:
                     /*% %*/
                     /*% ripper: case!(Qnil, $4) %*/
                     }
-#line 13102 "parse.c"
+#line 13104 "parse.c"
     break;
 
   case 357: /* primary: k_case expr_value opt_terms p_case_body k_end  */
-#line 4065 "parse.y"
+#line 4067 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_CASE3((yyvsp[-3].node), (yyvsp[-1].node), &(yyloc));
                     /*% %*/
                     /*% ripper: case!($2, $4) %*/
                     }
-#line 13113 "parse.c"
+#line 13115 "parse.c"
     break;
 
   case 358: /* primary: k_for for_var "`in'" expr_value_do compstmt k_end  */
-#line 4074 "parse.y"
+#line 4076 "parse.y"
                   {
                         restore_block_exit(p, (yyvsp[-5].node_exits));
                     /*%%%*/
@@ -13155,19 +13157,19 @@ yyreduce:
                     /*% %*/
                     /*% ripper: for!($2, $4, $5) %*/
                     }
-#line 13159 "parse.c"
+#line 13161 "parse.c"
     break;
 
   case 359: /* $@18: %empty  */
-#line 4116 "parse.y"
+#line 4118 "parse.y"
                   {
                         begin_definition("class", &(yylsp[-2]), &(yylsp[-1]));
                     }
-#line 13167 "parse.c"
+#line 13169 "parse.c"
     break;
 
   case 360: /* primary: k_class cpath superclass $@18 bodystmt k_end  */
-#line 4121 "parse.y"
+#line 4123 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_CLASS((yyvsp[-4].node), (yyvsp[-1].node), (yyvsp[-3].node), &(yyloc));
@@ -13180,19 +13182,19 @@ yyreduce:
                         p->ctxt.in_class = (yyvsp[-5].ctxt).in_class;
                         p->ctxt.shareable_constant_value = (yyvsp[-5].ctxt).shareable_constant_value;
                     }
-#line 13184 "parse.c"
+#line 13186 "parse.c"
     break;
 
   case 361: /* $@19: %empty  */
-#line 4134 "parse.y"
+#line 4136 "parse.y"
                   {
                         begin_definition("", &(yylsp[-2]), &(yylsp[-1]));
                     }
-#line 13192 "parse.c"
+#line 13194 "parse.c"
     break;
 
   case 362: /* primary: k_class "<<" expr_value $@19 term bodystmt k_end  */
-#line 4140 "parse.y"
+#line 4142 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_SCLASS((yyvsp[-4].node), (yyvsp[-1].node), &(yyloc));
@@ -13206,19 +13208,19 @@ yyreduce:
                         p->ctxt.in_class = (yyvsp[-6].ctxt).in_class;
                         p->ctxt.shareable_constant_value = (yyvsp[-6].ctxt).shareable_constant_value;
                     }
-#line 13210 "parse.c"
+#line 13212 "parse.c"
     break;
 
   case 363: /* $@20: %empty  */
-#line 4154 "parse.y"
+#line 4156 "parse.y"
                   {
                         begin_definition("module", &(yylsp[-1]), &(yylsp[0]));
                     }
-#line 13218 "parse.c"
+#line 13220 "parse.c"
     break;
 
   case 364: /* primary: k_module cpath $@20 bodystmt k_end  */
-#line 4159 "parse.y"
+#line 4161 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_MODULE((yyvsp[-3].node), (yyvsp[-1].node), &(yyloc));
@@ -13231,21 +13233,21 @@ yyreduce:
                         p->ctxt.in_class = (yyvsp[-4].ctxt).in_class;
                         p->ctxt.shareable_constant_value = (yyvsp[-4].ctxt).shareable_constant_value;
                     }
-#line 13235 "parse.c"
+#line 13237 "parse.c"
     break;
 
   case 365: /* $@21: %empty  */
-#line 4173 "parse.y"
+#line 4175 "parse.y"
                   {
                     /*%%%*/
                         push_end_expect_token_locations(p, &(yylsp[-1]).beg_pos);
                     /*% %*/
                     }
-#line 13245 "parse.c"
+#line 13247 "parse.c"
     break;
 
   case 366: /* primary: defn_head f_arglist $@21 bodystmt k_end  */
-#line 4180 "parse.y"
+#line 4182 "parse.y"
                   {
                         restore_defun(p, (yyvsp[-4].node_def_temp));
                     /*%%%*/
@@ -13256,21 +13258,21 @@ yyreduce:
                     /*% ripper: def!($head->nd_mid, $args, $bodystmt) %*/
                         local_pop(p);
                     }
-#line 13260 "parse.c"
+#line 13262 "parse.c"
     break;
 
   case 367: /* $@22: %empty  */
-#line 4192 "parse.y"
+#line 4194 "parse.y"
                   {
                     /*%%%*/
                         push_end_expect_token_locations(p, &(yylsp[-1]).beg_pos);
                     /*% %*/
                     }
-#line 13270 "parse.c"
+#line 13272 "parse.c"
     break;
 
   case 368: /* primary: defs_head f_arglist $@22 bodystmt k_end  */
-#line 4199 "parse.y"
+#line 4201 "parse.y"
                   {
                         restore_defun(p, (yyvsp[-4].node_def_temp));
                     /*%%%*/
@@ -13281,38 +13283,38 @@ yyreduce:
                     /*% ripper: defs!($head->nd_recv, $head->dot_or_colon, $head->nd_mid, $args, $bodystmt) %*/
                         local_pop(p);
                     }
-#line 13285 "parse.c"
+#line 13287 "parse.c"
     break;
 
   case 369: /* primary: "`break'"  */
-#line 4210 "parse.y"
+#line 4212 "parse.y"
                   {
                         (yyval.node) = add_block_exit(p, NEW_BREAK(0, &(yyloc)));
                     /*% ripper: break!(args_new!) %*/
                     }
-#line 13294 "parse.c"
+#line 13296 "parse.c"
     break;
 
   case 370: /* primary: "`next'"  */
-#line 4215 "parse.y"
+#line 4217 "parse.y"
                   {
                         (yyval.node) = add_block_exit(p, NEW_NEXT(0, &(yyloc)));
                     /*% ripper: next!(args_new!) %*/
                     }
-#line 13303 "parse.c"
+#line 13305 "parse.c"
     break;
 
   case 371: /* primary: "`redo'"  */
-#line 4220 "parse.y"
+#line 4222 "parse.y"
                   {
                         (yyval.node) = add_block_exit(p, NEW_REDO(&(yyloc)));
                     /*% ripper: redo! %*/
                     }
-#line 13312 "parse.c"
+#line 13314 "parse.c"
     break;
 
   case 372: /* primary: "`retry'"  */
-#line 4225 "parse.y"
+#line 4227 "parse.y"
                   {
                         if (!p->ctxt.in_defined) {
                             switch (p->ctxt.in_rescue) {
@@ -13327,31 +13329,31 @@ yyreduce:
                     /*% %*/
                     /*% ripper: retry! %*/
                     }
-#line 13331 "parse.c"
+#line 13333 "parse.c"
     break;
 
   case 373: /* primary_value: primary  */
-#line 4242 "parse.y"
+#line 4244 "parse.y"
                   {
                         value_expr((yyvsp[0].node));
                         (yyval.node) = (yyvsp[0].node);
                     }
-#line 13340 "parse.c"
+#line 13342 "parse.c"
     break;
 
   case 374: /* k_begin: "`begin'"  */
-#line 4249 "parse.y"
+#line 4251 "parse.y"
                   {
                         token_info_push(p, "begin", &(yyloc));
                     /*%%%*/
                         push_end_expect_token_locations(p, &(yylsp[0]).beg_pos);
                     /*% %*/
                     }
-#line 13351 "parse.c"
+#line 13353 "parse.c"
     break;
 
   case 375: /* k_if: "`if'"  */
-#line 4258 "parse.y"
+#line 4260 "parse.y"
                   {
                         WARN_EOL("if");
                         token_info_push(p, "if", &(yyloc));
@@ -13369,22 +13371,22 @@ yyreduce:
                         push_end_expect_token_locations(p, &(yylsp[0]).beg_pos);
                     /*% %*/
                     }
-#line 13373 "parse.c"
+#line 13375 "parse.c"
     break;
 
   case 376: /* k_unless: "`unless'"  */
-#line 4278 "parse.y"
+#line 4280 "parse.y"
                   {
                         token_info_push(p, "unless", &(yyloc));
                     /*%%%*/
                         push_end_expect_token_locations(p, &(yylsp[0]).beg_pos);
                     /*% %*/
                     }
-#line 13384 "parse.c"
+#line 13386 "parse.c"
     break;
 
   case 377: /* k_while: "`while'" allow_exits  */
-#line 4287 "parse.y"
+#line 4289 "parse.y"
                   {
                         (yyval.node_exits) = (yyvsp[0].node_exits);
                         token_info_push(p, "while", &(yyloc));
@@ -13392,11 +13394,11 @@ yyreduce:
                         push_end_expect_token_locations(p, &(yylsp[-1]).beg_pos);
                     /*% %*/
                     }
-#line 13396 "parse.c"
+#line 13398 "parse.c"
     break;
 
   case 378: /* k_until: "`until'" allow_exits  */
-#line 4297 "parse.y"
+#line 4299 "parse.y"
                   {
                         (yyval.node_exits) = (yyvsp[0].node_exits);
                         token_info_push(p, "until", &(yyloc));
@@ -13404,22 +13406,22 @@ yyreduce:
                         push_end_expect_token_locations(p, &(yylsp[-1]).beg_pos);
                     /*% %*/
                     }
-#line 13408 "parse.c"
+#line 13410 "parse.c"
     break;
 
   case 379: /* k_case: "`case'"  */
-#line 4307 "parse.y"
+#line 4309 "parse.y"
                   {
                         token_info_push(p, "case", &(yyloc));
                     /*%%%*/
                         push_end_expect_token_locations(p, &(yylsp[0]).beg_pos);
                     /*% %*/
                     }
-#line 13419 "parse.c"
+#line 13421 "parse.c"
     break;
 
   case 380: /* k_for: "`for'" allow_exits  */
-#line 4316 "parse.y"
+#line 4318 "parse.y"
                   {
                         (yyval.node_exits) = (yyvsp[0].node_exits);
                         token_info_push(p, "for", &(yyloc));
@@ -13427,11 +13429,11 @@ yyreduce:
                         push_end_expect_token_locations(p, &(yylsp[-1]).beg_pos);
                     /*% %*/
                     }
-#line 13431 "parse.c"
+#line 13433 "parse.c"
     break;
 
   case 381: /* k_class: "`class'"  */
-#line 4326 "parse.y"
+#line 4328 "parse.y"
                   {
                         token_info_push(p, "class", &(yyloc));
                         (yyval.ctxt) = p->ctxt;
@@ -13440,11 +13442,11 @@ yyreduce:
                         push_end_expect_token_locations(p, &(yylsp[0]).beg_pos);
                     /*% %*/
                     }
-#line 13444 "parse.c"
+#line 13446 "parse.c"
     break;
 
   case 382: /* k_module: "`module'"  */
-#line 4337 "parse.y"
+#line 4339 "parse.y"
                   {
                         token_info_push(p, "module", &(yyloc));
                         (yyval.ctxt) = p->ctxt;
@@ -13453,70 +13455,70 @@ yyreduce:
                         push_end_expect_token_locations(p, &(yylsp[0]).beg_pos);
                     /*% %*/
                     }
-#line 13457 "parse.c"
+#line 13459 "parse.c"
     break;
 
   case 383: /* k_def: "`def'"  */
-#line 4348 "parse.y"
+#line 4350 "parse.y"
                   {
                         token_info_push(p, "def", &(yyloc));
                         (yyval.node_def_temp) = NEW_DEF_TEMP(&(yyloc));
                         p->ctxt.in_argdef = 1;
                     }
-#line 13467 "parse.c"
+#line 13469 "parse.c"
     break;
 
   case 384: /* k_do: "`do'"  */
-#line 4356 "parse.y"
+#line 4358 "parse.y"
                   {
                         token_info_push(p, "do", &(yyloc));
                     /*%%%*/
                         push_end_expect_token_locations(p, &(yylsp[0]).beg_pos);
                     /*% %*/
                     }
-#line 13478 "parse.c"
+#line 13480 "parse.c"
     break;
 
   case 385: /* k_do_block: "`do' for block"  */
-#line 4365 "parse.y"
+#line 4367 "parse.y"
                   {
                         token_info_push(p, "do", &(yyloc));
                     /*%%%*/
                         push_end_expect_token_locations(p, &(yylsp[0]).beg_pos);
                     /*% %*/
                     }
-#line 13489 "parse.c"
+#line 13491 "parse.c"
     break;
 
   case 386: /* k_rescue: "`rescue'"  */
-#line 4374 "parse.y"
+#line 4376 "parse.y"
                   {
                         token_info_warn(p, "rescue", p->token_info, 1, &(yyloc));
                         (yyval.ctxt) = p->ctxt;
                         p->ctxt.in_rescue = after_rescue;
                     }
-#line 13499 "parse.c"
+#line 13501 "parse.c"
     break;
 
   case 387: /* k_ensure: "`ensure'"  */
-#line 4382 "parse.y"
+#line 4384 "parse.y"
                   {
                         token_info_warn(p, "ensure", p->token_info, 1, &(yyloc));
                         (yyval.ctxt) = p->ctxt;
                     }
-#line 13508 "parse.c"
+#line 13510 "parse.c"
     break;
 
   case 388: /* k_when: "`when'"  */
-#line 4389 "parse.y"
+#line 4391 "parse.y"
                   {
                         token_info_warn(p, "when", p->token_info, 0, &(yyloc));
                     }
-#line 13516 "parse.c"
+#line 13518 "parse.c"
     break;
 
   case 389: /* k_else: "`else'"  */
-#line 4395 "parse.y"
+#line 4397 "parse.y"
                   {
                         token_info *ptinfo_beg = p->token_info;
                         int same = ptinfo_beg && strcmp(ptinfo_beg->token, "case") != 0;
@@ -13529,57 +13531,57 @@ yyreduce:
                             if (!e.nonspc) *ptinfo_beg = e;
                         }
                     }
-#line 13533 "parse.c"
+#line 13535 "parse.c"
     break;
 
   case 390: /* k_elsif: "`elsif'"  */
-#line 4410 "parse.y"
+#line 4412 "parse.y"
                   {
                         WARN_EOL("elsif");
                         token_info_warn(p, "elsif", p->token_info, 1, &(yyloc));
                     }
-#line 13542 "parse.c"
+#line 13544 "parse.c"
     break;
 
   case 391: /* k_end: "`end'"  */
-#line 4417 "parse.y"
+#line 4419 "parse.y"
                   {
                         token_info_pop(p, "end", &(yyloc));
                     /*%%%*/
                         pop_end_expect_token_locations(p);
                     /*% %*/
                     }
-#line 13553 "parse.c"
+#line 13555 "parse.c"
     break;
 
   case 392: /* k_end: "dummy end"  */
-#line 4424 "parse.y"
+#line 4426 "parse.y"
                   {
                         compile_error(p, "syntax error, unexpected end-of-input");
                     }
-#line 13561 "parse.c"
+#line 13563 "parse.c"
     break;
 
   case 393: /* k_return: "`return'"  */
-#line 4430 "parse.y"
+#line 4432 "parse.y"
                   {
                         if (p->ctxt.in_class && !p->ctxt.in_def && !dyna_in_block(p))
                             yyerror1(&(yylsp[0]), "Invalid return in class/module body");
                     }
-#line 13570 "parse.c"
+#line 13572 "parse.c"
     break;
 
   case 394: /* k_yield: "`yield'"  */
-#line 4437 "parse.y"
+#line 4439 "parse.y"
                   {
                         if (!p->ctxt.in_defined && !p->ctxt.in_def && !compile_for_eval)
                             yyerror1(&(yylsp[0]), "Invalid yield");
                     }
-#line 13579 "parse.c"
+#line 13581 "parse.c"
     break;
 
   case 401: /* if_tail: k_elsif expr_value then compstmt if_tail  */
-#line 4456 "parse.y"
+#line 4458 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_if(p, (yyvsp[-3].node), (yyvsp[-1].node), (yyvsp[0].node), &(yyloc));
@@ -13587,22 +13589,22 @@ yyreduce:
                     /*% %*/
                     /*% ripper: elsif!($2, $4, $5) %*/
                     }
-#line 13591 "parse.c"
+#line 13593 "parse.c"
     break;
 
   case 403: /* opt_else: k_else compstmt  */
-#line 4467 "parse.y"
+#line 4469 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = (yyvsp[0].node);
                     /*% %*/
                     /*% ripper: else!($2) %*/
                     }
-#line 13602 "parse.c"
+#line 13604 "parse.c"
     break;
 
   case 406: /* f_marg: f_norm_arg  */
-#line 4480 "parse.y"
+#line 4482 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = assignable(p, (yyvsp[0].id), 0, &(yyloc));
@@ -13610,99 +13612,99 @@ yyreduce:
                     /*% %*/
                     /*% ripper: assignable(p, $1) %*/
                     }
-#line 13614 "parse.c"
+#line 13616 "parse.c"
     break;
 
   case 407: /* f_marg: "(" f_margs rparen  */
-#line 4488 "parse.y"
+#line 4490 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = (NODE *)(yyvsp[-1].node_masgn);
                     /*% %*/
                     /*% ripper: mlhs_paren!($2) %*/
                     }
-#line 13625 "parse.c"
+#line 13627 "parse.c"
     break;
 
   case 408: /* f_marg_list: f_marg  */
-#line 4497 "parse.y"
+#line 4499 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_LIST((yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: mlhs_add!(mlhs_new!, $1) %*/
                     }
-#line 13636 "parse.c"
+#line 13638 "parse.c"
     break;
 
   case 409: /* f_marg_list: f_marg_list ',' f_marg  */
-#line 4504 "parse.y"
+#line 4506 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = list_append(p, (yyvsp[-2].node), (yyvsp[0].node));
                     /*% %*/
                     /*% ripper: mlhs_add!($1, $3) %*/
                     }
-#line 13647 "parse.c"
+#line 13649 "parse.c"
     break;
 
   case 410: /* f_margs: f_marg_list  */
-#line 4513 "parse.y"
+#line 4515 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_masgn) = NEW_MASGN((yyvsp[0].node), 0, &(yyloc));
                     /*% %*/
                     /*% ripper: $1 %*/
                     }
-#line 13658 "parse.c"
+#line 13660 "parse.c"
     break;
 
   case 411: /* f_margs: f_marg_list ',' f_rest_marg  */
-#line 4520 "parse.y"
+#line 4522 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_masgn) = NEW_MASGN((yyvsp[-2].node), (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: mlhs_add_star!($1, $3) %*/
                     }
-#line 13669 "parse.c"
+#line 13671 "parse.c"
     break;
 
   case 412: /* f_margs: f_marg_list ',' f_rest_marg ',' f_marg_list  */
-#line 4527 "parse.y"
+#line 4529 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_masgn) = NEW_MASGN((yyvsp[-4].node), NEW_POSTARG((yyvsp[-2].node), (yyvsp[0].node), &(yyloc)), &(yyloc));
                     /*% %*/
                     /*% ripper: mlhs_add_post!(mlhs_add_star!($1, $3), $5) %*/
                     }
-#line 13680 "parse.c"
+#line 13682 "parse.c"
     break;
 
   case 413: /* f_margs: f_rest_marg  */
-#line 4534 "parse.y"
+#line 4536 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_masgn) = NEW_MASGN(0, (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: mlhs_add_star!(mlhs_new!, $1) %*/
                     }
-#line 13691 "parse.c"
+#line 13693 "parse.c"
     break;
 
   case 414: /* f_margs: f_rest_marg ',' f_marg_list  */
-#line 4541 "parse.y"
+#line 4543 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_masgn) = NEW_MASGN(0, NEW_POSTARG((yyvsp[-2].node), (yyvsp[0].node), &(yyloc)), &(yyloc));
                     /*% %*/
                     /*% ripper: mlhs_add_post!(mlhs_add_star!(mlhs_new!, $1), $3) %*/
                     }
-#line 13702 "parse.c"
+#line 13704 "parse.c"
     break;
 
   case 415: /* f_rest_marg: "*" f_norm_arg  */
-#line 4550 "parse.y"
+#line 4552 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = assignable(p, (yyvsp[0].id), 0, &(yyloc));
@@ -13710,82 +13712,82 @@ yyreduce:
                     /*% %*/
                     /*% ripper: assignable(p, $2) %*/
                     }
-#line 13714 "parse.c"
+#line 13716 "parse.c"
     break;
 
   case 416: /* f_rest_marg: "*"  */
-#line 4558 "parse.y"
+#line 4560 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NODE_SPECIAL_NO_NAME_REST;
                     /*% %*/
                     /*% ripper: Qnil %*/
                     }
-#line 13725 "parse.c"
+#line 13727 "parse.c"
     break;
 
   case 418: /* f_any_kwrest: f_no_kwarg  */
-#line 4567 "parse.y"
+#line 4569 "parse.y"
                            {(yyval.id) = ID2VAL(idNil);}
-#line 13731 "parse.c"
+#line 13733 "parse.c"
     break;
 
   case 419: /* $@23: %empty  */
-#line 4570 "parse.y"
+#line 4572 "parse.y"
       {p->ctxt.in_argdef = 0;}
-#line 13737 "parse.c"
+#line 13739 "parse.c"
     break;
 
   case 421: /* block_args_tail: f_block_kwarg ',' f_kwrest opt_f_block_arg  */
-#line 4573 "parse.y"
+#line 4575 "parse.y"
                   {
                         (yyval.node_args) = new_args_tail(p, (yyvsp[-3].node_kw_arg), (yyvsp[-1].id), (yyvsp[0].id), &(yylsp[-1]));
                     }
-#line 13745 "parse.c"
+#line 13747 "parse.c"
     break;
 
   case 422: /* block_args_tail: f_block_kwarg opt_f_block_arg  */
-#line 4577 "parse.y"
+#line 4579 "parse.y"
                   {
                         (yyval.node_args) = new_args_tail(p, (yyvsp[-1].node_kw_arg), Qnone, (yyvsp[0].id), &(yylsp[-1]));
                     }
-#line 13753 "parse.c"
+#line 13755 "parse.c"
     break;
 
   case 423: /* block_args_tail: f_any_kwrest opt_f_block_arg  */
-#line 4581 "parse.y"
+#line 4583 "parse.y"
                   {
                         (yyval.node_args) = new_args_tail(p, Qnone, (yyvsp[-1].id), (yyvsp[0].id), &(yylsp[-1]));
                     }
-#line 13761 "parse.c"
+#line 13763 "parse.c"
     break;
 
   case 424: /* block_args_tail: f_block_arg  */
-#line 4585 "parse.y"
+#line 4587 "parse.y"
                   {
                         (yyval.node_args) = new_args_tail(p, Qnone, Qnone, (yyvsp[0].id), &(yylsp[0]));
                     }
-#line 13769 "parse.c"
+#line 13771 "parse.c"
     break;
 
   case 425: /* opt_block_args_tail: ',' block_args_tail  */
-#line 4591 "parse.y"
+#line 4593 "parse.y"
                   {
                         (yyval.node_args) = (yyvsp[0].node_args);
                     }
-#line 13777 "parse.c"
+#line 13779 "parse.c"
     break;
 
   case 426: /* opt_block_args_tail: %empty  */
-#line 4595 "parse.y"
+#line 4597 "parse.y"
                   {
                         (yyval.node_args) = new_args_tail(p, Qnone, Qnone, Qnone, &(yylsp[0]));
                     }
-#line 13785 "parse.c"
+#line 13787 "parse.c"
     break;
 
   case 427: /* excessed_comma: ','  */
-#line 4601 "parse.y"
+#line 4603 "parse.y"
                   {
                         /* magic number for rest_id in iseq_set_arguments() */
                     /*%%%*/
@@ -13793,140 +13795,140 @@ yyreduce:
                     /*% %*/
                     /*% ripper: excessed_comma! %*/
                     }
-#line 13797 "parse.c"
+#line 13799 "parse.c"
     break;
 
   case 428: /* block_param: f_arg ',' f_block_optarg ',' f_rest_arg opt_block_args_tail  */
-#line 4611 "parse.y"
+#line 4613 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, (yyvsp[-5].node_args_aux), (yyvsp[-3].node_opt_arg), (yyvsp[-1].id), Qnone, (yyvsp[0].node_args), &(yyloc));
                     }
-#line 13805 "parse.c"
+#line 13807 "parse.c"
     break;
 
   case 429: /* block_param: f_arg ',' f_block_optarg ',' f_rest_arg ',' f_arg opt_block_args_tail  */
-#line 4615 "parse.y"
+#line 4617 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, (yyvsp[-7].node_args_aux), (yyvsp[-5].node_opt_arg), (yyvsp[-3].id), (yyvsp[-1].node_args_aux), (yyvsp[0].node_args), &(yyloc));
                     }
-#line 13813 "parse.c"
+#line 13815 "parse.c"
     break;
 
   case 430: /* block_param: f_arg ',' f_block_optarg opt_block_args_tail  */
-#line 4619 "parse.y"
+#line 4621 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, (yyvsp[-3].node_args_aux), (yyvsp[-1].node_opt_arg), Qnone, Qnone, (yyvsp[0].node_args), &(yyloc));
                     }
-#line 13821 "parse.c"
+#line 13823 "parse.c"
     break;
 
   case 431: /* block_param: f_arg ',' f_block_optarg ',' f_arg opt_block_args_tail  */
-#line 4623 "parse.y"
+#line 4625 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, (yyvsp[-5].node_args_aux), (yyvsp[-3].node_opt_arg), Qnone, (yyvsp[-1].node_args_aux), (yyvsp[0].node_args), &(yyloc));
                     }
-#line 13829 "parse.c"
+#line 13831 "parse.c"
     break;
 
   case 432: /* block_param: f_arg ',' f_rest_arg opt_block_args_tail  */
-#line 4627 "parse.y"
+#line 4629 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, (yyvsp[-3].node_args_aux), Qnone, (yyvsp[-1].id), Qnone, (yyvsp[0].node_args), &(yyloc));
                     }
-#line 13837 "parse.c"
+#line 13839 "parse.c"
     break;
 
   case 433: /* block_param: f_arg excessed_comma  */
-#line 4631 "parse.y"
+#line 4633 "parse.y"
                   {
                         (yyval.node_args) = new_args_tail(p, Qnone, Qnone, Qnone, &(yylsp[0]));
                         (yyval.node_args) = new_args(p, (yyvsp[-1].node_args_aux), Qnone, (yyvsp[0].id), Qnone, (yyval.node_args), &(yyloc));
                     }
-#line 13846 "parse.c"
+#line 13848 "parse.c"
     break;
 
   case 434: /* block_param: f_arg ',' f_rest_arg ',' f_arg opt_block_args_tail  */
-#line 4636 "parse.y"
+#line 4638 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, (yyvsp[-5].node_args_aux), Qnone, (yyvsp[-3].id), (yyvsp[-1].node_args_aux), (yyvsp[0].node_args), &(yyloc));
                     }
-#line 13854 "parse.c"
+#line 13856 "parse.c"
     break;
 
   case 435: /* block_param: f_arg opt_block_args_tail  */
-#line 4640 "parse.y"
+#line 4642 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, (yyvsp[-1].node_args_aux), Qnone, Qnone, Qnone, (yyvsp[0].node_args), &(yyloc));
                     }
-#line 13862 "parse.c"
+#line 13864 "parse.c"
     break;
 
   case 436: /* block_param: f_block_optarg ',' f_rest_arg opt_block_args_tail  */
-#line 4644 "parse.y"
+#line 4646 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, Qnone, (yyvsp[-3].node_opt_arg), (yyvsp[-1].id), Qnone, (yyvsp[0].node_args), &(yyloc));
                     }
-#line 13870 "parse.c"
+#line 13872 "parse.c"
     break;
 
   case 437: /* block_param: f_block_optarg ',' f_rest_arg ',' f_arg opt_block_args_tail  */
-#line 4648 "parse.y"
+#line 4650 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, Qnone, (yyvsp[-5].node_opt_arg), (yyvsp[-3].id), (yyvsp[-1].node_args_aux), (yyvsp[0].node_args), &(yyloc));
                     }
-#line 13878 "parse.c"
+#line 13880 "parse.c"
     break;
 
   case 438: /* block_param: f_block_optarg opt_block_args_tail  */
-#line 4652 "parse.y"
+#line 4654 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, Qnone, (yyvsp[-1].node_opt_arg), Qnone, Qnone, (yyvsp[0].node_args), &(yyloc));
                     }
-#line 13886 "parse.c"
+#line 13888 "parse.c"
     break;
 
   case 439: /* block_param: f_block_optarg ',' f_arg opt_block_args_tail  */
-#line 4656 "parse.y"
+#line 4658 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, Qnone, (yyvsp[-3].node_opt_arg), Qnone, (yyvsp[-1].node_args_aux), (yyvsp[0].node_args), &(yyloc));
                     }
-#line 13894 "parse.c"
+#line 13896 "parse.c"
     break;
 
   case 440: /* block_param: f_rest_arg opt_block_args_tail  */
-#line 4660 "parse.y"
+#line 4662 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, Qnone, Qnone, (yyvsp[-1].id), Qnone, (yyvsp[0].node_args), &(yyloc));
                     }
-#line 13902 "parse.c"
+#line 13904 "parse.c"
     break;
 
   case 441: /* block_param: f_rest_arg ',' f_arg opt_block_args_tail  */
-#line 4664 "parse.y"
+#line 4666 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, Qnone, Qnone, (yyvsp[-3].id), (yyvsp[-1].node_args_aux), (yyvsp[0].node_args), &(yyloc));
                     }
-#line 13910 "parse.c"
+#line 13912 "parse.c"
     break;
 
   case 442: /* block_param: block_args_tail  */
-#line 4668 "parse.y"
+#line 4670 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, Qnone, Qnone, Qnone, Qnone, (yyvsp[0].node_args), &(yyloc));
                     }
-#line 13918 "parse.c"
+#line 13920 "parse.c"
     break;
 
   case 444: /* opt_block_param: block_param_def  */
-#line 4675 "parse.y"
+#line 4677 "parse.y"
                   {
                         p->command_start = TRUE;
                     }
-#line 13926 "parse.c"
+#line 13928 "parse.c"
     break;
 
   case 445: /* block_param_def: '|' opt_bv_decl '|'  */
-#line 4681 "parse.y"
+#line 4683 "parse.y"
                   {
                         p->cur_arg = 0;
                         p->max_numparam = ORDINAL_PARAM;
@@ -13937,11 +13939,11 @@ yyreduce:
                     /*% ripper: params!(Qnil,Qnil,Qnil,Qnil,Qnil,Qnil,Qnil) %*/
                     /*% ripper: block_var!($$, $2) %*/
                     }
-#line 13941 "parse.c"
+#line 13943 "parse.c"
     break;
 
   case 446: /* block_param_def: '|' block_param opt_bv_decl '|'  */
-#line 4692 "parse.y"
+#line 4694 "parse.y"
                   {
                         p->cur_arg = 0;
                         p->max_numparam = ORDINAL_PARAM;
@@ -13951,83 +13953,83 @@ yyreduce:
                     /*% %*/
                     /*% ripper: block_var!($2, $3) %*/
                     }
-#line 13955 "parse.c"
+#line 13957 "parse.c"
     break;
 
   case 447: /* opt_bv_decl: opt_nl  */
-#line 4705 "parse.y"
+#line 4707 "parse.y"
                   {
                         (yyval.node) = 0;
                     }
-#line 13963 "parse.c"
+#line 13965 "parse.c"
     break;
 
   case 448: /* opt_bv_decl: opt_nl ';' bv_decls opt_nl  */
-#line 4709 "parse.y"
+#line 4711 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = 0;
                     /*% %*/
                     /*% ripper: $3 %*/
                     }
-#line 13974 "parse.c"
+#line 13976 "parse.c"
     break;
 
   case 451: /* bvar: "local variable or method"  */
-#line 4724 "parse.y"
+#line 4726 "parse.y"
                   {
                         new_bv(p, get_id((yyvsp[0].id)));
                     /*% ripper: get_value($1) %*/
                     }
-#line 13983 "parse.c"
+#line 13985 "parse.c"
     break;
 
   case 452: /* bvar: f_bad_arg  */
-#line 4729 "parse.y"
+#line 4731 "parse.y"
                   {
                         (yyval.node) = 0;
                     }
-#line 13991 "parse.c"
+#line 13993 "parse.c"
     break;
 
   case 453: /* max_numparam: %empty  */
-#line 4734 "parse.y"
+#line 4736 "parse.y"
                {
                         (yyval.num) = p->max_numparam;
                         p->max_numparam = 0;
                     }
-#line 14000 "parse.c"
+#line 14002 "parse.c"
     break;
 
   case 454: /* numparam: %empty  */
-#line 4740 "parse.y"
+#line 4742 "parse.y"
            {
                         (yyval.node) = numparam_push(p);
                     }
-#line 14008 "parse.c"
+#line 14010 "parse.c"
     break;
 
   case 455: /* @24: %empty  */
-#line 4746 "parse.y"
+#line 4748 "parse.y"
                   {
                         token_info_push(p, "->", &(yylsp[0]));
                         (yyvsp[0].vars) = dyna_push(p);
                         (yyval.num) = p->lex.lpar_beg;
                         p->lex.lpar_beg = p->lex.paren_nest;
                     }
-#line 14019 "parse.c"
+#line 14021 "parse.c"
     break;
 
   case 456: /* $@25: %empty  */
-#line 4754 "parse.y"
+#line 4756 "parse.y"
                   {
                         CMDARG_PUSH(0);
                     }
-#line 14027 "parse.c"
+#line 14029 "parse.c"
     break;
 
   case 457: /* lambda: "->" @24 max_numparam numparam allow_exits f_larglist $@25 lambda_body  */
-#line 4758 "parse.y"
+#line 4760 "parse.y"
                   {
                         int max_numparam = p->max_numparam;
                         p->lex.lpar_beg = (yyvsp[-6].num);
@@ -14048,11 +14050,11 @@ yyreduce:
                         numparam_pop(p, (yyvsp[-4].node));
                         dyna_pop(p, (yyvsp[-7].vars));
                     }
-#line 14052 "parse.c"
+#line 14054 "parse.c"
     break;
 
   case 458: /* f_larglist: '(' f_args opt_bv_decl ')'  */
-#line 4781 "parse.y"
+#line 4783 "parse.y"
                   {
                         p->ctxt.in_argdef = 0;
                     /*%%%*/
@@ -14061,11 +14063,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: paren!($2) %*/
                     }
-#line 14065 "parse.c"
+#line 14067 "parse.c"
     break;
 
   case 459: /* f_larglist: f_args  */
-#line 4790 "parse.y"
+#line 4792 "parse.y"
                   {
                         p->ctxt.in_argdef = 0;
                     /*%%%*/
@@ -14074,49 +14076,49 @@ yyreduce:
                     /*% %*/
                         (yyval.node_args) = (yyvsp[0].node_args);
                     }
-#line 14078 "parse.c"
+#line 14080 "parse.c"
     break;
 
   case 460: /* lambda_body: tLAMBEG compstmt '}'  */
-#line 4801 "parse.y"
+#line 4803 "parse.y"
                   {
                         token_info_pop(p, "}", &(yylsp[0]));
                         (yyval.node) = (yyvsp[-1].node);
                     }
-#line 14087 "parse.c"
+#line 14089 "parse.c"
     break;
 
   case 461: /* $@26: %empty  */
-#line 4806 "parse.y"
+#line 4808 "parse.y"
                   {
                     /*%%%*/
                         push_end_expect_token_locations(p, &(yylsp[0]).beg_pos);
                     /*% %*/
                     }
-#line 14097 "parse.c"
+#line 14099 "parse.c"
     break;
 
   case 462: /* lambda_body: "`do' for lambda" $@26 bodystmt k_end  */
-#line 4812 "parse.y"
+#line 4814 "parse.y"
                   {
                         (yyval.node) = (yyvsp[-1].node);
                     }
-#line 14105 "parse.c"
+#line 14107 "parse.c"
     break;
 
   case 463: /* do_block: k_do_block do_body k_end  */
-#line 4818 "parse.y"
+#line 4820 "parse.y"
                   {
                         (yyval.node) = (yyvsp[-1].node);
                     /*%%%*/
                         set_embraced_location((yyval.node), &(yylsp[-2]), &(yylsp[0]));
                     /*% %*/
                     }
-#line 14116 "parse.c"
+#line 14118 "parse.c"
     break;
 
   case 464: /* block_call: command do_block  */
-#line 4827 "parse.y"
+#line 4829 "parse.y"
                   {
                     /*%%%*/
                         if (nd_type_p((yyvsp[-1].node), NODE_YIELD)) {
@@ -14130,44 +14132,44 @@ yyreduce:
                     /*% %*/
                     /*% ripper: method_add_block!($1, $2) %*/
                     }
-#line 14134 "parse.c"
+#line 14136 "parse.c"
     break;
 
   case 465: /* block_call: block_call call_op2 operation2 opt_paren_args  */
-#line 4841 "parse.y"
+#line 4843 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_qcall(p, (yyvsp[-2].id), (yyvsp[-3].node), (yyvsp[-1].id), (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
                     /*% %*/
                     /*% ripper: opt_event(:method_add_arg!, call!($1, $2, $3), $4) %*/
                     }
-#line 14145 "parse.c"
+#line 14147 "parse.c"
     break;
 
   case 466: /* block_call: block_call call_op2 operation2 opt_paren_args brace_block  */
-#line 4848 "parse.y"
+#line 4850 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_command_qcall(p, (yyvsp[-3].id), (yyvsp[-4].node), (yyvsp[-2].id), (yyvsp[-1].node), (yyvsp[0].node), &(yylsp[-2]), &(yyloc));
                     /*% %*/
                     /*% ripper: opt_event(:method_add_block!, command_call!($1, $2, $3, $4), $5) %*/
                     }
-#line 14156 "parse.c"
+#line 14158 "parse.c"
     break;
 
   case 467: /* block_call: block_call call_op2 operation2 command_args do_block  */
-#line 4855 "parse.y"
+#line 4857 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_command_qcall(p, (yyvsp[-3].id), (yyvsp[-4].node), (yyvsp[-2].id), (yyvsp[-1].node), (yyvsp[0].node), &(yylsp[-2]), &(yyloc));
                     /*% %*/
                     /*% ripper: method_add_block!(command_call!($1, $2, $3, $4), $5) %*/
                     }
-#line 14167 "parse.c"
+#line 14169 "parse.c"
     break;
 
   case 468: /* method_call: fcall paren_args  */
-#line 4864 "parse.y"
+#line 4866 "parse.y"
                   {
                     /*%%%*/
                         (yyvsp[-1].node_fcall)->nd_args = (yyvsp[0].node);
@@ -14176,11 +14178,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: method_add_arg!(fcall!($1), $2) %*/
                     }
-#line 14180 "parse.c"
+#line 14182 "parse.c"
     break;
 
   case 469: /* method_call: primary_value call_op operation2 opt_paren_args  */
-#line 4873 "parse.y"
+#line 4875 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_qcall(p, (yyvsp[-2].id), (yyvsp[-3].node), (yyvsp[-1].id), (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
@@ -14188,11 +14190,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: opt_event(:method_add_arg!, call!($1, $2, $3), $4) %*/
                     }
-#line 14192 "parse.c"
+#line 14194 "parse.c"
     break;
 
   case 470: /* method_call: primary_value "::" operation2 paren_args  */
-#line 4881 "parse.y"
+#line 4883 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_qcall(p, ID2VAL(idCOLON2), (yyvsp[-3].node), (yyvsp[-1].id), (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
@@ -14200,22 +14202,22 @@ yyreduce:
                     /*% %*/
                     /*% ripper: method_add_arg!(call!($1, $2, $3), $4) %*/
                     }
-#line 14204 "parse.c"
+#line 14206 "parse.c"
     break;
 
   case 471: /* method_call: primary_value "::" operation3  */
-#line 4889 "parse.y"
+#line 4891 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_qcall(p, ID2VAL(idCOLON2), (yyvsp[-2].node), (yyvsp[0].id), Qnull, &(yylsp[0]), &(yyloc));
                     /*% %*/
                     /*% ripper: call!($1, $2, $3) %*/
                     }
-#line 14215 "parse.c"
+#line 14217 "parse.c"
     break;
 
   case 472: /* method_call: primary_value call_op paren_args  */
-#line 4896 "parse.y"
+#line 4898 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_qcall(p, (yyvsp[-1].id), (yyvsp[-2].node), ID2VAL(idCall), (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
@@ -14223,11 +14225,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: method_add_arg!(call!($1, $2, ID2VAL(idCall)), $3) %*/
                     }
-#line 14227 "parse.c"
+#line 14229 "parse.c"
     break;
 
   case 473: /* method_call: primary_value "::" paren_args  */
-#line 4904 "parse.y"
+#line 4906 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_qcall(p, ID2VAL(idCOLON2), (yyvsp[-2].node), ID2VAL(idCall), (yyvsp[0].node), &(yylsp[-1]), &(yyloc));
@@ -14235,33 +14237,33 @@ yyreduce:
                     /*% %*/
                     /*% ripper: method_add_arg!(call!($1, $2, ID2VAL(idCall)), $3) %*/
                     }
-#line 14239 "parse.c"
+#line 14241 "parse.c"
     break;
 
   case 474: /* method_call: "`super'" paren_args  */
-#line 4912 "parse.y"
+#line 4914 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_SUPER((yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: super!($2) %*/
                     }
-#line 14250 "parse.c"
+#line 14252 "parse.c"
     break;
 
   case 475: /* method_call: "`super'"  */
-#line 4919 "parse.y"
+#line 4921 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_ZSUPER(&(yyloc));
                     /*% %*/
                     /*% ripper: zsuper! %*/
                     }
-#line 14261 "parse.c"
+#line 14263 "parse.c"
     break;
 
   case 476: /* method_call: primary_value '[' opt_call_args rbracket  */
-#line 4926 "parse.y"
+#line 4928 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_CALL((yyvsp[-3].node), tAREF, (yyvsp[-1].node), &(yyloc));
@@ -14269,39 +14271,39 @@ yyreduce:
                     /*% %*/
                     /*% ripper: aref!($1, $3) %*/
                     }
-#line 14273 "parse.c"
+#line 14275 "parse.c"
     break;
 
   case 477: /* brace_block: '{' brace_body '}'  */
-#line 4936 "parse.y"
+#line 4938 "parse.y"
                   {
                         (yyval.node) = (yyvsp[-1].node);
                     /*%%%*/
                         set_embraced_location((yyval.node), &(yylsp[-2]), &(yylsp[0]));
                     /*% %*/
                     }
-#line 14284 "parse.c"
+#line 14286 "parse.c"
     break;
 
   case 478: /* brace_block: k_do do_body k_end  */
-#line 4943 "parse.y"
+#line 4945 "parse.y"
                   {
                         (yyval.node) = (yyvsp[-1].node);
                     /*%%%*/
                         set_embraced_location((yyval.node), &(yylsp[-2]), &(yylsp[0]));
                     /*% %*/
                     }
-#line 14295 "parse.c"
+#line 14297 "parse.c"
     break;
 
   case 479: /* @27: %empty  */
-#line 4951 "parse.y"
+#line 4953 "parse.y"
            {(yyval.vars) = dyna_push(p);}
-#line 14301 "parse.c"
+#line 14303 "parse.c"
     break;
 
   case 480: /* brace_body: @27 max_numparam numparam allow_exits opt_block_param compstmt  */
-#line 4954 "parse.y"
+#line 4956 "parse.y"
                   {
                         int max_numparam = p->max_numparam;
                         p->max_numparam = (yyvsp[-4].num);
@@ -14314,20 +14316,20 @@ yyreduce:
                         numparam_pop(p, (yyvsp[-3].node));
                         dyna_pop(p, (yyvsp[-5].vars));
                     }
-#line 14318 "parse.c"
+#line 14320 "parse.c"
     break;
 
   case 481: /* @28: %empty  */
-#line 4968 "parse.y"
+#line 4970 "parse.y"
            {
                         (yyval.vars) = dyna_push(p);
                         CMDARG_PUSH(0);
                     }
-#line 14327 "parse.c"
+#line 14329 "parse.c"
     break;
 
   case 482: /* do_body: @28 max_numparam numparam allow_exits opt_block_param bodystmt  */
-#line 4974 "parse.y"
+#line 4976 "parse.y"
                   {
                         int max_numparam = p->max_numparam;
                         p->max_numparam = (yyvsp[-4].num);
@@ -14341,11 +14343,11 @@ yyreduce:
                         numparam_pop(p, (yyvsp[-3].node));
                         dyna_pop(p, (yyvsp[-5].vars));
                     }
-#line 14345 "parse.c"
+#line 14347 "parse.c"
     break;
 
   case 483: /* case_args: arg_value  */
-#line 4990 "parse.y"
+#line 4992 "parse.y"
                   {
                     /*%%%*/
                         check_literal_when(p, (yyvsp[0].node), &(yylsp[0]));
@@ -14353,22 +14355,22 @@ yyreduce:
                     /*% %*/
                     /*% ripper: args_add!(args_new!, $1) %*/
                     }
-#line 14357 "parse.c"
+#line 14359 "parse.c"
     break;
 
   case 484: /* case_args: "*" arg_value  */
-#line 4998 "parse.y"
+#line 5000 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_SPLAT((yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: args_add_star!(args_new!, $2) %*/
                     }
-#line 14368 "parse.c"
+#line 14370 "parse.c"
     break;
 
   case 485: /* case_args: case_args ',' arg_value  */
-#line 5005 "parse.y"
+#line 5007 "parse.y"
                   {
                     /*%%%*/
                         check_literal_when(p, (yyvsp[0].node), &(yylsp[0]));
@@ -14376,22 +14378,22 @@ yyreduce:
                     /*% %*/
                     /*% ripper: args_add!($1, $3) %*/
                     }
-#line 14380 "parse.c"
+#line 14382 "parse.c"
     break;
 
   case 486: /* case_args: case_args ',' "*" arg_value  */
-#line 5013 "parse.y"
+#line 5015 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = rest_arg_append(p, (yyvsp[-3].node), (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: args_add_star!($1, $4) %*/
                     }
-#line 14391 "parse.c"
+#line 14393 "parse.c"
     break;
 
   case 487: /* case_body: k_when case_args then compstmt cases  */
-#line 5024 "parse.y"
+#line 5026 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_WHEN((yyvsp[-3].node), (yyvsp[-1].node), (yyvsp[0].node), &(yyloc));
@@ -14399,55 +14401,55 @@ yyreduce:
                     /*% %*/
                     /*% ripper: when!($2, $4, $5) %*/
                     }
-#line 14403 "parse.c"
+#line 14405 "parse.c"
     break;
 
   case 490: /* p_pvtbl: %empty  */
-#line 5037 "parse.y"
+#line 5039 "parse.y"
          {(yyval.tbl) = p->pvtbl; p->pvtbl = st_init_numtable();}
-#line 14409 "parse.c"
+#line 14411 "parse.c"
     break;
 
   case 491: /* p_pktbl: %empty  */
-#line 5038 "parse.y"
+#line 5040 "parse.y"
          {(yyval.tbl) = p->pktbl; p->pktbl = 0;}
-#line 14415 "parse.c"
+#line 14417 "parse.c"
     break;
 
   case 492: /* p_in_kwarg: %empty  */
-#line 5040 "parse.y"
+#line 5042 "parse.y"
              {
                         (yyval.ctxt) = p->ctxt;
                         SET_LEX_STATE(EXPR_BEG|EXPR_LABEL);
                         p->command_start = FALSE;
                         p->ctxt.in_kwarg = 1;
                     }
-#line 14426 "parse.c"
+#line 14428 "parse.c"
     break;
 
   case 493: /* $@29: %empty  */
-#line 5051 "parse.y"
+#line 5053 "parse.y"
                   {
                         pop_pktbl(p, (yyvsp[-2].tbl));
                         pop_pvtbl(p, (yyvsp[-3].tbl));
                         p->ctxt.in_kwarg = (yyvsp[-4].ctxt).in_kwarg;
                     }
-#line 14436 "parse.c"
+#line 14438 "parse.c"
     break;
 
   case 494: /* p_case_body: "`in'" p_in_kwarg p_pvtbl p_pktbl p_top_expr then $@29 compstmt p_cases  */
-#line 5058 "parse.y"
+#line 5060 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_IN((yyvsp[-4].node), (yyvsp[-1].node), (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: in!($expr, $compstmt, $cases) %*/
                     }
-#line 14447 "parse.c"
+#line 14449 "parse.c"
     break;
 
   case 498: /* p_top_expr: p_top_expr_body "`if' modifier" expr_value  */
-#line 5072 "parse.y"
+#line 5074 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_if(p, (yyvsp[0].node), (yyvsp[-2].node), 0, &(yyloc));
@@ -14455,11 +14457,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: if_mod!($3, $1) %*/
                     }
-#line 14459 "parse.c"
+#line 14461 "parse.c"
     break;
 
   case 499: /* p_top_expr: p_top_expr_body "`unless' modifier" expr_value  */
-#line 5080 "parse.y"
+#line 5082 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_unless(p, (yyvsp[0].node), (yyvsp[-2].node), 0, &(yyloc));
@@ -14467,20 +14469,20 @@ yyreduce:
                     /*% %*/
                     /*% ripper: unless_mod!($3, $1) %*/
                     }
-#line 14471 "parse.c"
+#line 14473 "parse.c"
     break;
 
   case 501: /* p_top_expr_body: p_expr ','  */
-#line 5091 "parse.y"
+#line 5093 "parse.y"
                   {
                         (yyval.node) = new_array_pattern_tail(p, Qnone, 1, Qnone, Qnone, &(yyloc));
                         (yyval.node) = new_array_pattern(p, Qnone, get_value((yyvsp[-1].node)), (yyval.node), &(yyloc));
                     }
-#line 14480 "parse.c"
+#line 14482 "parse.c"
     break;
 
   case 502: /* p_top_expr_body: p_expr ',' p_args  */
-#line 5096 "parse.y"
+#line 5098 "parse.y"
                   {
                         (yyval.node) = new_array_pattern(p, Qnone, get_value((yyvsp[-2].node)), (yyvsp[0].node), &(yyloc));
                     /*%%%*/
@@ -14488,35 +14490,35 @@ yyreduce:
                     /*%
                     %*/
                     }
-#line 14492 "parse.c"
+#line 14494 "parse.c"
     break;
 
   case 503: /* p_top_expr_body: p_find  */
-#line 5104 "parse.y"
+#line 5106 "parse.y"
                   {
                         (yyval.node) = new_find_pattern(p, Qnone, (yyvsp[0].node), &(yyloc));
                     }
-#line 14500 "parse.c"
+#line 14502 "parse.c"
     break;
 
   case 504: /* p_top_expr_body: p_args_tail  */
-#line 5108 "parse.y"
+#line 5110 "parse.y"
                   {
                         (yyval.node) = new_array_pattern(p, Qnone, Qnone, (yyvsp[0].node), &(yyloc));
                     }
-#line 14508 "parse.c"
+#line 14510 "parse.c"
     break;
 
   case 505: /* p_top_expr_body: p_kwargs  */
-#line 5112 "parse.y"
+#line 5114 "parse.y"
                   {
                         (yyval.node) = new_hash_pattern(p, Qnone, (yyvsp[0].node), &(yyloc));
                     }
-#line 14516 "parse.c"
+#line 14518 "parse.c"
     break;
 
   case 507: /* p_as: p_expr "=>" p_variable  */
-#line 5121 "parse.y"
+#line 5123 "parse.y"
                   {
                     /*%%%*/
                         NODE *n = NEW_LIST((yyvsp[-2].node), &(yyloc));
@@ -14525,34 +14527,34 @@ yyreduce:
                     /*% %*/
                     /*% ripper: binary!($1, STATIC_ID2SYM((id_assoc)), $3) %*/
                     }
-#line 14529 "parse.c"
+#line 14531 "parse.c"
     break;
 
   case 509: /* p_alt: p_alt '|' p_expr_basic  */
-#line 5133 "parse.y"
+#line 5135 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_OR((yyvsp[-2].node), (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: binary!($1, STATIC_ID2SYM(idOr), $3) %*/
                     }
-#line 14540 "parse.c"
+#line 14542 "parse.c"
     break;
 
   case 511: /* p_lparen: '(' p_pktbl  */
-#line 5142 "parse.y"
+#line 5144 "parse.y"
                      { (yyval.tbl) = (yyvsp[0].tbl);}
-#line 14546 "parse.c"
+#line 14548 "parse.c"
     break;
 
   case 512: /* p_lbracket: '[' p_pktbl  */
-#line 5143 "parse.y"
+#line 5145 "parse.y"
                        { (yyval.tbl) = (yyvsp[0].tbl);}
-#line 14552 "parse.c"
+#line 14554 "parse.c"
     break;
 
   case 515: /* p_expr_basic: p_const p_lparen p_args rparen  */
-#line 5148 "parse.y"
+#line 5150 "parse.y"
                   {
                         pop_pktbl(p, (yyvsp[-2].tbl));
                         (yyval.node) = new_array_pattern(p, (yyvsp[-3].node), Qnone, (yyvsp[-1].node), &(yyloc));
@@ -14561,11 +14563,11 @@ yyreduce:
                     /*%
                     %*/
                     }
-#line 14565 "parse.c"
+#line 14567 "parse.c"
     break;
 
   case 516: /* p_expr_basic: p_const p_lparen p_find rparen  */
-#line 5157 "parse.y"
+#line 5159 "parse.y"
                   {
                         pop_pktbl(p, (yyvsp[-2].tbl));
                         (yyval.node) = new_find_pattern(p, (yyvsp[-3].node), (yyvsp[-1].node), &(yyloc));
@@ -14574,11 +14576,11 @@ yyreduce:
                     /*%
                     %*/
                     }
-#line 14578 "parse.c"
+#line 14580 "parse.c"
     break;
 
   case 517: /* p_expr_basic: p_const p_lparen p_kwargs rparen  */
-#line 5166 "parse.y"
+#line 5168 "parse.y"
                   {
                         pop_pktbl(p, (yyvsp[-2].tbl));
                         (yyval.node) = new_hash_pattern(p, (yyvsp[-3].node), (yyvsp[-1].node), &(yyloc));
@@ -14587,20 +14589,20 @@ yyreduce:
                     /*%
                     %*/
                     }
-#line 14591 "parse.c"
+#line 14593 "parse.c"
     break;
 
   case 518: /* p_expr_basic: p_const '(' rparen  */
-#line 5175 "parse.y"
+#line 5177 "parse.y"
                   {
                         (yyval.node) = new_array_pattern_tail(p, Qnone, 0, Qnone, Qnone, &(yyloc));
                         (yyval.node) = new_array_pattern(p, (yyvsp[-2].node), Qnone, (yyval.node), &(yyloc));
                     }
-#line 14600 "parse.c"
+#line 14602 "parse.c"
     break;
 
   case 519: /* p_expr_basic: p_const p_lbracket p_args rbracket  */
-#line 5180 "parse.y"
+#line 5182 "parse.y"
                   {
                         pop_pktbl(p, (yyvsp[-2].tbl));
                         (yyval.node) = new_array_pattern(p, (yyvsp[-3].node), Qnone, (yyvsp[-1].node), &(yyloc));
@@ -14609,11 +14611,11 @@ yyreduce:
                     /*%
                     %*/
                     }
-#line 14613 "parse.c"
+#line 14615 "parse.c"
     break;
 
   case 520: /* p_expr_basic: p_const p_lbracket p_find rbracket  */
-#line 5189 "parse.y"
+#line 5191 "parse.y"
                   {
                         pop_pktbl(p, (yyvsp[-2].tbl));
                         (yyval.node) = new_find_pattern(p, (yyvsp[-3].node), (yyvsp[-1].node), &(yyloc));
@@ -14622,11 +14624,11 @@ yyreduce:
                     /*%
                     %*/
                     }
-#line 14626 "parse.c"
+#line 14628 "parse.c"
     break;
 
   case 521: /* p_expr_basic: p_const p_lbracket p_kwargs rbracket  */
-#line 5198 "parse.y"
+#line 5200 "parse.y"
                   {
                         pop_pktbl(p, (yyvsp[-2].tbl));
                         (yyval.node) = new_hash_pattern(p, (yyvsp[-3].node), (yyvsp[-1].node), &(yyloc));
@@ -14635,81 +14637,81 @@ yyreduce:
                     /*%
                     %*/
                     }
-#line 14639 "parse.c"
+#line 14641 "parse.c"
     break;
 
   case 522: /* p_expr_basic: p_const '[' rbracket  */
-#line 5207 "parse.y"
+#line 5209 "parse.y"
                   {
                         (yyval.node) = new_array_pattern_tail(p, Qnone, 0, Qnone, Qnone, &(yyloc));
                         (yyval.node) = new_array_pattern(p, (yyvsp[-2].node), Qnone, (yyval.node), &(yyloc));
                     }
-#line 14648 "parse.c"
+#line 14650 "parse.c"
     break;
 
   case 523: /* p_expr_basic: "[" p_args rbracket  */
-#line 5212 "parse.y"
+#line 5214 "parse.y"
                   {
                         (yyval.node) = new_array_pattern(p, Qnone, Qnone, (yyvsp[-1].node), &(yyloc));
                     }
-#line 14656 "parse.c"
+#line 14658 "parse.c"
     break;
 
   case 524: /* p_expr_basic: "[" p_find rbracket  */
-#line 5216 "parse.y"
+#line 5218 "parse.y"
                   {
                         (yyval.node) = new_find_pattern(p, Qnone, (yyvsp[-1].node), &(yyloc));
                     }
-#line 14664 "parse.c"
+#line 14666 "parse.c"
     break;
 
   case 525: /* p_expr_basic: "[" rbracket  */
-#line 5220 "parse.y"
+#line 5222 "parse.y"
                   {
                         (yyval.node) = new_array_pattern_tail(p, Qnone, 0, Qnone, Qnone, &(yyloc));
                         (yyval.node) = new_array_pattern(p, Qnone, Qnone, (yyval.node), &(yyloc));
                     }
-#line 14673 "parse.c"
+#line 14675 "parse.c"
     break;
 
   case 526: /* $@30: %empty  */
-#line 5225 "parse.y"
+#line 5227 "parse.y"
                   {
                         p->ctxt.in_kwarg = 0;
                     }
-#line 14681 "parse.c"
+#line 14683 "parse.c"
     break;
 
   case 527: /* p_expr_basic: "{" p_pktbl lex_ctxt $@30 p_kwargs rbrace  */
-#line 5229 "parse.y"
+#line 5231 "parse.y"
                   {
                         pop_pktbl(p, (yyvsp[-4].tbl));
                         p->ctxt.in_kwarg = (yyvsp[-3].ctxt).in_kwarg;
                         (yyval.node) = new_hash_pattern(p, Qnone, (yyvsp[-1].node), &(yyloc));
                     }
-#line 14691 "parse.c"
+#line 14693 "parse.c"
     break;
 
   case 528: /* p_expr_basic: "{" rbrace  */
-#line 5235 "parse.y"
+#line 5237 "parse.y"
                   {
                         (yyval.node) = new_hash_pattern_tail(p, Qnone, 0, &(yyloc));
                         (yyval.node) = new_hash_pattern(p, Qnone, (yyval.node), &(yyloc));
                     }
-#line 14700 "parse.c"
+#line 14702 "parse.c"
     break;
 
   case 529: /* p_expr_basic: "(" p_pktbl p_expr rparen  */
-#line 5240 "parse.y"
+#line 5242 "parse.y"
                   {
                         pop_pktbl(p, (yyvsp[-2].tbl));
                         (yyval.node) = (yyvsp[-1].node);
                     }
-#line 14709 "parse.c"
+#line 14711 "parse.c"
     break;
 
   case 530: /* p_args: p_expr  */
-#line 5247 "parse.y"
+#line 5249 "parse.y"
                   {
                     /*%%%*/
                         NODE *pre_args = NEW_LIST((yyvsp[0].node), &(yyloc));
@@ -14718,19 +14720,19 @@ yyreduce:
                         $$ = new_array_pattern_tail(p, rb_ary_new_from_args(1, get_value($1)), 0, Qnone, Qnone, &@$);
                     %*/
                     }
-#line 14722 "parse.c"
+#line 14724 "parse.c"
     break;
 
   case 531: /* p_args: p_args_head  */
-#line 5256 "parse.y"
+#line 5258 "parse.y"
                   {
                         (yyval.node) = new_array_pattern_tail(p, (yyvsp[0].node), 1, Qnone, Qnone, &(yyloc));
                     }
-#line 14730 "parse.c"
+#line 14732 "parse.c"
     break;
 
   case 532: /* p_args: p_args_head p_arg  */
-#line 5260 "parse.y"
+#line 5262 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_array_pattern_tail(p, list_concat((yyvsp[-1].node), (yyvsp[0].node)), 0, Qnone, Qnone, &(yyloc));
@@ -14739,70 +14741,70 @@ yyreduce:
                         $$ = new_array_pattern_tail(p, pre_args, 0, Qnone, Qnone, &@$);
                     %*/
                     }
-#line 14743 "parse.c"
+#line 14745 "parse.c"
     break;
 
   case 533: /* p_args: p_args_head p_rest  */
-#line 5269 "parse.y"
+#line 5271 "parse.y"
                   {
                         (yyval.node) = new_array_pattern_tail(p, (yyvsp[-1].node), 1, (yyvsp[0].node), Qnone, &(yyloc));
                     }
-#line 14751 "parse.c"
+#line 14753 "parse.c"
     break;
 
   case 534: /* p_args: p_args_head p_rest ',' p_args_post  */
-#line 5273 "parse.y"
+#line 5275 "parse.y"
                   {
                         (yyval.node) = new_array_pattern_tail(p, (yyvsp[-3].node), 1, (yyvsp[-2].node), (yyvsp[0].node), &(yyloc));
                     }
-#line 14759 "parse.c"
+#line 14761 "parse.c"
     break;
 
   case 536: /* p_args_head: p_arg ','  */
-#line 5280 "parse.y"
+#line 5282 "parse.y"
                   {
                         (yyval.node) = (yyvsp[-1].node);
                     }
-#line 14767 "parse.c"
+#line 14769 "parse.c"
     break;
 
   case 537: /* p_args_head: p_args_head p_arg ','  */
-#line 5284 "parse.y"
+#line 5286 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = list_concat((yyvsp[-2].node), (yyvsp[-1].node));
                     /*% %*/
                     /*% ripper: rb_ary_concat($1, get_value($2)) %*/
                     }
-#line 14778 "parse.c"
+#line 14780 "parse.c"
     break;
 
   case 538: /* p_args_tail: p_rest  */
-#line 5293 "parse.y"
+#line 5295 "parse.y"
                   {
                         (yyval.node) = new_array_pattern_tail(p, Qnone, 1, (yyvsp[0].node), Qnone, &(yyloc));
                     }
-#line 14786 "parse.c"
+#line 14788 "parse.c"
     break;
 
   case 539: /* p_args_tail: p_rest ',' p_args_post  */
-#line 5297 "parse.y"
+#line 5299 "parse.y"
                   {
                         (yyval.node) = new_array_pattern_tail(p, Qnone, 1, (yyvsp[-2].node), (yyvsp[0].node), &(yyloc));
                     }
-#line 14794 "parse.c"
+#line 14796 "parse.c"
     break;
 
   case 540: /* p_find: p_rest ',' p_args_post ',' p_rest  */
-#line 5303 "parse.y"
+#line 5305 "parse.y"
                   {
                         (yyval.node) = new_find_pattern_tail(p, (yyvsp[-4].node), (yyvsp[-2].node), (yyvsp[0].node), &(yyloc));
                     }
-#line 14802 "parse.c"
+#line 14804 "parse.c"
     break;
 
   case 541: /* p_rest: "*" "local variable or method"  */
-#line 5310 "parse.y"
+#line 5312 "parse.y"
                   {
                     /*%%%*/
                         error_duplicate_pattern_variable(p, (yyvsp[0].id), &(yylsp[0]));
@@ -14810,87 +14812,87 @@ yyreduce:
                     /*% %*/
                     /*% ripper: assignable(p, var_field(p, $2)) %*/
                     }
-#line 14814 "parse.c"
+#line 14816 "parse.c"
     break;
 
   case 542: /* p_rest: "*"  */
-#line 5318 "parse.y"
+#line 5320 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = 0;
                     /*% %*/
                     /*% ripper: var_field(p, Qnil) %*/
                     }
-#line 14825 "parse.c"
+#line 14827 "parse.c"
     break;
 
   case 544: /* p_args_post: p_args_post ',' p_arg  */
-#line 5328 "parse.y"
+#line 5330 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = list_concat((yyvsp[-2].node), (yyvsp[0].node));
                     /*% %*/
                     /*% ripper: rb_ary_concat($1, get_value($3)) %*/
                     }
-#line 14836 "parse.c"
+#line 14838 "parse.c"
     break;
 
   case 545: /* p_arg: p_expr  */
-#line 5337 "parse.y"
+#line 5339 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_LIST((yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: rb_ary_new_from_args(1, get_value($1)) %*/
                     }
-#line 14847 "parse.c"
+#line 14849 "parse.c"
     break;
 
   case 546: /* p_kwargs: p_kwarg ',' p_any_kwrest  */
-#line 5346 "parse.y"
+#line 5348 "parse.y"
                   {
                         (yyval.node) =  new_hash_pattern_tail(p, new_unique_key_hash(p, (yyvsp[-2].node), &(yyloc)), (yyvsp[0].id), &(yyloc));
                     }
-#line 14855 "parse.c"
+#line 14857 "parse.c"
     break;
 
   case 547: /* p_kwargs: p_kwarg  */
-#line 5350 "parse.y"
+#line 5352 "parse.y"
                   {
                         (yyval.node) =  new_hash_pattern_tail(p, new_unique_key_hash(p, (yyvsp[0].node), &(yyloc)), 0, &(yyloc));
                     }
-#line 14863 "parse.c"
+#line 14865 "parse.c"
     break;
 
   case 548: /* p_kwargs: p_kwarg ','  */
-#line 5354 "parse.y"
+#line 5356 "parse.y"
                   {
                         (yyval.node) =  new_hash_pattern_tail(p, new_unique_key_hash(p, (yyvsp[-1].node), &(yyloc)), 0, &(yyloc));
                     }
-#line 14871 "parse.c"
+#line 14873 "parse.c"
     break;
 
   case 549: /* p_kwargs: p_any_kwrest  */
-#line 5358 "parse.y"
+#line 5360 "parse.y"
                   {
                         (yyval.node) =  new_hash_pattern_tail(p, new_hash(p, Qnone, &(yyloc)), (yyvsp[0].id), &(yyloc));
                     }
-#line 14879 "parse.c"
+#line 14881 "parse.c"
     break;
 
   case 551: /* p_kwarg: p_kwarg ',' p_kw  */
-#line 5366 "parse.y"
+#line 5368 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = list_concat((yyvsp[-2].node), (yyvsp[0].node));
                     /*% %*/
                     /*% ripper: rb_ary_push($1, $3) %*/
                     }
-#line 14890 "parse.c"
+#line 14892 "parse.c"
     break;
 
   case 552: /* p_kw: p_kw_label p_expr  */
-#line 5375 "parse.y"
+#line 5377 "parse.y"
                   {
                         error_duplicate_pattern_key(p, get_id((yyvsp[-1].id)), &(yylsp[-1]));
                     /*%%%*/
@@ -14898,11 +14900,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: rb_ary_new_from_args(2, get_value($1), get_value($2)) %*/
                     }
-#line 14902 "parse.c"
+#line 14904 "parse.c"
     break;
 
   case 553: /* p_kw: p_kw_label  */
-#line 5383 "parse.y"
+#line 5385 "parse.y"
                   {
                         error_duplicate_pattern_key(p, get_id((yyvsp[0].id)), &(yylsp[0]));
                         if ((yyvsp[0].id) && !is_local_id(get_id((yyvsp[0].id)))) {
@@ -14914,11 +14916,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: rb_ary_new_from_args(2, get_value(assignable(p, $1)), Qnil) %*/
                     }
-#line 14918 "parse.c"
+#line 14920 "parse.c"
     break;
 
   case 555: /* p_kw_label: "string literal" string_contents tLABEL_END  */
-#line 5398 "parse.y"
+#line 5400 "parse.y"
                   {
                         YYLTYPE loc = code_loc_gen(&(yylsp[-2]), &(yylsp[0]));
                     /*%%%*/
@@ -14939,41 +14941,41 @@ yyreduce:
                             (yyval.id) = 0;
                         }
                     }
-#line 14943 "parse.c"
+#line 14945 "parse.c"
     break;
 
   case 556: /* p_kwrest: kwrest_mark "local variable or method"  */
-#line 5421 "parse.y"
+#line 5423 "parse.y"
                   {
                         (yyval.id) = (yyvsp[0].id);
                     }
-#line 14951 "parse.c"
+#line 14953 "parse.c"
     break;
 
   case 557: /* p_kwrest: kwrest_mark  */
-#line 5425 "parse.y"
+#line 5427 "parse.y"
                   {
                         (yyval.id) = 0;
                     }
-#line 14959 "parse.c"
+#line 14961 "parse.c"
     break;
 
   case 558: /* p_kwnorest: kwrest_mark "`nil'"  */
-#line 5431 "parse.y"
+#line 5433 "parse.y"
                   {
                         (yyval.id) = 0;
                     }
-#line 14967 "parse.c"
+#line 14969 "parse.c"
     break;
 
   case 560: /* p_any_kwrest: p_kwnorest  */
-#line 5437 "parse.y"
+#line 5439 "parse.y"
                            {(yyval.id) = ID2VAL(idNil);}
-#line 14973 "parse.c"
+#line 14975 "parse.c"
     break;
 
   case 562: /* p_value: p_primitive ".." p_primitive  */
-#line 5442 "parse.y"
+#line 5444 "parse.y"
                   {
                     /*%%%*/
                         value_expr((yyvsp[-2].node));
@@ -14982,11 +14984,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: dot2!($1, $3) %*/
                     }
-#line 14986 "parse.c"
+#line 14988 "parse.c"
     break;
 
   case 563: /* p_value: p_primitive "..." p_primitive  */
-#line 5451 "parse.y"
+#line 5453 "parse.y"
                   {
                     /*%%%*/
                         value_expr((yyvsp[-2].node));
@@ -14995,11 +14997,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: dot3!($1, $3) %*/
                     }
-#line 14999 "parse.c"
+#line 15001 "parse.c"
     break;
 
   case 564: /* p_value: p_primitive ".."  */
-#line 5460 "parse.y"
+#line 5462 "parse.y"
                   {
                     /*%%%*/
                         value_expr((yyvsp[-1].node));
@@ -15007,11 +15009,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: dot2!($1, Qnil) %*/
                     }
-#line 15011 "parse.c"
+#line 15013 "parse.c"
     break;
 
   case 565: /* p_value: p_primitive "..."  */
-#line 5468 "parse.y"
+#line 5470 "parse.y"
                   {
                     /*%%%*/
                         value_expr((yyvsp[-1].node));
@@ -15019,11 +15021,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: dot3!($1, Qnil) %*/
                     }
-#line 15023 "parse.c"
+#line 15025 "parse.c"
     break;
 
   case 569: /* p_value: "(.." p_primitive  */
-#line 5479 "parse.y"
+#line 5481 "parse.y"
                   {
                     /*%%%*/
                         value_expr((yyvsp[0].node));
@@ -15031,11 +15033,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: dot2!(Qnil, $2) %*/
                     }
-#line 15035 "parse.c"
+#line 15037 "parse.c"
     break;
 
   case 570: /* p_value: "(..." p_primitive  */
-#line 5487 "parse.y"
+#line 5489 "parse.y"
                   {
                     /*%%%*/
                         value_expr((yyvsp[0].node));
@@ -15043,22 +15045,22 @@ yyreduce:
                     /*% %*/
                     /*% ripper: dot3!(Qnil, $2) %*/
                     }
-#line 15047 "parse.c"
+#line 15049 "parse.c"
     break;
 
   case 579: /* p_primitive: keyword_variable  */
-#line 5505 "parse.y"
+#line 5507 "parse.y"
                   {
                     /*%%%*/
                         if (!((yyval.node) = gettable(p, (yyvsp[0].id), &(yyloc)))) (yyval.node) = NEW_ERROR(&(yyloc));
                     /*% %*/
                     /*% ripper: var_ref!($1) %*/
                     }
-#line 15058 "parse.c"
+#line 15060 "parse.c"
     break;
 
   case 581: /* p_variable: "local variable or method"  */
-#line 5515 "parse.y"
+#line 5517 "parse.y"
                   {
                     /*%%%*/
                         error_duplicate_pattern_variable(p, (yyvsp[0].id), &(yylsp[0]));
@@ -15066,11 +15068,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: assignable(p, var_field(p, $1)) %*/
                     }
-#line 15070 "parse.c"
+#line 15072 "parse.c"
     break;
 
   case 582: /* p_var_ref: '^' "local variable or method"  */
-#line 5525 "parse.y"
+#line 5527 "parse.y"
                   {
                     /*%%%*/
                         NODE *n = gettable(p, (yyvsp[0].id), &(yyloc));
@@ -15081,66 +15083,66 @@ yyreduce:
                     /*% %*/
                     /*% ripper: var_ref!($2) %*/
                     }
-#line 15085 "parse.c"
+#line 15087 "parse.c"
     break;
 
   case 583: /* p_var_ref: '^' nonlocal_var  */
-#line 5536 "parse.y"
+#line 5538 "parse.y"
                   {
                     /*%%%*/
                         if (!((yyval.node) = gettable(p, (yyvsp[0].id), &(yyloc)))) (yyval.node) = NEW_BEGIN(0, &(yyloc));
                     /*% %*/
                     /*% ripper: var_ref!($2) %*/
                     }
-#line 15096 "parse.c"
+#line 15098 "parse.c"
     break;
 
   case 584: /* p_expr_ref: '^' "(" expr_value rparen  */
-#line 5545 "parse.y"
+#line 5547 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_BLOCK((yyvsp[-1].node), &(yyloc));
                     /*% %*/
                     /*% ripper: begin!($3) %*/
                     }
-#line 15107 "parse.c"
+#line 15109 "parse.c"
     break;
 
   case 585: /* p_const: ":: at EXPR_BEG" cname  */
-#line 5554 "parse.y"
+#line 5556 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_COLON3((yyvsp[0].id), &(yyloc));
                     /*% %*/
                     /*% ripper: top_const_ref!($2) %*/
                     }
-#line 15118 "parse.c"
+#line 15120 "parse.c"
     break;
 
   case 586: /* p_const: p_const "::" cname  */
-#line 5561 "parse.y"
+#line 5563 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_COLON2((yyvsp[-2].node), (yyvsp[0].id), &(yyloc));
                     /*% %*/
                     /*% ripper: const_path_ref!($1, $3) %*/
                     }
-#line 15129 "parse.c"
+#line 15131 "parse.c"
     break;
 
   case 587: /* p_const: "constant"  */
-#line 5568 "parse.y"
+#line 5570 "parse.y"
                  {
                     /*%%%*/
                         (yyval.node) = gettable(p, (yyvsp[0].id), &(yyloc));
                     /*% %*/
                     /*% ripper: var_ref!($1) %*/
                    }
-#line 15140 "parse.c"
+#line 15142 "parse.c"
     break;
 
   case 588: /* opt_rescue: k_rescue exc_list exc_var then compstmt opt_rescue  */
-#line 5579 "parse.y"
+#line 5581 "parse.y"
                   {
                     /*%%%*/
                         NODE *body = (yyvsp[-1].node);
@@ -15162,41 +15164,41 @@ yyreduce:
                     /*% %*/
                     /*% ripper: rescue!($2, $3, $5, $6) %*/
                     }
-#line 15166 "parse.c"
+#line 15168 "parse.c"
     break;
 
   case 590: /* exc_list: arg_value  */
-#line 5604 "parse.y"
+#line 5606 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = NEW_LIST((yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: rb_ary_new3(1, get_value($1)) %*/
                     }
-#line 15177 "parse.c"
+#line 15179 "parse.c"
     break;
 
   case 591: /* exc_list: mrhs  */
-#line 5611 "parse.y"
+#line 5613 "parse.y"
                   {
                     /*%%%*/
                         if (!((yyval.node) = splat_array((yyvsp[0].node)))) (yyval.node) = (yyvsp[0].node);
                     /*% %*/
                     /*% ripper: $1 %*/
                     }
-#line 15188 "parse.c"
+#line 15190 "parse.c"
     break;
 
   case 593: /* exc_var: "=>" lhs  */
-#line 5621 "parse.y"
+#line 5623 "parse.y"
                   {
                         (yyval.node) = (yyvsp[0].node);
                     }
-#line 15196 "parse.c"
+#line 15198 "parse.c"
     break;
 
   case 595: /* opt_ensure: k_ensure compstmt  */
-#line 5628 "parse.y"
+#line 5630 "parse.y"
                   {
                         p->ctxt.in_rescue = (yyvsp[-1].ctxt).in_rescue;
                     /*%%%*/
@@ -15204,11 +15206,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: ensure!($2) %*/
                     }
-#line 15208 "parse.c"
+#line 15210 "parse.c"
     break;
 
   case 599: /* strings: string  */
-#line 5643 "parse.y"
+#line 5645 "parse.y"
                   {
                     /*%%%*/
                         NODE *node = (yyvsp[0].node);
@@ -15223,22 +15225,22 @@ yyreduce:
                     /*% %*/
                     /*% ripper: $1 %*/
                     }
-#line 15227 "parse.c"
+#line 15229 "parse.c"
     break;
 
   case 602: /* string: string string1  */
-#line 5662 "parse.y"
+#line 5664 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = literal_concat(p, (yyvsp[-1].node), (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: string_concat!($1, $2) %*/
                     }
-#line 15238 "parse.c"
+#line 15240 "parse.c"
     break;
 
   case 603: /* string1: "string literal" string_contents "terminator"  */
-#line 5671 "parse.y"
+#line 5673 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = heredoc_dedent(p, (yyvsp[-1].node));
@@ -15246,179 +15248,179 @@ yyreduce:
                     /*% %*/
                     /*% ripper: string_literal!(heredoc_dedent(p, $2)) %*/
                     }
-#line 15250 "parse.c"
+#line 15252 "parse.c"
     break;
 
   case 604: /* xstring: "backtick literal" xstring_contents "terminator"  */
-#line 5681 "parse.y"
+#line 5683 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = new_xstring(p, heredoc_dedent(p, (yyvsp[-1].node)), &(yyloc));
                     /*% %*/
                     /*% ripper: xstring_literal!(heredoc_dedent(p, $2)) %*/
                     }
-#line 15261 "parse.c"
+#line 15263 "parse.c"
     break;
 
   case 605: /* regexp: "regexp literal" regexp_contents tREGEXP_END  */
-#line 5690 "parse.y"
+#line 5692 "parse.y"
                   {
                         (yyval.node) = new_regexp(p, (yyvsp[-1].node), (yyvsp[0].num), &(yyloc));
                     }
-#line 15269 "parse.c"
+#line 15271 "parse.c"
     break;
 
   case 606: /* words_sep: ' '  */
-#line 5695 "parse.y"
+#line 5697 "parse.y"
               {}
-#line 15275 "parse.c"
+#line 15277 "parse.c"
     break;
 
   case 608: /* words: "word list" words_sep word_list "terminator"  */
-#line 5700 "parse.y"
+#line 5702 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = make_list((yyvsp[-1].node), &(yyloc));
                     /*% %*/
                     /*% ripper: array!($3) %*/
                     }
-#line 15286 "parse.c"
+#line 15288 "parse.c"
     break;
 
   case 609: /* word_list: %empty  */
-#line 5709 "parse.y"
+#line 5711 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = 0;
                     /*% %*/
                     /*% ripper: words_new! %*/
                     }
-#line 15297 "parse.c"
+#line 15299 "parse.c"
     break;
 
   case 610: /* word_list: word_list word words_sep  */
-#line 5716 "parse.y"
+#line 5718 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = list_append(p, (yyvsp[-2].node), evstr2dstr(p, (yyvsp[-1].node)));
                     /*% %*/
                     /*% ripper: words_add!($1, $2) %*/
                     }
-#line 15308 "parse.c"
+#line 15310 "parse.c"
     break;
 
   case 612: /* word: word string_content  */
-#line 5727 "parse.y"
+#line 5729 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = literal_concat(p, (yyvsp[-1].node), (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: word_add!($1, $2) %*/
                     }
-#line 15319 "parse.c"
+#line 15321 "parse.c"
     break;
 
   case 613: /* symbols: "symbol list" words_sep symbol_list "terminator"  */
-#line 5736 "parse.y"
+#line 5738 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = make_list((yyvsp[-1].node), &(yyloc));
                     /*% %*/
                     /*% ripper: array!($3) %*/
                     }
-#line 15330 "parse.c"
+#line 15332 "parse.c"
     break;
 
   case 614: /* symbol_list: %empty  */
-#line 5745 "parse.y"
+#line 5747 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = 0;
                     /*% %*/
                     /*% ripper: symbols_new! %*/
                     }
-#line 15341 "parse.c"
+#line 15343 "parse.c"
     break;
 
   case 615: /* symbol_list: symbol_list word words_sep  */
-#line 5752 "parse.y"
+#line 5754 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = symbol_append(p, (yyvsp[-2].node), evstr2dstr(p, (yyvsp[-1].node)));
                     /*% %*/
                     /*% ripper: symbols_add!($1, $2) %*/
                     }
-#line 15352 "parse.c"
+#line 15354 "parse.c"
     break;
 
   case 616: /* qwords: "verbatim word list" words_sep qword_list "terminator"  */
-#line 5761 "parse.y"
+#line 5763 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = make_list((yyvsp[-1].node), &(yyloc));
                     /*% %*/
                     /*% ripper: array!($3) %*/
                     }
-#line 15363 "parse.c"
+#line 15365 "parse.c"
     break;
 
   case 617: /* qsymbols: "verbatim symbol list" words_sep qsym_list "terminator"  */
-#line 5770 "parse.y"
+#line 5772 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = make_list((yyvsp[-1].node), &(yyloc));
                     /*% %*/
                     /*% ripper: array!($3) %*/
                     }
-#line 15374 "parse.c"
+#line 15376 "parse.c"
     break;
 
   case 618: /* qword_list: %empty  */
-#line 5779 "parse.y"
+#line 5781 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = 0;
                     /*% %*/
                     /*% ripper: qwords_new! %*/
                     }
-#line 15385 "parse.c"
+#line 15387 "parse.c"
     break;
 
   case 619: /* qword_list: qword_list "literal content" words_sep  */
-#line 5786 "parse.y"
+#line 5788 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = list_append(p, (yyvsp[-2].node), (yyvsp[-1].node));
                     /*% %*/
                     /*% ripper: qwords_add!($1, $2) %*/
                     }
-#line 15396 "parse.c"
+#line 15398 "parse.c"
     break;
 
   case 620: /* qsym_list: %empty  */
-#line 5795 "parse.y"
+#line 5797 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = 0;
                     /*% %*/
                     /*% ripper: qsymbols_new! %*/
                     }
-#line 15407 "parse.c"
+#line 15409 "parse.c"
     break;
 
   case 621: /* qsym_list: qsym_list "literal content" words_sep  */
-#line 5802 "parse.y"
+#line 5804 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = symbol_append(p, (yyvsp[-2].node), (yyvsp[-1].node));
                     /*% %*/
                     /*% ripper: qsymbols_add!($1, $2) %*/
                     }
-#line 15418 "parse.c"
+#line 15420 "parse.c"
     break;
 
   case 622: /* string_contents: %empty  */
-#line 5811 "parse.y"
+#line 5813 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = 0;
@@ -15429,11 +15431,11 @@ yyreduce:
                         $$ = ripper_new_yylval(p, 0, $$, 0);
                     %*/
                     }
-#line 15433 "parse.c"
+#line 15435 "parse.c"
     break;
 
   case 623: /* string_contents: string_contents string_content  */
-#line 5822 "parse.y"
+#line 5824 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = literal_concat(p, (yyvsp[-1].node), (yyvsp[0].node), &(yyloc));
@@ -15449,33 +15451,33 @@ yyreduce:
                         }
                     %*/
                     }
-#line 15453 "parse.c"
+#line 15455 "parse.c"
     break;
 
   case 624: /* xstring_contents: %empty  */
-#line 5840 "parse.y"
+#line 5842 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = 0;
                     /*% %*/
                     /*% ripper: xstring_new! %*/
                     }
-#line 15464 "parse.c"
+#line 15466 "parse.c"
     break;
 
   case 625: /* xstring_contents: xstring_contents string_content  */
-#line 5847 "parse.y"
+#line 5849 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = literal_concat(p, (yyvsp[-1].node), (yyvsp[0].node), &(yyloc));
                     /*% %*/
                     /*% ripper: xstring_add!($1, $2) %*/
                     }
-#line 15475 "parse.c"
+#line 15477 "parse.c"
     break;
 
   case 626: /* regexp_contents: %empty  */
-#line 5856 "parse.y"
+#line 5858 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = 0;
@@ -15486,11 +15488,11 @@ yyreduce:
                         $$ = ripper_new_yylval(p, 0, $$, 0);
                     %*/
                     }
-#line 15490 "parse.c"
+#line 15492 "parse.c"
     break;
 
   case 627: /* regexp_contents: regexp_contents string_content  */
-#line 5867 "parse.y"
+#line 5869 "parse.y"
                   {
                     /*%%%*/
                         NODE *head = (yyvsp[-1].node), *tail = (yyvsp[0].node);
@@ -15514,7 +15516,7 @@ yyreduce:
                             (yyval.node) = list_append(p, head, tail);
                         }
                     /*%
-                        VALUE s1 = 1, s2 = 0, n1 = $1, n2 = $2;
+                        VALUE s1 = (VALUE)1, s2 = 0, n1 = $1, n2 = $2;
                         if (ripper_is_node_yylval(p, n1)) {
                             s1 = RNODE_RIPPER(n1)->nd_cval;
                             n1 = RNODE_RIPPER(n1)->nd_rval;
@@ -15529,22 +15531,22 @@ yyreduce:
                         }
                     %*/
                     }
-#line 15533 "parse.c"
+#line 15535 "parse.c"
     break;
 
   case 629: /* @31: %empty  */
-#line 5910 "parse.y"
+#line 5912 "parse.y"
                   {
                         /* need to backup p->lex.strterm so that a string literal `%&foo,#$&,bar&` can be parsed */
                         (yyval.strterm) = p->lex.strterm;
                         p->lex.strterm = 0;
                         SET_LEX_STATE(EXPR_BEG);
                     }
-#line 15544 "parse.c"
+#line 15546 "parse.c"
     break;
 
   case 630: /* string_content: tSTRING_DVAR @31 string_dvar  */
-#line 5917 "parse.y"
+#line 5919 "parse.y"
                   {
                         p->lex.strterm = (yyvsp[-1].strterm);
                     /*%%%*/
@@ -15553,11 +15555,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: string_dvar!($3) %*/
                     }
-#line 15557 "parse.c"
+#line 15559 "parse.c"
     break;
 
   case 631: /* @32: %empty  */
-#line 5926 "parse.y"
+#line 5928 "parse.y"
                   {
                         CMDARG_PUSH(0);
                         COND_PUSH(0);
@@ -15567,29 +15569,29 @@ yyreduce:
                         (yyval.num) = p->lex.state;
                         SET_LEX_STATE(EXPR_BEG);
                     }
-#line 15571 "parse.c"
+#line 15573 "parse.c"
     break;
 
   case 632: /* @33: %empty  */
-#line 5935 "parse.y"
+#line 5937 "parse.y"
                   {
                         (yyval.num) = p->lex.brace_nest;
                         p->lex.brace_nest = 0;
                     }
-#line 15580 "parse.c"
+#line 15582 "parse.c"
     break;
 
   case 633: /* @34: %empty  */
-#line 5939 "parse.y"
+#line 5941 "parse.y"
                   {
                         (yyval.num) = p->heredoc_indent;
                         p->heredoc_indent = 0;
                     }
-#line 15589 "parse.c"
+#line 15591 "parse.c"
     break;
 
   case 634: /* string_content: tSTRING_DBEG @32 @33 @34 compstmt string_dend  */
-#line 5944 "parse.y"
+#line 5946 "parse.y"
                   {
                         COND_POP();
                         CMDARG_POP();
@@ -15604,22 +15606,22 @@ yyreduce:
                     /*% %*/
                     /*% ripper: string_embexpr!($compstmt) %*/
                     }
-#line 15608 "parse.c"
+#line 15610 "parse.c"
     break;
 
   case 637: /* string_dvar: nonlocal_var  */
-#line 5965 "parse.y"
+#line 5967 "parse.y"
                   {
                     /*%%%*/
                         if (!((yyval.node) = gettable(p, (yyvsp[0].id), &(yyloc)))) (yyval.node) = NEW_ERROR(&(yyloc));
                     /*% %*/
                     /*% ripper: var_ref!($1) %*/
                     }
-#line 15619 "parse.c"
+#line 15621 "parse.c"
     break;
 
   case 641: /* ssym: "symbol literal" sym  */
-#line 5979 "parse.y"
+#line 5981 "parse.y"
                   {
                         SET_LEX_STATE(EXPR_END);
                     /*%%%*/
@@ -15627,11 +15629,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: symbol_literal!(symbol!($2)) %*/
                     }
-#line 15631 "parse.c"
+#line 15633 "parse.c"
     break;
 
   case 644: /* dsym: "symbol literal" string_contents "terminator"  */
-#line 5993 "parse.y"
+#line 5995 "parse.y"
                   {
                         SET_LEX_STATE(EXPR_END);
                     /*%%%*/
@@ -15639,11 +15641,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: dyna_symbol!($2) %*/
                     }
-#line 15643 "parse.c"
+#line 15645 "parse.c"
     break;
 
   case 646: /* numeric: tUMINUS_NUM simple_numeric  */
-#line 6004 "parse.y"
+#line 6006 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = (yyvsp[0].node);
@@ -15651,53 +15653,53 @@ yyreduce:
                     /*% %*/
                     /*% ripper: unary!(ID2VAL(idUMinus), $2) %*/
                     }
-#line 15655 "parse.c"
+#line 15657 "parse.c"
     break;
 
   case 657: /* keyword_variable: "`nil'"  */
-#line 6029 "parse.y"
+#line 6031 "parse.y"
                             {(yyval.id) = KWD2EID(nil, (yyvsp[0].id));}
-#line 15661 "parse.c"
+#line 15663 "parse.c"
     break;
 
   case 658: /* keyword_variable: "`self'"  */
-#line 6030 "parse.y"
+#line 6032 "parse.y"
                              {(yyval.id) = KWD2EID(self, (yyvsp[0].id));}
-#line 15667 "parse.c"
+#line 15669 "parse.c"
     break;
 
   case 659: /* keyword_variable: "`true'"  */
-#line 6031 "parse.y"
+#line 6033 "parse.y"
                              {(yyval.id) = KWD2EID(true, (yyvsp[0].id));}
-#line 15673 "parse.c"
+#line 15675 "parse.c"
     break;
 
   case 660: /* keyword_variable: "`false'"  */
-#line 6032 "parse.y"
+#line 6034 "parse.y"
                               {(yyval.id) = KWD2EID(false, (yyvsp[0].id));}
-#line 15679 "parse.c"
+#line 15681 "parse.c"
     break;
 
   case 661: /* keyword_variable: "`__FILE__'"  */
-#line 6033 "parse.y"
+#line 6035 "parse.y"
                                 {(yyval.id) = KWD2EID(_FILE__, (yyvsp[0].id));}
-#line 15685 "parse.c"
+#line 15687 "parse.c"
     break;
 
   case 662: /* keyword_variable: "`__LINE__'"  */
-#line 6034 "parse.y"
+#line 6036 "parse.y"
                                 {(yyval.id) = KWD2EID(_LINE__, (yyvsp[0].id));}
-#line 15691 "parse.c"
+#line 15693 "parse.c"
     break;
 
   case 663: /* keyword_variable: "`__ENCODING__'"  */
-#line 6035 "parse.y"
+#line 6037 "parse.y"
                                     {(yyval.id) = KWD2EID(_ENCODING__, (yyvsp[0].id));}
-#line 15697 "parse.c"
+#line 15699 "parse.c"
     break;
 
   case 664: /* var_ref: user_variable  */
-#line 6039 "parse.y"
+#line 6041 "parse.y"
                   {
                     /*%%%*/
                         if (!((yyval.node) = gettable(p, (yyvsp[0].id), &(yyloc)))) (yyval.node) = NEW_BEGIN(0, &(yyloc));
@@ -15710,82 +15712,82 @@ yyreduce:
                         }
                     %*/
                     }
-#line 15714 "parse.c"
+#line 15716 "parse.c"
     break;
 
   case 665: /* var_ref: keyword_variable  */
-#line 6052 "parse.y"
+#line 6054 "parse.y"
                   {
                     /*%%%*/
                         if (!((yyval.node) = gettable(p, (yyvsp[0].id), &(yyloc)))) (yyval.node) = NEW_ERROR(&(yyloc));
                     /*% %*/
                     /*% ripper: var_ref!($1) %*/
                     }
-#line 15725 "parse.c"
+#line 15727 "parse.c"
     break;
 
   case 666: /* var_lhs: user_variable  */
-#line 6061 "parse.y"
+#line 6063 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = assignable(p, (yyvsp[0].id), 0, &(yyloc));
                     /*% %*/
                     /*% ripper: assignable(p, var_field(p, $1)) %*/
                     }
-#line 15736 "parse.c"
+#line 15738 "parse.c"
     break;
 
   case 667: /* var_lhs: keyword_variable  */
-#line 6068 "parse.y"
+#line 6070 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = assignable(p, (yyvsp[0].id), 0, &(yyloc));
                     /*% %*/
                     /*% ripper: assignable(p, var_field(p, $1)) %*/
                     }
-#line 15747 "parse.c"
+#line 15749 "parse.c"
     break;
 
   case 670: /* $@35: %empty  */
-#line 6081 "parse.y"
+#line 6083 "parse.y"
                   {
                         SET_LEX_STATE(EXPR_BEG);
                         p->command_start = TRUE;
                     }
-#line 15756 "parse.c"
+#line 15758 "parse.c"
     break;
 
   case 671: /* superclass: '<' $@35 expr_value term  */
-#line 6086 "parse.y"
+#line 6088 "parse.y"
                   {
                         (yyval.node) = (yyvsp[-1].node);
                     }
-#line 15764 "parse.c"
+#line 15766 "parse.c"
     break;
 
   case 672: /* superclass: %empty  */
-#line 6090 "parse.y"
+#line 6092 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = 0;
                     /*% %*/
                     /*% ripper: Qnil %*/
                     }
-#line 15775 "parse.c"
+#line 15777 "parse.c"
     break;
 
   case 674: /* f_opt_paren_args: none  */
-#line 6100 "parse.y"
+#line 6102 "parse.y"
                   {
                         p->ctxt.in_argdef = 0;
                         (yyval.node_args) = new_args_tail(p, Qnone, Qnone, Qnone, &(yylsp[-1]));
                         (yyval.node_args) = new_args(p, Qnone, Qnone, Qnone, Qnone, (yyval.node_args), &(yylsp[-1]));
                     }
-#line 15785 "parse.c"
+#line 15787 "parse.c"
     break;
 
   case 675: /* f_paren_args: '(' f_args rparen  */
-#line 6108 "parse.y"
+#line 6110 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_args) = (yyvsp[-1].node_args);
@@ -15795,22 +15797,22 @@ yyreduce:
                         p->command_start = TRUE;
                         p->ctxt.in_argdef = 0;
                     }
-#line 15799 "parse.c"
+#line 15801 "parse.c"
     break;
 
   case 677: /* @36: %empty  */
-#line 6120 "parse.y"
+#line 6122 "parse.y"
                   {
                         (yyval.ctxt) = p->ctxt;
                         p->ctxt.in_kwarg = 1;
                         p->ctxt.in_argdef = 1;
                         SET_LEX_STATE(p->lex.state|EXPR_LABEL); /* force for args */
                     }
-#line 15810 "parse.c"
+#line 15812 "parse.c"
     break;
 
   case 678: /* f_arglist: @36 f_args term  */
-#line 6127 "parse.y"
+#line 6129 "parse.y"
                   {
                         p->ctxt.in_kwarg = (yyvsp[-2].ctxt).in_kwarg;
                         p->ctxt.in_argdef = 0;
@@ -15818,43 +15820,43 @@ yyreduce:
                         SET_LEX_STATE(EXPR_BEG);
                         p->command_start = TRUE;
                     }
-#line 15822 "parse.c"
+#line 15824 "parse.c"
     break;
 
   case 679: /* args_tail: f_kwarg ',' f_kwrest opt_f_block_arg  */
-#line 6137 "parse.y"
+#line 6139 "parse.y"
                   {
                         (yyval.node_args) = new_args_tail(p, (yyvsp[-3].node_kw_arg), (yyvsp[-1].id), (yyvsp[0].id), &(yylsp[-1]));
                     }
-#line 15830 "parse.c"
+#line 15832 "parse.c"
     break;
 
   case 680: /* args_tail: f_kwarg opt_f_block_arg  */
-#line 6141 "parse.y"
+#line 6143 "parse.y"
                   {
                         (yyval.node_args) = new_args_tail(p, (yyvsp[-1].node_kw_arg), Qnone, (yyvsp[0].id), &(yylsp[-1]));
                     }
-#line 15838 "parse.c"
+#line 15840 "parse.c"
     break;
 
   case 681: /* args_tail: f_any_kwrest opt_f_block_arg  */
-#line 6145 "parse.y"
+#line 6147 "parse.y"
                   {
                         (yyval.node_args) = new_args_tail(p, Qnone, (yyvsp[-1].id), (yyvsp[0].id), &(yylsp[-1]));
                     }
-#line 15846 "parse.c"
+#line 15848 "parse.c"
     break;
 
   case 682: /* args_tail: f_block_arg  */
-#line 6149 "parse.y"
+#line 6151 "parse.y"
                   {
                         (yyval.node_args) = new_args_tail(p, Qnone, Qnone, (yyvsp[0].id), &(yylsp[0]));
                     }
-#line 15854 "parse.c"
+#line 15856 "parse.c"
     break;
 
   case 683: /* args_tail: args_forward  */
-#line 6153 "parse.y"
+#line 6155 "parse.y"
                   {
                         add_forwarding_args(p);
                         (yyval.node_args) = new_args_tail(p, Qnone, (yyvsp[0].id), arg_FWD_BLOCK, &(yylsp[0]));
@@ -15862,148 +15864,148 @@ yyreduce:
                         (yyval.node_args)->nd_ainfo.forwarding = 1;
                     /*% %*/
                     }
-#line 15866 "parse.c"
+#line 15868 "parse.c"
     break;
 
   case 684: /* opt_args_tail: ',' args_tail  */
-#line 6163 "parse.y"
+#line 6165 "parse.y"
                   {
                         (yyval.node_args) = (yyvsp[0].node_args);
                     }
-#line 15874 "parse.c"
+#line 15876 "parse.c"
     break;
 
   case 685: /* opt_args_tail: %empty  */
-#line 6167 "parse.y"
+#line 6169 "parse.y"
                   {
                         (yyval.node_args) = new_args_tail(p, Qnone, Qnone, Qnone, &(yylsp[0]));
                     }
-#line 15882 "parse.c"
+#line 15884 "parse.c"
     break;
 
   case 686: /* f_args: f_arg ',' f_optarg ',' f_rest_arg opt_args_tail  */
-#line 6173 "parse.y"
+#line 6175 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, (yyvsp[-5].node_args_aux), (yyvsp[-3].node_opt_arg), (yyvsp[-1].id), Qnone, (yyvsp[0].node_args), &(yyloc));
                     }
-#line 15890 "parse.c"
+#line 15892 "parse.c"
     break;
 
   case 687: /* f_args: f_arg ',' f_optarg ',' f_rest_arg ',' f_arg opt_args_tail  */
-#line 6177 "parse.y"
+#line 6179 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, (yyvsp[-7].node_args_aux), (yyvsp[-5].node_opt_arg), (yyvsp[-3].id), (yyvsp[-1].node_args_aux), (yyvsp[0].node_args), &(yyloc));
                     }
-#line 15898 "parse.c"
+#line 15900 "parse.c"
     break;
 
   case 688: /* f_args: f_arg ',' f_optarg opt_args_tail  */
-#line 6181 "parse.y"
+#line 6183 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, (yyvsp[-3].node_args_aux), (yyvsp[-1].node_opt_arg), Qnone, Qnone, (yyvsp[0].node_args), &(yyloc));
                     }
-#line 15906 "parse.c"
+#line 15908 "parse.c"
     break;
 
   case 689: /* f_args: f_arg ',' f_optarg ',' f_arg opt_args_tail  */
-#line 6185 "parse.y"
+#line 6187 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, (yyvsp[-5].node_args_aux), (yyvsp[-3].node_opt_arg), Qnone, (yyvsp[-1].node_args_aux), (yyvsp[0].node_args), &(yyloc));
                     }
-#line 15914 "parse.c"
+#line 15916 "parse.c"
     break;
 
   case 690: /* f_args: f_arg ',' f_rest_arg opt_args_tail  */
-#line 6189 "parse.y"
+#line 6191 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, (yyvsp[-3].node_args_aux), Qnone, (yyvsp[-1].id), Qnone, (yyvsp[0].node_args), &(yyloc));
                     }
-#line 15922 "parse.c"
+#line 15924 "parse.c"
     break;
 
   case 691: /* f_args: f_arg ',' f_rest_arg ',' f_arg opt_args_tail  */
-#line 6193 "parse.y"
+#line 6195 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, (yyvsp[-5].node_args_aux), Qnone, (yyvsp[-3].id), (yyvsp[-1].node_args_aux), (yyvsp[0].node_args), &(yyloc));
                     }
-#line 15930 "parse.c"
+#line 15932 "parse.c"
     break;
 
   case 692: /* f_args: f_arg opt_args_tail  */
-#line 6197 "parse.y"
+#line 6199 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, (yyvsp[-1].node_args_aux), Qnone, Qnone, Qnone, (yyvsp[0].node_args), &(yyloc));
                     }
-#line 15938 "parse.c"
+#line 15940 "parse.c"
     break;
 
   case 693: /* f_args: f_optarg ',' f_rest_arg opt_args_tail  */
-#line 6201 "parse.y"
+#line 6203 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, Qnone, (yyvsp[-3].node_opt_arg), (yyvsp[-1].id), Qnone, (yyvsp[0].node_args), &(yyloc));
                     }
-#line 15946 "parse.c"
+#line 15948 "parse.c"
     break;
 
   case 694: /* f_args: f_optarg ',' f_rest_arg ',' f_arg opt_args_tail  */
-#line 6205 "parse.y"
+#line 6207 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, Qnone, (yyvsp[-5].node_opt_arg), (yyvsp[-3].id), (yyvsp[-1].node_args_aux), (yyvsp[0].node_args), &(yyloc));
                     }
-#line 15954 "parse.c"
+#line 15956 "parse.c"
     break;
 
   case 695: /* f_args: f_optarg opt_args_tail  */
-#line 6209 "parse.y"
+#line 6211 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, Qnone, (yyvsp[-1].node_opt_arg), Qnone, Qnone, (yyvsp[0].node_args), &(yyloc));
                     }
-#line 15962 "parse.c"
+#line 15964 "parse.c"
     break;
 
   case 696: /* f_args: f_optarg ',' f_arg opt_args_tail  */
-#line 6213 "parse.y"
+#line 6215 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, Qnone, (yyvsp[-3].node_opt_arg), Qnone, (yyvsp[-1].node_args_aux), (yyvsp[0].node_args), &(yyloc));
                     }
-#line 15970 "parse.c"
+#line 15972 "parse.c"
     break;
 
   case 697: /* f_args: f_rest_arg opt_args_tail  */
-#line 6217 "parse.y"
+#line 6219 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, Qnone, Qnone, (yyvsp[-1].id), Qnone, (yyvsp[0].node_args), &(yyloc));
                     }
-#line 15978 "parse.c"
+#line 15980 "parse.c"
     break;
 
   case 698: /* f_args: f_rest_arg ',' f_arg opt_args_tail  */
-#line 6221 "parse.y"
+#line 6223 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, Qnone, Qnone, (yyvsp[-3].id), (yyvsp[-1].node_args_aux), (yyvsp[0].node_args), &(yyloc));
                     }
-#line 15986 "parse.c"
+#line 15988 "parse.c"
     break;
 
   case 699: /* f_args: args_tail  */
-#line 6225 "parse.y"
+#line 6227 "parse.y"
                   {
                         (yyval.node_args) = new_args(p, Qnone, Qnone, Qnone, Qnone, (yyvsp[0].node_args), &(yyloc));
                     }
-#line 15994 "parse.c"
+#line 15996 "parse.c"
     break;
 
   case 700: /* f_args: %empty  */
-#line 6229 "parse.y"
+#line 6231 "parse.y"
                   {
                         (yyval.node_args) = new_args_tail(p, Qnone, Qnone, Qnone, &(yylsp[0]));
                         (yyval.node_args) = new_args(p, Qnone, Qnone, Qnone, Qnone, (yyval.node_args), &(yylsp[0]));
                     }
-#line 16003 "parse.c"
+#line 16005 "parse.c"
     break;
 
   case 701: /* args_forward: "(..."  */
-#line 6236 "parse.y"
+#line 6238 "parse.y"
                   {
                     /*%%%*/
 #ifdef FORWARD_ARGS_WITH_RUBY2_KEYWORDS
@@ -16014,11 +16016,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: args_forward! %*/
                     }
-#line 16018 "parse.c"
+#line 16020 "parse.c"
     break;
 
   case 702: /* f_bad_arg: "constant"  */
-#line 6249 "parse.y"
+#line 6251 "parse.y"
                   {
                         static const char mesg[] = "formal argument cannot be a constant";
                     /*%%%*/
@@ -16027,11 +16029,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper[error]: param_error!(ERR_MESG(), $1) %*/
                     }
-#line 16031 "parse.c"
+#line 16033 "parse.c"
     break;
 
   case 703: /* f_bad_arg: "instance variable"  */
-#line 6258 "parse.y"
+#line 6260 "parse.y"
                   {
                         static const char mesg[] = "formal argument cannot be an instance variable";
                     /*%%%*/
@@ -16040,11 +16042,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper[error]: param_error!(ERR_MESG(), $1) %*/
                     }
-#line 16044 "parse.c"
+#line 16046 "parse.c"
     break;
 
   case 704: /* f_bad_arg: "global variable"  */
-#line 6267 "parse.y"
+#line 6269 "parse.y"
                   {
                         static const char mesg[] = "formal argument cannot be a global variable";
                     /*%%%*/
@@ -16053,11 +16055,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper[error]: param_error!(ERR_MESG(), $1) %*/
                     }
-#line 16057 "parse.c"
+#line 16059 "parse.c"
     break;
 
   case 705: /* f_bad_arg: "class variable"  */
-#line 6276 "parse.y"
+#line 6278 "parse.y"
                   {
                         static const char mesg[] = "formal argument cannot be a class variable";
                     /*%%%*/
@@ -16066,32 +16068,32 @@ yyreduce:
                     /*% %*/
                     /*% ripper[error]: param_error!(ERR_MESG(), $1) %*/
                     }
-#line 16070 "parse.c"
+#line 16072 "parse.c"
     break;
 
   case 707: /* f_norm_arg: "local variable or method"  */
-#line 6288 "parse.y"
+#line 6290 "parse.y"
                   {
                         formal_argument(p, (yyvsp[0].id));
                         p->max_numparam = ORDINAL_PARAM;
                         (yyval.id) = (yyvsp[0].id);
                     }
-#line 16080 "parse.c"
+#line 16082 "parse.c"
     break;
 
   case 708: /* f_arg_asgn: f_norm_arg  */
-#line 6296 "parse.y"
+#line 6298 "parse.y"
                   {
                         ID id = get_id((yyvsp[0].id));
                         arg_var(p, id);
                         p->cur_arg = id;
                         (yyval.id) = (yyvsp[0].id);
                     }
-#line 16091 "parse.c"
+#line 16093 "parse.c"
     break;
 
   case 709: /* f_arg_item: f_arg_asgn  */
-#line 6305 "parse.y"
+#line 6307 "parse.y"
                   {
                         p->cur_arg = 0;
                     /*%%%*/
@@ -16099,11 +16101,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: get_value($1) %*/
                     }
-#line 16103 "parse.c"
+#line 16105 "parse.c"
     break;
 
   case 710: /* f_arg_item: "(" f_margs rparen  */
-#line 6313 "parse.y"
+#line 6315 "parse.y"
                   {
                     /*%%%*/
                         ID tid = internal_id(p);
@@ -16122,11 +16124,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: mlhs_paren!($2) %*/
                     }
-#line 16126 "parse.c"
+#line 16128 "parse.c"
     break;
 
   case 712: /* f_arg: f_arg ',' f_arg_item  */
-#line 6336 "parse.y"
+#line 6338 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_args_aux) = (yyvsp[-2].node_args_aux);
@@ -16136,11 +16138,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: rb_ary_push($1, get_value($3)) %*/
                     }
-#line 16140 "parse.c"
+#line 16142 "parse.c"
     break;
 
   case 713: /* f_label: "label"  */
-#line 6349 "parse.y"
+#line 6351 "parse.y"
                   {
                         arg_var(p, formal_argument(p, (yyvsp[0].id)));
                         p->cur_arg = get_id((yyvsp[0].id));
@@ -16148,11 +16150,11 @@ yyreduce:
                         p->ctxt.in_argdef = 0;
                         (yyval.id) = (yyvsp[0].id);
                     }
-#line 16152 "parse.c"
+#line 16154 "parse.c"
     break;
 
   case 714: /* f_kw: f_label arg_value  */
-#line 6359 "parse.y"
+#line 6361 "parse.y"
                   {
                         p->cur_arg = 0;
                         p->ctxt.in_argdef = 1;
@@ -16161,11 +16163,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: rb_assoc_new(get_value(assignable(p, $1)), get_value($2)) %*/
                     }
-#line 16165 "parse.c"
+#line 16167 "parse.c"
     break;
 
   case 715: /* f_kw: f_label  */
-#line 6368 "parse.y"
+#line 6370 "parse.y"
                   {
                         p->cur_arg = 0;
                         p->ctxt.in_argdef = 1;
@@ -16174,11 +16176,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: rb_assoc_new(get_value(assignable(p, $1)), 0) %*/
                     }
-#line 16178 "parse.c"
+#line 16180 "parse.c"
     break;
 
   case 716: /* f_block_kw: f_label primary_value  */
-#line 6379 "parse.y"
+#line 6381 "parse.y"
                   {
                         p->ctxt.in_argdef = 1;
                     /*%%%*/
@@ -16186,11 +16188,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: rb_assoc_new(get_value(assignable(p, $1)), get_value($2)) %*/
                     }
-#line 16190 "parse.c"
+#line 16192 "parse.c"
     break;
 
   case 717: /* f_block_kw: f_label  */
-#line 6387 "parse.y"
+#line 6389 "parse.y"
                   {
                         p->ctxt.in_argdef = 1;
                     /*%%%*/
@@ -16198,65 +16200,65 @@ yyreduce:
                     /*% %*/
                     /*% ripper: rb_assoc_new(get_value(assignable(p, $1)), 0) %*/
                     }
-#line 16202 "parse.c"
+#line 16204 "parse.c"
     break;
 
   case 718: /* f_block_kwarg: f_block_kw  */
-#line 6397 "parse.y"
+#line 6399 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_kw_arg) = (yyvsp[0].node_kw_arg);
                     /*% %*/
                     /*% ripper: rb_ary_new3(1, get_value($1)) %*/
                     }
-#line 16213 "parse.c"
+#line 16215 "parse.c"
     break;
 
   case 719: /* f_block_kwarg: f_block_kwarg ',' f_block_kw  */
-#line 6404 "parse.y"
+#line 6406 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_kw_arg) = kwd_append((yyvsp[-2].node_kw_arg), (yyvsp[0].node_kw_arg));
                     /*% %*/
                     /*% ripper: rb_ary_push($1, get_value($3)) %*/
                     }
-#line 16224 "parse.c"
+#line 16226 "parse.c"
     break;
 
   case 720: /* f_kwarg: f_kw  */
-#line 6414 "parse.y"
+#line 6416 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_kw_arg) = (yyvsp[0].node_kw_arg);
                     /*% %*/
                     /*% ripper: rb_ary_new3(1, get_value($1)) %*/
                     }
-#line 16235 "parse.c"
+#line 16237 "parse.c"
     break;
 
   case 721: /* f_kwarg: f_kwarg ',' f_kw  */
-#line 6421 "parse.y"
+#line 6423 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_kw_arg) = kwd_append((yyvsp[-2].node_kw_arg), (yyvsp[0].node_kw_arg));
                     /*% %*/
                     /*% ripper: rb_ary_push($1, get_value($3)) %*/
                     }
-#line 16246 "parse.c"
+#line 16248 "parse.c"
     break;
 
   case 724: /* f_no_kwarg: p_kwnorest  */
-#line 6434 "parse.y"
+#line 6436 "parse.y"
                   {
                     /*%%%*/
                     /*% %*/
                     /*% ripper: nokw_param!(Qnil) %*/
                     }
-#line 16256 "parse.c"
+#line 16258 "parse.c"
     break;
 
   case 725: /* f_kwrest: kwrest_mark "local variable or method"  */
-#line 6442 "parse.y"
+#line 6444 "parse.y"
                   {
                         arg_var(p, shadowing_lvar(p, get_id((yyvsp[0].id))));
                     /*%%%*/
@@ -16264,11 +16266,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: kwrest_param!($2) %*/
                     }
-#line 16268 "parse.c"
+#line 16270 "parse.c"
     break;
 
   case 726: /* f_kwrest: kwrest_mark  */
-#line 6450 "parse.y"
+#line 6452 "parse.y"
                   {
                         arg_var(p, idFWD_KWREST);
                     /*%%%*/
@@ -16276,11 +16278,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: kwrest_param!(Qnil) %*/
                     }
-#line 16280 "parse.c"
+#line 16282 "parse.c"
     break;
 
   case 727: /* f_opt: f_arg_asgn f_eq arg_value  */
-#line 6460 "parse.y"
+#line 6462 "parse.y"
                   {
                         p->cur_arg = 0;
                         p->ctxt.in_argdef = 1;
@@ -16289,11 +16291,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: rb_assoc_new(get_value(assignable(p, $1)), get_value($3)) %*/
                     }
-#line 16293 "parse.c"
+#line 16295 "parse.c"
     break;
 
   case 728: /* f_block_opt: f_arg_asgn f_eq primary_value  */
-#line 6471 "parse.y"
+#line 6473 "parse.y"
                   {
                         p->cur_arg = 0;
                         p->ctxt.in_argdef = 1;
@@ -16302,55 +16304,55 @@ yyreduce:
                     /*% %*/
                     /*% ripper: rb_assoc_new(get_value(assignable(p, $1)), get_value($3)) %*/
                     }
-#line 16306 "parse.c"
+#line 16308 "parse.c"
     break;
 
   case 729: /* f_block_optarg: f_block_opt  */
-#line 6482 "parse.y"
+#line 6484 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_opt_arg) = (yyvsp[0].node_opt_arg);
                     /*% %*/
                     /*% ripper: rb_ary_new3(1, get_value($1)) %*/
                     }
-#line 16317 "parse.c"
+#line 16319 "parse.c"
     break;
 
   case 730: /* f_block_optarg: f_block_optarg ',' f_block_opt  */
-#line 6489 "parse.y"
+#line 6491 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_opt_arg) = opt_arg_append((yyvsp[-2].node_opt_arg), (yyvsp[0].node_opt_arg));
                     /*% %*/
                     /*% ripper: rb_ary_push($1, get_value($3)) %*/
                     }
-#line 16328 "parse.c"
+#line 16330 "parse.c"
     break;
 
   case 731: /* f_optarg: f_opt  */
-#line 6498 "parse.y"
+#line 6500 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_opt_arg) = (yyvsp[0].node_opt_arg);
                     /*% %*/
                     /*% ripper: rb_ary_new3(1, get_value($1)) %*/
                     }
-#line 16339 "parse.c"
+#line 16341 "parse.c"
     break;
 
   case 732: /* f_optarg: f_optarg ',' f_opt  */
-#line 6505 "parse.y"
+#line 6507 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node_opt_arg) = opt_arg_append((yyvsp[-2].node_opt_arg), (yyvsp[0].node_opt_arg));
                     /*% %*/
                     /*% ripper: rb_ary_push($1, get_value($3)) %*/
                     }
-#line 16350 "parse.c"
+#line 16352 "parse.c"
     break;
 
   case 735: /* f_rest_arg: restarg_mark "local variable or method"  */
-#line 6518 "parse.y"
+#line 6520 "parse.y"
                   {
                         arg_var(p, shadowing_lvar(p, get_id((yyvsp[0].id))));
                     /*%%%*/
@@ -16358,11 +16360,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: rest_param!($2) %*/
                     }
-#line 16362 "parse.c"
+#line 16364 "parse.c"
     break;
 
   case 736: /* f_rest_arg: restarg_mark  */
-#line 6526 "parse.y"
+#line 6528 "parse.y"
                   {
                         arg_var(p, idFWD_REST);
                     /*%%%*/
@@ -16370,11 +16372,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: rest_param!(Qnil) %*/
                     }
-#line 16374 "parse.c"
+#line 16376 "parse.c"
     break;
 
   case 739: /* f_block_arg: blkarg_mark "local variable or method"  */
-#line 6540 "parse.y"
+#line 6542 "parse.y"
                   {
                         arg_var(p, shadowing_lvar(p, get_id((yyvsp[0].id))));
                     /*%%%*/
@@ -16382,11 +16384,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: blockarg!($2) %*/
                     }
-#line 16386 "parse.c"
+#line 16388 "parse.c"
     break;
 
   case 740: /* f_block_arg: blkarg_mark  */
-#line 6548 "parse.y"
+#line 6550 "parse.y"
                   {
                         arg_var(p, idFWD_BLOCK);
                     /*%%%*/
@@ -16394,42 +16396,42 @@ yyreduce:
                     /*% %*/
                     /*% ripper: blockarg!(Qnil) %*/
                     }
-#line 16398 "parse.c"
+#line 16400 "parse.c"
     break;
 
   case 741: /* opt_f_block_arg: ',' f_block_arg  */
-#line 6558 "parse.y"
+#line 6560 "parse.y"
                   {
                         (yyval.id) = (yyvsp[0].id);
                     }
-#line 16406 "parse.c"
+#line 16408 "parse.c"
     break;
 
   case 742: /* opt_f_block_arg: none  */
-#line 6562 "parse.y"
+#line 6564 "parse.y"
                   {
                         (yyval.id) = Qnull;
                     }
-#line 16414 "parse.c"
+#line 16416 "parse.c"
     break;
 
   case 743: /* singleton: var_ref  */
-#line 6568 "parse.y"
+#line 6570 "parse.y"
                   {
                         value_expr((yyvsp[0].node));
                         (yyval.node) = (yyvsp[0].node);
                     }
-#line 16423 "parse.c"
+#line 16425 "parse.c"
     break;
 
   case 744: /* $@37: %empty  */
-#line 6572 "parse.y"
+#line 6574 "parse.y"
                     {SET_LEX_STATE(EXPR_BEG);}
-#line 16429 "parse.c"
+#line 16431 "parse.c"
     break;
 
   case 745: /* singleton: '(' $@37 expr rparen  */
-#line 6573 "parse.y"
+#line 6575 "parse.y"
                   {
                     /*%%%*/
                         NODE *expr = last_expr_node((yyvsp[-1].node));
@@ -16453,22 +16455,22 @@ yyreduce:
                     /*% %*/
                     /*% ripper: paren!($3) %*/
                     }
-#line 16457 "parse.c"
+#line 16459 "parse.c"
     break;
 
   case 747: /* assoc_list: assocs trailer  */
-#line 6600 "parse.y"
+#line 6602 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = (yyvsp[-1].node);
                     /*% %*/
                     /*% ripper: assoclist_from_args!($1) %*/
                     }
-#line 16468 "parse.c"
+#line 16470 "parse.c"
     break;
 
   case 749: /* assocs: assocs ',' assoc  */
-#line 6611 "parse.y"
+#line 6613 "parse.y"
                   {
                     /*%%%*/
                         NODE *assocs = (yyvsp[-2].node);
@@ -16489,11 +16491,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: rb_ary_push($1, get_value($3)) %*/
                     }
-#line 16493 "parse.c"
+#line 16495 "parse.c"
     break;
 
   case 750: /* assoc: arg_value "=>" arg_value  */
-#line 6634 "parse.y"
+#line 6636 "parse.y"
                   {
                     /*%%%*/
                         if (nd_type_p((yyvsp[-2].node), NODE_STR)) {
@@ -16504,22 +16506,22 @@ yyreduce:
                     /*% %*/
                     /*% ripper: assoc_new!($1, $3) %*/
                     }
-#line 16508 "parse.c"
+#line 16510 "parse.c"
     break;
 
   case 751: /* assoc: "label" arg_value  */
-#line 6645 "parse.y"
+#line 6647 "parse.y"
                   {
                     /*%%%*/
                         (yyval.node) = list_append(p, NEW_LIST(NEW_LIT(ID2SYM((yyvsp[-1].id)), &(yylsp[-1])), &(yyloc)), (yyvsp[0].node));
                     /*% %*/
                     /*% ripper: assoc_new!($1, $2) %*/
                     }
-#line 16519 "parse.c"
+#line 16521 "parse.c"
     break;
 
   case 752: /* assoc: "label"  */
-#line 6652 "parse.y"
+#line 6654 "parse.y"
                   {
                     /*%%%*/
                         NODE *val = gettable(p, (yyvsp[0].id), &(yyloc));
@@ -16528,11 +16530,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: assoc_new!($1, Qnil) %*/
                     }
-#line 16532 "parse.c"
+#line 16534 "parse.c"
     break;
 
   case 753: /* assoc: "string literal" string_contents tLABEL_END arg_value  */
-#line 6661 "parse.y"
+#line 6663 "parse.y"
                   {
                     /*%%%*/
                         YYLTYPE loc = code_loc_gen(&(yylsp[-3]), &(yylsp[-1]));
@@ -16540,11 +16542,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: assoc_new!(dyna_symbol!($2), $4) %*/
                     }
-#line 16544 "parse.c"
+#line 16546 "parse.c"
     break;
 
   case 754: /* assoc: "**arg" arg_value  */
-#line 6669 "parse.y"
+#line 6671 "parse.y"
                   {
                     /*%%%*/
                         if (nd_type_p((yyvsp[0].node), NODE_HASH) &&
@@ -16561,11 +16563,11 @@ yyreduce:
                     /*% %*/
                     /*% ripper: assoc_splat!($2) %*/
                     }
-#line 16565 "parse.c"
+#line 16567 "parse.c"
     break;
 
   case 755: /* assoc: "**arg"  */
-#line 6686 "parse.y"
+#line 6688 "parse.y"
                   {
                         forwarding_arg_check(p, idFWD_KWREST, idFWD_ALL, "keyword rest");
                     /*%%%*/
@@ -16574,40 +16576,40 @@ yyreduce:
                     /*% %*/
                     /*% ripper: assoc_splat!(Qnil) %*/
                     }
-#line 16578 "parse.c"
+#line 16580 "parse.c"
     break;
 
   case 779: /* term: ';'  */
-#line 6743 "parse.y"
+#line 6745 "parse.y"
           {yyerrok;token_flush(p);}
-#line 16584 "parse.c"
+#line 16586 "parse.c"
     break;
 
   case 780: /* term: '\n'  */
-#line 6745 "parse.y"
+#line 6747 "parse.y"
                   {
                         (yyloc).end_pos = (yyloc).beg_pos;
                         token_flush(p);
                     }
-#line 16593 "parse.c"
+#line 16595 "parse.c"
     break;
 
   case 782: /* terms: terms ';'  */
-#line 6752 "parse.y"
+#line 6754 "parse.y"
                           {yyerrok;}
-#line 16599 "parse.c"
+#line 16601 "parse.c"
     break;
 
   case 783: /* none: %empty  */
-#line 6756 "parse.y"
+#line 6758 "parse.y"
                   {
                         (yyval.node) = Qnull;
                     }
-#line 16607 "parse.c"
+#line 16609 "parse.c"
     break;
 
 
-#line 16611 "parse.c"
+#line 16613 "parse.c"
 
       default: break;
     }
@@ -16836,7 +16838,7 @@ yyreturnlab:
   return yyresult;
 }
 
-#line 6760 "parse.y"
+#line 6762 "parse.y"
 
 # undef p
 # undef yylex
@@ -17493,7 +17495,7 @@ yycompile0(VALUE arg)
     }
     p->ast->body.root = tree;
     if (!p->ast->body.script_lines) p->ast->body.script_lines = INT2FIX(p->line_count);
-    return TRUE;
+    return (VALUE)TRUE;
 }
 
 static rb_ast_t *
@@ -19276,7 +19278,7 @@ formal_argument(struct parser_params *p, VALUE lhs)
 #undef ERR
     }
     shadowing_lvar(p, id);
-    return lhs;
+    return (ID)lhs;
 }
 
 static int
@@ -24736,7 +24738,7 @@ error_duplicate_pattern_variable(struct parser_params *p, ID id, const YYLTYPE *
     if (is_private_local_id(p, id)) {
         return;
     }
-    if (st_is_member(p->pvtbl, id)) {
+    if (st_is_member(p->pvtbl, (st_data_t)id)) {
         yyerror1(loc, "duplicated variable name");
     }
     else {
@@ -24745,12 +24747,12 @@ error_duplicate_pattern_variable(struct parser_params *p, ID id, const YYLTYPE *
 }
 
 static void
-error_duplicate_pattern_key(struct parser_params *p, VALUE key, const YYLTYPE *loc)
+error_duplicate_pattern_key(struct parser_params *p, ID key, const YYLTYPE *loc)
 {
     if (!p->pktbl) {
         p->pktbl = st_init_numtable();
     }
-    else if (st_is_member(p->pktbl, key)) {
+    else if (st_is_member(p->pktbl, (st_data_t)key)) {
         yyerror1(loc, "duplicated key name");
         return;
     }
diff --git a/parse.h b/parse.h
index 057a6df2e88d..cef82d322544 100644
--- a/parse.h
+++ b/parse.h
@@ -190,7 +190,7 @@ extern int yydebug;
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 union YYSTYPE
 {
-#line 1962 "parse.y"
+#line 1964 "parse.y"
 
     VALUE val;
     NODE *node;
diff --git a/parse.y b/parse.y
index f84320b4b445..f3d878e78697 100644
--- a/parse.y
+++ b/parse.y
@@ -350,7 +350,7 @@ RBIMPL_WARNING_POP()
     parser_set_lex_state(p, ls, __LINE__)
 static inline enum lex_state_e parser_set_lex_state(struct parser_params *p, enum lex_state_e ls, int line);
 
-typedef VALUE stack_type;
+typedef uintptr_t stack_type;
 
 static const rb_code_location_t NULL_LOC = { {0, -1}, {0, -1} };
 
@@ -1457,6 +1457,7 @@ void ripper_error(struct parser_params *p);
 
 #define yyparse ripper_yyparse
 
+#define THINGY(tok) ((VALUE)(tok))
 #define ID2VAL(id) STATIC_ID2SYM(id)
 #define TOKEN2VAL(t) ID2VAL(TOKEN2ID(t))
 #define KWD2EID(t, v) ripper_new_yylval(p, keyword_##t, get_value(v), 0)
@@ -1502,7 +1503,7 @@ new_array_pattern(struct parser_params *p, VALUE constant, VALUE pre_arg, VALUE
 }
 
 static VALUE
-new_array_pattern_tail(struct parser_params *p, VALUE pre_args, VALUE has_rest, VALUE rest_arg, VALUE post_args, const YYLTYPE *loc)
+new_array_pattern_tail(struct parser_params *p, VALUE pre_args, int has_rest, VALUE rest_arg, VALUE post_args, const YYLTYPE *loc)
 {
     return ripper_new_yylval2(p, pre_args, rest_arg, post_args);
 }
@@ -1555,6 +1556,7 @@ new_hash_pattern_tail(struct parser_params *p, VALUE kw_args, VALUE kw_rest_arg,
 static VALUE heredoc_dedent(struct parser_params*,VALUE);
 
 #else
+#define THINGY(tok) (tok)
 #define ID2VAL(id) (id)
 #define TOKEN2VAL(t) ID2VAL(t)
 #define KWD2EID(t, v) keyword_##t
@@ -3032,7 +3034,7 @@ mlhs_node	: user_variable
                     }
                 | primary_value call_op tIDENTIFIER
                     {
-                        anddot_multiple_assignment_check(p, &@2, $2);
+                        anddot_multiple_assignment_check(p, &@2, (ID)$2);
                     /*%%%*/
                         $$ = attrset(p, $1, $2, $3, &@$);
                     /*% %*/
@@ -3047,7 +3049,7 @@ mlhs_node	: user_variable
                     }
                 | primary_value call_op tCONSTANT
                     {
-                        anddot_multiple_assignment_check(p, &@2, $2);
+                        anddot_multiple_assignment_check(p, &@2, (ID)$2);
                     /*%%%*/
                         $$ = attrset(p, $1, $2, $3, &@$);
                     /*% %*/
@@ -3535,10 +3537,10 @@ endless_arg	: arg %prec modifier_rescue
                     }
                 ;
 
-relop		: '>'  {$$ = '>';}
-                | '<'  {$$ = '<';}
-                | tGEQ {$$ = idGE;}
-                | tLEQ {$$ = idLE;}
+relop		: '>'  {$$ = THINGY('>');}
+                | '<'  {$$ = THINGY('<');}
+                | tGEQ {$$ = THINGY(idGE);}
+                | tLEQ {$$ = THINGY(idLE);}
                 ;
 
 rel_expr	: arg relop arg   %prec '>'
@@ -3547,7 +3549,7 @@ rel_expr	: arg relop arg   %prec '>'
                     }
                 | rel_expr relop arg   %prec '>'
                     {
-                        rb_warning1("comparison '%s' after comparison", WARN_ID($2));
+                        rb_warning1("comparison '%s' after comparison", WARN_ID((ID)$2));
                         $$ = call_bin_op(p, $1, $2, $3, &@2, &@$);
                     }
                 ;
@@ -5887,7 +5889,7 @@ regexp_contents: /* none */
                             $$ = list_append(p, head, tail);
                         }
                     /*%
-                        VALUE s1 = 1, s2 = 0, n1 = $1, n2 = $2;
+                        VALUE s1 = (VALUE)1, s2 = 0, n1 = $1, n2 = $2;
                         if (ripper_is_node_yylval(p, n1)) {
                             s1 = RNODE_RIPPER(n1)->nd_cval;
                             n1 = RNODE_RIPPER(n1)->nd_rval;
@@ -7413,7 +7415,7 @@ yycompile0(VALUE arg)
     }
     p->ast->body.root = tree;
     if (!p->ast->body.script_lines) p->ast->body.script_lines = INT2FIX(p->line_count);
-    return TRUE;
+    return (VALUE)TRUE;
 }
 
 static rb_ast_t *
@@ -9196,7 +9198,7 @@ formal_argument(struct parser_params *p, VALUE lhs)
 #undef ERR
     }
     shadowing_lvar(p, id);
-    return lhs;
+    return (ID)lhs;
 }
 
 static int
@@ -14656,7 +14658,7 @@ error_duplicate_pattern_variable(struct parser_params *p, ID id, const YYLTYPE *
     if (is_private_local_id(p, id)) {
         return;
     }
-    if (st_is_member(p->pvtbl, id)) {
+    if (st_is_member(p->pvtbl, (st_data_t)id)) {
         yyerror1(loc, "duplicated variable name");
     }
     else {
@@ -14665,12 +14667,12 @@ error_duplicate_pattern_variable(struct parser_params *p, ID id, const YYLTYPE *
 }
 
 static void
-error_duplicate_pattern_key(struct parser_params *p, VALUE key, const YYLTYPE *loc)
+error_duplicate_pattern_key(struct parser_params *p, ID key, const YYLTYPE *loc)
 {
     if (!p->pktbl) {
         p->pktbl = st_init_numtable();
     }
-    else if (st_is_member(p->pktbl, key)) {
+    else if (st_is_member(p->pktbl, (st_data_t)key)) {
         yyerror1(loc, "duplicated key name");
         return;
     }
diff --git a/prism/api_node.c b/prism/api_node.c
index 67319ee9fcbb..787ca0bad9c1 100644
--- a/prism/api_node.c
+++ b/prism/api_node.c
@@ -238,7 +238,7 @@ pm_ast_new(pm_parser_t *parser, pm_node_t *node, rb_encoding *encoding) {
         int state = 0;
 
         VALUE string = rb_enc_str_new((const char *) constant->start, constant->length, encoding);
-        ID value = rb_protect(rb_intern_str, string, &state);
+        ID value = (ID)rb_protect((VALUE(*)(VALUE))rb_intern_str, string, &state);
 
         if (state != 0) {
             value = rb_intern_const("?");
diff --git a/prism/templates/ext/prism/api_node.c.erb b/prism/templates/ext/prism/api_node.c.erb
index 93f67f655159..376330844cf5 100644
--- a/prism/templates/ext/prism/api_node.c.erb
+++ b/prism/templates/ext/prism/api_node.c.erb
@@ -86,7 +86,7 @@ pm_ast_new(pm_parser_t *parser, pm_node_t *node, rb_encoding *encoding) {
         int state = 0;
 
         VALUE string = rb_enc_str_new((const char *) constant->start, constant->length, encoding);
-        ID value = rb_protect(rb_intern_str, string, &state);
+        ID value = (ID)rb_protect((VALUE(*)(VALUE))rb_intern_str, string, &state);
 
         if (state != 0) {
             value = rb_intern_const("?");
diff --git a/prism_compile.c b/prism_compile.c
index 15b5f1cb41de..adfb5ca5092c 100644
--- a/prism_compile.c
+++ b/prism_compile.c
@@ -769,7 +769,7 @@ pm_lookup_local_index_any_scope(rb_iseq_t *iseq, pm_scope_node_t *scope_node, pm
 
     st_data_t local_index;
 
-    if (!st_lookup(scope_node->index_lookup_table, constant_id, &local_index)) {
+    if (!st_lookup(scope_node->index_lookup_table, (st_data_t)constant_id, &local_index)) {
         // Local does not exist at this level, continue recursing up
         return pm_lookup_local_index_any_scope(iseq, scope_node->previous, constant_id);
     }
@@ -782,7 +782,7 @@ pm_lookup_local_index(rb_iseq_t *iseq, pm_scope_node_t *scope_node, pm_constant_
 {
     st_data_t local_index;
 
-    if (!st_lookup(scope_node->index_lookup_table, constant_id, &local_index)) {
+    if (!st_lookup(scope_node->index_lookup_table, (st_data_t)constant_id, &local_index)) {
         rb_bug("This local does not exist");
     }
 
@@ -1881,7 +1881,7 @@ pm_compile_pattern(rb_iseq_t *iseq, pm_scope_node_t *scope_node, const pm_node_t
                     ADD_INSN(ret, &line.node, dup);
                     ADD_INSNL(ret, &line.node, branchif, match_succeeded_label);
 
-                    ADD_INSN1(ret, &line.node, putobject, rb_str_freeze(rb_sprintf("key not found: %+"PRIsVALUE, symbol)));
+                    ADD_INSN1(ret, &line.node, putobject, rb_str_freeze(rb_sprintf("key not found: %"PRIsVALUE, symbol)));
                     ADD_INSN1(ret, &line.node, setn, INT2FIX(base_index + PM_PATTERN_BASE_INDEX_OFFSET_ERROR_STRING + 2));
                     ADD_INSN1(ret, &line.node, putobject, Qtrue);
                     ADD_INSN1(ret, &line.node, setn, INT2FIX(base_index + PM_PATTERN_BASE_INDEX_OFFSET_KEY_ERROR_P + 3));
@@ -2378,7 +2378,7 @@ pm_compile_defined_expr0(rb_iseq_t *iseq, const pm_node_t *node, LINK_ANCHOR *co
       }
       case PM_BACK_REFERENCE_READ_NODE: {
         char *char_ptr = (char *)(node->location.start) + 1;
-        ID backref_val = INT2FIX(rb_intern2(char_ptr, 1)) << 1 | 1;
+        ID backref_val = (uintptr_t)INT2FIX(rb_intern2(char_ptr, 1)) << 1 | 1;
 
         PM_PUTNIL;
         ADD_INSN3(ret, &dummy_line_node, defined, INT2FIX(DEFINED_REF),
@@ -2705,7 +2705,7 @@ pm_insert_local_index(pm_constant_id_t constant_id, int local_index, st_table *i
 {
     ID local = pm_constant_id_lookup(scope_node, constant_id);
     local_table_for_iseq->ids[local_index] = local;
-    st_insert(index_lookup_table, constant_id, local_index);
+    st_insert(index_lookup_table, (st_data_t)constant_id, (st_data_t)local_index);
 }
 
 static int
@@ -2971,7 +2971,7 @@ pm_compile_node(rb_iseq_t *iseq, const pm_node_t *node, LINK_ANCHOR *const ret,
             // Since a back reference is `$<char>`, ruby represents the ID as the
             // an rb_intern on the value after the `$`.
             char *char_ptr = (char *)(node->location.start) + 1;
-            ID backref_val = INT2FIX(rb_intern2(char_ptr, 1)) << 1 | 1;
+            ID backref_val = (uintptr_t)INT2FIX(rb_intern2(char_ptr, 1)) << 1 | 1;
             ADD_INSN2(ret, &dummy_line_node, getspecial, INT2FIX(1), backref_val);
         }
         return;
@@ -6513,7 +6513,7 @@ rb_translate_prism(pm_parser_t *parser, rb_iseq_t *iseq, pm_scope_node_t *scope_
     st_table *index_lookup_table = st_init_numtable();
     pm_constant_id_list_t *locals = &scope_node->locals;
     for (size_t i = 0; i < locals->size; i++) {
-        st_insert(index_lookup_table, locals->ids[i], i);
+        st_insert(index_lookup_table, (st_data_t)locals->ids[i], (st_data_t)i);
     }
     scope_node->constants = constants;
     scope_node->index_lookup_table = index_lookup_table;
diff --git a/proc.c b/proc.c
index fee58cbf9338..987478c00148 100644
--- a/proc.c
+++ b/proc.c
@@ -670,7 +670,7 @@ cfunc_proc_new(VALUE klass, VALUE ifunc)
     vm_block_type_set(&proc->block, block_type_ifunc);
 
     *(VALUE **)&proc->block.as.captured.ep = ep = sproc->env + VM_ENV_DATA_SIZE-1;
-    ep[VM_ENV_DATA_INDEX_FLAGS]   = VM_FRAME_MAGIC_IFUNC | VM_FRAME_FLAG_CFRAME | VM_ENV_FLAG_LOCAL | VM_ENV_FLAG_ESCAPED;
+    ep[VM_ENV_DATA_INDEX_FLAGS]   = (VALUE)(VM_FRAME_MAGIC_IFUNC | VM_FRAME_FLAG_CFRAME | VM_ENV_FLAG_LOCAL | VM_ENV_FLAG_ESCAPED);
     ep[VM_ENV_DATA_INDEX_ME_CREF] = Qfalse;
     ep[VM_ENV_DATA_INDEX_SPECVAL] = VM_BLOCK_HANDLER_NONE;
     ep[VM_ENV_DATA_INDEX_ENV]     = Qundef; /* envval */
@@ -2513,7 +2513,7 @@ call_method_data(rb_execution_context_t *ec, const struct METHOD *data,
                  int argc, const VALUE *argv, VALUE passed_procval, int kw_splat)
 {
     vm_passed_block_handler_set(ec, proc_to_block_handler(passed_procval));
-    return rb_vm_call_kw(ec, data->recv, data->me->called_id, argc, argv,
+    return rb_vm_call_kw(ec, data->recv, (VALUE)data->me->called_id, argc, argv,
                          method_callable_method_entry(data), kw_splat);
 }
 
@@ -2724,7 +2724,7 @@ umethod_bind_call(int argc, VALUE *argv, VALUE method)
     const rb_callable_method_entry_t *cme = rb_callable_method_entry(CLASS_OF(recv), data->me->called_id);
     if (data->me == (const rb_method_entry_t *)cme) {
         vm_passed_block_handler_set(ec, proc_to_block_handler(passed_procval));
-        return rb_vm_call_kw(ec, recv, cme->called_id, argc, argv, cme, RB_PASS_CALLED_KEYWORDS);
+        return rb_vm_call_kw(ec, recv, (VALUE)cme->called_id, argc, argv, cme, RB_PASS_CALLED_KEYWORDS);
     }
     else {
         VALUE methclass, klass, iclass;
diff --git a/process.c b/process.c
index aff350331ba6..7d65ca136a05 100644
--- a/process.c
+++ b/process.c
@@ -4058,6 +4058,10 @@ disable_child_handler_fork_child(struct child_handler_disabler_state *old, char
     int ret;
 
     for (sig = 1; sig < NSIG; sig++) {
+        if (zis_unsafe_signal_for_handlers(sig)) {
+            continue;
+        }
+
         sig_t handler = signal(sig, SIG_DFL);
 
         if (handler == SIG_ERR && errno == EINVAL) {
@@ -4399,11 +4403,11 @@ exit_status_code(VALUE status)
 {
     int istatus;
 
-    switch (status) {
-      case Qtrue:
+    switch ((uintptr_t)status) {
+      case (uintptr_t)Qtrue:
         istatus = EXIT_SUCCESS;
         break;
-      case Qfalse:
+      case (uintptr_t)Qfalse:
         istatus = EXIT_FAILURE;
         break;
       default:
@@ -7661,7 +7665,7 @@ p_uid_switch(VALUE obj)
         proc_seteuid(uid);
         if (rb_block_given_p()) {
             under_uid_switch = 1;
-            return rb_ensure(rb_yield, Qnil, p_uid_sw_ensure, SAVED_USER_ID);
+            return rb_ensure(rb_yield, Qnil, p_uid_sw_ensure, (VALUE)SAVED_USER_ID);
         }
         else {
             return UIDT2NUM(euid);
@@ -7671,7 +7675,7 @@ p_uid_switch(VALUE obj)
         proc_seteuid(SAVED_USER_ID);
         if (rb_block_given_p()) {
             under_uid_switch = 1;
-            return rb_ensure(rb_yield, Qnil, p_uid_sw_ensure, euid);
+            return rb_ensure(rb_yield, Qnil, p_uid_sw_ensure, (VALUE)euid);
         }
         else {
             return UIDT2NUM(uid);
@@ -7775,7 +7779,7 @@ p_gid_switch(VALUE obj)
         proc_setegid(obj, GIDT2NUM(gid));
         if (rb_block_given_p()) {
             under_gid_switch = 1;
-            return rb_ensure(rb_yield, Qnil, p_gid_sw_ensure, SAVED_GROUP_ID);
+            return rb_ensure(rb_yield, Qnil, p_gid_sw_ensure, (VALUE)SAVED_GROUP_ID);
         }
         else {
             return GIDT2NUM(egid);
@@ -7785,7 +7789,7 @@ p_gid_switch(VALUE obj)
         proc_setegid(obj, GIDT2NUM(SAVED_GROUP_ID));
         if (rb_block_given_p()) {
             under_gid_switch = 1;
-            return rb_ensure(rb_yield, Qnil, p_gid_sw_ensure, egid);
+            return rb_ensure(rb_yield, Qnil, p_gid_sw_ensure, (VALUE)egid);
         }
         else {
             return GIDT2NUM(gid);
diff --git a/ractor.c b/ractor.c
index 7d50c81086dd..c23457f15b52 100644
--- a/ractor.c
+++ b/ractor.c
@@ -1783,7 +1783,7 @@ ractor_selector_wait(int argc, VALUE *argv, VALUE selector)
     rb_get_kwargs(options, keywords, 0, numberof(values), values);
     return ractor_selector__wait(selector,
                                  values[0] == Qundef ? Qfalse : RTEST(values[0]),
-                                 values[1] != Qundef, values[1], values[2]);
+                                 (VALUE)(values[1] != Qundef), values[1], values[2]);
 }
 
 static VALUE
@@ -2843,7 +2843,7 @@ obj_traverse_i(VALUE obj, struct obj_traverse_data *data)
       case traverse_stop: return 1; // stop search
     }
 
-    if (UNLIKELY(st_insert(obj_traverse_rec(data), obj, 1))) {
+    if (UNLIKELY(st_insert(obj_traverse_rec(data), obj, (st_data_t)1))) {
         // already traversed
         return 0;
     }
@@ -3484,14 +3484,14 @@ rb_obj_traverse_replace(VALUE obj,
 }
 
 struct RVALUE {
-    VALUE flags;
+    uintptr_t flags;
     VALUE klass;
     VALUE v1;
     VALUE v2;
     VALUE v3;
 };
 
-static const VALUE fl_users = FL_USER1  | FL_USER2  | FL_USER3  |
+static const uintptr_t fl_users = FL_USER1  | FL_USER2  | FL_USER3  |
                               FL_USER4  | FL_USER5  | FL_USER6  | FL_USER7  |
                               FL_USER8  | FL_USER9  | FL_USER10 | FL_USER11 |
                               FL_USER12 | FL_USER13 | FL_USER14 | FL_USER15 |
diff --git a/random.c b/random.c
index 0902114a285c..256e683259e5 100644
--- a/random.c
+++ b/random.c
@@ -721,7 +721,7 @@ fill_random_seed(uint32_t *seed, size_t cnt)
     seed[2] ^= getpid() ^ (ATOMIC_FETCH_ADD(n, 1) << 16);
     seed[3] ^= (uint32_t)(VALUE)&seed;
 #if SIZEOF_VOIDP > SIZEOF_INT
-    seed[2] ^= (uint32_t)((VALUE)&seed >> SIZEOF_INT * CHAR_BIT);
+    seed[2] ^= (uint32_t)((uintptr_t)&seed >> SIZEOF_INT * CHAR_BIT);
 #endif
 }
 
@@ -1424,11 +1424,11 @@ invalid_argument(VALUE arg0)
 static VALUE
 check_random_number(VALUE v, const VALUE *argv)
 {
-    switch (v) {
-      case Qfalse:
+    switch ((uintptr_t)v) {
+      case (uintptr_t)Qfalse:
         (void)NUM2LONG(argv[0]);
         break;
-      case Qnil:
+      case (uintptr_t)Qnil:
         invalid_argument(argv[0]);
     }
     return v;
diff --git a/range.c b/range.c
index f66d23d07be5..03ec49f8deb1 100644
--- a/range.c
+++ b/range.c
@@ -314,7 +314,7 @@ step_i_iter(VALUE arg)
     VALUE *iter = (VALUE *)arg;
 
     if (FIXNUM_P(iter[0])) {
-        iter[0] -= INT2FIX(1) & ~FIXNUM_FLAG;
+        iter[0] -= (uintptr_t)INT2FIX(1) & ~FIXNUM_FLAG;
     }
     else {
         iter[0] = rb_funcall(iter[0], '-', 1, INT2FIX(1));
diff --git a/rational.c b/rational.c
index c5ad7598f7d5..f80145f97f9d 100644
--- a/rational.c
+++ b/rational.c
@@ -206,7 +206,7 @@ f_minus_one_p(VALUE x)
         return x == LONG2FIX(-1);
     }
     else if (RB_BIGNUM_TYPE_P(x)) {
-        return Qfalse;
+        return (int)Qfalse;
     }
     else if (RB_TYPE_P(x, T_RATIONAL)) {
         VALUE num = RRATIONAL(x)->num;
@@ -1292,7 +1292,7 @@ nurat_round_half_up(VALUE self)
 
     num = dat->num;
     den = dat->den;
-    neg = INT_NEGATIVE_P(num);
+    neg = (VALUE)INT_NEGATIVE_P(num);
 
     if (neg)
         num = rb_int_uminus(num);
@@ -1316,7 +1316,7 @@ nurat_round_half_down(VALUE self)
 
     num = dat->num;
     den = dat->den;
-    neg = INT_NEGATIVE_P(num);
+    neg = (VALUE)INT_NEGATIVE_P(num);
 
     if (neg)
         num = rb_int_uminus(num);
@@ -1341,7 +1341,7 @@ nurat_round_half_even(VALUE self)
 
     num = dat->num;
     den = dat->den;
-    neg = INT_NEGATIVE_P(num);
+    neg = (VALUE)INT_NEGATIVE_P(num);
 
     if (neg)
         num = rb_int_uminus(num);
diff --git a/re.c b/re.c
index a1d0ca3400d8..09214e20780d 100644
--- a/re.c
+++ b/re.c
@@ -155,7 +155,7 @@ rb_memsearch_qs(const unsigned char *xs, long m, const unsigned char *ys, long n
 {
     const unsigned char *x = xs, *xe = xs + m;
     const unsigned char *y = ys;
-    VALUE i, qstable[256];
+    uintptr_t i, qstable[256];
 
     /* Preprocessing */
     for (i = 0; i < 256; ++i)
@@ -207,7 +207,7 @@ rb_memsearch_qs_utf8(const unsigned char *xs, long m, const unsigned char *ys, l
 {
     const unsigned char *x = xs, *xe = xs + m;
     const unsigned char *y = ys;
-    VALUE i, qstable[512];
+    uintptr_t i, qstable[512];
 
     /* Preprocessing */
     for (i = 0; i < 512; ++i) {
@@ -970,7 +970,7 @@ static VALUE
 match_alloc(VALUE klass)
 {
     size_t alloc_size = sizeof(struct RMatch) + sizeof(rb_matchext_t);
-    VALUE flags = T_MATCH | (RGENGC_WB_PROTECTED_MATCH ? FL_WB_PROTECTED : 0);
+    uintptr_t flags = T_MATCH | (RGENGC_WB_PROTECTED_MATCH ? FL_WB_PROTECTED : 0);
     NEWOBJ_OF(match, struct RMatch, klass, flags, alloc_size, 0);
 
     match->str = Qfalse;
@@ -2133,12 +2133,12 @@ match_ary_aref(VALUE match, VALUE idx, VALUE result)
     int num_regs = RMATCH_REGS(match)->num_regs;
 
     /* check if idx is Range */
-    switch (rb_range_beg_len(idx, &beg, &len, (long)num_regs, !NIL_P(result))) {
-      case Qfalse:
+    switch ((uintptr_t)rb_range_beg_len(idx, &beg, &len, (long)num_regs, !NIL_P(result))) {
+      case (uintptr_t)Qfalse:
         if (NIL_P(result)) return rb_reg_nth_match(NUM2INT(idx), match);
         rb_ary_push(result, rb_reg_nth_match(NUM2INT(idx), match));
         return result;
-      case Qnil:
+      case (uintptr_t)Qnil:
         return Qnil;
       default:
         return match_ary_subseq(match, beg, len, result);
@@ -2398,7 +2398,7 @@ match_named_captures(int argc, VALUE *argv, VALUE match)
         }
         rb_get_kwargs(opt, keyword_ids, 0, 1, &symbolize_names_val);
         if (!UNDEF_P(symbolize_names_val) && RTEST(symbolize_names_val)) {
-            symbolize_names = 1;
+            symbolize_names = (VALUE)1;
         }
     }
 
diff --git a/regint.h b/regint.h
index 75abfba23579..421ae87a2e91 100644
--- a/regint.h
+++ b/regint.h
@@ -53,6 +53,14 @@
 # endif
 #endif
 
+#ifdef __FILC__
+# if defined UNALIGNED_WORD_ACCESS && UNALIGNED_WORD_ACCESS
+#  error "UNALIGNED_WORD_ACCESS already defined and true"
+# else
+#  define UNALIGNED_WORD_ACCESS 0
+# endif
+#endif
+
 /* __POWERPC__ added to accommodate Darwin case. */
 #ifndef UNALIGNED_WORD_ACCESS
 # if defined(__i386) || defined(__i386__) || defined(_M_IX86) || \
diff --git a/ruby.c b/ruby.c
index 611d887cee44..c23252949b4e 100644
--- a/ruby.c
+++ b/ruby.c
@@ -63,8 +63,8 @@
 #include "ruby/internal/error.h"
 
 #define singlebit_only_p(x) !((x) & ((x)-1))
-STATIC_ASSERT(Qnil_1bit_from_Qfalse, singlebit_only_p(Qnil^Qfalse));
-STATIC_ASSERT(Qundef_1bit_from_Qnil, singlebit_only_p(Qundef^Qnil));
+STATIC_ASSERT(Qnil_1bit_from_Qfalse, singlebit_only_p((uintptr_t)Qnil^(uintptr_t)Qfalse));
+STATIC_ASSERT(Qundef_1bit_from_Qnil, singlebit_only_p((uintptr_t)Qundef^(uintptr_t)Qnil));
 
 #ifndef MAXPATHLEN
 # define MAXPATHLEN 1024
@@ -2528,7 +2528,7 @@ load_file_internal(VALUE argp_v)
 
     CONST_ID(set_encoding, "set_encoding");
     if (script) {
-        VALUE c = 1;		/* something not nil */
+        VALUE c = (VALUE)1;		/* something not nil */
         VALUE line;
         char *p, *str;
         long len;
@@ -2924,12 +2924,12 @@ opt_W_getter(ID id, VALUE *dmy)
 {
     VALUE v = *rb_ruby_verbose_ptr();
 
-    switch (v) {
-      case Qnil:
+    switch ((uintptr_t)v) {
+      case (uintptr_t)Qnil:
         return INT2FIX(0);
-      case Qfalse:
+      case (uintptr_t)Qfalse:
         return INT2FIX(1);
-      case Qtrue:
+      case (uintptr_t)Qtrue:
         return INT2FIX(2);
       default:
         return Qnil;
diff --git a/rubyparser.h b/rubyparser.h
index d1f499a060ba..a044faf7f552 100644
--- a/rubyparser.h
+++ b/rubyparser.h
@@ -164,7 +164,7 @@ typedef struct rb_code_location_struct {
 
 /* Header part of AST Node */
 typedef struct RNode {
-    VALUE flags;
+    uintptr_t flags;
     rb_code_location_t nd_loc;
     int node_id;
 } NODE;
@@ -1067,10 +1067,10 @@ typedef struct RNode_RIPPER_VALUES {
  *          8..14: nd_type,
  *          15..: nd_line
  */
-#define NODE_FL_NEWLINE              (((VALUE)1)<<7)
+#define NODE_FL_NEWLINE              (((uintptr_t)1)<<7)
 
 #define NODE_TYPESHIFT 8
-#define NODE_TYPEMASK  (((VALUE)0x7f)<<NODE_TYPESHIFT)
+#define NODE_TYPEMASK  (((uintptr_t)0x7f)<<NODE_TYPESHIFT)
 
 #define nd_fl_newline(n) (n)->flags & NODE_FL_NEWLINE
 #define nd_set_fl_newline(n) (n)->flags |= NODE_FL_NEWLINE
diff --git a/shape.h b/shape.h
index 5fee17ebd94e..34fb485b5e91 100644
--- a/shape.h
+++ b/shape.h
@@ -26,7 +26,7 @@ typedef uint32_t redblack_id_t;
 #define MAX_IVARS (attr_index_t)(-1)
 
 # define SHAPE_MASK (((uintptr_t)1 << SHAPE_ID_NUM_BITS) - 1)
-# define SHAPE_FLAG_MASK (((VALUE)-1) >> SHAPE_ID_NUM_BITS)
+# define SHAPE_FLAG_MASK (((uintptr_t)-1) >> SHAPE_ID_NUM_BITS)
 
 # define SHAPE_FLAG_SHIFT ((SIZEOF_VALUE * 8) - SHAPE_ID_NUM_BITS)
 
@@ -99,7 +99,7 @@ set_shape_id_in_flags(VALUE obj, shape_id_t shape_id)
     // Ractors are occupying the upper 32 bits of flags, but only in debug mode
     // Object shapes are occupying top bits
     RBASIC(obj)->flags &= SHAPE_FLAG_MASK;
-    RBASIC(obj)->flags |= ((VALUE)(shape_id) << SHAPE_FLAG_SHIFT);
+    RBASIC(obj)->flags |= ((uintptr_t)(shape_id) << SHAPE_FLAG_SHIFT);
 }
 
 
diff --git a/signal.c b/signal.c
index ff116c86d40c..ae8c09dacc3c 100644
--- a/signal.c
+++ b/signal.c
@@ -1263,17 +1263,17 @@ trap(int sig, sighandler_t func, VALUE command)
         if (oldfunc == SIG_ERR) rb_sys_fail_str(rb_signo2signm(sig));
     }
     oldcmd = vm->trap_list.cmd[sig];
-    switch (oldcmd) {
+    switch ((uintptr_t)oldcmd) {
       case 0:
-      case Qtrue:
+      case (uintptr_t)Qtrue:
         if (oldfunc == SIG_IGN) oldcmd = rb_str_new2("IGNORE");
         else if (oldfunc == SIG_DFL) oldcmd = rb_str_new2("SYSTEM_DEFAULT");
         else if (oldfunc == sighandler) oldcmd = rb_str_new2("DEFAULT");
         else oldcmd = Qnil;
         break;
-      case Qnil:
+      case (uintptr_t)Qnil:
         break;
-      case Qundef:
+      case (uintptr_t)Qundef:
         oldcmd = rb_str_new2("EXIT");
         break;
     }
@@ -1522,6 +1522,7 @@ Init_signal(void)
     install_sighandler(SIGUSR2, sighandler);
 #endif
 
+#ifndef __FILC__
     if (!ruby_enable_coredump) {
 #ifdef SIGBUS
         force_install_sighandler(SIGBUS, (sighandler_t)sigbus, &default_sigbus_handler);
@@ -1534,6 +1535,7 @@ Init_signal(void)
         force_install_sighandler(SIGSEGV, (sighandler_t)sigsegv, &default_sigsegv_handler);
 #endif
     }
+#endif
 #ifdef SIGPIPE
     install_sighandler(SIGPIPE, sig_do_nothing);
 #endif
diff --git a/spec/ruby/optional/capi/ext/class_spec.c b/spec/ruby/optional/capi/ext/class_spec.c
index f376534924cf..84ad25038138 100644
--- a/spec/ruby/optional/capi/ext/class_spec.c
+++ b/spec/ruby/optional/capi/ext/class_spec.c
@@ -73,7 +73,7 @@ static VALUE class_spec_rb_class_new_instance_kw(VALUE self, VALUE args, VALUE k
 
 static VALUE class_spec_rb_class_real(VALUE self, VALUE object) {
   if (rb_type_p(object, T_FIXNUM)) {
-    return INT2FIX(rb_class_real(FIX2INT(object)));
+    return (VALUE)INT2FIX((uintptr_t)rb_class_real((VALUE)FIX2INT(object)));
   } else {
     return rb_class_real(CLASS_OF(object));
   }
diff --git a/spec/ruby/optional/capi/ext/language_spec.c b/spec/ruby/optional/capi/ext/language_spec.c
index 749c18895693..67272129d863 100644
--- a/spec/ruby/optional/capi/ext/language_spec.c
+++ b/spec/ruby/optional/capi/ext/language_spec.c
@@ -10,14 +10,14 @@ static VALUE language_spec_switch(VALUE self, VALUE value) {
     value = Qundef;
   }
 
-  switch (value) {
-    case Qtrue:
+  switch ((uintptr_t)value) {
+    case (uintptr_t)Qtrue:
       return ID2SYM(rb_intern("true"));
-    case Qfalse:
+    case (uintptr_t)Qfalse:
       return ID2SYM(rb_intern("false"));
-    case Qnil:
+    case (uintptr_t)Qnil:
       return ID2SYM(rb_intern("nil"));
-    case Qundef:
+    case (uintptr_t)Qundef:
       return ID2SYM(rb_intern("undef"));
     default:
       return ID2SYM(rb_intern("default"));
diff --git a/spec/ruby/optional/capi/ext/object_spec.c b/spec/ruby/optional/capi/ext/object_spec.c
index 7023c29bdb31..f0c14a48a5bf 100644
--- a/spec/ruby/optional/capi/ext/object_spec.c
+++ b/spec/ruby/optional/capi/ext/object_spec.c
@@ -388,7 +388,7 @@ static VALUE object_spec_rb_ivar_foreach(VALUE self, VALUE obj) {
 }
 
 static VALUE speced_allocator(VALUE klass) {
-  VALUE flags = 0;
+  uintptr_t flags = 0;
   VALUE instance;
   if (RTEST(rb_class_inherited_p(klass, rb_cString))) {
     flags = T_STRING;
diff --git a/spec/ruby/optional/capi/ext/rbasic_spec.c b/spec/ruby/optional/capi/ext/rbasic_spec.c
index 26be2fed6d37..98d0d6e6f037 100644
--- a/spec/ruby/optional/capi/ext/rbasic_spec.c
+++ b/spec/ruby/optional/capi/ext/rbasic_spec.c
@@ -14,11 +14,11 @@ extern "C" {
 #endif
 
 #ifndef FL_SHAREABLE
-static const VALUE VISIBLE_BITS = FL_TAINT | FL_FREEZE;
-static const VALUE DATA_VISIBLE_BITS = FL_TAINT | FL_FREEZE | ~(FL_USER0 - 1);
+static const uintptr_t VISIBLE_BITS = FL_TAINT | FL_FREEZE;
+static const uintptr_t DATA_VISIBLE_BITS = FL_TAINT | FL_FREEZE | ~(FL_USER0 - 1);
 #else
-static const VALUE VISIBLE_BITS = FL_FREEZE;
-static const VALUE DATA_VISIBLE_BITS = FL_FREEZE | ~(FL_USER0 - 1);
+static const uintptr_t VISIBLE_BITS = FL_FREEZE;
+static const uintptr_t DATA_VISIBLE_BITS = FL_FREEZE | ~(FL_USER0 - 1);
 #endif
 
 #if SIZEOF_VALUE == SIZEOF_LONG
@@ -42,12 +42,12 @@ VALUE rbasic_spec_freeze_flag(VALUE self) {
   return VALUE2NUM(RUBY_FL_FREEZE);
 }
 
-static VALUE spec_get_flags(VALUE obj, VALUE visible_bits) {
-  VALUE flags = RB_FL_TEST(obj, visible_bits);
+static VALUE spec_get_flags(VALUE obj, uintptr_t visible_bits) {
+  uintptr_t flags = RB_FL_TEST(obj, visible_bits);
   return VALUE2NUM(flags);
 }
 
-static VALUE spec_set_flags(VALUE obj, VALUE flags, VALUE visible_bits) {
+static VALUE spec_set_flags(VALUE obj, uintptr_t flags, uintptr_t visible_bits) {
   flags &= visible_bits;
 
   // Could also be done like:
diff --git a/spec/ruby/optional/capi/ext/st_spec.c b/spec/ruby/optional/capi/ext/st_spec.c
index 0fb5b5dc2d58..e844b51808c5 100644
--- a/spec/ruby/optional/capi/ext/st_spec.c
+++ b/spec/ruby/optional/capi/ext/st_spec.c
@@ -34,7 +34,7 @@ VALUE st_spec_st_init_numtable_with_size(VALUE self) {
 VALUE st_spec_st_insert(VALUE self) {
   st_index_t entries;
   st_table *tbl = st_init_numtable_with_size(128);
-  st_insert(tbl, 1, 1);
+  st_insert(tbl, (st_data_t)1, (st_data_t)1);
   entries = tbl->num_entries;
   st_free_table(tbl);
   return ST2NUM(entries);
@@ -48,8 +48,8 @@ static int sum(st_data_t key, st_data_t value, st_data_t arg) {
 VALUE st_spec_st_foreach(VALUE self) {
   int total = 0;
   st_table *tbl = st_init_numtable_with_size(128);
-  st_insert(tbl, 1, 3);
-  st_insert(tbl, 2, 4);
+  st_insert(tbl, (st_data_t)1, (st_data_t)3);
+  st_insert(tbl, (st_data_t)2, (st_data_t)4);
   st_foreach(tbl, sum, (st_data_t)&total);
   st_free_table(tbl);
   return INT2FIX(total);
@@ -58,14 +58,14 @@ VALUE st_spec_st_foreach(VALUE self) {
 VALUE st_spec_st_lookup(VALUE self) {
   st_data_t result = (st_data_t)0;
   st_table *tbl = st_init_numtable_with_size(128);
-  st_insert(tbl, 7, 42);
-  st_insert(tbl, 2, 4);
+  st_insert(tbl, (st_data_t)7, (st_data_t)42);
+  st_insert(tbl, (st_data_t)2, (st_data_t)4);
   st_lookup(tbl, (st_data_t)7, &result);
   st_free_table(tbl);
 #if SIZEOF_LONG == SIZEOF_VOIDP
-  return ULONG2NUM(result);
+  return ULONG2NUM((unsigned long)result);
 #else
-  return ULL2NUM(result);
+  return ULL2NUM((unsigned long long)result);
 #endif
 }
 
diff --git a/sprintf.c b/sprintf.c
index b13530614fd7..80e2a4043253 100644
--- a/sprintf.c
+++ b/sprintf.c
@@ -31,6 +31,7 @@
 #include "ruby/encoding.h"
 #include "ruby/re.h"
 #include "ruby/util.h"
+#include <stdfil.h>
 
 #define BIT_DIGITS(N)   (((N)*146)/485 + 1)  /* log2(10) =~ 146/485 */
 
@@ -1107,8 +1108,8 @@ ruby__sfvextra(rb_printf_buffer *fp, size_t valsize, void *valp, long *sz, int s
     if (sign == '+') {
 # define LITERAL(str) (*sz = rb_strlen_lit(str), str)
         /* optimize special const cases */
-        switch (value) {
-# define LITERAL_CASE(x) case Q##x: return LITERAL(#x)
+        switch ((uintptr_t)value) {
+# define LITERAL_CASE(x) case (uintptr_t)Q##x: return LITERAL(#x)
           LITERAL_CASE(nil);
           LITERAL_CASE(true);
           LITERAL_CASE(false);
diff --git a/st.c b/st.c
index ab361e1ca8f3..502325ea5784 100644
--- a/st.c
+++ b/st.c
@@ -1842,7 +1842,7 @@ st_hash(const void *ptr, size_t len, st_index_t h)
 #undef SKIP_TAIL
     if (len >= sizeof(st_index_t)) {
 #if !UNALIGNED_WORD_ACCESS
-        int align = (int)((st_data_t)data % sizeof(st_index_t));
+        int align = (int)((st_index_t)data % sizeof(st_index_t));
         if (align) {
             st_index_t d = 0;
             int sl, sr, pack;
@@ -2102,7 +2102,7 @@ st_index_t
 st_numhash(st_data_t n)
 {
     enum {s1 = 11, s2 = 3};
-    return (st_index_t)((n>>s1|(n<<s2)) ^ (n>>s2));
+    return ((st_index_t)n>>s1|((st_index_t)n<<s2)) ^ ((st_index_t)n>>s2);
 }
 
 #ifdef RUBY
diff --git a/string.c b/string.c
index 44734c695ec4..a502d5da8373 100644
--- a/string.c
+++ b/string.c
@@ -345,6 +345,7 @@ fstr_update_callback(st_data_t *key, st_data_t *value, st_data_t data, int exist
 
         if (rb_objspace_garbage_object_p(str)) {
             arg->fstr = Qundef;
+            // FIXME: Sounds like the frozen string table needs to be weak!
             // When RSTRING_FSTR strings are swept, they call `st_delete`.
             // To avoid a race condition if an equivalent string was inserted
             // we must remove the flag immediately.
@@ -1715,11 +1716,11 @@ ec_str_alloc_heap(struct rb_execution_context_struct *ec, VALUE klass)
 static inline VALUE
 str_duplicate_setup(VALUE klass, VALUE str, VALUE dup)
 {
-    const VALUE flag_mask =
+    const uintptr_t flag_mask =
         ENC_CODERANGE_MASK | ENCODING_MASK |
         FL_FREEZE
         ;
-    VALUE flags = FL_TEST_RAW(str, flag_mask);
+    uintptr_t flags = FL_TEST_RAW(str, flag_mask);
     int encidx = 0;
     if (STR_EMBED_P(str)) {
         long len = RSTRING_LEN(str);
@@ -5242,10 +5243,10 @@ rb_str_aref(VALUE str, VALUE indx)
     else {
         /* check if indx is Range */
         long beg, len = str_strlen(str, NULL);
-        switch (rb_range_beg_len(indx, &beg, &len, len, 0)) {
-          case Qfalse:
+        switch ((uintptr_t)rb_range_beg_len(indx, &beg, &len, len, 0)) {
+          case (uintptr_t)Qfalse:
             break;
-          case Qnil:
+          case (uintptr_t)Qnil:
             return Qnil;
           default:
             return rb_str_substr(str, beg, len);
@@ -5624,10 +5625,10 @@ rb_str_slice_bang(int argc, VALUE *argv, VALUE str)
         goto squash;
     }
     else {
-        switch (rb_range_beg_len(indx, &beg, &len, str_strlen(str, NULL), 0)) {
-          case Qnil:
+        switch ((uintptr_t)rb_range_beg_len(indx, &beg, &len, str_strlen(str, NULL), 0)) {
+          case (uintptr_t)Qnil:
             return Qnil;
-          case Qfalse:
+          case (uintptr_t)Qfalse:
             beg = NUM2LONG(indx);
             if (!(p = rb_str_subpos(str, beg, &len))) return Qnil;
             if (!len) return Qnil;
@@ -6265,10 +6266,10 @@ str_byte_aref(VALUE str, VALUE indx)
         /* check if indx is Range */
         long beg, len = RSTRING_LEN(str);
 
-        switch (rb_range_beg_len(indx, &beg, &len, len, 0)) {
-          case Qfalse:
+        switch ((uintptr_t)rb_range_beg_len(indx, &beg, &len, len, 0)) {
+          case (uintptr_t)Qfalse:
             break;
-          case Qnil:
+          case (uintptr_t)Qnil:
             return Qnil;
           default:
             return str_byte_substr(str, beg, len, TRUE);
@@ -9046,7 +9047,7 @@ rb_str_enumerate_lines(int argc, VALUE *argv, VALUE str, VALUE ary)
             keywords[0] = rb_intern_const("chomp");
         }
         rb_get_kwargs(opts, keywords, 0, 1, &chomp);
-        chomp = (!UNDEF_P(chomp) && RTEST(chomp));
+        chomp = (VALUE)(!UNDEF_P(chomp) && RTEST(chomp));
     }
 
     if (NIL_P(rs)) {
diff --git a/struct.c b/struct.c
index 23420d5e8cc6..3afb1806b00d 100644
--- a/struct.c
+++ b/struct.c
@@ -750,16 +750,16 @@ rb_struct_initialize_m(int argc, const VALUE *argv, VALUE self)
     }
 
     bool keyword_init = false;
-    switch (rb_struct_s_keyword_init(klass)) {
+    switch ((uintptr_t)rb_struct_s_keyword_init(klass)) {
       default:
         if (argc > 1 || !RB_TYPE_P(argv[0], T_HASH)) {
             rb_error_arity(argc, 0, 0);
         }
         keyword_init = true;
         break;
-      case Qfalse:
+      case (uintptr_t)Qfalse:
         break;
-      case Qnil:
+      case (uintptr_t)Qnil:
         if (argc > 1 || !RB_TYPE_P(argv[0], T_HASH)) {
             break;
         }
@@ -811,7 +811,7 @@ struct_alloc(VALUE klass)
 {
     long n = num_members(klass);
     size_t embedded_size = offsetof(struct RStruct, as.ary) + (sizeof(VALUE) * n);
-    VALUE flags = T_STRUCT | (RGENGC_WB_PROTECTED_STRUCT ? FL_WB_PROTECTED : 0);
+    uintptr_t flags = T_STRUCT | (RGENGC_WB_PROTECTED_STRUCT ? FL_WB_PROTECTED : 0);
 
     if (n > 0 && rb_gc_size_allocatable_p(embedded_size)) {
         flags |= n << RSTRUCT_EMBED_LEN_SHIFT;
@@ -1435,7 +1435,7 @@ rb_struct_hash(VALUE s)
     st_index_t h;
     VALUE n;
 
-    h = rb_hash_start(rb_hash(rb_obj_class(s)));
+    h = rb_hash_start((st_index_t)rb_hash(rb_obj_class(s)));
     len = RSTRUCT_LEN(s);
     for (i = 0; i < len; i++) {
         n = rb_hash(RSTRUCT_GET(s, i));
diff --git a/symbol.c b/symbol.c
index 03ca9cf15084..f84540d5671e 100644
--- a/symbol.c
+++ b/symbol.c
@@ -44,7 +44,7 @@
 
 #define SYMBOL_PINNED_P(sym) (RSYMBOL(sym)->id&~ID_SCOPE_MASK)
 
-#define STATIC_SYM2ID(sym) RSHIFT((VALUE)(sym), RUBY_SPECIAL_SHIFT)
+#define STATIC_SYM2ID(sym) RSHIFT((uintptr_t)(sym), RUBY_SPECIAL_SHIFT)
 
 static ID register_static_symid(ID, const char *, long, rb_encoding *);
 static ID register_static_symid_str(ID, VALUE);
diff --git a/symbol.h b/symbol.h
index 3649f125bfbe..45dde87a4df2 100644
--- a/symbol.h
+++ b/symbol.h
@@ -15,7 +15,7 @@
 #include "ruby/encoding.h"
 
 #define DYNAMIC_ID_P(id) (!(id&ID_STATIC_SYM)&&id>tLAST_OP_ID)
-#define STATIC_ID2SYM(id)  (((VALUE)(id)<<RUBY_SPECIAL_SHIFT)|SYMBOL_FLAG)
+#define STATIC_ID2SYM(id)  ((VALUE)(((uintptr_t)(id)<<RUBY_SPECIAL_SHIFT)|SYMBOL_FLAG))
 
 #ifdef HAVE_BUILTIN___BUILTIN_CONSTANT_P
 #define rb_id2sym(id) \
@@ -81,7 +81,7 @@ sym_type(VALUE sym)
 {
     ID id;
     if (STATIC_SYM_P(sym)) {
-        id = RSHIFT(sym, RUBY_SPECIAL_SHIFT);
+        id = RSHIFT((uintptr_t)sym, RUBY_SPECIAL_SHIFT);
         if (id<=tLAST_OP_ID) {
             return -1;
         }
diff --git a/thread.c b/thread.c
index 1fe1e0159596..3e0cc9c3d81f 100644
--- a/thread.c
+++ b/thread.c
@@ -1115,8 +1115,8 @@ thread_join(rb_thread_t *target_th, VALUE timeout, rb_hrtime_t *limit)
         VALUE err = target_th->ec->errinfo;
 
         if (FIXNUM_P(err)) {
-            switch (err) {
-              case INT2FIX(TAG_FATAL):
+            switch ((uintptr_t)err) {
+              case (uintptr_t)INT2FIX(TAG_FATAL):
                 RUBY_DEBUG_LOG("terminated target_th:%u status:%s", rb_th_serial(target_th), thread_status_name(target_th, TRUE));
 
                 /* OK. killed. */
@@ -4952,7 +4952,7 @@ rb_thread_shield_waiting_inc(VALUE b)
     if (w > THREAD_SHIELD_WAITING_MAX)
         rb_raise(rb_eRuntimeError, "waiting count overflow");
     RBASIC(b)->flags &= ~THREAD_SHIELD_WAITING_MASK;
-    RBASIC(b)->flags |= ((VALUE)w << THREAD_SHIELD_WAITING_SHIFT);
+    RBASIC(b)->flags |= ((uintptr_t)w << THREAD_SHIELD_WAITING_SHIFT);
 }
 
 static inline void
@@ -4962,7 +4962,7 @@ rb_thread_shield_waiting_dec(VALUE b)
     if (!w) rb_raise(rb_eRuntimeError, "waiting count underflow");
     w--;
     RBASIC(b)->flags &= ~THREAD_SHIELD_WAITING_MASK;
-    RBASIC(b)->flags |= ((VALUE)w << THREAD_SHIELD_WAITING_SHIFT);
+    RBASIC(b)->flags |= ((uintptr_t)w << THREAD_SHIELD_WAITING_SHIFT);
 }
 
 VALUE
diff --git a/tool/ruby_vm/views/_insn_len_info.erb b/tool/ruby_vm/views/_insn_len_info.erb
index 569dca5845bb..85054ad473ab 100644
--- a/tool/ruby_vm/views/_insn_len_info.erb
+++ b/tool/ruby_vm/views/_insn_len_info.erb
@@ -5,7 +5,7 @@
 %# granted, to either  redistribute and/or modify this file,  provided that the
 %# conditions mentioned  in the  file COPYING  are met.   Consult the  file for
 %# details.
-CONSTFUNC(MAYBE_UNUSED(static int insn_len(VALUE insn)));
+CONSTFUNC(MAYBE_UNUSED(static int insn_len(uintptr_t insn)));
 
 RUBY_SYMBOL_EXPORT_BEGIN /* for debuggers */
 extern const uint8_t rb_vm_insn_len_info[VM_INSTRUCTION_SIZE];
@@ -22,7 +22,7 @@ ASSERT_VM_INSTRUCTION_SIZE(rb_vm_insn_len_info);
 #endif
 
 int
-insn_len(VALUE i)
+insn_len(uintptr_t i)
 {
     return rb_vm_insn_len_info[i];
 }
diff --git a/tool/ruby_vm/views/_insn_name_info.erb b/tool/ruby_vm/views/_insn_name_info.erb
index e7ded75e6576..434ea089357a 100644
--- a/tool/ruby_vm/views/_insn_name_info.erb
+++ b/tool/ruby_vm/views/_insn_name_info.erb
@@ -11,7 +11,7 @@
 % c = a.inject([0]) {|r, i| r << (r[-1] + i.length + 1) }
 % c.pop
 %
-CONSTFUNC(MAYBE_UNUSED(static const char *insn_name(VALUE insn)));
+CONSTFUNC(MAYBE_UNUSED(static const char *insn_name(uintptr_t insn)));
 
 RUBY_SYMBOL_EXPORT_BEGIN /* for debuggers */
 extern const int rb_vm_max_insn_name_size;
@@ -38,7 +38,7 @@ ASSERT_VM_INSTRUCTION_SIZE(rb_vm_insn_name_offset);
 #endif
 
 const char *
-insn_name(VALUE i)
+insn_name(uintptr_t i)
 {
     return &rb_vm_insn_name_base[rb_vm_insn_name_offset[i]];
 }
diff --git a/tool/ruby_vm/views/_insn_operand_info.erb b/tool/ruby_vm/views/_insn_operand_info.erb
index 996c33e96053..d1197bb42dbb 100644
--- a/tool/ruby_vm/views/_insn_operand_info.erb
+++ b/tool/ruby_vm/views/_insn_operand_info.erb
@@ -11,8 +11,8 @@
 % c = a.inject([0]) {|r, i| r << (r[-1] + i.length + 1) }
 % c.pop
 %
-CONSTFUNC(MAYBE_UNUSED(static const char *insn_op_types(VALUE insn)));
-CONSTFUNC(MAYBE_UNUSED(static int insn_op_type(VALUE insn, long pos)));
+CONSTFUNC(MAYBE_UNUSED(static const char *insn_op_types(uintptr_t insn)));
+CONSTFUNC(MAYBE_UNUSED(static int insn_op_type(uintptr_t insn, long pos)));
 
 RUBY_SYMBOL_EXPORT_BEGIN /* for debuggers */
 extern const char rb_vm_insn_op_base[];
@@ -36,13 +36,13 @@ ASSERT_VM_INSTRUCTION_SIZE(rb_vm_insn_op_offset);
 #endif
 
 const char *
-insn_op_types(VALUE i)
+insn_op_types(uintptr_t i)
 {
     return &rb_vm_insn_op_base[rb_vm_insn_op_offset[i]];
 }
 
 int
-insn_op_type(VALUE i, long j)
+insn_op_type(uintptr_t i, long j)
 {
     if (j >= insn_len(i)) {
         return 0;
diff --git a/tool/ruby_vm/views/optinsn.inc.erb b/tool/ruby_vm/views/optinsn.inc.erb
index de7bb210eae3..035c8cbd02a5 100644
--- a/tool/ruby_vm/views/optinsn.inc.erb
+++ b/tool/ruby_vm/views/optinsn.inc.erb
@@ -49,7 +49,7 @@ insn_operands_unification(INSN *iobj)
 }
 
 int
-rb_insn_unified_local_var_level(VALUE insn)
+rb_insn_unified_local_var_level(uintptr_t insn)
 {
 #ifdef OPT_OPERANDS_UNIFICATION
     /* optimize rule */
@@ -60,7 +60,7 @@ rb_insn_unified_local_var_level(VALUE insn)
 %   unifs.each do|insn|
       case <%= insn.bin %>:
 %     insn.spec.map{|(var,val)|val}.reject{|i| i == '*' }.each do |val|
-        return <%= val %>;
+        return (int)<%= val %>;
 %       break
 %     end
 %   end
diff --git a/transcode.c b/transcode.c
index 892814ee3ba0..ded55330a7ab 100644
--- a/transcode.c
+++ b/transcode.c
@@ -581,12 +581,12 @@ transcode_restartable0(const unsigned char **in_pos, unsigned char **out_pos,
         next_byte = (unsigned char)*in_p++;
       follow_byte:
         if (next_byte < BL_MIN_BYTE || BL_MAX_BYTE < next_byte)
-            next_info = INVALID;
+            next_info = (VALUE)INVALID;
         else {
             next_info = (VALUE)BL_ACTION(next_byte);
         }
       follow_info:
-        switch (next_info & 0x1F) {
+        switch ((uintptr_t)next_info & 0x1F) {
           case NOMAP:
             {
                 const unsigned char *p = inchar_start;
@@ -616,33 +616,33 @@ transcode_restartable0(const unsigned char **in_pos, unsigned char **out_pos,
           case ZERObt: /* drop input */
             continue;
           case ONEbt:
-            SUSPEND_OBUF(9); *out_p++ = getBT1(next_info);
+              SUSPEND_OBUF(9); *out_p++ = getBT1((uintptr_t)next_info);
             continue;
           case TWObt:
-            SUSPEND_OBUF(10); *out_p++ = getBT1(next_info);
-            SUSPEND_OBUF(21); *out_p++ = getBT2(next_info);
+            SUSPEND_OBUF(10); *out_p++ = getBT1((uintptr_t)next_info);
+            SUSPEND_OBUF(21); *out_p++ = getBT2((uintptr_t)next_info);
             continue;
           case THREEbt:
-            SUSPEND_OBUF(11); *out_p++ = getBT1(next_info);
-            SUSPEND_OBUF(15); *out_p++ = getBT2(next_info);
-            SUSPEND_OBUF(16); *out_p++ = getBT3(next_info);
+            SUSPEND_OBUF(11); *out_p++ = getBT1((uintptr_t)next_info);
+            SUSPEND_OBUF(15); *out_p++ = getBT2((uintptr_t)next_info);
+            SUSPEND_OBUF(16); *out_p++ = getBT3((uintptr_t)next_info);
             continue;
           case FOURbt:
-            SUSPEND_OBUF(12); *out_p++ = getBT0(next_info);
-            SUSPEND_OBUF(17); *out_p++ = getBT1(next_info);
-            SUSPEND_OBUF(18); *out_p++ = getBT2(next_info);
-            SUSPEND_OBUF(19); *out_p++ = getBT3(next_info);
+            SUSPEND_OBUF(12); *out_p++ = getBT0((uintptr_t)next_info);
+            SUSPEND_OBUF(17); *out_p++ = getBT1((uintptr_t)next_info);
+            SUSPEND_OBUF(18); *out_p++ = getBT2((uintptr_t)next_info);
+            SUSPEND_OBUF(19); *out_p++ = getBT3((uintptr_t)next_info);
             continue;
           case GB4bt:
-            SUSPEND_OBUF(29); *out_p++ = getGB4bt0(next_info);
-            SUSPEND_OBUF(30); *out_p++ = getGB4bt1(next_info);
-            SUSPEND_OBUF(31); *out_p++ = getGB4bt2(next_info);
-            SUSPEND_OBUF(32); *out_p++ = getGB4bt3(next_info);
+            SUSPEND_OBUF(29); *out_p++ = getGB4bt0((uintptr_t)next_info);
+            SUSPEND_OBUF(30); *out_p++ = getGB4bt1((uintptr_t)next_info);
+            SUSPEND_OBUF(31); *out_p++ = getGB4bt2((uintptr_t)next_info);
+            SUSPEND_OBUF(32); *out_p++ = getGB4bt3((uintptr_t)next_info);
             continue;
           case STR1:
             tc->output_index = 0;
-            while (tc->output_index < STR1_LENGTH(BYTE_ADDR(STR1_BYTEINDEX(next_info)))) {
-                SUSPEND_OBUF(28); *out_p++ = BYTE_ADDR(STR1_BYTEINDEX(next_info))[1+tc->output_index];
+            while (tc->output_index < STR1_LENGTH(BYTE_ADDR(STR1_BYTEINDEX((uintptr_t)next_info)))) {
+                SUSPEND_OBUF(28); *out_p++ = BYTE_ADDR(STR1_BYTEINDEX((uintptr_t)next_info))[1+tc->output_index];
                 tc->output_index++;
             }
             continue;
diff --git a/variable.c b/variable.c
index 4d442ff9e314..be45f9eb9216 100644
--- a/variable.c
+++ b/variable.c
@@ -320,11 +320,11 @@ static VALUE
 make_temporary_path(VALUE obj, VALUE klass)
 {
     VALUE path;
-    switch (klass) {
-      case Qnil:
+    switch ((uintptr_t)klass) {
+      case (uintptr_t)Qnil:
         path = rb_sprintf("#<Class:%p>", (void*)obj);
         break;
-      case Qfalse:
+      case (uintptr_t)Qfalse:
         path = rb_sprintf("#<Module:%p>", (void*)obj);
         break;
       default:
@@ -1964,7 +1964,7 @@ rb_ivar_defined(VALUE obj, ID id)
           }
         }
 
-        if (!table || !rb_st_lookup(table, id, &idx)) {
+        if (!table || !rb_st_lookup(table, (st_data_t)id, &idx)) {
             return Qfalse;
         }
 
@@ -2737,7 +2737,7 @@ autoload_delete(VALUE module, ID name)
 {
     RUBY_ASSERT_CRITICAL_SECTION_ENTER();
 
-    st_data_t load = 0, key = name;
+    st_data_t load = 0, key = (st_data_t)name;
 
     RUBY_ASSERT(RB_TYPE_P(module, T_CLASS) || RB_TYPE_P(module, T_MODULE));
 
@@ -3982,7 +3982,7 @@ static void
 check_for_cvar_table(VALUE subclass, VALUE key)
 {
     // Must not check ivar on ICLASS
-    if (!RB_TYPE_P(subclass, T_ICLASS) && RTEST(rb_ivar_defined(subclass, key))) {
+    if (!RB_TYPE_P(subclass, T_ICLASS) && RTEST(rb_ivar_defined(subclass, (ID)key))) {
         RB_DEBUG_COUNTER_INC(cvar_class_invalidate);
         ruby_vm_global_cvar_state++;
         return;
@@ -4040,7 +4040,7 @@ rb_cvar_set(VALUE klass, ID id, VALUE val)
     if (result == 0) {
         if (RB_TYPE_P(target, T_CLASS)) {
             if (RCLASS_SUBCLASSES(target)) {
-                rb_class_foreach_subclass(target, check_for_cvar_table, id);
+                rb_class_foreach_subclass(target, check_for_cvar_table, (VALUE)id);
             }
         }
     }
diff --git a/vm.c b/vm.c
index 259d16b85a38..140e7f9d2b3c 100644
--- a/vm.c
+++ b/vm.c
@@ -734,7 +734,7 @@ vm_set_top_stack(rb_execution_context_t *ec, const rb_iseq_t *iseq)
     }
 
     /* for return */
-    vm_push_frame(ec, iseq, VM_FRAME_MAGIC_TOP | VM_ENV_FLAG_LOCAL | VM_FRAME_FLAG_FINISH, rb_ec_thread_ptr(ec)->top_self,
+    vm_push_frame(ec, iseq, (VALUE)(VM_FRAME_MAGIC_TOP | VM_ENV_FLAG_LOCAL | VM_FRAME_FLAG_FINISH), rb_ec_thread_ptr(ec)->top_self,
                   VM_BLOCK_HANDLER_NONE,
                   (VALUE)vm_cref_new_toplevel(ec), /* cref or me */
                   ISEQ_BODY(iseq)->iseq_encoded, ec->cfp->sp,
@@ -744,7 +744,7 @@ vm_set_top_stack(rb_execution_context_t *ec, const rb_iseq_t *iseq)
 static void
 vm_set_eval_stack(rb_execution_context_t *ec, const rb_iseq_t *iseq, const rb_cref_t *cref, const struct rb_block *base_block)
 {
-    vm_push_frame(ec, iseq, VM_FRAME_MAGIC_EVAL | VM_FRAME_FLAG_FINISH,
+    vm_push_frame(ec, iseq, (VALUE)(VM_FRAME_MAGIC_EVAL | VM_FRAME_FLAG_FINISH),
                   vm_block_self(base_block), VM_GUARDED_PREV_EP(vm_block_ep(base_block)),
                   (VALUE)cref, /* cref or me */
                   ISEQ_BODY(iseq)->iseq_encoded,
@@ -1233,7 +1233,7 @@ env_copy(const VALUE *src_ep, VALUE read_only_variables)
 
     // Copy after allocations above, since they can move objects in src_ep.
     RB_OBJ_WRITE(copied_env, &ep[VM_ENV_DATA_INDEX_ME_CREF], src_ep[VM_ENV_DATA_INDEX_ME_CREF]);
-    ep[VM_ENV_DATA_INDEX_FLAGS] = src_ep[VM_ENV_DATA_INDEX_FLAGS] | VM_ENV_FLAG_ISOLATED;
+    ep[VM_ENV_DATA_INDEX_FLAGS] = (VALUE)((uintptr_t)src_ep[VM_ENV_DATA_INDEX_FLAGS] | VM_ENV_FLAG_ISOLATED);
     if (!VM_ENV_LOCAL_P(src_ep)) {
         VM_ENV_FLAGS_SET(ep, VM_ENV_FLAG_LOCAL);
     }
@@ -1407,7 +1407,7 @@ rb_vm_make_proc_lambda(const rb_execution_context_t *ec, const struct rb_capture
             }
             else {
                 VM_ASSERT(FIXNUM_P(ep0));
-                if (ep0 & VM_ENV_FLAG_ESCAPED) {
+                if ((uintptr_t)ep0 & VM_ENV_FLAG_ESCAPED) {
                     // ok. do nothing
                 }
                 else {
@@ -1504,11 +1504,11 @@ rb_binding_add_dynavars(VALUE bindval, rb_binding_t *bind, int dyncount, const I
 /* C -> Ruby: block */
 
 static inline VALUE
-invoke_block(rb_execution_context_t *ec, const rb_iseq_t *iseq, VALUE self, const struct rb_captured_block *captured, const rb_cref_t *cref, VALUE type, int opt_pc)
+invoke_block(rb_execution_context_t *ec, const rb_iseq_t *iseq, VALUE self, const struct rb_captured_block *captured, const rb_cref_t *cref, uintptr_t type, int opt_pc)
 {
     int arg_size = ISEQ_BODY(iseq)->param.size;
 
-    vm_push_frame(ec, iseq, type | VM_FRAME_FLAG_FINISH, self,
+    vm_push_frame(ec, iseq, (VALUE)(type | VM_FRAME_FLAG_FINISH), self,
                   VM_GUARDED_PREV_EP(captured->ep),
                   (VALUE)cref, /* cref or method */
                   ISEQ_BODY(iseq)->iseq_encoded + opt_pc,
@@ -1519,7 +1519,7 @@ invoke_block(rb_execution_context_t *ec, const rb_iseq_t *iseq, VALUE self, cons
 }
 
 static VALUE
-invoke_bmethod(rb_execution_context_t *ec, const rb_iseq_t *iseq, VALUE self, const struct rb_captured_block *captured, const rb_callable_method_entry_t *me, VALUE type, int opt_pc)
+invoke_bmethod(rb_execution_context_t *ec, const rb_iseq_t *iseq, VALUE self, const struct rb_captured_block *captured, const rb_callable_method_entry_t *me, uintptr_t type, int opt_pc)
 {
     /* bmethod call from outside the VM */
     int arg_size = ISEQ_BODY(iseq)->param.size;
@@ -1527,7 +1527,7 @@ invoke_bmethod(rb_execution_context_t *ec, const rb_iseq_t *iseq, VALUE self, co
 
     VM_ASSERT(me->def->type == VM_METHOD_TYPE_BMETHOD);
 
-    vm_push_frame(ec, iseq, type | VM_FRAME_FLAG_BMETHOD, self,
+    vm_push_frame(ec, iseq, (VALUE)(type | VM_FRAME_FLAG_BMETHOD), self,
                   VM_GUARDED_PREV_EP(captured->ep),
                   (VALUE)me,
                   ISEQ_BODY(iseq)->iseq_encoded + opt_pc,
@@ -1553,7 +1553,7 @@ invoke_iseq_block_from_c(rb_execution_context_t *ec, const struct rb_captured_bl
 {
     const rb_iseq_t *iseq = rb_iseq_check(captured->code.iseq);
     int opt_pc;
-    VALUE type = VM_FRAME_MAGIC_BLOCK | (is_lambda ? VM_FRAME_FLAG_LAMBDA : 0);
+    uintptr_t type = VM_FRAME_MAGIC_BLOCK | (is_lambda ? VM_FRAME_FLAG_LAMBDA : 0);
     rb_control_frame_t *cfp = ec->cfp;
     VALUE *sp = cfp->sp;
     int flags = (kw_splat ? VM_CALL_KW_SPLAT : 0);
@@ -1777,13 +1777,13 @@ rb_vm_svar_lep(const rb_execution_context_t *ec, const rb_control_frame_t *cfp)
 static VALUE
 vm_cfp_svar_get(const rb_execution_context_t *ec, rb_control_frame_t *cfp, VALUE key)
 {
-    return lep_svar_get(ec, rb_vm_svar_lep(ec, cfp), key);
+    return lep_svar_get(ec, rb_vm_svar_lep(ec, cfp), (rb_num_t)key);
 }
 
 static void
 vm_cfp_svar_set(const rb_execution_context_t *ec, rb_control_frame_t *cfp, VALUE key, const VALUE val)
 {
-    lep_svar_set(ec, rb_vm_svar_lep(ec, cfp), key, val);
+    lep_svar_set(ec, rb_vm_svar_lep(ec, cfp), (rb_num_t)key, val);
 }
 
 static VALUE
@@ -1801,13 +1801,13 @@ vm_svar_set(const rb_execution_context_t *ec, VALUE key, VALUE val)
 VALUE
 rb_backref_get(void)
 {
-    return vm_svar_get(GET_EC(), VM_SVAR_BACKREF);
+    return vm_svar_get(GET_EC(), (VALUE)VM_SVAR_BACKREF);
 }
 
 void
 rb_backref_set(VALUE val)
 {
-    vm_svar_set(GET_EC(), VM_SVAR_BACKREF, val);
+    vm_svar_set(GET_EC(), (VALUE)VM_SVAR_BACKREF, val);
 }
 
 VALUE
@@ -2134,7 +2134,7 @@ rb_vm_check_redefinition_opt_method(const rb_method_entry_t *me, VALUE klass)
             if (flag != 0) {
                 rb_yjit_bop_redefined(flag, (enum ruby_basic_operators)bop);
                 rb_rjit_bop_redefined(flag, (enum ruby_basic_operators)bop);
-                ruby_vm_redefined_flag[bop] |= flag;
+                ruby_vm_redefined_flag[(uintptr_t)bop] |= flag;
             }
         }
     }
@@ -2160,7 +2160,7 @@ rb_vm_check_redefinition_by_prepend(VALUE klass)
 }
 
 static void
-add_opt_method(VALUE klass, ID mid, VALUE bop)
+add_opt_method(VALUE klass, ID mid, uintptr_t bop)
 {
     const rb_method_entry_t *me = rb_method_entry_at(klass, mid);
 
@@ -2177,7 +2177,7 @@ static void
 vm_init_redefined_flag(void)
 {
     ID mid;
-    VALUE bop;
+    uintptr_t bop;
 
     vm_opt_method_def_table = st_init_numtable();
     vm_opt_mid_table = st_init_numtable();
@@ -2542,7 +2542,7 @@ vm_exec_handle_exception(rb_execution_context_t *ec, enum ruby_tag_type state, V
         const struct iseq_catch_table *ct;
         unsigned long epc, cont_pc, cont_sp;
         const rb_iseq_t *catch_iseq;
-        VALUE type;
+        enum rb_catch_type type;
         const rb_control_frame_t *escape_cfp;
 
         cont_pc = cont_sp = 0;
@@ -2708,7 +2708,7 @@ vm_exec_handle_exception(rb_execution_context_t *ec, enum ruby_tag_type state, V
 
             /* push block frame */
             cfp->sp[0] = (VALUE)err;
-            vm_push_frame(ec, catch_iseq, VM_FRAME_MAGIC_RESCUE,
+            vm_push_frame(ec, catch_iseq, (VALUE)VM_FRAME_MAGIC_RESCUE,
                           cfp->self,
                           VM_GUARDED_PREV_EP(cfp->ep),
                           0, /* cref or me */
@@ -2800,7 +2800,7 @@ rb_vm_call_cfunc(VALUE recv, VALUE (*func)(VALUE), VALUE arg,
     const rb_iseq_t *iseq = rb_iseq_new(0, filename, filename, Qnil, 0, ISEQ_TYPE_TOP);
     VALUE val;
 
-    vm_push_frame(ec, iseq, VM_FRAME_MAGIC_TOP | VM_ENV_FLAG_LOCAL | VM_FRAME_FLAG_FINISH,
+    vm_push_frame(ec, iseq, (VALUE)(VM_FRAME_MAGIC_TOP | VM_ENV_FLAG_LOCAL | VM_FRAME_FLAG_FINISH),
                   recv, block_handler,
                   (VALUE)vm_cref_new_toplevel(ec), /* cref or me */
                   0, reg_cfp->sp, 0, 0);
@@ -3519,7 +3519,7 @@ rb_ec_initialize_vm_stack(rb_execution_context_t *ec, VALUE *stack, size_t size)
 
     vm_push_frame(ec,
         NULL /* dummy iseq */,
-        VM_FRAME_MAGIC_DUMMY | VM_ENV_FLAG_LOCAL | VM_FRAME_FLAG_FINISH | VM_FRAME_FLAG_CFRAME /* dummy frame */,
+        (VALUE)(VM_FRAME_MAGIC_DUMMY | VM_ENV_FLAG_LOCAL | VM_FRAME_FLAG_FINISH | VM_FRAME_FLAG_CFRAME) /* dummy frame */,
         Qnil /* dummy self */, VM_BLOCK_HANDLER_NONE /* dummy block ptr */,
         0 /* dummy cref/me */,
         0 /* dummy pc */, ec->vm_stack, 0, 0
diff --git a/vm.inc b/vm.inc
index b72a9ea80c06..be1fcd4bfbc9 100644
--- a/vm.inc
+++ b/vm.inc
@@ -2128,7 +2128,7 @@ INSN_ENTRY(defineclass)
     rb_iseq_check(class_iseq);
 
     /* enter scope */
-    vm_push_frame(ec, class_iseq, VM_FRAME_MAGIC_CLASS | VM_ENV_FLAG_LOCAL, klass,
+    vm_push_frame(ec, class_iseq, (VALUE)(VM_FRAME_MAGIC_CLASS | VM_ENV_FLAG_LOCAL), klass,
                   GET_BLOCK_HANDLER(),
                   (VALUE)vm_cref_push(ec, klass, NULL, FALSE, FALSE),
                   ISEQ_BODY(class_iseq)->iseq_encoded, GET_SP(),
diff --git a/vm_args.c b/vm_args.c
index 1b720a89c484..5a34d677a045 100644
--- a/vm_args.c
+++ b/vm_args.c
@@ -710,7 +710,7 @@ setup_parameters_complex(rb_execution_context_t * const ec, const rb_iseq_t * co
     if (ISEQ_BODY(iseq)->param.flags.has_rest) {
         args_setup_rest_parameter(args, locals + ISEQ_BODY(iseq)->param.rest_start);
         VALUE ary = *(locals + ISEQ_BODY(iseq)->param.rest_start);
-        VALUE index = RARRAY_LEN(ary) - 1;
+        uintptr_t index = RARRAY_LEN(ary) - 1;
         if (splat_flagged_keyword_hash &&
             !ISEQ_BODY(iseq)->param.flags.ruby2_keywords &&
             !ISEQ_BODY(iseq)->param.flags.has_kw &&
@@ -779,7 +779,7 @@ raise_argument_error(rb_execution_context_t *ec, const rb_iseq_t *iseq, const VA
     VALUE at;
 
     if (iseq) {
-        vm_push_frame(ec, iseq, VM_FRAME_MAGIC_DUMMY | VM_ENV_FLAG_LOCAL, Qnil /* self */,
+        vm_push_frame(ec, iseq, (VALUE)(VM_FRAME_MAGIC_DUMMY | VM_ENV_FLAG_LOCAL), Qnil /* self */,
                       VM_BLOCK_HANDLER_NONE /* specval*/, Qfalse /* me or cref */,
                       ISEQ_BODY(iseq)->iseq_encoded,
                       ec->cfp->sp, 0, 0 /* stack_max */);
diff --git a/vm_backtrace.c b/vm_backtrace.c
index 6e9436f76a33..976e52c6e395 100644
--- a/vm_backtrace.c
+++ b/vm_backtrace.c
@@ -1102,8 +1102,8 @@ ec_backtrace_to_ary(const rb_execution_context_t *ec, int argc, const VALUE *arg
       case 1:
         {
             long beg, len, bt_size = backtrace_size(ec);
-            switch (rb_range_beg_len(level, &beg, &len, bt_size - lev_plus, 0)) {
-              case Qfalse:
+            switch ((uintptr_t)rb_range_beg_len(level, &beg, &len, bt_size - lev_plus, 0)) {
+              case (uintptr_t)Qfalse:
                 lev = NUM2LONG(level);
                 if (lev < 0) {
                     rb_raise(rb_eArgError, "negative level (%ld)", lev);
@@ -1111,7 +1111,7 @@ ec_backtrace_to_ary(const rb_execution_context_t *ec, int argc, const VALUE *arg
                 lev += lev_plus;
                 n = ALL_BACKTRACE_LINES;
                 break;
-              case Qnil:
+              case (uintptr_t)Qnil:
                 return Qnil;
               default:
                 lev = beg + lev_plus;
diff --git a/vm_callinfo.h b/vm_callinfo.h
index ab7c199e3c22..2c1803441926 100644
--- a/vm_callinfo.h
+++ b/vm_callinfo.h
@@ -59,11 +59,11 @@ rb_callinfo_kwarg_bytes(int keyword_len)
 
 // imemo_callinfo
 struct rb_callinfo {
-    VALUE flags;
+    uintptr_t flags;
     const struct rb_callinfo_kwarg *kwarg;
-    VALUE mid;
-    VALUE flag;
-    VALUE argc;
+    uintptr_t mid;
+    uintptr_t flag;
+    uintptr_t argc;
 };
 
 #if !defined(USE_EMBED_CI) || (USE_EMBED_CI+0)
@@ -92,11 +92,11 @@ struct rb_callinfo {
 
 #define CI_EMBED_FLAG 0x01
 #define CI_EMBED_ARGC_SHFT (CI_EMBED_TAG_bits)
-#define CI_EMBED_ARGC_MASK ((((VALUE)1)<<CI_EMBED_ARGC_bits) - 1)
+#define CI_EMBED_ARGC_MASK ((((uintptr_t)1)<<CI_EMBED_ARGC_bits) - 1)
 #define CI_EMBED_FLAG_SHFT (CI_EMBED_TAG_bits + CI_EMBED_ARGC_bits)
-#define CI_EMBED_FLAG_MASK ((((VALUE)1)<<CI_EMBED_FLAG_bits) - 1)
+#define CI_EMBED_FLAG_MASK ((((uintptr_t)1)<<CI_EMBED_FLAG_bits) - 1)
 #define CI_EMBED_ID_SHFT   (CI_EMBED_TAG_bits + CI_EMBED_ARGC_bits + CI_EMBED_FLAG_bits)
-#define CI_EMBED_ID_MASK   ((((VALUE)1)<<CI_EMBED_ID_bits) - 1)
+#define CI_EMBED_ID_MASK   ((((uintptr_t)1)<<CI_EMBED_ID_bits) - 1)
 
 static inline bool
 vm_ci_packed_p(const struct rb_callinfo *ci)
@@ -104,7 +104,7 @@ vm_ci_packed_p(const struct rb_callinfo *ci)
     if (!USE_EMBED_CI) {
         return 0;
     }
-    if (LIKELY(((VALUE)ci) & 0x01)) {
+    if (LIKELY(((uintptr_t)ci) & 0x01)) {
         return 1;
     }
     else {
@@ -128,7 +128,7 @@ static inline ID
 vm_ci_mid(const struct rb_callinfo *ci)
 {
     if (vm_ci_packed_p(ci)) {
-        return (((VALUE)ci) >> CI_EMBED_ID_SHFT) & CI_EMBED_ID_MASK;
+        return (((uintptr_t)ci) >> CI_EMBED_ID_SHFT) & CI_EMBED_ID_MASK;
     }
     else {
         return (ID)ci->mid;
@@ -139,7 +139,7 @@ static inline unsigned int
 vm_ci_flag(const struct rb_callinfo *ci)
 {
     if (vm_ci_packed_p(ci)) {
-        return (unsigned int)((((VALUE)ci) >> CI_EMBED_FLAG_SHFT) & CI_EMBED_FLAG_MASK);
+        return (unsigned int)((((uintptr_t)ci) >> CI_EMBED_FLAG_SHFT) & CI_EMBED_FLAG_MASK);
     }
     else {
         return (unsigned int)ci->flag;
@@ -150,7 +150,7 @@ static inline unsigned int
 vm_ci_argc(const struct rb_callinfo *ci)
 {
     if (vm_ci_packed_p(ci)) {
-        return (unsigned int)((((VALUE)ci) >> CI_EMBED_ARGC_SHFT) & CI_EMBED_ARGC_MASK);
+        return (unsigned int)((((uintptr_t)ci) >> CI_EMBED_ARGC_SHFT) & CI_EMBED_ARGC_MASK);
     }
     else {
         return (unsigned int)ci->argc;
@@ -192,9 +192,9 @@ vm_ci_dump(const struct rb_callinfo *ci)
 
 #define vm_ci_new_id(mid, flag, argc, must_zero) \
     ((const struct rb_callinfo *)                \
-     ((((VALUE)(mid )) << CI_EMBED_ID_SHFT)   |  \
-      (((VALUE)(flag)) << CI_EMBED_FLAG_SHFT) |  \
-      (((VALUE)(argc)) << CI_EMBED_ARGC_SHFT) |  \
+     ((((uintptr_t)(mid )) << CI_EMBED_ID_SHFT)   |  \
+      (((uintptr_t)(flag)) << CI_EMBED_FLAG_SHFT) |  \
+      (((uintptr_t)(argc)) << CI_EMBED_ARGC_SHFT) |  \
       RUBY_FIXNUM_FLAG))
 
 // vm_method.c
@@ -271,7 +271,7 @@ typedef VALUE (*vm_call_handler)(
 // imemo_callcache
 
 struct rb_callcache {
-    const VALUE flags;
+    uintptr_t flags;
 
     /* inline cache: key */
     const VALUE klass; // should not mark it because klass can not be free'd
@@ -332,10 +332,10 @@ vm_cc_new(VALUE klass,
       case cc_type_normal:
         break;
       case cc_type_super:
-        *(VALUE *)&cc->flags |= VM_CALLCACHE_SUPER;
+        *(uintptr_t*)&cc->flags |= VM_CALLCACHE_SUPER;
         break;
       case cc_type_refinement:
-        *(VALUE *)&cc->flags |= VM_CALLCACHE_REFINEMENT;
+        *(uintptr_t*)&cc->flags |= VM_CALLCACHE_REFINEMENT;
         break;
     }
 
@@ -486,7 +486,7 @@ vm_cc_call_set(const struct rb_callcache *cc, vm_call_handler call)
 static inline void
 set_vm_cc_ivar(const struct rb_callcache *cc)
 {
-    *(VALUE *)&cc->flags |= VM_CALLCACHE_IVAR;
+    *(uintptr_t *)&cc->flags |= VM_CALLCACHE_IVAR;
 }
 
 static inline void
@@ -535,7 +535,7 @@ vm_cc_bf_set(const struct rb_callcache *cc, const struct rb_builtin_function *bf
     VM_ASSERT(IMEMO_TYPE_P(cc, imemo_callcache));
     VM_ASSERT(cc != vm_cc_empty());
     *(const struct rb_builtin_function **)&cc->aux_.bf = bf;
-    *(VALUE *)&cc->flags |= VM_CALLCACHE_BF;
+    *(uintptr_t *)&cc->flags |= VM_CALLCACHE_BF;
 }
 
 static inline bool
diff --git a/vm_core.h b/vm_core.h
index c29791a6c46d..b89e638c5f50 100644
--- a/vm_core.h
+++ b/vm_core.h
@@ -50,6 +50,7 @@
 #include <stddef.h>
 #include <signal.h>
 #include <stdarg.h>
+#include <stdfil.h>
 
 #include "ruby_assert.h"
 
@@ -137,7 +138,7 @@ extern int ruby_assert_critical_section_entered;
 #  define RUBY_SIGCHLD (SIGCHLD)
 #endif
 
-#if defined(SIGSEGV) && defined(HAVE_SIGALTSTACK) && defined(SA_SIGINFO) && !defined(__NetBSD__)
+#if defined(SIGSEGV) && defined(HAVE_SIGALTSTACK) && defined(SA_SIGINFO) && !defined(__NetBSD__) && !defined(__FILC__)
 #  define USE_SIGALTSTACK
 void *rb_allocate_sigaltstack(void);
 void *rb_register_sigaltstack(void *);
@@ -231,7 +232,7 @@ union ic_serial_entry {
 
 // imemo_constcache
 struct iseq_inline_constant_cache_entry {
-    VALUE flags;
+    uintptr_t flags;
 
     VALUE value;              // v0
     VALUE _unused1;           // v1
@@ -532,7 +533,7 @@ struct rb_iseq_constant_body {
 /* T_IMEMO/iseq */
 /* typedef rb_iseq_t is in method.h */
 struct rb_iseq_struct {
-    VALUE flags; /* 1 */
+    uintptr_t flags; /* 1 */
     VALUE wrapper; /* 2 */
 
     struct rb_iseq_constant_body *body;  /* 3 */
@@ -1297,8 +1298,8 @@ typedef VALUE CDHASH;
 typedef rb_control_frame_t *
   (FUNC_FASTCALL(*rb_insn_func_t))(rb_execution_context_t *, rb_control_frame_t *);
 
-#define VM_TAGGED_PTR_SET(p, tag)  ((VALUE)(p) | (tag))
-#define VM_TAGGED_PTR_REF(v, mask) ((void *)((v) & ~mask))
+#define VM_TAGGED_PTR_SET(p, tag)  (zorptr((VALUE)(p), (tag)))
+#define VM_TAGGED_PTR_REF(v, mask) ((void *)(zandptr((v),  ~mask)))
 
 #define GC_GUARDED_PTR(p)     VM_TAGGED_PTR_SET((p), 0x01)
 #define GC_GUARDED_PTR_REF(p) VM_TAGGED_PTR_REF((p), 0x03)
@@ -1355,19 +1356,19 @@ enum vm_frame_env_flags {
 static inline void VM_FORCE_WRITE_SPECIAL_CONST(const VALUE *ptr, VALUE special_const_value);
 
 static inline void
-VM_ENV_FLAGS_SET(const VALUE *ep, VALUE flag)
+VM_ENV_FLAGS_SET(const VALUE *ep, uintptr_t flag)
 {
     VALUE flags = ep[VM_ENV_DATA_INDEX_FLAGS];
     VM_ASSERT(FIXNUM_P(flags));
-    VM_FORCE_WRITE_SPECIAL_CONST(&ep[VM_ENV_DATA_INDEX_FLAGS], flags | flag);
+    VM_FORCE_WRITE_SPECIAL_CONST(&ep[VM_ENV_DATA_INDEX_FLAGS], zorptr(flags, flag));
 }
 
 static inline void
-VM_ENV_FLAGS_UNSET(const VALUE *ep, VALUE flag)
+VM_ENV_FLAGS_UNSET(const VALUE *ep, uintptr_t flag)
 {
     VALUE flags = ep[VM_ENV_DATA_INDEX_FLAGS];
     VM_ASSERT(FIXNUM_P(flags));
-    VM_FORCE_WRITE_SPECIAL_CONST(&ep[VM_ENV_DATA_INDEX_FLAGS], flags & ~flag);
+    VM_FORCE_WRITE_SPECIAL_CONST(&ep[VM_ENV_DATA_INDEX_FLAGS], zandptr(flags, ~flag));
 }
 
 static inline unsigned long
@@ -1375,7 +1376,7 @@ VM_ENV_FLAGS(const VALUE *ep, long flag)
 {
     VALUE flags = ep[VM_ENV_DATA_INDEX_FLAGS];
     VM_ASSERT(FIXNUM_P(flags));
-    return flags & flag;
+    return (uintptr_t)flags & flag;
 }
 
 static inline unsigned long
@@ -1553,7 +1554,7 @@ RUBY_VM_CONTROL_FRAME_STACK_OVERFLOW_P(const rb_execution_context_t *ec, const r
 static inline int
 VM_BH_ISEQ_BLOCK_P(VALUE block_handler)
 {
-    if ((block_handler & 0x03) == 0x01) {
+    if (((uintptr_t)block_handler & 0x03) == 0x01) {
 #if VM_CHECK_MODE > 0
         struct rb_captured_block *captured = VM_TAGGED_PTR_REF(block_handler, 0x03);
         VM_ASSERT(imemo_type_p(captured->code.val, imemo_iseq));
@@ -1584,7 +1585,7 @@ VM_BH_TO_ISEQ_BLOCK(VALUE block_handler)
 static inline int
 VM_BH_IFUNC_P(VALUE block_handler)
 {
-    if ((block_handler & 0x03) == 0x03) {
+    if (((uintptr_t)block_handler & 0x03) == 0x03) {
 #if VM_CHECK_MODE > 0
         struct rb_captured_block *captured = (void *)(block_handler & ~0x03);
         VM_ASSERT(imemo_type_p(captured->code.val, imemo_ifunc));
diff --git a/vm_eval.c b/vm_eval.c
index 937f0582c4a6..09a954916ede 100644
--- a/vm_eval.c
+++ b/vm_eval.c
@@ -164,7 +164,7 @@ vm_call0_cfunc_with_frame(rb_execution_context_t* ec, struct rb_calling_info *ca
     {
         rb_control_frame_t *reg_cfp = ec->cfp;
 
-        vm_push_frame(ec, 0, frame_flags, recv,
+        vm_push_frame(ec, 0, (VALUE)frame_flags, recv,
                       block_handler, (VALUE)me,
                       0, reg_cfp->sp, 0, 0);
 
@@ -327,7 +327,7 @@ vm_call0_body(rb_execution_context_t *ec, struct rb_calling_info *calling, const
 VALUE
 rb_vm_call_kw(rb_execution_context_t *ec, VALUE recv, VALUE id, int argc, const VALUE *argv, const rb_callable_method_entry_t *me, int kw_splat)
 {
-    return rb_vm_call0(ec, recv, id, argc, argv, me, kw_splat);
+    return rb_vm_call0(ec, recv, (ID)id, argc, argv, me, kw_splat);
 }
 
 static inline VALUE
@@ -351,7 +351,7 @@ vm_call_super(rb_execution_context_t *ec, int argc, const VALUE *argv, int kw_sp
     if (!me) {
         return method_missing(ec, recv, id, argc, argv, MISSING_SUPER, kw_splat);
     }
-    return rb_vm_call_kw(ec, recv, id, argc, argv, me, kw_splat);
+    return rb_vm_call_kw(ec, recv, (VALUE)id, argc, argv, me, kw_splat);
 }
 
 VALUE
@@ -442,10 +442,10 @@ cc_new(VALUE klass, ID mid, int argc, const rb_callable_method_entry_t *cme)
     return cc;
 }
 
-static VALUE
+static uintptr_t
 gccct_hash(VALUE klass, ID mid)
 {
-    return (klass >> 3) ^ (VALUE)mid;
+    return ((uintptr_t)klass >> 3) ^ (uintptr_t)mid;
 }
 
 NOINLINE(static const struct rb_callcache *gccct_method_search_slowpath(rb_vm_t *vm, VALUE klass, ID mid, int argc, unsigned int index));
@@ -557,7 +557,7 @@ rb_call0(rb_execution_context_t *ec,
         }
         else if (UNLIKELY(cc_cme != cme)) { // refinement is solved
             stack_check(ec);
-            return rb_vm_call_kw(ec, recv, mid, argc, argv, cme, kw_splat);
+            return rb_vm_call_kw(ec, recv, (VALUE)mid, argc, argv, cme, kw_splat);
         }
     }
     else {
@@ -710,7 +710,7 @@ rb_check_funcall_default_kw(VALUE recv, ID mid, int argc, const VALUE *argv, VAL
         return ret;
     }
     stack_check(ec);
-    return rb_vm_call_kw(ec, recv, mid, argc, argv, me, kw_splat);
+    return rb_vm_call_kw(ec, recv, (VALUE)mid, argc, argv, me, kw_splat);
 }
 
 VALUE
@@ -742,7 +742,7 @@ rb_check_funcall_with_hook_kw(VALUE recv, ID mid, int argc, const VALUE *argv,
     }
     stack_check(ec);
     (*hook)(TRUE, recv, mid, argc, argv, arg);
-    return rb_vm_call_kw(ec, recv, mid, argc, argv, me, kw_splat);
+    return rb_vm_call_kw(ec, recv, (VALUE)mid, argc, argv, me, kw_splat);
 }
 
 VALUE
@@ -793,7 +793,7 @@ rb_type_str(enum ruby_value_type type)
 static void
 uncallable_object(VALUE recv, ID mid)
 {
-    VALUE flags;
+    uintptr_t flags;
     int type;
     const char *typestr;
     VALUE mname = rb_id2str(mid);
@@ -1048,7 +1048,7 @@ method_missing(rb_execution_context_t *ec, VALUE obj, ID id, int argc, const VAL
     me = rb_callable_method_entry(klass, idMethodMissing);
     if (!me || METHOD_ENTRY_BASIC(me)) goto missing;
     vm_passed_block_handler_set(ec, block_handler);
-    result = rb_vm_call_kw(ec, obj, idMethodMissing, argc, argv, me, kw_splat);
+    result = rb_vm_call_kw(ec, obj, (VALUE)idMethodMissing, argc, argv, me, kw_splat);
     if (work) ALLOCV_END(work);
     return result;
   missing:
diff --git a/vm_insnhelper.c b/vm_insnhelper.c
index 1af20721a733..85533f640ab0 100644
--- a/vm_insnhelper.c
+++ b/vm_insnhelper.c
@@ -431,7 +431,7 @@ vm_pop_frame(rb_execution_context_t *ec, rb_control_frame_t *cfp, const VALUE *e
     RUBY_VM_CHECK_INTS(ec);
     ec->cfp = RUBY_VM_PREVIOUS_CONTROL_FRAME(cfp);
 
-    return flags & VM_FRAME_FLAG_FINISH;
+    return (uintptr_t)flags & VM_FRAME_FLAG_FINISH;
 }
 
 void
@@ -449,7 +449,7 @@ rb_vm_push_frame_fname(rb_execution_context_t *ec, VALUE fname)
 
     vm_push_frame(ec,
                   dmy_iseq, //const rb_iseq_t *iseq,
-                  VM_FRAME_MAGIC_DUMMY | VM_ENV_FLAG_LOCAL | VM_FRAME_FLAG_FINISH, // VALUE type,
+                  (VALUE)(VM_FRAME_MAGIC_DUMMY | VM_ENV_FLAG_LOCAL | VM_FRAME_FLAG_FINISH), // VALUE type,
                   ec->cfp->self, // VALUE self,
                   VM_BLOCK_HANDLER_NONE, // VALUE specval,
                   Qfalse, // VALUE cref_or_me,
@@ -503,7 +503,7 @@ static inline void
 vm_env_write(const VALUE *ep, int index, VALUE v)
 {
     VALUE flags = ep[VM_ENV_DATA_INDEX_FLAGS];
-    if (LIKELY((flags & VM_ENV_FLAG_WB_REQUIRED) == 0)) {
+    if (LIKELY(((uintptr_t)flags & VM_ENV_FLAG_WB_REQUIRED) == 0)) {
         VM_STACK_ENV_WRITE(ep, index, v);
     }
     else {
@@ -1058,14 +1058,14 @@ vm_get_ev_const(rb_execution_context_t *ec, VALUE orig_klass, ID id, bool allow_
                     if (UNDEF_P(val)) {
                         if (am == klass) break;
                         am = klass;
-                        if (is_defined) return 1;
+                        if (is_defined) return (VALUE)1;
                         if (rb_autoloading_value(klass, id, &av, NULL)) return av;
                         rb_autoload_load(klass, id);
                         goto search_continue;
                     }
                     else {
                         if (is_defined) {
-                            return 1;
+                            return (VALUE)1;
                         }
                         else {
                             if (UNLIKELY(!rb_ractor_main_p())) {
@@ -1090,7 +1090,7 @@ vm_get_ev_const(rb_execution_context_t *ec, VALUE orig_klass, ID id, bool allow_
         }
 
         if (is_defined) {
-            return rb_const_defined(klass, id);
+            return (VALUE)rb_const_defined(klass, id);
         }
         else {
             return rb_const_get(klass, id);
@@ -1099,7 +1099,7 @@ vm_get_ev_const(rb_execution_context_t *ec, VALUE orig_klass, ID id, bool allow_
     else {
         vm_check_if_namespace(orig_klass);
         if (is_defined) {
-            return rb_public_const_defined_from(orig_klass, id);
+            return (VALUE)rb_public_const_defined_from(orig_klass, id);
         }
         else {
             return rb_public_const_get_from(orig_klass, id);
@@ -1312,7 +1312,7 @@ vm_getivar(VALUE obj, ID id, const rb_iseq_t *iseq, IVC ic, const struct rb_call
               }
             }
 
-            if (!table || !st_lookup(table, id, &val)) {
+            if (!table || !st_lookup(table, (st_data_t)id, &val)) {
                 val = default_value;
             }
         }
@@ -1712,7 +1712,7 @@ vm_throw_start(const rb_execution_context_t *ec, rb_control_frame_t *const reg_c
             while (escape_cfp < eocfp) {
                 if (escape_cfp->ep == ep) {
                     const rb_iseq_t *const iseq = escape_cfp->iseq;
-                    const VALUE epc = escape_cfp->pc - ISEQ_BODY(iseq)->iseq_encoded;
+                    const VALUE epc = (VALUE)(escape_cfp->pc - ISEQ_BODY(iseq)->iseq_encoded);
                     const struct iseq_catch_table *const ct = ISEQ_BODY(iseq)->catch_table;
                     unsigned int i;
 
@@ -2303,8 +2303,8 @@ FIXNUM_2_P(VALUE a, VALUE b)
     /* FIXNUM_P(a) && FIXNUM_P(b)
      * == ((a & 1) && (b & 1))
      * == a & b & 1 */
-    SIGNED_VALUE x = a;
-    SIGNED_VALUE y = b;
+    SIGNED_VALUE x = (SIGNED_VALUE)a;
+    SIGNED_VALUE y = (SIGNED_VALUE)b;
     SIGNED_VALUE z = x & y & 1;
     return z == 1;
 }
@@ -2317,8 +2317,8 @@ FLONUM_2_P(VALUE a, VALUE b)
      * == ((a & 3) == 2) && ((b & 3) == 2)
      * == ! ((a ^ 2) | (b ^ 2) & 3)
      */
-    SIGNED_VALUE x = a;
-    SIGNED_VALUE y = b;
+    SIGNED_VALUE x = (SIGNED_VALUE)a;
+    SIGNED_VALUE y = (SIGNED_VALUE)b;
     SIGNED_VALUE z = ((x ^ 2) | (y ^ 2)) & 3;
     return !z;
 #else
@@ -3081,7 +3081,7 @@ vm_call_iseq_setup_normal(rb_execution_context_t *ec, rb_control_frame_t *cfp, s
     VALUE *sp = argv + param_size;
     cfp->sp = argv - 1 /* recv */;
 
-    vm_push_frame(ec, iseq, VM_FRAME_MAGIC_METHOD | VM_ENV_FLAG_LOCAL, calling->recv,
+    vm_push_frame(ec, iseq, (VALUE)(VM_FRAME_MAGIC_METHOD | VM_ENV_FLAG_LOCAL), calling->recv,
                   calling->block_handler, (VALUE)me,
                   ISEQ_BODY(iseq)->iseq_encoded + opt_pc, sp,
                   local_size - param_size,
@@ -3099,7 +3099,7 @@ vm_call_iseq_setup_tailcall(rb_execution_context_t *ec, rb_control_frame_t *cfp,
     const rb_iseq_t *iseq = def_iseq_ptr(me->def);
     VALUE *src_argv = argv;
     VALUE *sp_orig, *sp;
-    VALUE finish_flag = VM_FRAME_FINISHED_P(cfp) ? VM_FRAME_FLAG_FINISH : 0;
+    uintptr_t finish_flag = VM_FRAME_FINISHED_P(cfp) ? VM_FRAME_FLAG_FINISH : 0;
 
     if (VM_BH_FROM_CFP_P(calling->block_handler, cfp)) {
         struct rb_captured_block *dst_captured = VM_CFP_TO_CAPTURED_BLOCK(RUBY_VM_PREVIOUS_CONTROL_FRAME(cfp));
@@ -3127,7 +3127,7 @@ vm_call_iseq_setup_tailcall(rb_execution_context_t *ec, rb_control_frame_t *cfp,
         *sp++ = src_argv[i];
     }
 
-    vm_push_frame(ec, iseq, VM_FRAME_MAGIC_METHOD | VM_ENV_FLAG_LOCAL | finish_flag,
+vm_push_frame(ec, iseq, (VALUE)(VM_FRAME_MAGIC_METHOD | VM_ENV_FLAG_LOCAL | finish_flag),
                   calling->recv, calling->block_handler, (VALUE)me,
                   ISEQ_BODY(iseq)->iseq_encoded + opt_pc, sp,
                   ISEQ_BODY(iseq)->local_table_size - ISEQ_BODY(iseq)->param.size,
@@ -3473,7 +3473,7 @@ vm_call_cfunc_with_frame_(rb_execution_context_t *ec, rb_control_frame_t *reg_cf
 
     VALUE recv = calling->recv;
     VALUE block_handler = calling->block_handler;
-    VALUE frame_type = VM_FRAME_MAGIC_CFUNC | VM_FRAME_FLAG_CFRAME | VM_ENV_FLAG_LOCAL;
+    uintptr_t frame_type = VM_FRAME_MAGIC_CFUNC | VM_FRAME_FLAG_CFRAME | VM_ENV_FLAG_LOCAL;
 
     if (UNLIKELY(calling->kw_splat)) {
         frame_type |= VM_FRAME_FLAG_CFRAME_KW;
@@ -3484,7 +3484,7 @@ vm_call_cfunc_with_frame_(rb_execution_context_t *ec, rb_control_frame_t *reg_cf
     RUBY_DTRACE_CMETHOD_ENTRY_HOOK(ec, me->owner, me->def->original_id);
     EXEC_EVENT_HOOK(ec, RUBY_EVENT_C_CALL, recv, me->def->original_id, vm_ci_mid(ci), me->owner, Qundef);
 
-    vm_push_frame(ec, NULL, frame_type, recv,
+    vm_push_frame(ec, NULL, (VALUE)frame_type, recv,
                   block_handler, (VALUE)me,
                   0, ec->cfp->sp, 0, 0);
 
@@ -3699,7 +3699,7 @@ vm_call_bmethod_body(rb_execution_context_t *ec, struct rb_calling_info *calling
 }
 
 static int vm_callee_setup_block_arg(rb_execution_context_t *ec, struct rb_calling_info *calling, const struct rb_callinfo *ci, const rb_iseq_t *iseq, VALUE *argv, const enum arg_setup_type arg_setup_type);
-static VALUE invoke_bmethod(rb_execution_context_t *ec, const rb_iseq_t *iseq, VALUE self, const struct rb_captured_block *captured, const rb_callable_method_entry_t *me, VALUE type, int opt_pc);
+static VALUE invoke_bmethod(rb_execution_context_t *ec, const rb_iseq_t *iseq, VALUE self, const struct rb_captured_block *captured, const rb_callable_method_entry_t *me, uintptr_t type, int opt_pc);
 
 static VALUE
 vm_call_iseq_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp, struct rb_calling_info *calling)
@@ -3740,7 +3740,7 @@ vm_call_iseq_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp, struct
     cfp->sp = argv - 1; // -1 for the receiver
 
     vm_push_frame(ec, iseq,
-                  VM_FRAME_MAGIC_BLOCK | VM_FRAME_FLAG_BMETHOD | VM_FRAME_FLAG_LAMBDA,
+                  (VALUE)(VM_FRAME_MAGIC_BLOCK | VM_FRAME_FLAG_BMETHOD | VM_FRAME_FLAG_LAMBDA),
                   calling->recv,
                   VM_GUARDED_PREV_EP(captured->ep),
                   (VALUE)cme,
@@ -4780,7 +4780,7 @@ vm_yield_with_cfunc(rb_execution_context_t *ec,
     }
 
     vm_push_frame(ec, (const rb_iseq_t *)captured->code.ifunc,
-                  frame_flag,
+                  (VALUE)frame_flag,
                   self,
                   VM_GUARDED_PREV_EP(captured->ep),
                   (VALUE)me,
@@ -4905,7 +4905,7 @@ vm_invoke_iseq_block(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
     SET_SP(rsp);
 
     vm_push_frame(ec, iseq,
-                  VM_FRAME_MAGIC_BLOCK | (is_lambda ? VM_FRAME_FLAG_LAMBDA : 0),
+                  (VALUE)(VM_FRAME_MAGIC_BLOCK | (is_lambda ? VM_FRAME_FLAG_LAMBDA : 0)),
                   captured->self,
                   VM_GUARDED_PREV_EP(captured->ep), 0,
                   ISEQ_BODY(iseq)->iseq_encoded + opt_pc,
@@ -5850,7 +5850,7 @@ vm_ic_track_const_chain(rb_control_frame_t *cfp, IC ic, const ID *segments)
 
 // For RJIT inlining
 static inline bool
-vm_inlined_ic_hit_p(VALUE flags, VALUE value, const rb_cref_t *ic_cref, const VALUE *reg_ep)
+vm_inlined_ic_hit_p(uintptr_t flags, VALUE value, const rb_cref_t *ic_cref, const VALUE *reg_ep)
 {
     if ((flags & IMEMO_CONST_CACHE_SHAREABLE) || rb_ractor_main_p()) {
         VM_ASSERT(ractor_incidental_shareable_p(flags & IMEMO_CONST_CACHE_SHAREABLE, value));
@@ -6282,7 +6282,7 @@ vm_opt_and(VALUE recv, VALUE obj)
     // will be 1 on both.  1 & 1 == 1, so the result value will also
     // be a fixnum.  If either side is *not* a fixnum, then the tag bit
     // will be 0, and we return Qundef.
-    VALUE ret = ((SIGNED_VALUE) recv) & ((SIGNED_VALUE) obj);
+    VALUE ret = (VALUE)(((SIGNED_VALUE) recv) & ((SIGNED_VALUE) obj));
 
     if (FIXNUM_P(ret) &&
         BASIC_OP_UNREDEFINED_P(BOP_AND, INTEGER_REDEFINED_OP_FLAG)) {
@@ -6298,7 +6298,7 @@ vm_opt_or(VALUE recv, VALUE obj)
 {
     if (FIXNUM_2_P(recv, obj) &&
         BASIC_OP_UNREDEFINED_P(BOP_OR, INTEGER_REDEFINED_OP_FLAG)) {
-        return recv | obj;
+        return (VALUE)((uintptr_t)recv | (uintptr_t)obj);
     }
     else {
         return Qundef;
@@ -6419,9 +6419,9 @@ vm_opt_length(VALUE recv, int bop)
 static VALUE
 vm_opt_empty_p(VALUE recv)
 {
-    switch (vm_opt_length(recv, BOP_EMPTY_P)) {
-      case Qundef: return Qundef;
-      case INT2FIX(0): return Qtrue;
+    switch ((uintptr_t)vm_opt_length(recv, BOP_EMPTY_P)) {
+      case (uintptr_t)Qundef: return Qundef;
+      case (uintptr_t)INT2FIX(0): return Qtrue;
       default: return Qfalse;
     }
 }
@@ -6446,12 +6446,12 @@ vm_opt_nil_p(const rb_iseq_t *iseq, CALL_DATA cd, VALUE recv)
 static VALUE
 fix_succ(VALUE x)
 {
-    switch (x) {
-      case ~0UL:
+    switch ((uintptr_t)x) {
+      case (uintptr_t)~0UL:
         /* 0xFFFF_FFFF == INT2FIX(-1)
          * `-1.succ` is of course 0. */
         return INT2FIX(0);
-      case RSHIFT(~0UL, 1):
+      case (uintptr_t)RSHIFT(~0UL, 1):
         /* 0x7FFF_FFFF == LONG2FIX(0x3FFF_FFFF)
          * 0x3FFF_FFFF + 1 == 0x4000_0000, which is a Bignum. */
         return rb_uint2big(1UL << (SIZEOF_LONG * CHAR_BIT - 2));
diff --git a/vm_insnhelper.h b/vm_insnhelper.h
index e4a6c5b492ac..b3bb7a2498fb 100644
--- a/vm_insnhelper.h
+++ b/vm_insnhelper.h
@@ -107,7 +107,7 @@ enum vm_regan_acttype {
 /* deal with variables                                    */
 /**********************************************************/
 
-#define GET_PREV_EP(ep)                ((VALUE *)((ep)[VM_ENV_DATA_INDEX_SPECVAL] & ~0x03))
+#define GET_PREV_EP(ep)                ((VALUE *)((uintptr_t)(ep)[VM_ENV_DATA_INDEX_SPECVAL] & ~0x03))
 
 /**********************************************************/
 /* deal with values                                       */
@@ -224,6 +224,246 @@ THROW_DATA_CATCH_FRAME_SET(struct vm_throw_data *obj, const rb_control_frame_t *
 
 static inline void
 THROW_DATA_STATE_SET(struct vm_throw_data *obj, int st)
+#ifndef INTERNAL_IMEMO_H                                 /*-*-C-*-vi:se ft=c:*/
+#define INTERNAL_IMEMO_H
+/**
+ * @author     Ruby developers <ruby-core@ruby-lang.org>
+ * @copyright  This  file  is   a  part  of  the   programming  language  Ruby.
+ *             Permission  is hereby  granted,  to  either redistribute  and/or
+ *             modify this file, provided that  the conditions mentioned in the
+ *             file COPYING are met.  Consult the file for details.
+ * @brief      IMEMO: Internal memo object.
+ */
+#include "ruby/internal/config.h"
+#include <stddef.h>             /* for size_t */
+#include "internal/array.h"     /* for rb_ary_hidden_new_fill */
+#include "ruby/internal/stdbool.h"     /* for bool */
+#include "ruby/ruby.h"          /* for rb_block_call_func_t */
+
+#ifndef IMEMO_DEBUG
+# define IMEMO_DEBUG 0
+#endif
+
+#define IMEMO_MASK   0x0f
+
+/* FL_USER0 to FL_USER3 is for type */
+#define IMEMO_FL_USHIFT (FL_USHIFT + 4)
+#define IMEMO_FL_USER0 FL_USER4
+#define IMEMO_FL_USER1 FL_USER5
+#define IMEMO_FL_USER2 FL_USER6
+#define IMEMO_FL_USER3 FL_USER7
+#define IMEMO_FL_USER4 FL_USER8
+#define IMEMO_FL_USER5 FL_USER9
+
+enum imemo_type {
+    imemo_env            =  0,
+    imemo_cref           =  1, /*!< class reference */
+    imemo_svar           =  2, /*!< special variable */
+    imemo_throw_data     =  3,
+    imemo_ifunc          =  4, /*!< iterator function */
+    imemo_memo           =  5,
+    imemo_ment           =  6,
+    imemo_iseq           =  7,
+    imemo_tmpbuf         =  8,
+    imemo_ast            =  9,
+    imemo_parser_strterm = 10,
+    imemo_callinfo       = 11,
+    imemo_callcache      = 12,
+    imemo_constcache     = 13,
+};
+
+/* CREF (Class REFerence) is defined in method.h */
+
+/*! SVAR (Special VARiable) */
+struct vm_svar {
+    VALUE flags;
+    const VALUE cref_or_me; /*!< class reference or rb_method_entry_t */
+    const VALUE lastline;
+    const VALUE backref;
+    const VALUE others;
+};
+
+/*! THROW_DATA */
+struct vm_throw_data {
+    uintptr_t flags;
+    VALUE reserved;
+    const VALUE throw_obj;
+    const struct rb_control_frame_struct *catch_frame;
+    int throw_state;
+};
+
+#define THROW_DATA_CONSUMED IMEMO_FL_USER0
+
+/* IFUNC (Internal FUNCtion) */
+
+struct vm_ifunc_argc {
+#if SIZEOF_INT * 2 > SIZEOF_VALUE
+    signed int min: (SIZEOF_VALUE * CHAR_BIT) / 2;
+    signed int max: (SIZEOF_VALUE * CHAR_BIT) / 2;
+#else
+    int min, max;
+#endif
+};
+
+/*! IFUNC (Internal FUNCtion) */
+struct vm_ifunc {
+    VALUE flags;
+    VALUE *svar_lep;
+    rb_block_call_func_t func;
+    const void *data;
+    struct vm_ifunc_argc argc;
+};
+
+struct rb_imemo_tmpbuf_struct {
+    VALUE flags;
+    VALUE reserved;
+    VALUE *ptr; /* malloc'ed buffer */
+    struct rb_imemo_tmpbuf_struct *next; /* next imemo */
+    size_t cnt; /* buffer size in VALUE */
+};
+
+/*! MEMO
+ *
+ * @see imemo_type
+ * */
+struct MEMO {
+    uintptr_t flags;
+    VALUE reserved;
+    const VALUE v1;
+    const VALUE v2;
+    union {
+        long cnt;
+        long state;
+        const VALUE value;
+        void (*func)(void);
+    } u3;
+};
+
+/* ment is in method.h */
+
+#define THROW_DATA_P(err) imemo_throw_data_p((VALUE)err)
+#define MEMO_CAST(m) ((struct MEMO *)(m))
+#define MEMO_NEW(a, b, c) ((struct MEMO *)rb_imemo_new(imemo_memo, (VALUE)(a), (VALUE)(b), (VALUE)(c), 0))
+#define MEMO_FOR(type, value) ((type *)RARRAY_PTR(value))
+#define NEW_MEMO_FOR(type, value) \
+  ((value) = rb_ary_hidden_new_fill(type_roomof(type, VALUE)), MEMO_FOR(type, value))
+#define NEW_PARTIAL_MEMO_FOR(type, value, member) \
+  ((value) = rb_ary_hidden_new_fill(type_roomof(type, VALUE)), \
+   rb_ary_set_len((value), offsetof(type, member) / sizeof(VALUE)), \
+   MEMO_FOR(type, value))
+
+typedef struct rb_imemo_tmpbuf_struct rb_imemo_tmpbuf_t;
+rb_imemo_tmpbuf_t *rb_imemo_tmpbuf_parser_heap(void *buf, rb_imemo_tmpbuf_t *old_heap, size_t cnt);
+struct vm_ifunc *rb_vm_ifunc_new(rb_block_call_func_t func, const void *data, int min_argc, int max_argc);
+static inline enum imemo_type imemo_type(VALUE imemo);
+static inline int imemo_type_p(VALUE imemo, enum imemo_type imemo_type);
+static inline bool imemo_throw_data_p(VALUE imemo);
+static inline struct vm_ifunc *rb_vm_ifunc_proc_new(rb_block_call_func_t func, const void *data);
+static inline VALUE rb_imemo_tmpbuf_auto_free_pointer(void);
+static inline void *RB_IMEMO_TMPBUF_PTR(VALUE v);
+static inline void *rb_imemo_tmpbuf_set_ptr(VALUE v, void *ptr);
+static inline VALUE rb_imemo_tmpbuf_auto_free_pointer_new_from_an_RString(VALUE str);
+static inline void MEMO_V1_SET(struct MEMO *m, VALUE v);
+static inline void MEMO_V2_SET(struct MEMO *m, VALUE v);
+
+RUBY_SYMBOL_EXPORT_BEGIN
+#if IMEMO_DEBUG
+VALUE rb_imemo_new_debug(enum imemo_type type, VALUE v1, VALUE v2, VALUE v3, VALUE v0, const char *file, int line);
+#define rb_imemo_new(type, v1, v2, v3, v0) rb_imemo_new_debug(type, v1, v2, v3, v0, __FILE__, __LINE__)
+#else
+VALUE rb_imemo_new(enum imemo_type type, VALUE v1, VALUE v2, VALUE v3, VALUE v0);
+#endif
+const char *rb_imemo_name(enum imemo_type type);
+RUBY_SYMBOL_EXPORT_END
+
+static inline enum imemo_type
+imemo_type(VALUE imemo)
+{
+    return (RBASIC(imemo)->flags >> FL_USHIFT) & IMEMO_MASK;
+}
+
+static inline int
+imemo_type_p(VALUE imemo, enum imemo_type imemo_type)
+{
+    if (LIKELY(!RB_SPECIAL_CONST_P(imemo))) {
+        /* fixed at compile time if imemo_type is given. */
+        const uintptr_t mask = (IMEMO_MASK << FL_USHIFT) | RUBY_T_MASK;
+        const uintptr_t expected_type = (imemo_type << FL_USHIFT) | T_IMEMO;
+        /* fixed at runtime. */
+        return expected_type == (RBASIC(imemo)->flags & mask);
+    }
+    else {
+        return 0;
+    }
+}
+
+#define IMEMO_TYPE_P(v, t) imemo_type_p((VALUE)v, t)
+
+static inline bool
+imemo_throw_data_p(VALUE imemo)
+{
+    return RB_TYPE_P(imemo, T_IMEMO);
+}
+
+static inline struct vm_ifunc *
+rb_vm_ifunc_proc_new(rb_block_call_func_t func, const void *data)
+{
+    return rb_vm_ifunc_new(func, data, 0, UNLIMITED_ARGUMENTS);
+}
+
+static inline VALUE
+rb_imemo_tmpbuf_auto_free_pointer(void)
+{
+    return rb_imemo_new(imemo_tmpbuf, 0, 0, 0, 0);
+}
+
+static inline void *
+RB_IMEMO_TMPBUF_PTR(VALUE v)
+{
+    const struct rb_imemo_tmpbuf_struct *p = (const void *)v;
+    return p->ptr;
+}
+
+static inline void *
+rb_imemo_tmpbuf_set_ptr(VALUE v, void *ptr)
+{
+    return ((rb_imemo_tmpbuf_t *)v)->ptr = ptr;
+}
+
+static inline VALUE
+rb_imemo_tmpbuf_auto_free_pointer_new_from_an_RString(VALUE str)
+{
+    const void *src;
+    VALUE imemo;
+    rb_imemo_tmpbuf_t *tmpbuf;
+    void *dst;
+    size_t len;
+
+    SafeStringValue(str);
+    /* create tmpbuf to keep the pointer before xmalloc */
+    imemo = rb_imemo_tmpbuf_auto_free_pointer();
+    tmpbuf = (rb_imemo_tmpbuf_t *)imemo;
+    len = RSTRING_LEN(str);
+    src = RSTRING_PTR(str);
+    dst = ruby_xmalloc(len);
+    memcpy(dst, src, len);
+    tmpbuf->ptr = dst;
+    return imemo;
+}
+
+static inline void
+MEMO_V1_SET(struct MEMO *m, VALUE v)
+{
+    RB_OBJ_WRITE(m, &m->v1, v);
+}
+
+static inline void
+MEMO_V2_SET(struct MEMO *m, VALUE v)
+{
+    RB_OBJ_WRITE(m, &m->v2, v);
+}
+
+#endif /* INTERNAL_IMEMO_H */
 {
     VM_ASSERT(THROW_DATA_P(obj));
     obj->throw_state = st;
diff --git a/vm_method.c b/vm_method.c
index d09c7aab9b6e..1f67d52d4542 100644
--- a/vm_method.c
+++ b/vm_method.c
@@ -300,10 +300,10 @@ rb_clear_method_cache(VALUE klass_or_module, ID mid)
         if (FL_TEST(module, RMODULE_IS_REFINEMENT)) {
             VALUE refined_class = rb_refinement_module_get_refined_class(module);
             rb_clear_method_cache(refined_class, mid);
-            rb_class_foreach_subclass(refined_class, clear_iclass_method_cache_by_id_for_refinements, mid);
+            rb_class_foreach_subclass(refined_class, clear_iclass_method_cache_by_id_for_refinements, (VALUE)mid);
             rb_clear_all_refinement_method_cache();
         }
-        rb_class_foreach_subclass(module, clear_iclass_method_cache_by_id, mid);
+        rb_class_foreach_subclass(module, clear_iclass_method_cache_by_id, (VALUE)mid);
     }
     else {
         clear_method_cache_by_id_in_class(klass_or_module, mid);
@@ -347,7 +347,7 @@ vm_ci_hash(VALUE v)
     h = rb_hash_uint(h, ci->argc);
     if (ci->kwarg) {
         for (int i = 0; i < ci->kwarg->keyword_len; i++) {
-            h = rb_hash_uint(h, ci->kwarg->keywords[i]);
+            h = (st_index_t)rb_hash_uint(h, (uintptr_t)ci->kwarg->keywords[i]);
         }
     }
     return h;
@@ -2358,7 +2358,7 @@ rb_mod_alias_method(VALUE mod, VALUE newname, VALUE oldname)
     if (!oldid) {
         rb_print_undef_str(mod, oldname);
     }
-    VALUE id = rb_to_id(newname);
+    ID id = rb_to_id(newname);
     rb_alias(mod, id, oldid);
     return ID2SYM(id);
 }
@@ -2830,7 +2830,7 @@ call_method_entry(rb_execution_context_t *ec, VALUE defined_class, VALUE obj, ID
                   const rb_callable_method_entry_t *cme, int argc, const VALUE *argv, int kw_splat)
 {
     VALUE passed_block_handler = vm_passed_block_handler(ec);
-    VALUE result = rb_vm_call_kw(ec, obj, id, argc, argv, cme, kw_splat);
+    VALUE result = rb_vm_call_kw(ec, obj, (VALUE)id, argc, argv, cme, kw_splat);
     vm_passed_block_handler_set(ec, passed_block_handler);
     return result;
 }
diff --git a/vsnprintf.c b/vsnprintf.c
index ecd5573dd581..c5fe06cf7de1 100644
--- a/vsnprintf.c
+++ b/vsnprintf.c
@@ -551,6 +551,7 @@ BSD_vfprintf(FILE *fp, const char *fmt0, va_list ap)
 	char expstr[7];		/* buffer for exponent string */
 #endif
 	u_long MAYBE_UNUSED(ulval) = 0; /* integer arguments %[diouxX] */
+        void *MAYBE_UNUSED(pval) = NULL;
 #ifdef _HAVE_SANE_QUAD_
 	u_quad_t MAYBE_UNUSED(uqval) = 0; /* %q integers */
 #endif /* _HAVE_SANE_QUAD_ */
@@ -822,7 +823,10 @@ reswitch:	switch (ch) {
 			    IS_PRI_EXTRA_MARK(fmt)) {
 				fmt += PRI_EXTRA_MARK_LEN;
 				FLUSH();
-#if defined _HAVE_SANE_QUAD_ && SIZEOF_VOIDP == SIZEOF_LONG_LONG
+#if defined __FILC__
+                                pval = va_arg(ap, void*);
+				cp = (*fp->vextra)(fp, sizeof(pval), &pval, &fieldsz, sign);
+#elif defined _HAVE_SANE_QUAD_ && SIZEOF_VOIDP == SIZEOF_LONG_LONG
 				uqval = va_arg(ap, u_quad_t);
 				cp = (*fp->vextra)(fp, sizeof(uqval), &uqval, &fieldsz, sign);
 #else
