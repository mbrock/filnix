diff --git a/.bundle/gems/racc-1.7.3/ext/racc/cparse/cparse.c b/.bundle/gems/racc-1.7.3/ext/racc/cparse/cparse.c
index 7d9319be2234..3f64925d325d 100644
--- a/.bundle/gems/racc-1.7.3/ext/racc/cparse/cparse.c
+++ b/.bundle/gems/racc-1.7.3/ext/racc/cparse/cparse.c
@@ -645,7 +645,7 @@ parse_main(struct cparse_params *v, VALUE tok, VALUE val, int resume)
     /* shift/reduce error token */
     if (act > 0 && act < v->shift_n) {
         D_puts("e shift");
-        SHIFT(v, act, ERROR_TOKEN, val);
+        SHIFT(v, act, (VALUE)ERROR_TOKEN, val);
     }
     else if (act < 0 && act > -(v->reduce_n)) {
         D_puts("e reduce");
diff --git a/array.c b/array.c
index e1b855356849..274672131984 100644
--- a/array.c
+++ b/array.c
@@ -1854,10 +1854,10 @@ rb_ary_aref1(VALUE ary, VALUE arg)
         return rb_ary_entry(ary, FIX2LONG(arg));
     }
     /* check if idx is Range or ArithmeticSequence */
-    switch (rb_arithmetic_sequence_beg_len_step(arg, &beg, &len, &step, RARRAY_LEN(ary), 0)) {
-      case Qfalse:
+    switch ((uintptr_t)rb_arithmetic_sequence_beg_len_step(arg, &beg, &len, &step, RARRAY_LEN(ary), 0)) {
+      case (uintptr_t)Qfalse:
         break;
-      case Qnil:
+      case (uintptr_t)Qnil:
         return Qnil;
       default:
         return rb_ary_subseq_step(ary, beg, len, step);
@@ -4190,11 +4190,11 @@ rb_ary_slice_bang(int argc, VALUE *argv, VALUE ary)
     }
 
     if (!FIXNUM_P(arg1)) {
-        switch (rb_range_beg_len(arg1, &pos, &len, RARRAY_LEN(ary), 0)) {
-          case Qtrue:
+        switch ((uintptr_t)rb_range_beg_len(arg1, &pos, &len, RARRAY_LEN(ary), 0)) {
+          case (uintptr_t)Qtrue:
             /* valid range */
             return ary_slice_bang_by_rb_ary_splice(ary, pos, len);
-          case Qnil:
+          case (uintptr_t)Qnil:
             /* invalid range */
             return Qnil;
           default:
@@ -6613,7 +6613,7 @@ ary_sample(rb_execution_context_t *ec, VALUE ary, VALUE randgen, VALUE nv, VALUE
         RARRAY_PTR_USE(result, ptr_result, {
             for (i=0; i<n; i++) {
                 long r = RAND_UPTO(len-i) + i;
-                ptr_result[i] = r;
+                ptr_result[i] = (VALUE)r;
                 if (r > max_idx) max_idx = r;
             }
             len = RARRAY_LEN(ary);
@@ -6621,7 +6621,7 @@ ary_sample(rb_execution_context_t *ec, VALUE ary, VALUE randgen, VALUE nv, VALUE
             else if (n > len) n = len;
             RARRAY_PTR_USE(ary, ptr_ary, {
                 for (i=0; i<n; i++) {
-                    long j2 = j = ptr_result[i];
+                    long j2 = j = (long)ptr_result[i];
                     long i2 = i;
                     st_data_t value;
                     if (st_lookup(memo, (st_data_t)i, &value)) i2 = (long)value;
diff --git a/bignum.c b/bignum.c
index bc48697bf4ad..30c8750042ed 100644
--- a/bignum.c
+++ b/bignum.c
@@ -3216,11 +3216,11 @@ VALUE
 rb_int2big(intptr_t n)
 {
     long neg = 0;
-    VALUE u;
+    uintptr_t u;
     VALUE big;
 
     if (n < 0) {
-        u = 1 + (VALUE)(-(n + 1)); /* u = -n avoiding overflow */
+        u = 1 + (uintptr_t)(-(n + 1)); /* u = -n avoiding overflow */
         neg = 1;
     }
     else {
diff --git a/class.c b/class.c
index b2a219100cc8..c8eb7c2f9fb3 100644
--- a/class.c
+++ b/class.c
@@ -227,7 +227,7 @@ rb_class_detach_module_subclasses(VALUE klass)
  * \note this function is not Class#allocate.
  */
 static VALUE
-class_alloc(VALUE flags, VALUE klass)
+class_alloc(uintptr_t flags, VALUE klass)
 {
     size_t alloc_size = sizeof(struct RClass) + sizeof(rb_classext_t);
 
@@ -474,7 +474,7 @@ copy_tables(VALUE clone, VALUE orig)
     rb_id_table_free(RCLASS_M_TBL(clone));
     RCLASS_M_TBL(clone) = 0;
     if (!RB_TYPE_P(clone, T_ICLASS)) {
-        st_data_t id;
+        ID id;
 
         rb_iv_tbl_copy(clone, orig);
         CONST_ID(id, "__tmp_classpath__");
@@ -1784,7 +1784,7 @@ method_entry_i(ID key, VALUE value, void *data)
         if (!me) return ID_TABLE_CONTINUE;
         if (!arg->recur && me->owner != owner) return ID_TABLE_CONTINUE;
     }
-    if (!st_is_member(arg->list, key)) {
+    if (!st_is_member(arg->list, (st_data_t)key)) {
         if (UNDEFINED_METHOD_ENTRY_P(me)) {
             type = METHOD_VISI_UNDEF; /* none */
         }
@@ -1792,7 +1792,7 @@ method_entry_i(ID key, VALUE value, void *data)
             type = METHOD_ENTRY_VISI(me);
             RUBY_ASSERT(type != METHOD_VISI_UNDEF);
         }
-        st_add_direct(arg->list, key, (st_data_t)type);
+        st_add_direct(arg->list, (st_data_t)key, (st_data_t)type);
     }
     return ID_TABLE_CONTINUE;
 }
@@ -2188,10 +2188,10 @@ rb_undef_methods_from(VALUE klass, VALUE super)
 static inline VALUE
 special_singleton_class_of(VALUE obj)
 {
-    switch (obj) {
-      case Qnil:   return rb_cNilClass;
-      case Qfalse: return rb_cFalseClass;
-      case Qtrue:  return rb_cTrueClass;
+    switch ((uintptr_t)obj) {
+      case (uintptr_t)Qnil:   return rb_cNilClass;
+      case (uintptr_t)Qfalse: return rb_cFalseClass;
+      case (uintptr_t)Qtrue:  return rb_cTrueClass;
       default:     return Qnil;
     }
 }
diff --git a/compile.c b/compile.c
index 504afbc59224..63da697d8e21 100644
--- a/compile.c
+++ b/compile.c
@@ -40,6 +40,7 @@
 #include "vm_callinfo.h"
 #include "vm_debug.h"
 #include "yjit.h"
+#include <stdfil.h>
 
 #include "builtin.h"
 #include "insns.inc"
@@ -48,8 +49,8 @@
 #undef RUBY_UNTYPED_DATA_WARNING
 #define RUBY_UNTYPED_DATA_WARNING 0
 
-#define FIXNUM_INC(n, i) ((n)+(INT2FIX(i)&~FIXNUM_FLAG))
-#define FIXNUM_OR(n, i) ((n)|INT2FIX(i))
+#define FIXNUM_INC(n, i) ((VALUE)((n)+((uintptr_t)INT2FIX(i)&~FIXNUM_FLAG)))
+#define FIXNUM_OR(n, i) ((VALUE)((n)|(uintptr_t)INT2FIX(i)))
 
 typedef struct iseq_link_element {
     enum {
@@ -308,8 +309,8 @@ static void iseq_add_setlocal(rb_iseq_t *iseq, LINK_ANCHOR *const seq, const NOD
     ((label) ? (LABEL_REF(label), (label)->unremovable=1) : 0)
 #define ADD_CATCH_ENTRY(type, ls, le, iseqv, lc) do {				\
     VALUE _e = rb_ary_new3(5, (type),						\
-                           (VALUE)(ls) | 1, (VALUE)(le) | 1,			\
-                           (VALUE)(iseqv), (VALUE)(lc) | 1);			\
+                           zorptr((ls), 1), zorptr((le), 1),            \
+                           (VALUE)(iseqv), zorptr((lc), 1));           \
     LABEL_UNREMOVABLE(ls);							\
     LABEL_REF(le);								\
     LABEL_REF(lc);								\
@@ -622,7 +623,7 @@ decl_branch_base(rb_iseq_t *iseq, const NODE *node, const char *type)
      */
 
     VALUE structure = RARRAY_AREF(ISEQ_BRANCH_COVERAGE(iseq), 0);
-    VALUE key = (VALUE)node | 1; // FIXNUM for hash key
+    VALUE key = zorptr(node, 1); // FIXNUM for hash key
     VALUE branch_base = rb_hash_aref(structure, key);
     VALUE branches;
 
@@ -844,7 +845,7 @@ rb_iseq_compile_callback(rb_iseq_t *iseq, const struct rb_iseq_new_with_callback
     ADD_INSN(ret, &dummy_line_node, leave);
 
     CHECK(iseq_setup_insn(iseq, ret));
-    return iseq_setup(iseq, ret);
+    return (VALUE)iseq_setup(iseq, ret);
 }
 
 VALUE
@@ -964,7 +965,7 @@ rb_iseq_compile_node(rb_iseq_t *iseq, const NODE *node)
     }
 #endif
     CHECK(iseq_setup_insn(iseq, ret));
-    return iseq_setup(iseq, ret);
+    return (VALUE)iseq_setup(iseq, ret);
 }
 
 static VALUE rb_translate_prism(pm_parser_t *parser, rb_iseq_t *iseq, pm_scope_node_t *scope_node, LINK_ANCHOR *const ret);
@@ -978,7 +979,7 @@ rb_iseq_compile_prism_node(rb_iseq_t * iseq, pm_scope_node_t *scope_node, pm_par
     CHECK(rb_translate_prism(parser, iseq, scope_node, ret));
 
     CHECK(iseq_setup_insn(iseq, ret));
-    return iseq_setup(iseq, ret);
+    return (VALUE)iseq_setup(iseq, ret);
 }
 
 static int
@@ -1022,7 +1023,7 @@ rb_iseq_original_iseq(const rb_iseq_t *iseq) /* cold path */
             const void *addr = (const void *)original_code[i];
             const int insn = rb_vm_insn_addr2insn(addr);
 
-            original_code[i] = insn;
+            original_code[i] = (VALUE)insn;
             i += insn_len(insn);
         }
     }
@@ -1376,7 +1377,7 @@ new_adjust_body(rb_iseq_t *iseq, LABEL *label, int line)
 static void
 iseq_insn_each_markable_object(INSN *insn, void (*func)(VALUE, VALUE), VALUE data)
 {
-    const char *types = insn_op_types(insn->insn_id);
+    const char *types = insn_op_types((uintptr_t)insn->insn_id);
     for (int j = 0; types[j]; j++) {
         char type = types[j];
         switch (type) {
@@ -1578,11 +1579,11 @@ iseq_insert_nop_between_end_and_cont(rb_iseq_t *iseq)
     const VALUE *tptr = RARRAY_CONST_PTR(catch_table_ary);
     for (i = 0; i < tlen; i++) {
         const VALUE *ptr = RARRAY_CONST_PTR(tptr[i]);
-        LINK_ELEMENT *end = (LINK_ELEMENT *)(ptr[2] & ~1);
-        LINK_ELEMENT *cont = (LINK_ELEMENT *)(ptr[4] & ~1);
+        LINK_ELEMENT *end = (LINK_ELEMENT *)zandptr(ptr[2], ~1);
+        LINK_ELEMENT *cont = (LINK_ELEMENT *)zandptr(ptr[4], ~1);
         LINK_ELEMENT *e;
 
-        enum rb_catch_type ct = (enum rb_catch_type)(ptr[0] & 0xffff);
+        enum rb_catch_type ct = (enum rb_catch_type)((uintptr_t)ptr[0] & 0xffff);
 
         if (ct != CATCH_TYPE_BREAK
             && ct != CATCH_TYPE_NEXT
@@ -2012,7 +2013,7 @@ iseq_set_arguments(rb_iseq_t *iseq, LINK_ANCHOR *const optargs, const NODE *cons
 
             while (node) {
                 label = NEW_LABEL(nd_line(RNODE(node)));
-                rb_ary_push(labels, (VALUE)label | 1);
+                rb_ary_push(labels, zorptr(label, 1));
                 ADD_LABEL(optargs, label);
                 NO_CHECK(COMPILE_POPPED(optargs, "optarg", node->nd_body));
                 node = node->nd_next;
@@ -2021,14 +2022,14 @@ iseq_set_arguments(rb_iseq_t *iseq, LINK_ANCHOR *const optargs, const NODE *cons
 
             /* last label */
             label = NEW_LABEL(nd_line(node_args));
-            rb_ary_push(labels, (VALUE)label | 1);
+            rb_ary_push(labels, zorptr(label, 1));
             ADD_LABEL(optargs, label);
 
             opt_table = ALLOC_N(VALUE, i+1);
 
             MEMCPY(opt_table, RARRAY_CONST_PTR(labels), VALUE, i+1);
             for (j = 0; j < i+1; j++) {
-                opt_table[j] &= ~1;
+                opt_table[j] = zandptr(opt_table[j], ~1);
             }
             rb_ary_clear(labels);
 
@@ -2208,7 +2209,7 @@ static int
 cdhash_set_label_i(VALUE key, VALUE val, VALUE ptr)
 {
     struct cdhash_set_label_struct *data = (struct cdhash_set_label_struct *)ptr;
-    LABEL *lobj = (LABEL *)(val & ~1);
+    LABEL *lobj = (LABEL *)zandptr(val, ~1);
     rb_hash_aset(data->hash, key, INT2FIX(lobj->position - (data->pos+data->len)));
     return ST_CONTINUE;
 }
@@ -2556,7 +2557,7 @@ iseq_set_sequence(rb_iseq_t *iseq, LINK_ANCHOR *const anchor)
                 /* fprintf(stderr, "insn: %-16s, sp: %d\n", insn_name(iobj->insn_id), sp); */
                 operands = iobj->operands;
                 insn = iobj->insn_id;
-                generated_iseq[code_index] = insn;
+                generated_iseq[code_index] = (VALUE)insn;
                 types = insn_op_types(insn);
                 len = insn_len(insn);
 
@@ -2569,7 +2570,7 @@ iseq_set_sequence(rb_iseq_t *iseq, LINK_ANCHOR *const anchor)
                         {
                             /* label(destination position) */
                             LABEL *lobj = (LABEL *)operands[j];
-                            generated_iseq[code_index + 1 + j] = lobj->position - (code_index + len);
+                            generated_iseq[code_index + 1 + j] = (VALUE)(lobj->position - (code_index + len));
                             break;
                         }
                       case TS_CDHASH:
@@ -2591,7 +2592,7 @@ iseq_set_sequence(rb_iseq_t *iseq, LINK_ANCHOR *const anchor)
                         }
                       case TS_LINDEX:
                       case TS_NUM:	/* ulong */
-                        generated_iseq[code_index + 1 + j] = FIX2INT(operands[j]);
+                        generated_iseq[code_index + 1 + j] = (VALUE)FIX2INT(operands[j]);
                         break;
                       case TS_ISEQ:	/* iseq */
                       case TS_VALUE:	/* VALUE */
@@ -2664,7 +2665,7 @@ iseq_set_sequence(rb_iseq_t *iseq, LINK_ANCHOR *const anchor)
                             break;
                         }
                       case TS_ID: /* ID */
-                        generated_iseq[code_index + 1 + j] = SYM2ID(operands[j]);
+                        generated_iseq[code_index + 1 + j] = (VALUE)SYM2ID(operands[j]);
                         break;
                       case TS_FUNCPTR:
                         generated_iseq[code_index + 1 + j] = operands[j];
@@ -2715,11 +2716,11 @@ iseq_set_sequence(rb_iseq_t *iseq, LINK_ANCHOR *const anchor)
                         if (add_adjust_info(insns_info, positions, insns_info_index, code_index, adjust)) insns_info_index++;
                     }
                     if (diff > 1) {
-                        generated_iseq[code_index++] = BIN(adjuststack);
-                        generated_iseq[code_index++] = orig_sp - sp;
+                        generated_iseq[code_index++] = (VALUE)BIN(adjuststack);
+                        generated_iseq[code_index++] = (VALUE)(orig_sp - sp);
                     }
                     else if (diff == 1) {
-                        generated_iseq[code_index++] = BIN(pop);
+                        generated_iseq[code_index++] = (VALUE)BIN(pop);
                     }
                     else if (diff < 0) {
                         int label_no = adjust->label ? adjust->label->label_no : -1;
@@ -2808,15 +2809,15 @@ iseq_set_exception_table(rb_iseq_t *iseq)
         for (i = 0; i < table->size; i++) {
             ptr = RARRAY_CONST_PTR(tptr[i]);
             entry = UNALIGNED_MEMBER_PTR(table, entries[i]);
-            entry->type = (enum rb_catch_type)(ptr[0] & 0xffff);
-            entry->start = label_get_position((LABEL *)(ptr[1] & ~1));
-            entry->end = label_get_position((LABEL *)(ptr[2] & ~1));
+            entry->type = (enum rb_catch_type)((uintptr_t)ptr[0] & 0xffff);
+            entry->start = label_get_position((LABEL *)zandptr(ptr[1], ~1));
+            entry->end = label_get_position((LABEL *)zandptr(ptr[2], ~1));
             entry->iseq = (rb_iseq_t *)ptr[3];
             RB_OBJ_WRITTEN(iseq, Qundef, entry->iseq);
 
             /* stack depth */
             if (ptr[4]) {
-                LABEL *lobj = (LABEL *)(ptr[4] & ~1);
+                LABEL *lobj = (LABEL *)zandptr(ptr[4], ~1);
                 entry->cont = label_get_position(lobj);
                 entry->sp = label_get_sp(lobj);
 
@@ -2857,7 +2858,7 @@ iseq_set_optargs_table(rb_iseq_t *iseq)
 
     if (ISEQ_BODY(iseq)->param.flags.has_opt) {
         for (i = 0; i < ISEQ_BODY(iseq)->param.opt_num + 1; i++) {
-            opt_table[i] = label_get_position((LABEL *)opt_table[i]);
+            opt_table[i] = (VALUE)label_get_position((LABEL *)opt_table[i]);
         }
     }
     return COMPILE_OK;
@@ -2999,7 +3000,7 @@ remove_unreachable_chunk(rb_iseq_t *iseq, LINK_ELEMENT *i)
     do {
         if (IS_INSN(i)) {
             struct rb_iseq_constant_body *body = ISEQ_BODY(iseq);
-            VALUE insn = INSN_OF(i);
+            uintptr_t insn = INSN_OF(i);
             int pos, len = insn_len(insn);
             for (pos = 0; pos < len; ++pos) {
                 switch (insn_op_types(insn)[pos]) {
@@ -3020,11 +3021,11 @@ remove_unreachable_chunk(rb_iseq_t *iseq, LINK_ELEMENT *i)
 static int
 iseq_pop_newarray(rb_iseq_t *iseq, INSN *iobj)
 {
-    switch (OPERAND_AT(iobj, 0)) {
-      case INT2FIX(0): /* empty array */
+    switch ((uintptr_t)OPERAND_AT(iobj, 0)) {
+      case (uintptr_t)INT2FIX(0): /* empty array */
         ELEM_REMOVE(&iobj->link);
         return TRUE;
-      case INT2FIX(1): /* single element array */
+      case (uintptr_t)INT2FIX(1): /* single element array */
         ELEM_REMOVE(&iobj->link);
         return FALSE;
       default:
@@ -5074,7 +5075,7 @@ when_vals(rb_iseq_t *iseq, LINK_ANCHOR *const cond_seq, const NODE *vals,
             only_special_literals = 0;
         }
         else if (NIL_P(rb_hash_lookup(literals, lit))) {
-            rb_hash_aset(literals, lit, (VALUE)(l1) | 1);
+            rb_hash_aset(literals, lit, zorptr(l1, 1));
         }
 
         if (nd_type_p(val, NODE_STR)) {
@@ -5409,9 +5410,9 @@ compile_massign_opt(rb_iseq_t *iseq, LINK_ANCHOR *const ret,
     int i; \
     if (memindex == memsize) return 0; \
     for (i=0; i<memindex; i++) { \
-        if (mem[i] == (v)) return 0; \
+        if (mem[i] == (VALUE)(v)) return 0; \
     } \
-    mem[memindex++] = (v); \
+    mem[memindex++] = (VALUE)(v); \
 }
 
     if (rhsn == 0 || !nd_type_p(rhsn, NODE_LIST)) {
@@ -6146,7 +6147,7 @@ setup_args_core(rb_iseq_t *iseq, LINK_ANCHOR *const args, const NODE *argn,
         return argc;
       }
       default: {
-        UNKNOWN_NODE("setup_arg", argn, Qnil);
+        UNKNOWN_NODE("setup_arg", argn, 0);
       }
     }
 }
@@ -7682,7 +7683,7 @@ compile_loop(rb_iseq_t *iseq, LINK_ANCHOR *const ret, const NODE *const node, in
     ADD_LABEL(ret, end_label);
     ADD_ADJUST_RESTORE(ret, adjust_label);
 
-    if (UNDEF_P(RNODE_WHILE(node)->nd_state)) {
+    if (UNDEF_P((VALUE)RNODE_WHILE(node)->nd_state)) {
         /* ADD_INSN(ret, line_node, putundef); */
         COMPILE_ERROR(ERROR_ARGS "unsupported: putundef");
         return COMPILE_NG;
@@ -10642,7 +10643,7 @@ dump_disasm_list_with_cursor(const LINK_ELEMENT *link, const LINK_ELEMENT *curr,
             }
           default:
             /* ignore */
-            rb_raise(rb_eSyntaxError, "dump_disasm_list error: %ld\n", FIX2LONG(link->type));
+            rb_raise(rb_eSyntaxError, "dump_disasm_list error: %d\n", link->type);
         }
         link = link->next;
     }
@@ -10651,7 +10652,7 @@ dump_disasm_list_with_cursor(const LINK_ELEMENT *link, const LINK_ELEMENT *curr,
 }
 
 int
-rb_insn_len(VALUE insn)
+rb_insn_len(uintptr_t insn)
 {
     return insn_len(insn);
 }
@@ -10691,7 +10692,7 @@ register_label(rb_iseq_t *iseq, struct st_table *labels_table, VALUE obj)
     return label;
 }
 
-static VALUE
+static uintptr_t
 get_exception_sym2type(VALUE sym)
 {
     static VALUE symRescue, symEnsure, symRetry;
@@ -10724,7 +10725,8 @@ iseq_build_from_ary_exception(rb_iseq_t *iseq, struct st_table *labels_table,
 
     for (i=0; i<RARRAY_LEN(exception); i++) {
         const rb_iseq_t *eiseq;
-        VALUE v, type;
+        VALUE v;
+        uintptr_t type;
         LABEL *lstart, *lend, *lcont;
         unsigned int sp;
 
@@ -10769,7 +10771,7 @@ insn_make_insn_table(void)
     table = st_init_numtable_with_size(VM_INSTRUCTION_SIZE);
 
     for (i=0; i<VM_INSTRUCTION_SIZE; i++) {
-        st_insert(table, ID2SYM(rb_intern_const(insn_name(i))), i);
+        st_insert(table, ID2SYM(rb_intern_const(insn_name(i))), (st_data_t)i);
     }
 
     return table;
@@ -10900,12 +10902,12 @@ iseq_build_from_ary_body(rb_iseq_t *iseq, LINK_ANCHOR *const anchor,
             if (st_lookup(insn_table, (st_data_t)insn, &insn_id) == 0) {
                 /* TODO: exception */
                 COMPILE_ERROR(iseq, line_no,
-                              "unknown instruction: %+"PRIsVALUE, insn);
+                              "unknown instruction: %"PRIsVALUE, insn);
                 ret = COMPILE_NG;
                 break;
             }
 
-            if (argc != insn_len((VALUE)insn_id)-1) {
+            if (argc != insn_len((uintptr_t)insn_id)-1) {
                 COMPILE_ERROR(iseq, line_no,
                               "operand size mismatch");
                 ret = COMPILE_NG;
@@ -10923,7 +10925,7 @@ iseq_build_from_ary_body(rb_iseq_t *iseq, LINK_ANCHOR *const anchor,
 
                 for (j=0; j<argc; j++) {
                     VALUE op = rb_ary_entry(obj, j+1);
-                    switch (insn_op_type((VALUE)insn_id, j)) {
+                    switch (insn_op_type((uintptr_t)insn_id, j)) {
                       case TS_OFFSET: {
                         LABEL *label = register_label(iseq, labels_table, op);
                         argv[j] = (VALUE)label;
@@ -11003,7 +11005,7 @@ iseq_build_from_ary_body(rb_iseq_t *iseq, LINK_ANCHOR *const anchor,
                                 VALUE sym = RARRAY_AREF(op, i+1);
                                 LABEL *label =
                                   register_label(iseq, labels_table, sym);
-                                rb_hash_aset(map, key, (VALUE)label | 1);
+                                rb_hash_aset(map, key, zorptr(label, 1));
                             }
                             RB_GC_GUARD(op);
                             argv[j] = map;
@@ -11021,7 +11023,7 @@ iseq_build_from_ary_body(rb_iseq_t *iseq, LINK_ANCHOR *const anchor,
                         }
                         break;
                       default:
-                        rb_raise(rb_eSyntaxError, "unknown operand: %c", insn_op_type((VALUE)insn_id, j));
+                        rb_raise(rb_eSyntaxError, "unknown operand: %c", insn_op_type((uintptr_t)insn_id, j));
                     }
                 }
             }
@@ -11589,7 +11591,7 @@ ibf_dump_object_table_new(void)
 static VALUE
 ibf_dump_object(struct ibf_dump *dump, VALUE obj)
 {
-    return ibf_table_find_or_insert(dump->current_buffer->obj_table, (st_data_t)obj);
+    return (VALUE)ibf_table_find_or_insert(dump->current_buffer->obj_table, (st_data_t)obj);
 }
 
 static VALUE
@@ -11607,7 +11609,7 @@ ibf_load_id(const struct ibf_load *load, const ID id_index)
     if (id_index == 0) {
         return 0;
     }
-    VALUE sym = ibf_load_object(load, id_index);
+    VALUE sym = ibf_load_object(load, (VALUE)id_index);
     return rb_sym2id(sym);
 }
 
@@ -11644,10 +11646,10 @@ ibf_load_byte(const struct ibf_load *load, ibf_offset_t *offset)
  * 0x01000000_00000000 - 0xffffffff_ffffffff: 9byte | 0000 0000 | XXXX XXXX | XXXX XXXX | XXXX XXXX | XXXX XXXX | XXXX XXXX | XXXX XXXX | XXXX XXXX | XXXX XXXX |
  */
 static void
-ibf_dump_write_small_value(struct ibf_dump *dump, VALUE x)
+ibf_dump_write_small_value(struct ibf_dump *dump, VALUE x_value)
 {
     if (sizeof(VALUE) > 8 || CHAR_BIT != 8) {
-        ibf_dump_write(dump, &x, sizeof(VALUE));
+        ibf_dump_write(dump, &x_value, sizeof(VALUE));
         return;
     }
 
@@ -11656,6 +11658,8 @@ ibf_dump_write_small_value(struct ibf_dump *dump, VALUE x)
     unsigned char bytes[max_byte_length];
     ibf_offset_t n;
 
+    uintptr_t x = (uintptr_t)x_value;
+
     for (n = 0; n < sizeof(VALUE) && (x >> (7 - n)); n++, x >>= 8) {
         bytes[max_byte_length - 1 - n] = (unsigned char)x;
     }
@@ -11689,7 +11693,7 @@ ibf_load_small_value(const struct ibf_load *load, ibf_offset_t *offset)
     ibf_offset_t n =
         c & 1 ? 1 :
         c == 0 ? 9 : ntz_int32(c) + 1;
-    VALUE x = (VALUE)c >> n;
+    uintptr_t x = (uintptr_t)c >> n;
 
     if (*offset + n > load->current_buffer->size) {
         rb_raise(rb_eRuntimeError, "invalid byte sequence");
@@ -11698,11 +11702,11 @@ ibf_load_small_value(const struct ibf_load *load, ibf_offset_t *offset)
     ibf_offset_t i;
     for (i = 1; i < n; i++) {
         x <<= 8;
-        x |= (VALUE)buffer[*offset + i];
+        x |= (uintptr_t)buffer[*offset + i];
     }
 
     *offset += n;
-    return x;
+    return (VALUE)x;
 }
 
 static void
@@ -11752,11 +11756,11 @@ ibf_dump_code(struct ibf_dump *dump, const rb_iseq_t *iseq)
 
     for (code_index=0; code_index<iseq_size;) {
         const VALUE insn = orig_code[code_index++];
-        const char *types = insn_op_types(insn);
+        const char *types = insn_op_types((uintptr_t)insn);
         int op_index;
 
         /* opcode */
-        if (insn >= 0x100) { rb_raise(rb_eRuntimeError, "invalid instruction"); }
+        if (insn >= (VALUE)0x100) { rb_raise(rb_eRuntimeError, "invalid instruction"); }
         ibf_dump_write_small_value(dump, insn);
 
         /* operands */
@@ -11784,7 +11788,7 @@ ibf_dump_code(struct ibf_dump *dump, const rb_iseq_t *iseq)
               case TS_ICVARC:
                 {
                     union iseq_inline_storage_entry *is = (union iseq_inline_storage_entry *)op;
-                    wv = is - ISEQ_IS_ENTRY_START(body, types[op_index]);
+                    wv = (VALUE)(is - ISEQ_IS_ENTRY_START(body, types[op_index]));
                 }
                 break;
               case TS_CALLDATA:
@@ -11843,7 +11847,7 @@ ibf_load_code(const struct ibf_load *load, rb_iseq_t *iseq, ibf_offset_t bytecod
     for (code_index=0; code_index<iseq_size;) {
         /* opcode */
         const VALUE insn = code[code_index] = ibf_load_small_value(load, &reading_pos);
-        const char *types = insn_op_types(insn);
+        const char *types = insn_op_types((uintptr_t)insn);
         int op_index;
 
         code_index++;
@@ -11940,7 +11944,7 @@ ibf_load_code(const struct ibf_load *load, rb_iseq_t *iseq, ibf_offset_t bytecod
               case TS_ID:
                 {
                     VALUE op = ibf_load_small_value(load, &reading_pos);
-                    code[code_index] = ibf_load_id(load, (ID)(VALUE)op);
+                    code[code_index] = (VALUE)ibf_load_id(load, (ID)(VALUE)op);
                 }
                 break;
               case TS_FUNCPTR:
@@ -11954,7 +11958,7 @@ ibf_load_code(const struct ibf_load *load, rb_iseq_t *iseq, ibf_offset_t bytecod
                 continue;
             }
         }
-        if (insn_len(insn) != op_index+1) {
+        if (insn_len((uintptr_t)insn) != op_index+1) {
             rb_raise(rb_eRuntimeError, "operand size mismatch");
         }
     }
@@ -12065,11 +12069,11 @@ ibf_dump_insns_info_body(struct ibf_dump *dump, const rb_iseq_t *iseq)
 
     unsigned int i;
     for (i = 0; i < ISEQ_BODY(iseq)->insns_info.size; i++) {
-        ibf_dump_write_small_value(dump, entries[i].line_no);
+        ibf_dump_write_small_value(dump, (VALUE)entries[i].line_no);
 #ifdef USE_ISEQ_NODE_ID
-        ibf_dump_write_small_value(dump, entries[i].node_id);
+        ibf_dump_write_small_value(dump, (VALUE)entries[i].node_id);
 #endif
-        ibf_dump_write_small_value(dump, entries[i].events);
+        ibf_dump_write_small_value(dump, (VALUE)entries[i].events);
     }
 
     return offset;
@@ -12101,7 +12105,7 @@ ibf_dump_insns_info_positions(struct ibf_dump *dump, const unsigned int *positio
     unsigned int last = 0;
     unsigned int i;
     for (i = 0; i < size; i++) {
-        ibf_dump_write_small_value(dump, positions[i] - last);
+        ibf_dump_write_small_value(dump, (VALUE)(positions[i] - last));
         last = positions[i];
     }
 
@@ -12133,7 +12137,7 @@ ibf_dump_local_table(struct ibf_dump *dump, const rb_iseq_t *iseq)
     int i;
 
     for (i=0; i<size; i++) {
-        table[i] = ibf_dump_id(dump, body->local_table[i]);
+        table[i] = (ID)ibf_dump_id(dump, body->local_table[i]);
     }
 
     IBF_W_ALIGN(ID);
@@ -12173,12 +12177,12 @@ ibf_dump_catch_table(struct ibf_dump *dump, const rb_iseq_t *iseq)
         const ibf_offset_t offset = ibf_dump_pos(dump);
 
         for (i=0; i<table->size; i++) {
-            ibf_dump_write_small_value(dump, iseq_indices[i]);
-            ibf_dump_write_small_value(dump, table->entries[i].type);
-            ibf_dump_write_small_value(dump, table->entries[i].start);
-            ibf_dump_write_small_value(dump, table->entries[i].end);
-            ibf_dump_write_small_value(dump, table->entries[i].cont);
-            ibf_dump_write_small_value(dump, table->entries[i].sp);
+            ibf_dump_write_small_value(dump, (VALUE)iseq_indices[i]);
+            ibf_dump_write_small_value(dump, (VALUE)table->entries[i].type);
+            ibf_dump_write_small_value(dump, (VALUE)table->entries[i].start);
+            ibf_dump_write_small_value(dump, (VALUE)table->entries[i].end);
+            ibf_dump_write_small_value(dump, (VALUE)table->entries[i].cont);
+            ibf_dump_write_small_value(dump, (VALUE)table->entries[i].sp);
         }
         return offset;
     }
@@ -12230,13 +12234,13 @@ ibf_dump_ci_entries(struct ibf_dump *dump, const rb_iseq_t *iseq)
         const struct rb_callinfo *ci = cds[i].ci;
         if (ci != NULL) {
             ibf_dump_write_small_value(dump, ibf_dump_id(dump, vm_ci_mid(ci)));
-            ibf_dump_write_small_value(dump, vm_ci_flag(ci));
-            ibf_dump_write_small_value(dump, vm_ci_argc(ci));
+            ibf_dump_write_small_value(dump, (VALUE)vm_ci_flag(ci));
+            ibf_dump_write_small_value(dump, (VALUE)vm_ci_argc(ci));
 
             const struct rb_callinfo_kwarg *kwarg = vm_ci_kwarg(ci);
             if (kwarg) {
                 int len = kwarg->keyword_len;
-                ibf_dump_write_small_value(dump, len);
+                ibf_dump_write_small_value(dump, (VALUE)len);
                 for (int j=0; j<len; j++) {
                     VALUE keyword = ibf_dump_object(dump, kwarg->keywords[j]);
                     ibf_dump_write_small_value(dump, keyword);
@@ -12306,9 +12310,9 @@ ibf_dump_outer_variables(struct ibf_dump *dump, const rb_iseq_t *iseq)
         ruby_qsort(ovlist->pairs, size, sizeof(struct outer_variable_pair), outer_variable_cmp, NULL);
         for (size_t i = 0; i < size; ++i) {
             ID id = ovlist->pairs[i].id;
-            ID val = ovlist->pairs[i].val;
+            ID val = (ID)ovlist->pairs[i].val;
             ibf_dump_write_small_value(dump, ibf_dump_id(dump, id));
-            ibf_dump_write_small_value(dump, val);
+            ibf_dump_write_small_value(dump, (VALUE)val);
         }
     }
 
@@ -12332,7 +12336,7 @@ ibf_load_ci_entries(const struct ibf_load *load,
     for (i = 0; i < ci_size; i++) {
         VALUE mid_index = ibf_load_small_value(load, &reading_pos);
         if (mid_index != (VALUE)-1) {
-            ID mid = ibf_load_id(load, mid_index);
+            ID mid = ibf_load_id(load, (ID)mid_index);
             unsigned int flag = (unsigned int)ibf_load_small_value(load, &reading_pos);
             unsigned int argc = (unsigned int)ibf_load_small_value(load, &reading_pos);
 
@@ -12453,49 +12457,49 @@ ibf_dump_iseq_each(struct ibf_dump *dump, const rb_iseq_t *iseq)
 #  define IBF_BODY_OFFSET(x) (body_offset - (x))
 #endif
 
-    ibf_dump_write_small_value(dump, body->type);
-    ibf_dump_write_small_value(dump, body->iseq_size);
-    ibf_dump_write_small_value(dump, IBF_BODY_OFFSET(bytecode_offset));
-    ibf_dump_write_small_value(dump, bytecode_size);
-    ibf_dump_write_small_value(dump, param_flags);
-    ibf_dump_write_small_value(dump, body->param.size);
-    ibf_dump_write_small_value(dump, body->param.lead_num);
-    ibf_dump_write_small_value(dump, body->param.opt_num);
-    ibf_dump_write_small_value(dump, body->param.rest_start);
-    ibf_dump_write_small_value(dump, body->param.post_start);
-    ibf_dump_write_small_value(dump, body->param.post_num);
-    ibf_dump_write_small_value(dump, body->param.block_start);
-    ibf_dump_write_small_value(dump, IBF_BODY_OFFSET(param_opt_table_offset));
-    ibf_dump_write_small_value(dump, param_keyword_offset);
-    ibf_dump_write_small_value(dump, location_pathobj_index);
-    ibf_dump_write_small_value(dump, location_base_label_index);
-    ibf_dump_write_small_value(dump, location_label_index);
-    ibf_dump_write_small_value(dump, body->location.first_lineno);
-    ibf_dump_write_small_value(dump, body->location.node_id);
-    ibf_dump_write_small_value(dump, body->location.code_location.beg_pos.lineno);
-    ibf_dump_write_small_value(dump, body->location.code_location.beg_pos.column);
-    ibf_dump_write_small_value(dump, body->location.code_location.end_pos.lineno);
-    ibf_dump_write_small_value(dump, body->location.code_location.end_pos.column);
-    ibf_dump_write_small_value(dump, IBF_BODY_OFFSET(insns_info_body_offset));
-    ibf_dump_write_small_value(dump, IBF_BODY_OFFSET(insns_info_positions_offset));
-    ibf_dump_write_small_value(dump, body->insns_info.size);
-    ibf_dump_write_small_value(dump, IBF_BODY_OFFSET(local_table_offset));
-    ibf_dump_write_small_value(dump, catch_table_size);
-    ibf_dump_write_small_value(dump, IBF_BODY_OFFSET(catch_table_offset));
-    ibf_dump_write_small_value(dump, parent_iseq_index);
-    ibf_dump_write_small_value(dump, local_iseq_index);
-    ibf_dump_write_small_value(dump, mandatory_only_iseq_index);
-    ibf_dump_write_small_value(dump, IBF_BODY_OFFSET(ci_entries_offset));
-    ibf_dump_write_small_value(dump, IBF_BODY_OFFSET(outer_variables_offset));
-    ibf_dump_write_small_value(dump, body->variable.flip_count);
-    ibf_dump_write_small_value(dump, body->local_table_size);
-    ibf_dump_write_small_value(dump, body->ivc_size);
-    ibf_dump_write_small_value(dump, body->icvarc_size);
-    ibf_dump_write_small_value(dump, body->ise_size);
-    ibf_dump_write_small_value(dump, body->ic_size);
-    ibf_dump_write_small_value(dump, body->ci_size);
-    ibf_dump_write_small_value(dump, body->stack_max);
-    ibf_dump_write_small_value(dump, body->builtin_attrs);
+    ibf_dump_write_small_value(dump, (VALUE)body->type);
+    ibf_dump_write_small_value(dump, (VALUE)body->iseq_size);
+    ibf_dump_write_small_value(dump, (VALUE)IBF_BODY_OFFSET(bytecode_offset));
+    ibf_dump_write_small_value(dump, (VALUE)bytecode_size);
+    ibf_dump_write_small_value(dump, (VALUE)param_flags);
+    ibf_dump_write_small_value(dump, (VALUE)body->param.size);
+    ibf_dump_write_small_value(dump, (VALUE)body->param.lead_num);
+    ibf_dump_write_small_value(dump, (VALUE)body->param.opt_num);
+    ibf_dump_write_small_value(dump, (VALUE)body->param.rest_start);
+    ibf_dump_write_small_value(dump, (VALUE)body->param.post_start);
+    ibf_dump_write_small_value(dump, (VALUE)body->param.post_num);
+    ibf_dump_write_small_value(dump, (VALUE)body->param.block_start);
+    ibf_dump_write_small_value(dump, (VALUE)IBF_BODY_OFFSET(param_opt_table_offset));
+    ibf_dump_write_small_value(dump, (VALUE)param_keyword_offset);
+    ibf_dump_write_small_value(dump, (VALUE)location_pathobj_index);
+    ibf_dump_write_small_value(dump, (VALUE)location_base_label_index);
+    ibf_dump_write_small_value(dump, (VALUE)location_label_index);
+    ibf_dump_write_small_value(dump, (VALUE)body->location.first_lineno);
+    ibf_dump_write_small_value(dump, (VALUE)body->location.node_id);
+    ibf_dump_write_small_value(dump, (VALUE)body->location.code_location.beg_pos.lineno);
+    ibf_dump_write_small_value(dump, (VALUE)body->location.code_location.beg_pos.column);
+    ibf_dump_write_small_value(dump, (VALUE)body->location.code_location.end_pos.lineno);
+    ibf_dump_write_small_value(dump, (VALUE)body->location.code_location.end_pos.column);
+    ibf_dump_write_small_value(dump, (VALUE)IBF_BODY_OFFSET(insns_info_body_offset));
+    ibf_dump_write_small_value(dump, (VALUE)IBF_BODY_OFFSET(insns_info_positions_offset));
+    ibf_dump_write_small_value(dump, (VALUE)body->insns_info.size);
+    ibf_dump_write_small_value(dump, (VALUE)IBF_BODY_OFFSET(local_table_offset));
+    ibf_dump_write_small_value(dump, (VALUE)catch_table_size);
+    ibf_dump_write_small_value(dump, (VALUE)IBF_BODY_OFFSET(catch_table_offset));
+    ibf_dump_write_small_value(dump, (VALUE)parent_iseq_index);
+    ibf_dump_write_small_value(dump, (VALUE)local_iseq_index);
+    ibf_dump_write_small_value(dump, (VALUE)mandatory_only_iseq_index);
+    ibf_dump_write_small_value(dump, (VALUE)IBF_BODY_OFFSET(ci_entries_offset));
+    ibf_dump_write_small_value(dump, (VALUE)IBF_BODY_OFFSET(outer_variables_offset));
+    ibf_dump_write_small_value(dump, (VALUE)body->variable.flip_count);
+    ibf_dump_write_small_value(dump, (VALUE)body->local_table_size);
+    ibf_dump_write_small_value(dump, (VALUE)body->ivc_size);
+    ibf_dump_write_small_value(dump, (VALUE)body->icvarc_size);
+    ibf_dump_write_small_value(dump, (VALUE)body->ise_size);
+    ibf_dump_write_small_value(dump, (VALUE)body->ic_size);
+    ibf_dump_write_small_value(dump, (VALUE)body->ci_size);
+    ibf_dump_write_small_value(dump, (VALUE)body->stack_max);
+    ibf_dump_write_small_value(dump, (VALUE)body->builtin_attrs);
 
 #undef IBF_BODY_OFFSET
 
@@ -12565,7 +12569,7 @@ ibf_load_iseq_each(struct ibf_load *load, rb_iseq_t *iseq, ibf_offset_t offset)
 
     const unsigned int type = (unsigned int)ibf_load_small_value(load, &reading_pos);
     const unsigned int iseq_size = (unsigned int)ibf_load_small_value(load, &reading_pos);
-    const ibf_offset_t bytecode_offset = (ibf_offset_t)IBF_BODY_OFFSET(ibf_load_small_value(load, &reading_pos));
+    const ibf_offset_t bytecode_offset = (ibf_offset_t)IBF_BODY_OFFSET((uintptr_t)ibf_load_small_value(load, &reading_pos));
     const ibf_offset_t bytecode_size = (ibf_offset_t)ibf_load_small_value(load, &reading_pos);
     const unsigned int param_flags = (unsigned int)ibf_load_small_value(load, &reading_pos);
     const unsigned int param_size = (unsigned int)ibf_load_small_value(load, &reading_pos);
@@ -12575,7 +12579,7 @@ ibf_load_iseq_each(struct ibf_load *load, rb_iseq_t *iseq, ibf_offset_t offset)
     const int param_post_start = (int)ibf_load_small_value(load, &reading_pos);
     const int param_post_num = (int)ibf_load_small_value(load, &reading_pos);
     const int param_block_start = (int)ibf_load_small_value(load, &reading_pos);
-    const ibf_offset_t param_opt_table_offset = (ibf_offset_t)IBF_BODY_OFFSET(ibf_load_small_value(load, &reading_pos));
+    const ibf_offset_t param_opt_table_offset = (ibf_offset_t)IBF_BODY_OFFSET((uintptr_t)ibf_load_small_value(load, &reading_pos));
     const ibf_offset_t param_keyword_offset = (ibf_offset_t)ibf_load_small_value(load, &reading_pos);
     const VALUE location_pathobj_index = ibf_load_small_value(load, &reading_pos);
     const VALUE location_base_label_index = ibf_load_small_value(load, &reading_pos);
@@ -12586,17 +12590,17 @@ ibf_load_iseq_each(struct ibf_load *load, rb_iseq_t *iseq, ibf_offset_t offset)
     const int location_code_location_beg_pos_column = (int)ibf_load_small_value(load, &reading_pos);
     const int location_code_location_end_pos_lineno = (int)ibf_load_small_value(load, &reading_pos);
     const int location_code_location_end_pos_column = (int)ibf_load_small_value(load, &reading_pos);
-    const ibf_offset_t insns_info_body_offset = (ibf_offset_t)IBF_BODY_OFFSET(ibf_load_small_value(load, &reading_pos));
-    const ibf_offset_t insns_info_positions_offset = (ibf_offset_t)IBF_BODY_OFFSET(ibf_load_small_value(load, &reading_pos));
+    const ibf_offset_t insns_info_body_offset = (ibf_offset_t)IBF_BODY_OFFSET((uintptr_t)ibf_load_small_value(load, &reading_pos));
+    const ibf_offset_t insns_info_positions_offset = (ibf_offset_t)IBF_BODY_OFFSET((uintptr_t)ibf_load_small_value(load, &reading_pos));
     const unsigned int insns_info_size = (unsigned int)ibf_load_small_value(load, &reading_pos);
-    const ibf_offset_t local_table_offset = (ibf_offset_t)IBF_BODY_OFFSET(ibf_load_small_value(load, &reading_pos));
+    const ibf_offset_t local_table_offset = (ibf_offset_t)IBF_BODY_OFFSET((uintptr_t)ibf_load_small_value(load, &reading_pos));
     const unsigned int catch_table_size = (unsigned int)ibf_load_small_value(load, &reading_pos);
-    const ibf_offset_t catch_table_offset = (ibf_offset_t)IBF_BODY_OFFSET(ibf_load_small_value(load, &reading_pos));
+    const ibf_offset_t catch_table_offset = (ibf_offset_t)IBF_BODY_OFFSET((uintptr_t)ibf_load_small_value(load, &reading_pos));
     const int parent_iseq_index = (int)ibf_load_small_value(load, &reading_pos);
     const int local_iseq_index = (int)ibf_load_small_value(load, &reading_pos);
     const int mandatory_only_iseq_index = (int)ibf_load_small_value(load, &reading_pos);
-    const ibf_offset_t ci_entries_offset = (ibf_offset_t)IBF_BODY_OFFSET(ibf_load_small_value(load, &reading_pos));
-    const ibf_offset_t outer_variables_offset = (ibf_offset_t)IBF_BODY_OFFSET(ibf_load_small_value(load, &reading_pos));
+    const ibf_offset_t ci_entries_offset = (ibf_offset_t)IBF_BODY_OFFSET((uintptr_t)ibf_load_small_value(load, &reading_pos));
+    const ibf_offset_t outer_variables_offset = (ibf_offset_t)IBF_BODY_OFFSET((uintptr_t)ibf_load_small_value(load, &reading_pos));
     const rb_snum_t variable_flip_count = (rb_snum_t)ibf_load_small_value(load, &reading_pos);
     const unsigned int local_table_size = (unsigned int)ibf_load_small_value(load, &reading_pos);
 
@@ -12627,7 +12631,7 @@ ibf_load_iseq_each(struct ibf_load *load, rb_iseq_t *iseq, ibf_offset_t offset)
             if (!NIL_P(realpath)) {
                 if (!RB_TYPE_P(realpath, T_STRING)) {
                     rb_raise(rb_eArgError, "unexpected realpath %"PRIxVALUE
-                             "(%x), path=%+"PRIsVALUE,
+                             "(%x), path=%"PRIsVALUE,
                              realpath, TYPE(realpath), path);
                 }
                 realpath = rb_fstring(realpath);
@@ -12946,11 +12950,11 @@ ibf_dump_object_string(struct ibf_dump *dump, VALUE obj)
     if (encindex > RUBY_ENCINDEX_BUILTIN_MAX) {
         rb_encoding *enc = rb_enc_from_index((int)encindex);
         const char *enc_name = rb_enc_name(enc);
-        encindex = RUBY_ENCINDEX_BUILTIN_MAX + ibf_dump_object(dump, rb_str_new2(enc_name));
+        encindex = RUBY_ENCINDEX_BUILTIN_MAX + (uintptr_t)ibf_dump_object(dump, rb_str_new2(enc_name));
     }
 
-    ibf_dump_write_small_value(dump, encindex);
-    ibf_dump_write_small_value(dump, len);
+    ibf_dump_write_small_value(dump, (VALUE)encindex);
+    ibf_dump_write_small_value(dump, (VALUE)len);
     IBF_WP(ptr, char, len);
 }
 
@@ -12964,7 +12968,7 @@ ibf_load_object_string(const struct ibf_load *load, const struct ibf_object_head
     const char *ptr = load->current_buffer->buff + reading_pos;
 
     if (encindex > RUBY_ENCINDEX_BUILTIN_MAX) {
-        VALUE enc_name_str = ibf_load_object(load, encindex - RUBY_ENCINDEX_BUILTIN_MAX);
+        VALUE enc_name_str = ibf_load_object(load, (VALUE)(encindex - RUBY_ENCINDEX_BUILTIN_MAX));
         encindex = rb_enc_find_index(RSTRING_PTR(enc_name_str));
     }
 
@@ -12990,7 +12994,7 @@ ibf_dump_object_regexp(struct ibf_dump *dump, VALUE obj)
     regexp.srcstr = (long)ibf_dump_object(dump, srcstr);
 
     ibf_dump_write_byte(dump, (unsigned char)regexp.option);
-    ibf_dump_write_small_value(dump, regexp.srcstr);
+    ibf_dump_write_small_value(dump, (VALUE)regexp.srcstr);
 }
 
 static VALUE
@@ -12998,9 +13002,9 @@ ibf_load_object_regexp(const struct ibf_load *load, const struct ibf_object_head
 {
     struct ibf_object_regexp regexp;
     regexp.option = ibf_load_byte(load, &offset);
-    regexp.srcstr = ibf_load_small_value(load, &offset);
+    regexp.srcstr = (uintptr_t)ibf_load_small_value(load, &offset);
 
-    VALUE srcstr = ibf_load_object(load, regexp.srcstr);
+    VALUE srcstr = ibf_load_object(load, (VALUE)regexp.srcstr);
     VALUE reg = rb_reg_compile(srcstr, (int)regexp.option, NULL, 0);
 
     if (header->internal) rb_obj_hide(reg);
@@ -13013,10 +13017,10 @@ static void
 ibf_dump_object_array(struct ibf_dump *dump, VALUE obj)
 {
     long i, len = RARRAY_LEN(obj);
-    ibf_dump_write_small_value(dump, len);
+    ibf_dump_write_small_value(dump, (VALUE)len);
     for (i=0; i<len; i++) {
         long index = (long)ibf_dump_object(dump, RARRAY_AREF(obj, i));
-        ibf_dump_write_small_value(dump, index);
+        ibf_dump_write_small_value(dump, (VALUE)index);
     }
 }
 
@@ -13112,8 +13116,8 @@ static VALUE
 ibf_load_object_struct(const struct ibf_load *load, const struct ibf_object_header *header, ibf_offset_t offset)
 {
     const struct ibf_object_struct_range *range = IBF_OBJBODY(struct ibf_object_struct_range, offset);
-    VALUE beg = ibf_load_object(load, range->beg);
-    VALUE end = ibf_load_object(load, range->end);
+    VALUE beg = ibf_load_object(load, (VALUE)range->beg);
+    VALUE end = ibf_load_object(load, (VALUE)range->end);
     VALUE obj = rb_range_new(beg, end, range->excl);
     if (header->internal) rb_obj_hide(obj);
     if (header->frozen)   rb_obj_freeze(obj);
@@ -13199,8 +13203,8 @@ static VALUE
 ibf_load_object_complex_rational(const struct ibf_load *load, const struct ibf_object_header *header, ibf_offset_t offset)
 {
     const struct ibf_object_complex_rational *nums = IBF_OBJBODY(struct ibf_object_complex_rational, offset);
-    VALUE a = ibf_load_object(load, nums->a);
-    VALUE b = ibf_load_object(load, nums->b);
+    VALUE a = ibf_load_object(load, (VALUE)nums->a);
+    VALUE b = ibf_load_object(load, (VALUE)nums->b);
     VALUE obj = header->type == T_COMPLEX ?
       rb_complex_new(a, b) : rb_rational_new(a, b);
 
@@ -13225,7 +13229,7 @@ ibf_load_object_symbol(const struct ibf_load *load, const struct ibf_object_head
     const char *ptr = load->current_buffer->buff + reading_pos;
 
     if (encindex > RUBY_ENCINDEX_BUILTIN_MAX) {
-        VALUE enc_name_str = ibf_load_object(load, encindex - RUBY_ENCINDEX_BUILTIN_MAX);
+        VALUE enc_name_str = ibf_load_object(load, (VALUE)(encindex - RUBY_ENCINDEX_BUILTIN_MAX));
         encindex = rb_enc_find_index(RSTRING_PTR(enc_name_str));
     }
 
@@ -13365,14 +13369,14 @@ static const ibf_load_object_function load_object_functions[RUBY_T_MASK+1] = {
 static VALUE
 ibf_load_object(const struct ibf_load *load, VALUE object_index)
 {
-    if (object_index == 0) {
+    if (object_index == (VALUE)0) {
         return Qnil;
     }
     else {
         VALUE obj = pinned_list_fetch(load->current_buffer->obj_list, (long)object_index);
         if (!obj) {
             ibf_offset_t *offsets = (ibf_offset_t *)(load->current_buffer->obj_list_offset + load->current_buffer->buff);
-            ibf_offset_t offset = offsets[object_index];
+            ibf_offset_t offset = offsets[(uintptr_t)object_index];
             const struct ibf_object_header header = ibf_load_object_object_header(load, &offset);
 
 #if IBF_ISEQ_DEBUG
diff --git a/configure.txt b/configure.txt
new file mode 100644
index 000000000000..4a1929bff567
--- /dev/null
+++ b/configure.txt
@@ -0,0 +1 @@
+CC=$PWD/../../build/bin/clang CXX=$PWD/../../build/bin/clang++ ./configure --enable-shared --disable-yjit --disable-rjit --without-jit --without-gcc --without-valgrind --with-thread=pthread --without-jemalloc --with-coroutine=pthread --prefix=$PWD/../../pizfix
diff --git a/debug.c b/debug.c
index e84e3d602a3e..3d4b1ffbcfe3 100644
--- a/debug.c
+++ b/debug.c
@@ -213,14 +213,18 @@ ruby_env_debug_option(const char *str, int len, void *arg)
 #define SET_WHEN_UINT(name, vals, num, req) \
     if (NAME_MATCH_VALUE(name)) SET_UINT_LIST(name, vals, num);
 
+#ifndef __FILC__
     SET_WHEN("gc_stress", *ruby_initial_gc_stress_ptr, Qtrue);
+#endif
     SET_WHEN("core", ruby_enable_coredump, 1);
     SET_WHEN("ci", ruby_on_ci, 1);
+#ifndef __FILC__
     if (NAME_MATCH_VALUE("rgengc")) {
         if (!len) ruby_rgengc_debug = 1;
         else SET_UINT_LIST("rgengc", &ruby_rgengc_debug, 1);
         return 1;
     }
+#endif
 #if defined _WIN32
 # if RUBY_MSVCRT_VERSION >= 80
     SET_WHEN("rtc_error", ruby_w32_rtc_error, 1);
diff --git a/dir.c b/dir.c
index 96c1a455b3cd..d3cae1ba42af 100644
--- a/dir.c
+++ b/dir.c
@@ -1706,7 +1706,7 @@ gc_for_fd_with_gvl(int e)
     if (vm_initialized)
         return (int)(VALUE)rb_thread_call_with_gvl(with_gvl_gc_for_fd, &e);
     else
-        return RBOOL(rb_gc_for_fd(e));
+        return (int)RBOOL(rb_gc_for_fd(e));
 }
 
 static void *
diff --git a/enc/trans/emoji.c b/enc/trans/emoji.c
index 72ef11dbf05a..e29e09924677 100644
--- a/enc/trans/emoji.c
+++ b/enc/trans/emoji.c
@@ -1,7 +1,7 @@
 /* autogenerated. */
 /* src="transcode-tblgen.rb", len=30823, checksum=59589 */
 /* src="emoji.trans", len=1009, checksum=14571 */
-/* src="emoji-exchange-tbl.rb", len=524703, checksum=40005 */
+/* src="emoji-exchange-tbl.rb", len=515597, checksum=40005 */
 
 #include "transcode_data.h"
 
diff --git a/enc/trans/gb18030.c b/enc/trans/gb18030.c
index b38f5ac4717d..460bc4367bec 100644
--- a/enc/trans/gb18030.c
+++ b/enc/trans/gb18030.c
@@ -1,6 +1,6 @@
 /* autogenerated. */
 /* src="transcode-tblgen.rb", len=30823, checksum=59589 */
-/* src="gb18030.trans", len=5681, checksum=53185 */
+/* src="gb18030.trans", len=5703, checksum=55349 */
 /* src="gb18030-tbl.rb", len=1357449, checksum=30205 */
 
 #include "transcode_data.h"
@@ -21511,7 +21511,7 @@ fun_so_to_gb18030(void *statep, const unsigned char *s, size_t l, unsigned char
 static ssize_t
 fun_sio_from_gb18030(void *statep, const unsigned char *s, size_t l, VALUE info, unsigned char *o, size_t osize)
 {
-    unsigned int diff = (unsigned int)(info >> 8);
+    unsigned int diff = (unsigned int)((uintptr_t)info >> 8);
     unsigned int u;    /* Unicode Scalar Value */
     if (diff & 0x20000) { /* GB18030 4 bytes */
         u = ((s[0]*10+s[1])*126+s[2])*10+s[3] - diff - 0x170000;
@@ -21529,7 +21529,7 @@ fun_sio_from_gb18030(void *statep, const unsigned char *s, size_t l, VALUE info,
 static ssize_t
 fun_sio_to_gb18030(void *statep, const unsigned char *s, size_t l, VALUE info, unsigned char *o, size_t osize)
 {
-    unsigned int diff = (unsigned int)(info >> 8);
+    unsigned int diff = (unsigned int)((uintptr_t)info >> 8);
     unsigned int u;    /* Unicode Scalar Value */
 
     u = ((s[0]&0x0F)<<12) | ((s[1]&0x3F)<<6) | (s[2]&0x3F);
diff --git a/enc/trans/gb18030.trans b/enc/trans/gb18030.trans
index f42f8fd2d53c..b14c3fa3b3ab 100644
--- a/enc/trans/gb18030.trans
+++ b/enc/trans/gb18030.trans
@@ -103,7 +103,7 @@ fun_so_to_gb18030(void *statep, const unsigned char *s, size_t l, unsigned char
 static ssize_t
 fun_sio_from_gb18030(void *statep, const unsigned char *s, size_t l, VALUE info, unsigned char *o, size_t osize)
 {
-    unsigned int diff = (unsigned int)(info >> 8);
+    unsigned int diff = (unsigned int)((uintptr_t)info >> 8);
     unsigned int u;    /* Unicode Scalar Value */
     if (diff & 0x20000) { /* GB18030 4 bytes */
         u = ((s[0]*10+s[1])*126+s[2])*10+s[3] - diff - 0x170000;
@@ -121,7 +121,7 @@ fun_sio_from_gb18030(void *statep, const unsigned char *s, size_t l, VALUE info,
 static ssize_t
 fun_sio_to_gb18030(void *statep, const unsigned char *s, size_t l, VALUE info, unsigned char *o, size_t osize)
 {
-    unsigned int diff = (unsigned int)(info >> 8);
+    unsigned int diff = (unsigned int)((uintptr_t)info >> 8);
     unsigned int u;    /* Unicode Scalar Value */
 
     u = ((s[0]&0x0F)<<12) | ((s[1]&0x3F)<<6) | (s[2]&0x3F);
diff --git a/enc/trans/utf8_mac.c b/enc/trans/utf8_mac.c
index 6984e3d0c481..7c08a34b3e16 100644
--- a/enc/trans/utf8_mac.c
+++ b/enc/trans/utf8_mac.c
@@ -1,6 +1,6 @@
 /* autogenerated. */
 /* src="transcode-tblgen.rb", len=30823, checksum=59589 */
-/* src="utf8_mac.trans", len=7053, checksum=2830 */
+/* src="utf8_mac.trans", len=7080, checksum=6392 */
 /* src="utf8_mac-tbl.rb", len=754604, checksum=27903 */
 
 #include "transcode_data.h"
@@ -68924,8 +68924,8 @@ rb_to_UTF8_MAC = {
 
 #define BYTE_ADDR(index) (utf8_mac_byte_array + (index))
 #define WORD_ADDR(index) (utf8_mac_word_array + INFO2WORDINDEX(index))
-#define BL_BASE BYTE_ADDR(BYTE_LOOKUP_BASE(WORD_ADDR(next_info)))
-#define BL_INFO WORD_ADDR(BYTE_LOOKUP_INFO(WORD_ADDR(next_info)))
+#define BL_BASE BYTE_ADDR(BYTE_LOOKUP_BASE(WORD_ADDR((uintptr_t)next_info)))
+#define BL_INFO WORD_ADDR(BYTE_LOOKUP_INFO(WORD_ADDR((uintptr_t)next_info)))
 #define BL_MIN_BYTE     (BL_BASE[0])
 #define BL_MAX_BYTE     (BL_BASE[1])
 #define BL_OFFSET(byte) (BL_BASE[2+(byte)-BL_MIN_BYTE])
@@ -68996,15 +68996,15 @@ buf_output_all(struct from_utf8_mac_status *sp, unsigned char *o)
     return n;
 }
 
-static VALUE
-get_info(VALUE next_info, struct from_utf8_mac_status *sp) {
+static uintptr_t
+get_info(uintptr_t next_info, struct from_utf8_mac_status *sp) {
     int pos = 0;
     while (pos < buf_bytesize(sp)) {
         unsigned char next_byte = buf_at(sp, pos++);
         if (next_byte < BL_MIN_BYTE || BL_MAX_BYTE < next_byte)
             next_info = INVALID;
         else {
-            next_info = (VALUE)BL_ACTION(next_byte);
+            next_info = BL_ACTION(next_byte);
         }
         if ((next_info & 3) == 0) continue;
         break;
@@ -69016,7 +69016,7 @@ static size_t
 buf_apply(struct from_utf8_mac_status *sp, unsigned char *o)
 {
     size_t n = 0;
-    VALUE next_info;
+    uintptr_t next_info;
     unsigned char buf[3];
     if (buf_bytesize(sp) < 3 || (buf_bytesize(sp) == 3 && buf_at(sp, 0) >= 0xE0)) {
         /* char length is less than 2 */
diff --git a/enc/trans/utf8_mac.trans b/enc/trans/utf8_mac.trans
index bcaa785eade5..1418de99109e 100644
--- a/enc/trans/utf8_mac.trans
+++ b/enc/trans/utf8_mac.trans
@@ -78,8 +78,8 @@
 
 #define BYTE_ADDR(index) (<%= OUTPUT_PREFIX %>byte_array + (index))
 #define WORD_ADDR(index) (<%= OUTPUT_PREFIX %>word_array + INFO2WORDINDEX(index))
-#define BL_BASE BYTE_ADDR(BYTE_LOOKUP_BASE(WORD_ADDR(next_info)))
-#define BL_INFO WORD_ADDR(BYTE_LOOKUP_INFO(WORD_ADDR(next_info)))
+#define BL_BASE BYTE_ADDR(BYTE_LOOKUP_BASE(WORD_ADDR((uintptr_t)next_info)))
+#define BL_INFO WORD_ADDR(BYTE_LOOKUP_INFO(WORD_ADDR((uintptr_t)next_info)))
 #define BL_MIN_BYTE     (BL_BASE[0])
 #define BL_MAX_BYTE     (BL_BASE[1])
 #define BL_OFFSET(byte) (BL_BASE[2+(byte)-BL_MIN_BYTE])
@@ -150,15 +150,15 @@ buf_output_all(struct from_utf8_mac_status *sp, unsigned char *o)
     return n;
 }
 
-static VALUE
-get_info(VALUE next_info, struct from_utf8_mac_status *sp) {
+static uintptr_t
+get_info(uintptr_t next_info, struct from_utf8_mac_status *sp) {
     int pos = 0;
     while (pos < buf_bytesize(sp)) {
         unsigned char next_byte = buf_at(sp, pos++);
         if (next_byte < BL_MIN_BYTE || BL_MAX_BYTE < next_byte)
             next_info = INVALID;
         else {
-            next_info = (VALUE)BL_ACTION(next_byte);
+            next_info = BL_ACTION(next_byte);
         }
         if ((next_info & 3) == 0) continue;
         break;
@@ -170,7 +170,7 @@ static size_t
 buf_apply(struct from_utf8_mac_status *sp, unsigned char *o)
 {
     size_t n = 0;
-    VALUE next_info;
+    uintptr_t next_info;
     unsigned char buf[3];
     if (buf_bytesize(sp) < 3 || (buf_bytesize(sp) == 3 && buf_at(sp, 0) >= 0xE0)) {
         /* char length is less than 2 */
diff --git a/enc/trans/utf_16_32.c b/enc/trans/utf_16_32.c
index d83341b0502b..f21d83b840c6 100644
--- a/enc/trans/utf_16_32.c
+++ b/enc/trans/utf_16_32.c
@@ -1,6 +1,6 @@
 /* autogenerated. */
 /* src="transcode-tblgen.rb", len=30823, checksum=59589 */
-/* src="utf_16_32.trans", len=15308, checksum=28538 */
+/* src="utf_16_32.trans", len=15336, checksum=30386 */
 
 #include "transcode_data.h"
 
@@ -575,11 +575,11 @@ fun_si_from_utf_16(void *statep, const unsigned char *s, size_t l)
     case 0:
         if (s[0] == 0xFE && s[1] == 0xFF) {
             *sp = BE;
-            return ZERObt;
+            return (VALUE)ZERObt;
         }
         else if (s[0] == 0xFF && s[1] == 0xFE) {
             *sp = LE;
-            return ZERObt;
+            return (VALUE)ZERObt;
         }
         break;
     case BE:
@@ -623,11 +623,11 @@ fun_si_from_utf_32(void *statep, const unsigned char *s, size_t l)
     case 0:
         if (s[0] == 0 && s[1] == 0 && s[2] == 0xFE && s[3] == 0xFF) {
             *sp = BE;
-            return ZERObt;
+            return (VALUE)ZERObt;
         }
         else if (s[0] == 0xFF && s[1] == 0xFE && s[2] == 0 && s[3] == 0) {
             *sp = LE;
-            return ZERObt;
+            return (VALUE)ZERObt;
         }
         break;
     case BE:
diff --git a/enc/trans/utf_16_32.trans b/enc/trans/utf_16_32.trans
index 632c8808efc6..1b172a475310 100644
--- a/enc/trans/utf_16_32.trans
+++ b/enc/trans/utf_16_32.trans
@@ -285,11 +285,11 @@ fun_si_from_utf_16(void *statep, const unsigned char *s, size_t l)
     case 0:
         if (s[0] == 0xFE && s[1] == 0xFF) {
             *sp = BE;
-            return ZERObt;
+            return (VALUE)ZERObt;
         }
         else if (s[0] == 0xFF && s[1] == 0xFE) {
             *sp = LE;
-            return ZERObt;
+            return (VALUE)ZERObt;
         }
         break;
     case BE:
@@ -333,11 +333,11 @@ fun_si_from_utf_32(void *statep, const unsigned char *s, size_t l)
     case 0:
         if (s[0] == 0 && s[1] == 0 && s[2] == 0xFE && s[3] == 0xFF) {
             *sp = BE;
-            return ZERObt;
+            return (VALUE)ZERObt;
         }
         else if (s[0] == 0xFF && s[1] == 0xFE && s[2] == 0 && s[3] == 0) {
             *sp = LE;
-            return ZERObt;
+            return (VALUE)ZERObt;
         }
         break;
     case BE:
diff --git a/enum.c b/enum.c
index cd48e8086667..1a5abd145b80 100644
--- a/enum.c
+++ b/enum.c
@@ -1170,7 +1170,7 @@ tally_up(st_data_t *group, st_data_t *value, st_data_t arg, int existing)
         tally = INT2FIX(1);
     }
     else if (FIXNUM_P(tally) && tally < INT2FIX(FIXNUM_MAX)) {
-        tally += INT2FIX(1) & ~FIXNUM_FLAG;
+        tally += (uintptr_t)INT2FIX(1) & ~FIXNUM_FLAG;
     }
     else {
         Check_Type(tally, T_BIGNUM);
@@ -4770,7 +4770,7 @@ enum_sum(int argc, VALUE* argv, VALUE obj)
         memo.c = 0.0;
     }
 
-    if (RTEST(rb_range_values(obj, &beg, &end, &excl))) {
+    if (RTEST((VALUE)rb_range_values(obj, &beg, &end, &excl))) {
         if (!memo.block_given && !memo.float_value &&
                 (FIXNUM_P(beg) || RB_BIGNUM_TYPE_P(beg)) &&
                 (FIXNUM_P(end) || RB_BIGNUM_TYPE_P(end))) {
diff --git a/error.c b/error.c
index 70ba070f422a..45d07fe7aaa2 100644
--- a/error.c
+++ b/error.c
@@ -171,7 +171,7 @@ rb_warning_category_from_name(VALUE category)
     ID cat_id;
     Check_Type(category, T_SYMBOL);
     if (!(cat_id = rb_check_id(&category)) ||
-        !st_lookup(warning_categories.id2enum, cat_id, &cat_value)) {
+        !st_lookup(warning_categories.id2enum, (st_data_t)cat_id, &cat_value)) {
         rb_raise(rb_eArgError, "unknown category: %"PRIsVALUE, category);
     }
     return (rb_warning_category_t)cat_value;
@@ -181,10 +181,10 @@ static VALUE
 rb_warning_category_to_name(rb_warning_category_t category)
 {
     st_data_t id;
-    if (!st_lookup(warning_categories.enum2id, category, &id)) {
+    if (!st_lookup(warning_categories.enum2id, (st_data_t)category, &id)) {
         rb_raise(rb_eArgError, "invalid category: %d", (int)category);
     }
-    return id ? ID2SYM(id) : Qnil;
+    return id ? ID2SYM((ID)id) : Qnil;
 }
 
 void
@@ -1178,10 +1178,10 @@ rb_builtin_type_name(int t)
 static VALUE
 displaying_class_of(VALUE x)
 {
-    switch (x) {
-      case Qfalse: return rb_fstring_cstr("false");
-      case Qnil:   return rb_fstring_cstr("nil");
-      case Qtrue:  return rb_fstring_cstr("true");
+    switch ((uintptr_t)x) {
+      case (uintptr_t)Qfalse: return rb_fstring_cstr("false");
+      case (uintptr_t)Qnil:   return rb_fstring_cstr("nil");
+      case (uintptr_t)Qtrue:  return rb_fstring_cstr("true");
       default:     return rb_obj_class(x);
     }
 }
@@ -1515,11 +1515,11 @@ check_highlight_keyword(VALUE opt, int auto_tty_detect)
     if (!NIL_P(opt)) {
         highlight = rb_hash_lookup(opt, sym_highlight);
 
-        switch (highlight) {
+        switch ((uintptr_t)highlight) {
           default:
             rb_bool_expected(highlight, "highlight", TRUE);
             UNREACHABLE;
-          case Qtrue: case Qfalse: case Qnil: break;
+          case (uintptr_t)Qtrue: case (uintptr_t)Qfalse: case (uintptr_t)Qnil: break;
         }
     }
 
@@ -1921,13 +1921,13 @@ exit_initialize(int argc, VALUE *argv, VALUE exc)
     if (argc > 0) {
         status = *argv;
 
-        switch (status) {
-          case Qtrue:
+        switch ((uintptr_t)status) {
+          case (uintptr_t)Qtrue:
             status = INT2FIX(EXIT_SUCCESS);
             ++argv;
             --argc;
             break;
-          case Qfalse:
+          case (uintptr_t)Qfalse:
             status = INT2FIX(EXIT_FAILURE);
             ++argv;
             --argc;
@@ -2329,14 +2329,14 @@ name_err_mesg_to_str(VALUE obj)
 #define FAKE_CSTR(v, str) rb_setup_fake_str((v), (str), rb_strlen_lit(str), usascii)
         c = s = FAKE_CSTR(&s_str, "");
         obj = ptr->recv;
-        switch (obj) {
-          case Qnil:
+        switch ((uintptr_t)obj) {
+          case (uintptr_t)Qnil:
             c = d = FAKE_CSTR(&d_str, "nil");
             break;
-          case Qtrue:
+          case (uintptr_t)Qtrue:
             c = d = FAKE_CSTR(&d_str, "true");
             break;
-          case Qfalse:
+          case (uintptr_t)Qfalse:
             c = d = FAKE_CSTR(&d_str, "false");
             break;
           default:
@@ -2477,7 +2477,7 @@ rb_invalid_str(const char *str, const char *type)
 {
     VALUE s = rb_str_new2(str);
 
-    rb_raise(rb_eArgError, "invalid value for %s: %+"PRIsVALUE, type, s);
+    rb_raise(rb_eArgError, "invalid value for %s: %"PRIsVALUE, type, s);
 }
 
 /*
@@ -2707,7 +2707,7 @@ set_syserr(int n, const char *name)
 {
     st_data_t error;
 
-    if (!st_lookup(syserr_tbl, n, &error)) {
+    if (!st_lookup(syserr_tbl, (st_data_t)n, &error)) {
         error = rb_define_class_under(rb_mErrno, name, rb_eSystemCallError);
 
         /* capture nonblock errnos for WaitReadable/WaitWritable subclasses */
@@ -2728,7 +2728,7 @@ set_syserr(int n, const char *name)
         }
 
         rb_define_const(error, "Errno", INT2NUM(n));
-        st_add_direct(syserr_tbl, n, error);
+        st_add_direct(syserr_tbl, (st_data_t)n, error);
     }
     else {
         rb_define_const(rb_mErrno, name, error);
@@ -2741,7 +2741,7 @@ get_syserr(int n)
 {
     st_data_t error;
 
-    if (!st_lookup(syserr_tbl, n, &error)) {
+    if (!st_lookup(syserr_tbl, (st_data_t)n, &error)) {
         char name[8];	/* some Windows' errno have 5 digits. */
 
         snprintf(name, sizeof(name), "E%03d", n);
@@ -2773,7 +2773,7 @@ syserr_initialize(int argc, VALUE *argv, VALUE self)
         if (argc == 1 && FIXNUM_P(mesg)) {
             error = mesg; mesg = Qnil;
         }
-        if (!NIL_P(error) && st_lookup(syserr_tbl, NUM2LONG(error), &data)) {
+        if (!NIL_P(error) && st_lookup(syserr_tbl, (st_data_t)NUM2LONG(error), &data)) {
             klass = (VALUE)data;
             /* change class */
             if (!RB_TYPE_P(self, T_OBJECT)) { /* insurance to avoid type crash */
@@ -3421,15 +3421,15 @@ Init_Exception(void)
     sym_highlight = ID2SYM(rb_intern_const("highlight"));
 
     warning_categories.id2enum = rb_init_identtable();
-    st_add_direct(warning_categories.id2enum, id_deprecated, RB_WARN_CATEGORY_DEPRECATED);
-    st_add_direct(warning_categories.id2enum, id_experimental, RB_WARN_CATEGORY_EXPERIMENTAL);
-    st_add_direct(warning_categories.id2enum, id_performance, RB_WARN_CATEGORY_PERFORMANCE);
+    st_add_direct(warning_categories.id2enum, (st_data_t)id_deprecated, (st_data_t)RB_WARN_CATEGORY_DEPRECATED);
+    st_add_direct(warning_categories.id2enum, (st_data_t)id_experimental, (st_data_t)RB_WARN_CATEGORY_EXPERIMENTAL);
+    st_add_direct(warning_categories.id2enum, (st_data_t)id_performance, (st_data_t)RB_WARN_CATEGORY_PERFORMANCE);
 
     warning_categories.enum2id = rb_init_identtable();
-    st_add_direct(warning_categories.enum2id, RB_WARN_CATEGORY_NONE, 0);
-    st_add_direct(warning_categories.enum2id, RB_WARN_CATEGORY_DEPRECATED, id_deprecated);
-    st_add_direct(warning_categories.enum2id, RB_WARN_CATEGORY_EXPERIMENTAL, id_experimental);
-    st_add_direct(warning_categories.enum2id, RB_WARN_CATEGORY_PERFORMANCE, id_performance);
+    st_add_direct(warning_categories.enum2id, (st_data_t)RB_WARN_CATEGORY_NONE, (st_data_t)0);
+    st_add_direct(warning_categories.enum2id, (st_data_t)RB_WARN_CATEGORY_DEPRECATED, (st_data_t)id_deprecated);
+    st_add_direct(warning_categories.enum2id, (st_data_t)RB_WARN_CATEGORY_EXPERIMENTAL, (st_data_t)id_experimental);
+    st_add_direct(warning_categories.enum2id, (st_data_t)RB_WARN_CATEGORY_PERFORMANCE, (st_data_t)id_performance);
 }
 
 void
diff --git a/eval.c b/eval.c
index a8fc48daf54a..464b10481f42 100644
--- a/eval.c
+++ b/eval.c
@@ -304,9 +304,9 @@ ruby_executable_node(void *n, int *status)
     VALUE v = (VALUE)n;
     int s;
 
-    switch (v) {
-      case Qtrue:  s = EXIT_SUCCESS; break;
-      case Qfalse: s = EXIT_FAILURE; break;
+    switch ((uintptr_t)v) {
+      case (uintptr_t)Qtrue:  s = EXIT_SUCCESS; break;
+      case (uintptr_t)Qfalse: s = EXIT_FAILURE; break;
       default:
         if (!FIXNUM_P(v)) return TRUE;
         s = FIX2INT(v);
diff --git a/ext/-test-/cxxanyargs/cxxanyargs.cpp b/ext/-test-/cxxanyargs/cxxanyargs.cpp
index eded13e2eec0..c3c5b72c0844 100644
--- a/ext/-test-/cxxanyargs/cxxanyargs.cpp
+++ b/ext/-test-/cxxanyargs/cxxanyargs.cpp
@@ -419,7 +419,7 @@ namespace test_rb_hash_foreach {
 
 namespace test_rb_ivar_foreach {
     static int
-    iter(VALUE, VALUE, VALUE)
+    iter(ID, VALUE, VALUE)
     {
         return ST_CONTINUE;
     }
diff --git a/ext/-test-/memory_view/memory_view.c b/ext/-test-/memory_view/memory_view.c
index c1df0353cfc5..fcdc02aeb852 100644
--- a/ext/-test-/memory_view/memory_view.c
+++ b/ext/-test-/memory_view/memory_view.c
@@ -198,7 +198,7 @@ memory_view_get_ref_count(VALUE obj)
 
     st_data_t count;
     if (st_lookup(table, (st_data_t)obj, &count)) {
-        return ULL2NUM(count);
+        return ULL2NUM((unsigned long long)count);
     }
 
     return Qnil;
diff --git a/ext/-test-/st/foreach/foreach.c b/ext/-test-/st/foreach/foreach.c
index 7fbf0646941c..5da4ca8d2ba5 100644
--- a/ext/-test-/st/foreach/foreach.c
+++ b/ext/-test-/st/foreach/foreach.c
@@ -1,7 +1,7 @@
 #include <ruby.h>
 #include <ruby/st.h>
 
-static st_data_t expect_size = 32;
+static uintptr_t expect_size = 32;
 struct checker {
     st_table *tbl;
     st_index_t nr;
@@ -12,13 +12,13 @@ static void
 force_unpack_check(struct checker *c, st_data_t key, st_data_t val)
 {
     if (c->nr == 0) {
-        st_data_t i;
+        uintptr_t i;
 
         if (c->tbl->bins != NULL) rb_bug("should be packed");
 
         /* force unpacking during iteration: */
         for (i = 1; i < expect_size; i++)
-            st_add_direct(c->tbl, i, i);
+            st_add_direct(c->tbl, (st_data_t)i, (st_data_t)i);
 
         if (c->tbl->bins == NULL) rb_bug("should be unpacked");
     }
@@ -86,7 +86,7 @@ unp_fec(VALUE self, VALUE test)
 
     if (tbl->bins != NULL) rb_bug("should still be packed");
 
-    st_foreach_check(tbl, unp_fec_i, (st_data_t)&c, -1);
+    st_foreach_check(tbl, unp_fec_i, (st_data_t)&c, (st_data_t)-1);
 
     if (c.test == ID2SYM(rb_intern("delete2"))) {
         if (c.nr != 1) {
diff --git a/ext/-test-/st/numhash/numhash.c b/ext/-test-/st/numhash/numhash.c
index 7e8d5d9fe2db..473bbc90d3ad 100644
--- a/ext/-test-/st/numhash/numhash.c
+++ b/ext/-test-/st/numhash/numhash.c
@@ -77,10 +77,10 @@ static int
 update_func(st_data_t *key, st_data_t *value, st_data_t arg, int existing)
 {
     VALUE ret = rb_yield_values(existing ? 2 : 1, (VALUE)*key, (VALUE)*value);
-    switch (ret) {
-      case Qfalse:
+    switch ((uintptr_t)ret) {
+      case (uintptr_t)Qfalse:
         return ST_STOP;
-      case Qnil:
+      case (uintptr_t)Qnil:
         return ST_DELETE;
       default:
         *value = ret;
diff --git a/ext/-test-/st/update/update.c b/ext/-test-/st/update/update.c
index ea7fab12e115..3d9c2198d4b4 100644
--- a/ext/-test-/st/update/update.c
+++ b/ext/-test-/st/update/update.c
@@ -5,10 +5,10 @@ static int
 update_func(st_data_t *key, st_data_t *value, st_data_t arg, int existing)
 {
     VALUE ret = rb_yield_values(existing ? 2 : 1, (VALUE)*key, (VALUE)*value);
-    switch (ret) {
-      case Qfalse:
+    switch ((uintptr_t)ret) {
+      case (uintptr_t)Qfalse:
         return ST_STOP;
-      case Qnil:
+      case (uintptr_t)Qnil:
         return ST_DELETE;
       default:
         *value = ret;
diff --git a/ext/-test-/vm/at_exit.c b/ext/-test-/vm/at_exit.c
index efc439b26ade..a571bacbfdfc 100644
--- a/ext/-test-/vm/at_exit.c
+++ b/ext/-test-/vm/at_exit.c
@@ -21,11 +21,11 @@ print_end(ruby_vm_t *vm)
 static VALUE
 register_at_exit(VALUE self, VALUE t)
 {
-    switch (t) {
-      case Qtrue:
+    switch ((uintptr_t)t) {
+      case (uintptr_t)Qtrue:
         ruby_vm_at_exit(print_begin);
         break;
-      case Qfalse:
+      case (uintptr_t)Qfalse:
         ruby_vm_at_exit(print_end);
         break;
       default:
diff --git a/ext/bigdecimal/bigdecimal.c b/ext/bigdecimal/bigdecimal.c
index cb8874d31a1a..776d3faafaf5 100644
--- a/ext/bigdecimal/bigdecimal.c
+++ b/ext/bigdecimal/bigdecimal.c
@@ -2906,7 +2906,7 @@ is_zero(VALUE x)
 	return FIX2LONG(x) == 0;
 
       case T_BIGNUM:
-	return Qfalse;
+	return (int)Qfalse;
 
       case T_RATIONAL:
 	num = rb_rational_num(x);
@@ -2929,7 +2929,7 @@ is_one(VALUE x)
 	return FIX2LONG(x) == 1;
 
       case T_BIGNUM:
-	return Qfalse;
+	return (int)Qfalse;
 
       case T_RATIONAL:
 	num = rb_rational_num(x);
@@ -3614,10 +3614,10 @@ rb_str_convert_to_BigDecimal(VALUE val, size_t digs, int raise_exception)
 static VALUE
 rb_convert_to_BigDecimal(VALUE val, size_t digs, int raise_exception)
 {
-    switch (val) {
-      case Qnil:
-      case Qtrue:
-      case Qfalse:
+    switch ((uintptr_t)val) {
+      case (uintptr_t)Qnil:
+      case (uintptr_t)Qtrue:
+      case (uintptr_t)Qfalse:
         if (raise_exception) {
             const char *cname = NIL_P(val)    ? "nil"   :
                                 val == Qtrue  ? "true"  :
diff --git a/ext/date/date_core.c b/ext/date/date_core.c
index 55706088f427..bb989984aa01 100644
--- a/ext/date/date_core.c
+++ b/ext/date/date_core.c
@@ -6957,7 +6957,7 @@ d_lite_hash(VALUE self)
 
     h[2] = m_jd(dat);
     h[3] = m_df(dat);
-    h[4] = m_sf(dat);
+    h[4] = (st_index_t)m_sf(dat);
 
     v = rb_memhash(h, sizeof(h));
     return ST2FIX(v);
diff --git a/ext/fiddle/fiddle.c b/ext/fiddle/fiddle.c
index f420d9fa3bb5..5c65e8e2e651 100644
--- a/ext/fiddle/fiddle.c
+++ b/ext/fiddle/fiddle.c
@@ -679,25 +679,25 @@ Init_fiddle(void)
      *
      * The value of Qtrue
      */
-    rb_define_const(mFiddle, "Qtrue", INT2NUM(Qtrue));
+    rb_define_const(mFiddle, "Qtrue", INT2NUM((uintptr_t)Qtrue));
 
     /* Document-const: Qfalse
      *
      * The value of Qfalse
      */
-    rb_define_const(mFiddle, "Qfalse", INT2NUM(Qfalse));
+    rb_define_const(mFiddle, "Qfalse", INT2NUM((uintptr_t)Qfalse));
 
     /* Document-const: Qnil
      *
      * The value of Qnil
      */
-    rb_define_const(mFiddle, "Qnil", INT2NUM(Qnil));
+    rb_define_const(mFiddle, "Qnil", INT2NUM((uintptr_t)Qnil));
 
     /* Document-const: Qundef
      *
      * The value of Qundef
      */
-    rb_define_const(mFiddle, "Qundef", INT2NUM(Qundef));
+    rb_define_const(mFiddle, "Qundef", INT2NUM((uintptr_t)Qundef));
 
     Init_fiddle_function();
     Init_fiddle_closure();
diff --git a/ext/io/console/console.c b/ext/io/console/console.c
index 78eb11a209e8..a05b56c3501c 100644
--- a/ext/io/console/console.c
+++ b/ext/io/console/console.c
@@ -205,17 +205,17 @@ rawmode_opt(int *argcp, VALUE *argv, int min_argc, int max_argc, rawmode_arg_t *
 	    opts->vtime = NUM2INT(vtime);
 	    optp = opts;
 	}
-	switch (intr) {
-	  case Qtrue:
+	switch ((uintptr_t)intr) {
+	  case (uintptr_t)Qtrue:
 	    opts->intr = 1;
 	    optp = opts;
 	    break;
-	  case Qfalse:
+	  case (uintptr_t)Qfalse:
 	    opts->intr = 0;
 	    optp = opts;
 	    break;
-	  case Qundef:
-	  case Qnil:
+	  case (uintptr_t)Qundef:
+	  case (uintptr_t)Qnil:
 	    break;
 	  default:
 	    rb_raise(rb_eArgError, "true or false expected as intr: %"PRIsVALUE,
diff --git a/ext/json/generator/generator.c b/ext/json/generator/generator.c
index 6d78284bc444..762f4fb6271c 100644
--- a/ext/json/generator/generator.c
+++ b/ext/json/generator/generator.c
@@ -1442,7 +1442,7 @@ static VALUE cState_max_nesting_set(VALUE self, VALUE depth)
 {
     GET_STATE(self);
     Check_Type(depth, T_FIXNUM);
-    return state->max_nesting = FIX2LONG(depth);
+    return (VALUE)(state->max_nesting = FIX2LONG(depth));
 }
 
 /*
diff --git a/ext/objspace/object_tracing.c b/ext/objspace/object_tracing.c
index c1c93c51f5fe..041e2e70cc6d 100644
--- a/ext/objspace/object_tracing.c
+++ b/ext/objspace/object_tracing.c
@@ -47,7 +47,7 @@ make_unique_str(st_table *tbl, const char *str, long len)
             result = (char *)ruby_xmalloc(len+1);
             strncpy(result, str, len);
             result[len] = 0;
-            st_add_direct(tbl, (st_data_t)result, 1);
+            st_add_direct(tbl, (st_data_t)result, (st_data_t)1);
         }
         return result;
     }
diff --git a/ext/objspace/objspace.h b/ext/objspace/objspace.h
index 95b84d6c1e0d..12514400297a 100644
--- a/ext/objspace/objspace.h
+++ b/ext/objspace/objspace.h
@@ -5,7 +5,7 @@
 struct allocation_info {
     /* all of information don't need marking. */
     int living;
-    VALUE flags;
+    uintptr_t flags;
     VALUE klass;
 
     /* allocation info */
diff --git a/ext/objspace/objspace_dump.c b/ext/objspace/objspace_dump.c
index 1812ba1d08c6..55ddcb34e431 100644
--- a/ext/objspace/objspace_dump.c
+++ b/ext/objspace/objspace_dump.c
@@ -176,8 +176,8 @@ dump_append_ptr(struct dump_config *dc, VALUE ref)
     buffer_start = buffer_end = &buffer[sizeof(buffer)];
     *--buffer_start = '"';
     while (ref) {
-        *--buffer_start = ruby_hexdigits[ref & 0xF];
-        ref >>= 4;
+        *--buffer_start = ruby_hexdigits[(uintptr_t)ref & 0xF];
+        ref = (VALUE)((uintptr_t)ref >> 4);
     }
     *--buffer_start = 'x';
     *--buffer_start = '0';
diff --git a/ext/openssl/ossl.c b/ext/openssl/ossl.c
index 00eded55cb9a..744ace5fe101 100644
--- a/ext/openssl/ossl.c
+++ b/ext/openssl/ossl.c
@@ -109,7 +109,7 @@ ossl_str_new(const char *ptr, long len, int *pstate)
     VALUE str;
     int state;
 
-    str = rb_protect(ossl_str_new_i, len, &state);
+    str = rb_protect(ossl_str_new_i, (VALUE)len, &state);
     if (pstate)
 	*pstate = state;
     if (state) {
diff --git a/ext/openssl/ossl_asn1.c b/ext/openssl/ossl_asn1.c
index f26a4759cf78..04dd11bad550 100644
--- a/ext/openssl/ossl_asn1.c
+++ b/ext/openssl/ossl_asn1.c
@@ -1758,7 +1758,7 @@ Init_ossl_asn1(void)
      * _tagging_ is not set when a ASN.1 structure is parsed using
      * OpenSSL::ASN1.decode.
      */
-    rb_attr(cASN1Primitive, rb_intern("tagging"), 1, 1, Qtrue);
+    rb_attr(cASN1Primitive, rb_intern("tagging"), 1, 1, (int)Qtrue);
     rb_undef_method(cASN1Primitive, "indefinite_length=");
     rb_undef_method(cASN1Primitive, "infinite_length=");
     rb_define_method(cASN1Primitive, "initialize", ossl_asn1_initialize, -1);
@@ -1799,7 +1799,7 @@ Init_ossl_asn1(void)
      * _tagging_ is not set when a ASN.1 structure is parsed using
      * OpenSSL::ASN1.decode.
      */
-    rb_attr(cASN1Constructive, rb_intern("tagging"), 1, 1, Qtrue);
+    rb_attr(cASN1Constructive, rb_intern("tagging"), 1, 1, (int)Qtrue);
     rb_define_method(cASN1Constructive, "initialize", ossl_asn1_initialize, -1);
     rb_define_method(cASN1Constructive, "to_der", ossl_asn1cons_to_der, 0);
     rb_define_method(cASN1Constructive, "each", ossl_asn1cons_each, 0);
diff --git a/ext/openssl/ossl_bn.c b/ext/openssl/ossl_bn.c
index ce0d3ec7eed1..baddf2c622f8 100644
--- a/ext/openssl/ossl_bn.c
+++ b/ext/openssl/ossl_bn.c
@@ -385,7 +385,7 @@ ossl_bn_to_i(VALUE self)
     if (!(txt = BN_bn2hex(bn))) {
 	ossl_raise(eBNError, NULL);
     }
-    num = rb_cstr_to_inum(txt, 16, Qtrue);
+    num = rb_cstr_to_inum(txt, 16, (int)Qtrue);
     OPENSSL_free(txt);
 
     return num;
diff --git a/ext/openssl/ossl_pkcs12.c b/ext/openssl/ossl_pkcs12.c
index 164b2da465fb..cbf5fc88116b 100644
--- a/ext/openssl/ossl_pkcs12.c
+++ b/ext/openssl/ossl_pkcs12.c
@@ -267,9 +267,10 @@ Init_ossl_pkcs12(void)
 
     rb_define_alloc_func(cPKCS12, ossl_pkcs12_s_allocate);
     rb_define_method(cPKCS12, "initialize_copy", ossl_pkcs12_initialize_copy, 1);
-    rb_attr(cPKCS12, rb_intern("key"), 1, 0, Qfalse);
-    rb_attr(cPKCS12, rb_intern("certificate"), 1, 0, Qfalse);
-    rb_attr(cPKCS12, rb_intern("ca_certs"), 1, 0, Qfalse);
+
+    rb_attr(cPKCS12, rb_intern("key"), 1, 0, (int)Qfalse);
+    rb_attr(cPKCS12, rb_intern("certificate"), 1, 0, (int)Qfalse);
+    rb_attr(cPKCS12, rb_intern("ca_certs"), 1, 0, (int)Qfalse);
     rb_define_method(cPKCS12, "initialize", ossl_pkcs12_initialize, -1);
     rb_define_method(cPKCS12, "to_der", ossl_pkcs12_to_der, 0);
 }
diff --git a/ext/openssl/ossl_pkcs7.c b/ext/openssl/ossl_pkcs7.c
index 7e5fb9c1b2da..7ea107e771a0 100644
--- a/ext/openssl/ossl_pkcs7.c
+++ b/ext/openssl/ossl_pkcs7.c
@@ -389,7 +389,7 @@ ossl_pkcs7_copy(VALUE self, VALUE other)
 static int
 ossl_pkcs7_sym2typeid(VALUE sym)
 {
-    int i, ret = Qnil;
+    int i, ret = (int)Qnil;
     const char *s;
     size_t l;
 
@@ -1032,8 +1032,8 @@ Init_ossl_pkcs7(void)
     rb_define_singleton_method(cPKCS7, "write_smime", ossl_pkcs7_s_write_smime, -1);
     rb_define_singleton_method(cPKCS7, "sign",  ossl_pkcs7_s_sign, -1);
     rb_define_singleton_method(cPKCS7, "encrypt", ossl_pkcs7_s_encrypt, -1);
-    rb_attr(cPKCS7, rb_intern("data"), 1, 0, Qfalse);
-    rb_attr(cPKCS7, rb_intern("error_string"), 1, 1, Qfalse);
+    rb_attr(cPKCS7, rb_intern("data"), 1, 0, (int)Qfalse);
+    rb_attr(cPKCS7, rb_intern("error_string"), 1, 1, (int)Qfalse);
     rb_define_alloc_func(cPKCS7, ossl_pkcs7_alloc);
     rb_define_method(cPKCS7, "initialize_copy", ossl_pkcs7_copy, 1);
     rb_define_method(cPKCS7, "initialize", ossl_pkcs7_initialize, -1);
diff --git a/ext/openssl/ossl_pkey_ec.c b/ext/openssl/ossl_pkey_ec.c
index 4b3a1fd0febb..2b25aaabb1b6 100644
--- a/ext/openssl/ossl_pkey_ec.c
+++ b/ext/openssl/ossl_pkey_ec.c
@@ -955,7 +955,7 @@ static VALUE ossl_ec_group_get_point_conversion_form(VALUE self)
 {
     EC_GROUP *group = NULL;
     point_conversion_form_t form;
-    VALUE ret;
+    ID ret;
 
     GetECGroup(self, group);
     form = EC_GROUP_get_point_conversion_form(group);
diff --git a/ext/openssl/ossl_ssl.c b/ext/openssl/ossl_ssl.c
index 236d455ff2a4..386fac0d1727 100644
--- a/ext/openssl/ossl_ssl.c
+++ b/ext/openssl/ossl_ssl.c
@@ -2640,7 +2640,7 @@ Init_ossl_ssl(void)
      * The _cert_, _key_, and _extra_chain_cert_ attributes are deprecated.
      * It is recommended to use #add_certificate instead.
      */
-    rb_attr(cSSLContext, rb_intern_const("cert"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("cert"), 1, 1, (int)Qfalse);
 
     /*
      * Context private key
@@ -2648,29 +2648,29 @@ Init_ossl_ssl(void)
      * The _cert_, _key_, and _extra_chain_cert_ attributes are deprecated.
      * It is recommended to use #add_certificate instead.
      */
-    rb_attr(cSSLContext, rb_intern_const("key"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("key"), 1, 1, (int)Qfalse);
 
     /*
      * A certificate or Array of certificates that will be sent to the client.
      */
-    rb_attr(cSSLContext, rb_intern_const("client_ca"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("client_ca"), 1, 1, (int)Qfalse);
 
     /*
      * The path to a file containing a PEM-format CA certificate
      */
-    rb_attr(cSSLContext, rb_intern_const("ca_file"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("ca_file"), 1, 1, (int)Qfalse);
 
     /*
      * The path to a directory containing CA certificates in PEM format.
      *
      * Files are looked up by subject's X509 name's hash value.
      */
-    rb_attr(cSSLContext, rb_intern_const("ca_path"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("ca_path"), 1, 1, (int)Qfalse);
 
     /*
      * Maximum session lifetime in seconds.
      */
-    rb_attr(cSSLContext, rb_intern_const("timeout"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("timeout"), 1, 1, (int)Qfalse);
 
     /*
      * Session verification mode.
@@ -2683,12 +2683,12 @@ Init_ossl_ssl(void)
      *
      * See SSL_CTX_set_verify(3) for details.
      */
-    rb_attr(cSSLContext, rb_intern_const("verify_mode"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("verify_mode"), 1, 1, (int)Qfalse);
 
     /*
      * Number of CA certificates to walk when verifying a certificate chain.
      */
-    rb_attr(cSSLContext, rb_intern_const("verify_depth"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("verify_depth"), 1, 1, (int)Qfalse);
 
     /*
      * A callback for additional certificate verification.  The callback is
@@ -2702,7 +2702,7 @@ Init_ossl_ssl(void)
      * If the callback returns +false+, the chain verification is immediately
      * stopped and a bad_certificate alert is then sent.
      */
-    rb_attr(cSSLContext, rb_intern_const("verify_callback"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("verify_callback"), 1, 1, (int)Qfalse);
 
     /*
      * Whether to check the server certificate is valid for the hostname.
@@ -2710,12 +2710,12 @@ Init_ossl_ssl(void)
      * In order to make this work, verify_mode must be set to VERIFY_PEER and
      * the server hostname must be given by OpenSSL::SSL::SSLSocket#hostname=.
      */
-    rb_attr(cSSLContext, rb_intern_const("verify_hostname"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("verify_hostname"), 1, 1, (int)Qfalse);
 
     /*
      * An OpenSSL::X509::Store used for certificate verification.
      */
-    rb_attr(cSSLContext, rb_intern_const("cert_store"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("cert_store"), 1, 1, (int)Qfalse);
 
     /*
      * An Array of extra X509 certificates to be added to the certificate
@@ -2724,7 +2724,7 @@ Init_ossl_ssl(void)
      * The _cert_, _key_, and _extra_chain_cert_ attributes are deprecated.
      * It is recommended to use #add_certificate instead.
      */
-    rb_attr(cSSLContext, rb_intern_const("extra_chain_cert"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("extra_chain_cert"), 1, 1, (int)Qfalse);
 
     /*
      * A callback invoked when a client certificate is requested by a server
@@ -2734,14 +2734,14 @@ Init_ossl_ssl(void)
      * containing an OpenSSL::X509::Certificate and an OpenSSL::PKey.  If any
      * other value is returned the handshake is suspended.
      */
-    rb_attr(cSSLContext, rb_intern_const("client_cert_cb"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("client_cert_cb"), 1, 1, (int)Qfalse);
 
     /*
      * Sets the context in which a session can be reused.  This allows
      * sessions for multiple applications to be distinguished, for example, by
      * name.
      */
-    rb_attr(cSSLContext, rb_intern_const("session_id_context"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("session_id_context"), 1, 1, (int)Qfalse);
 
     /*
      * A callback invoked on a server when a session is proposed by the client
@@ -2750,7 +2750,7 @@ Init_ossl_ssl(void)
      * The callback is invoked with the SSLSocket and session id.  The
      * callback may return a Session from an external cache.
      */
-    rb_attr(cSSLContext, rb_intern_const("session_get_cb"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("session_get_cb"), 1, 1, (int)Qfalse);
 
     /*
      * A callback invoked when a new session was negotiated.
@@ -2758,7 +2758,7 @@ Init_ossl_ssl(void)
      * The callback is invoked with an SSLSocket.  If +false+ is returned the
      * session will be removed from the internal cache.
      */
-    rb_attr(cSSLContext, rb_intern_const("session_new_cb"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("session_new_cb"), 1, 1, (int)Qfalse);
 
     /*
      * A callback invoked when a session is removed from the internal cache.
@@ -2769,7 +2769,7 @@ Init_ossl_ssl(void)
      * multi-threaded application. The callback is called inside a global lock
      * and it can randomly cause deadlock on Ruby thread switching.
      */
-    rb_attr(cSSLContext, rb_intern_const("session_remove_cb"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("session_remove_cb"), 1, 1, (int)Qfalse);
 
     /*
      * A callback invoked whenever a new handshake is initiated on an
@@ -2790,7 +2790,7 @@ Init_ossl_ssl(void)
      *     raise RuntimeError, "Client renegotiation disabled"
      *   end
      */
-    rb_attr(cSSLContext, rb_intern_const("renegotiation_cb"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("renegotiation_cb"), 1, 1, (int)Qfalse);
 #ifdef OSSL_USE_NEXTPROTONEG
     /*
      * An Enumerable of Strings. Each String represents a protocol to be
@@ -2803,7 +2803,7 @@ Init_ossl_ssl(void)
      *
      *   ctx.npn_protocols = ["http/1.1", "spdy/2"]
      */
-    rb_attr(cSSLContext, rb_intern_const("npn_protocols"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("npn_protocols"), 1, 1, (int)Qfalse);
     /*
      * A callback invoked on the client side when the client needs to select
      * a protocol from the list sent by the server. Supported in OpenSSL 1.0.1
@@ -2820,7 +2820,7 @@ Init_ossl_ssl(void)
      *     protocols.first
      *   end
      */
-    rb_attr(cSSLContext, rb_intern_const("npn_select_cb"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("npn_select_cb"), 1, 1, (int)Qfalse);
 #endif
 
     /*
@@ -2834,7 +2834,7 @@ Init_ossl_ssl(void)
      *
      *   ctx.alpn_protocols = ["http/1.1", "spdy/2", "h2"]
      */
-    rb_attr(cSSLContext, rb_intern_const("alpn_protocols"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("alpn_protocols"), 1, 1, (int)Qfalse);
     /*
      * A callback invoked on the server side when the server needs to select
      * a protocol from the list sent by the client. Supported in OpenSSL 1.0.2
@@ -2851,7 +2851,7 @@ Init_ossl_ssl(void)
      *     protocols.first
      *   end
      */
-    rb_attr(cSSLContext, rb_intern_const("alpn_select_cb"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("alpn_select_cb"), 1, 1, (int)Qfalse);
 
     /*
      * A callback invoked when TLS key material is generated or received, in
@@ -2874,7 +2874,7 @@ Init_ossl_ssl(void)
      *     end
      *   end
      */
-    rb_attr(cSSLContext, rb_intern_const("keylog_cb"), 1, 1, Qfalse);
+    rb_attr(cSSLContext, rb_intern_const("keylog_cb"), 1, 1, (int)Qfalse);
 
     rb_define_alias(cSSLContext, "ssl_timeout", "timeout");
     rb_define_alias(cSSLContext, "ssl_timeout=", "timeout=");
diff --git a/ext/openssl/ossl_x509ext.c b/ext/openssl/ossl_x509ext.c
index 192d09bd3fea..2ffacd4c00ff 100644
--- a/ext/openssl/ossl_x509ext.c
+++ b/ext/openssl/ossl_x509ext.c
@@ -469,11 +469,11 @@ Init_ossl_x509ext(void)
     rb_define_alloc_func(cX509ExtFactory, ossl_x509extfactory_alloc);
     rb_define_method(cX509ExtFactory, "initialize", ossl_x509extfactory_initialize, -1);
 
-    rb_attr(cX509ExtFactory, rb_intern("issuer_certificate"), 1, 0, Qfalse);
-    rb_attr(cX509ExtFactory, rb_intern("subject_certificate"), 1, 0, Qfalse);
-    rb_attr(cX509ExtFactory, rb_intern("subject_request"), 1, 0, Qfalse);
-    rb_attr(cX509ExtFactory, rb_intern("crl"), 1, 0, Qfalse);
-    rb_attr(cX509ExtFactory, rb_intern("config"), 1, 1, Qfalse);
+    rb_attr(cX509ExtFactory, rb_intern("issuer_certificate"), 1, 0, (int)Qfalse);
+    rb_attr(cX509ExtFactory, rb_intern("subject_certificate"), 1, 0, (int)Qfalse);
+    rb_attr(cX509ExtFactory, rb_intern("subject_request"), 1, 0, (int)Qfalse);
+    rb_attr(cX509ExtFactory, rb_intern("crl"), 1, 0, (int)Qfalse);
+    rb_attr(cX509ExtFactory, rb_intern("config"), 1, 1, (int)Qfalse);
 
     rb_define_method(cX509ExtFactory, "issuer_certificate=", ossl_x509extfactory_set_issuer_cert, 1);
     rb_define_method(cX509ExtFactory, "subject_certificate=", ossl_x509extfactory_set_subject_cert, 1);
diff --git a/ext/openssl/ossl_x509store.c b/ext/openssl/ossl_x509store.c
index f27381ca905f..6ad557203ae2 100644
--- a/ext/openssl/ossl_x509store.c
+++ b/ext/openssl/ossl_x509store.c
@@ -934,25 +934,25 @@ Init_ossl_x509store(void)
      *
      * See also the man page X509_STORE_CTX_set_verify_cb(3).
      */
-    rb_attr(cX509Store, rb_intern("verify_callback"), 1, 0, Qfalse);
+    rb_attr(cX509Store, rb_intern("verify_callback"), 1, 0, (int)Qfalse);
     /*
      * The error code set by the last call of #verify.
      *
      * See also StoreContext#error.
      */
-    rb_attr(cX509Store, rb_intern("error"), 1, 0, Qfalse);
+    rb_attr(cX509Store, rb_intern("error"), 1, 0, (int)Qfalse);
     /*
      * The description for the error code set by the last call of #verify.
      *
      * See also StoreContext#error_string.
      */
-    rb_attr(cX509Store, rb_intern("error_string"), 1, 0, Qfalse);
+    rb_attr(cX509Store, rb_intern("error_string"), 1, 0, (int)Qfalse);
     /*
      * The certificate chain constructed by the last call of #verify.
      *
      * See also StoreContext#chain.
      */
-    rb_attr(cX509Store, rb_intern("chain"), 1, 0, Qfalse);
+    rb_attr(cX509Store, rb_intern("chain"), 1, 0, (int)Qfalse);
     rb_define_alloc_func(cX509Store, ossl_x509store_alloc);
     rb_define_method(cX509Store, "initialize",   ossl_x509store_initialize, -1);
     rb_undef_method(cX509Store, "initialize_copy");
diff --git a/ext/ripper/ripper.y b/ext/ripper/ripper.y
index b79f1dee4104..bd33962761c8 100644
--- a/ext/ripper/ripper.y
+++ b/ext/ripper/ripper.y
@@ -350,7 +350,7 @@ RBIMPL_WARNING_POP()
     parser_set_lex_state(p, ls, __LINE__)
 static inline enum lex_state_e parser_set_lex_state(struct parser_params *p, enum lex_state_e ls, int line);
 
-typedef VALUE stack_type;
+typedef uintptr_t stack_type;
 
 static const rb_code_location_t NULL_LOC = { {0, -1}, {0, -1} };
 
@@ -1457,6 +1457,7 @@ void ripper_error(struct parser_params *p);
 
 #define yyparse ripper_yyparse
 
+#define THINGY(tok) ((VALUE)(tok))
 #define ID2VAL(id) STATIC_ID2SYM(id)
 #define TOKEN2VAL(t) ID2VAL(TOKEN2ID(t))
 #define KWD2EID(t, v) ripper_new_yylval(p, keyword_##t, get_value(v), 0)
@@ -1502,7 +1503,7 @@ new_array_pattern(struct parser_params *p, VALUE constant, VALUE pre_arg, VALUE
 }
 
 static VALUE
-new_array_pattern_tail(struct parser_params *p, VALUE pre_args, VALUE has_rest, VALUE rest_arg, VALUE post_args, const YYLTYPE *loc)
+new_array_pattern_tail(struct parser_params *p, VALUE pre_args, int has_rest, VALUE rest_arg, VALUE post_args, const YYLTYPE *loc)
 {
     return ripper_new_yylval2(p, pre_args, rest_arg, post_args);
 }
@@ -1555,6 +1556,7 @@ new_hash_pattern_tail(struct parser_params *p, VALUE kw_args, VALUE kw_rest_arg,
 static VALUE heredoc_dedent(struct parser_params*,VALUE);
 
 #else
+#define THINGY(tok) (tok)
 #define ID2VAL(id) (id)
 #define TOKEN2VAL(t) ID2VAL(t)
 #define KWD2EID(t, v) keyword_##t
@@ -3032,7 +3034,7 @@ mlhs_node	: user_variable
                     }
                 | primary_value call_op tIDENTIFIER
                     {
-                        anddot_multiple_assignment_check(p, &@2, $2);
+                        anddot_multiple_assignment_check(p, &@2, (ID)$2);
 #if 0
                         $$ = attrset(p, $1, $2, $3, &@$);
 #endif
@@ -3047,7 +3049,7 @@ mlhs_node	: user_variable
                     }
                 | primary_value call_op tCONSTANT
                     {
-                        anddot_multiple_assignment_check(p, &@2, $2);
+                        anddot_multiple_assignment_check(p, &@2, (ID)$2);
 #if 0
                         $$ = attrset(p, $1, $2, $3, &@$);
 #endif
@@ -3535,10 +3537,10 @@ endless_arg	: arg %prec modifier_rescue
                     }
                 ;
 
-relop		: '>'  {$$ = '>';}
-                | '<'  {$$ = '<';}
-                | tGEQ {$$ = idGE;}
-                | tLEQ {$$ = idLE;}
+relop		: '>'  {$$ = THINGY('>');}
+                | '<'  {$$ = THINGY('<');}
+                | tGEQ {$$ = THINGY(idGE);}
+                | tLEQ {$$ = THINGY(idLE);}
                 ;
 
 rel_expr	: arg relop arg   %prec '>'
@@ -3547,7 +3549,7 @@ rel_expr	: arg relop arg   %prec '>'
                     }
                 | rel_expr relop arg   %prec '>'
                     {
-                        rb_warning1("comparison '%s' after comparison", WARN_ID($2));
+                        rb_warning1("comparison '%s' after comparison", WARN_ID((ID)$2));
                         $$ = call_bin_op(p, $1, $2, $3, &@2, &@$);
                     }
                 ;
@@ -5887,7 +5889,7 @@ regexp_contents: /* none */
                             $$ = list_append(p, head, tail);
                         }
 #endif
-                        VALUE s1 = 1, s2 = 0, n1 = $1, n2 = $2;
+                        VALUE s1 = (VALUE)1, s2 = 0, n1 = $1, n2 = $2;
                         if (ripper_is_node_yylval(p, n1)) {
                             s1 = RNODE_RIPPER(n1)->nd_cval;
                             n1 = RNODE_RIPPER(n1)->nd_rval;
@@ -7413,7 +7415,7 @@ yycompile0(VALUE arg)
     }
     p->ast->body.root = tree;
     if (!p->ast->body.script_lines) p->ast->body.script_lines = INT2FIX(p->line_count);
-    return TRUE;
+    return (VALUE)TRUE;
 }
 
 static rb_ast_t *
@@ -9196,7 +9198,7 @@ formal_argument(struct parser_params *p, VALUE lhs)
 #undef ERR
     }
     shadowing_lvar(p, id);
-    return lhs;
+    return (ID)lhs;
 }
 
 static int
@@ -14656,7 +14658,7 @@ error_duplicate_pattern_variable(struct parser_params *p, ID id, const YYLTYPE *
     if (is_private_local_id(p, id)) {
         return;
     }
-    if (st_is_member(p->pvtbl, id)) {
+    if (st_is_member(p->pvtbl, (st_data_t)id)) {
         yyerror1(loc, "duplicated variable name");
     }
     else {
@@ -14665,12 +14667,12 @@ error_duplicate_pattern_variable(struct parser_params *p, ID id, const YYLTYPE *
 }
 
 static void
-error_duplicate_pattern_key(struct parser_params *p, VALUE key, const YYLTYPE *loc)
+error_duplicate_pattern_key(struct parser_params *p, ID key, const YYLTYPE *loc)
 {
     if (!p->pktbl) {
         p->pktbl = st_init_numtable();
     }
-    else if (st_is_member(p->pktbl, key)) {
+    else if (st_is_member(p->pktbl, (st_data_t)key)) {
         yyerror1(loc, "duplicated key name");
         return;
     }
diff --git a/ext/socket/ipsocket.c b/ext/socket/ipsocket.c
index 0c1362025846..6cb16b7b1293 100644
--- a/ext/socket/ipsocket.c
+++ b/ext/socket/ipsocket.c
@@ -196,10 +196,10 @@ rsock_revlookup_flag(VALUE revlookup, int *norevlookup)
 #define return_norevlookup(x) {*norevlookup = (x); return 1;}
     ID id;
 
-    switch (revlookup) {
-      case Qtrue:  return_norevlookup(0);
-      case Qfalse: return_norevlookup(1);
-      case Qnil: break;
+    switch ((uintptr_t)revlookup) {
+      case (uintptr_t)Qtrue:  return_norevlookup(0);
+      case (uintptr_t)Qfalse: return_norevlookup(1);
+      case (uintptr_t)Qnil: break;
       default:
         Check_Type(revlookup, T_SYMBOL);
         id = SYM2ID(revlookup);
diff --git a/ext/socket/unixsocket.c b/ext/socket/unixsocket.c
index a8475e3e6090..1ee6830b232f 100644
--- a/ext/socket/unixsocket.c
+++ b/ext/socket/unixsocket.c
@@ -212,7 +212,7 @@ static VALUE
 sendmsg_blocking(void *data)
 {
     struct iomsg_arg *arg = data;
-    return sendmsg(arg->fd, &arg->msg, 0);
+    return (VALUE)sendmsg(arg->fd, &arg->msg, 0);
 }
 
 /*
@@ -305,7 +305,7 @@ recvmsg_blocking(void *data)
 {
     struct iomsg_arg *arg = data;
     int flags = 0;
-    return rsock_recvmsg(arg->fd, &arg->msg, flags);
+    return (VALUE)rsock_recvmsg(arg->fd, &arg->msg, flags);
 }
 
 /*
diff --git a/gc.c b/gc.c
index 0346812f42bb..6959f9725c42 100644
--- a/gc.c
+++ b/gc.c
@@ -338,6 +338,2074 @@ size_mul_add_mul_or_raise(size_t x, size_t y, size_t z, size_t w, VALUE exc)
     }
 }
 
+#define nomem_error GET_VM()->special_exceptions[ruby_error_nomemory]
+
+size_t rb_iseq_memsize(const rb_iseq_t *iseq);
+
+typedef int each_obj_callback(void *, void *, size_t, void *);
+
+#define UNEXPECTED_NODE(func) \
+    rb_bug(#func"(): GC does not handle T_NODE 0x%x(%p) 0x%"PRIxVALUE, \
+           BUILTIN_TYPE(obj), (void*)(obj), RBASIC(obj)->flags)
+
+struct gc_raise_tag {
+    VALUE exc;
+    const char *fmt;
+    va_list *ap;
+};
+
+NORETURN(static void *gc_vraise(void *ptr));
+NORETURN(static void gc_raise(VALUE exc, const char *fmt, ...));
+
+static void *
+gc_vraise(void *ptr)
+{
+    struct gc_raise_tag *argv = ptr;
+    rb_vraise(argv->exc, argv->fmt, *argv->ap);
+    UNREACHABLE_RETURN(NULL);
+}
+
+static void
+gc_raise(VALUE exc, const char *fmt, ...)
+{
+    va_list ap;
+    va_start(ap, fmt);
+    struct gc_raise_tag argv = {
+        exc, fmt, &ap,
+    };
+
+    if (ruby_thread_has_gvl_p()) {
+        gc_vraise(&argv);
+        UNREACHABLE;
+    }
+    else if (ruby_native_thread_p()) {
+        rb_thread_call_with_gvl(gc_vraise, &argv);
+        UNREACHABLE;
+    }
+    else {
+        /* Not in a ruby thread */
+        fprintf(stderr, "%s", "[FATAL] ");
+        vfprintf(stderr, fmt, ap);
+    }
+
+    va_end(ap);
+    abort();
+}
+
+VALUE rb_mGC;
+int ruby_disable_gc = 0;
+
+#define CEILDIV(i, mod) roomof(i, mod)
+
+static void gc_finalize_deferred(void *dmy);
+
+static VALUE
+run_single_final(VALUE cmd, VALUE objid)
+{
+    return rb_check_funcall(cmd, idCall, 1, &objid);
+}
+
+static void
+warn_exception_in_finalizer(rb_execution_context_t *ec, VALUE final)
+{
+    if (!UNDEF_P(final) && !NIL_P(ruby_verbose)) {
+        VALUE errinfo = ec->errinfo;
+        rb_warn("Exception in finalizer %+"PRIsVALUE, final);
+        rb_ec_error_print(ec, errinfo);
+    }
+}
+
+static void
+run_finalizer(VALUE obj, VALUE table)
+{
+    long i;
+    enum ruby_tag_type state;
+    volatile struct {
+        VALUE errinfo;
+        VALUE objid;
+        VALUE final;
+        rb_control_frame_t *cfp;
+        VALUE *sp;
+        long finished;
+    } saved;
+
+    rb_execution_context_t * volatile ec = GET_EC();
+#define RESTORE_FINALIZER() (\
+        ec->cfp = saved.cfp, \
+        ec->cfp->sp = saved.sp, \
+        ec->errinfo = saved.errinfo)
+
+    saved.errinfo = ec->errinfo;
+    saved.objid = rb_obj_id(obj);
+    saved.cfp = ec->cfp;
+    saved.sp = ec->cfp->sp;
+    saved.finished = 0;
+    saved.final = Qundef;
+
+    EC_PUSH_TAG(ec);
+    state = EC_EXEC_TAG();
+    if (state != TAG_NONE) {
+        ++saved.finished;	/* skip failed finalizer */
+        warn_exception_in_finalizer(ec, ATOMIC_VALUE_EXCHANGE(saved.final, Qundef));
+    }
+    for (i = saved.finished;
+         RESTORE_FINALIZER(), i<RARRAY_LEN(table);
+         saved.finished = ++i) {
+        run_single_final(saved.final = RARRAY_AREF(table, i), saved.objid);
+    }
+    EC_POP_TAG();
+#undef RESTORE_FINALIZER
+}
+
+#ifdef __FILC__
+
+/* FIXME: I started out writing this chunk thinking that I'd just replace some simple API with calls
+   to malloc. But then I learned that the GC also provides functionality that isn't about GC itself,
+   like telling you the sizes of objects. So, I ended up copy-pasting a decent amount of code from the
+   !defined(__FILC__) case into here.
+
+   That kinda sucks but then again, maybe it's not even as bad as the rest of the carnage I have done
+   to Ruby. */
+
+typedef struct RVALUE {
+    union {
+        struct RBasic  basic;
+        struct RObject object;
+        struct RClass  klass;
+        struct RFloat  flonum;
+        struct RString string;
+        struct RArray  array;
+        struct RRegexp regexp;
+        struct RHash   hash;
+        struct RData   data;
+        struct RTypedData   typeddata;
+        struct RStruct rstruct;
+        struct RBignum bignum;
+        struct RFile   file;
+        struct RMatch  match;
+        struct RRational rational;
+        struct RComplex complex;
+        struct RSymbol symbol;
+        union {
+            rb_cref_t cref;
+            struct vm_svar svar;
+            struct vm_throw_data throw_data;
+            struct vm_ifunc ifunc;
+            struct MEMO memo;
+            struct rb_method_entry_struct ment;
+            const rb_iseq_t iseq;
+            rb_env_t env;
+            struct rb_imemo_tmpbuf_struct alloc;
+            rb_ast_t ast;
+        } imemo;
+        struct {
+            struct RBasic basic;
+            VALUE v1;
+            VALUE v2;
+            VALUE v3;
+        } values;
+    } as;
+} RVALUE;
+
+#define RANY(o) ((RVALUE*)(o))
+
+struct rb_objspace {
+    zweak_map *finalizer_table;
+    zgc_finq *finalizer_queue;
+    rb_postponed_job_handle_t finalize_deferred_pjob;
+    rb_atomic_t finalizing;
+    zgc_cycle_number completed_cycle;
+};
+
+#define get_objspace (*get_objspace_of(GET_VM()))
+#define get_objspace_of(vm) ((vm)->objspace)
+
+struct rb_objspace *
+rb_objspace_alloc(void)
+{
+    struct rb_objspace *result = malloc(sizeof(struct rb_objspace));
+    result->finalizer_table = zweak_map_new();
+    result->finalizer_queue = zgc_finq_new();
+    result->finalize_deferred_pjob = rb_postponed_job_preregister(0, gc_finalize_deferred, result);
+    if (result->finalize_deferred_pjob == POSTPONED_JOB_HANDLE_INVALID) {
+        rb_bug("Could not preregister postponed job for GC");
+    }
+    return result;
+}
+
+void
+rb_objspace_free(struct rb_objspace *objspace)
+{
+    free(objspace);
+}
+
+void
+rb_objspace_set_event_hook(const rb_event_flag_t event)
+{
+}
+
+size_t
+rb_size_pool_slot_size(unsigned char pool_id)
+{
+    ZASSERT(pool_id < SIZE_POOL_COUNT);
+
+    return (1 << pool_id) * sizeof(RVALUE);
+}
+
+bool
+rb_gc_size_allocatable_p(size_t size)
+{
+    return size <= rb_size_pool_slot_size(SIZE_POOL_COUNT - 1);
+}
+
+struct finalizer_box {
+    VALUE object;
+    VALUE table;
+    bool is_file;
+};
+
+static inline VALUE newobj(VALUE klass, uintptr_t flags, VALUE v1, VALUE v2, VALUE v3, size_t size)
+{
+    struct rb_objspace *objspace = &get_objspace;
+    zgc_cycle_number completed_cycle = zgc_completed_cycle();
+    if (completed_cycle != objspace->completed_cycle) {
+        objspace->completed_cycle = completed_cycle;
+        rb_postponed_job_trigger(objspace->finalize_deferred_pjob);
+    }
+    RVALUE *p = malloc(CEILDIV(size, sizeof(RVALUE)) * sizeof(RVALUE));
+    if ((flags & T_MASK) == T_FILE) {
+        struct finalizer_box *box = zgc_finq_alloc(objspace->finalizer_queue,
+                                                   sizeof(struct finalizer_box));
+        box->object = (VALUE)p;
+        box->is_file = true;
+        zweak_map_set(objspace->finalizer_table, p, box);
+    }
+    p->as.basic.flags = flags;
+    *(VALUE*)&p->as.basic.klass = klass;
+    p->as.values.v1 = v1;
+    p->as.values.v2 = v2;
+    p->as.values.v3 = v3;
+    return (VALUE)p;
+}
+
+VALUE
+rb_wb_unprotected_newobj_of(VALUE klass, uintptr_t flags, size_t size)
+{
+    return newobj(klass, flags, 0, 0, 0, size);
+}
+
+VALUE
+rb_wb_protected_newobj_of(rb_execution_context_t *ec, VALUE klass, uintptr_t flags, size_t size)
+{
+    return newobj(klass, flags, 0, 0, 0, size);
+}
+
+VALUE
+rb_newobj(void)
+{
+    return newobj(0, T_NONE, 0, 0, 0, RVALUE_SIZE);
+}
+
+static VALUE
+rb_class_instance_allocate_internal(VALUE klass, uintptr_t flags)
+{
+    ZASSERT((flags & RUBY_T_MASK) == T_OBJECT);
+    ZASSERT(flags & ROBJECT_EMBED);
+
+    size_t size;
+    uint32_t index_tbl_num_entries = RCLASS_EXT(klass)->max_iv_count;
+
+    size = rb_obj_embedded_size(index_tbl_num_entries);
+    if (!rb_gc_size_allocatable_p(size)) {
+        size = sizeof(struct RObject);
+    }
+
+    VALUE obj = newobj(klass, flags, 0, 0, 0, size);
+    RUBY_ASSERT(rb_shape_get_shape(obj)->type == SHAPE_ROOT);
+
+    // Set the shape to the specific T_OBJECT shape which is always
+    // SIZE_POOL_COUNT away from the root shape.
+    ROBJECT_SET_SHAPE_ID(obj, ROBJECT_SHAPE_ID(obj) + SIZE_POOL_COUNT);
+
+    return obj;
+}
+
+VALUE
+rb_newobj_of(VALUE klass, uintptr_t flags)
+{
+    if ((flags & RUBY_T_MASK) == T_OBJECT) {
+        return rb_class_instance_allocate_internal(klass, (flags | ROBJECT_EMBED) & ~FL_WB_PROTECTED);
+    }
+    else {
+        return newobj(klass, flags & ~FL_WB_PROTECTED, 0, 0, 0, sizeof(RVALUE));
+    }
+}
+
+const char *
+rb_imemo_name(enum imemo_type type)
+{
+    // put no default case to get a warning if an imemo type is missing
+    switch (type) {
+#define IMEMO_NAME(x) case imemo_##x: return #x;
+        IMEMO_NAME(env);
+        IMEMO_NAME(cref);
+        IMEMO_NAME(svar);
+        IMEMO_NAME(throw_data);
+        IMEMO_NAME(ifunc);
+        IMEMO_NAME(memo);
+        IMEMO_NAME(ment);
+        IMEMO_NAME(iseq);
+        IMEMO_NAME(tmpbuf);
+        IMEMO_NAME(ast);
+        IMEMO_NAME(parser_strterm);
+        IMEMO_NAME(callinfo);
+        IMEMO_NAME(callcache);
+        IMEMO_NAME(constcache);
+#undef IMEMO_NAME
+    }
+    return "unknown";
+}
+
+VALUE
+rb_imemo_new(enum imemo_type type, VALUE v1, VALUE v2, VALUE v3, VALUE v0)
+{
+    size_t size = sizeof(RVALUE);
+    uintptr_t flags = T_IMEMO | (type << FL_USHIFT);
+    return newobj(v0, flags, v1, v2, v3, size);
+}
+
+static VALUE
+rb_imemo_tmpbuf_new(VALUE v1, VALUE v2, VALUE v3, VALUE v0)
+{
+    size_t size = sizeof(struct rb_imemo_tmpbuf_struct);
+    uintptr_t flags = T_IMEMO | (imemo_tmpbuf << FL_USHIFT);
+    return newobj(v0, flags, v1, v2, v3, size);
+}
+
+static VALUE
+rb_imemo_tmpbuf_auto_free_maybe_mark_buffer(void *buf, size_t cnt)
+{
+    return rb_imemo_tmpbuf_new((VALUE)buf, 0, (VALUE)cnt, 0);
+}
+
+rb_imemo_tmpbuf_t *
+rb_imemo_tmpbuf_parser_heap(void *buf, rb_imemo_tmpbuf_t *old_heap, size_t cnt)
+{
+    return (rb_imemo_tmpbuf_t *)rb_imemo_tmpbuf_new((VALUE)buf, (VALUE)old_heap, (VALUE)cnt, 0);
+}
+
+static size_t
+imemo_memsize(VALUE obj)
+{
+    size_t size = 0;
+    switch (imemo_type(obj)) {
+      case imemo_ment:
+        size += sizeof(RANY(obj)->as.imemo.ment.def);
+        break;
+      case imemo_iseq:
+        size += rb_iseq_memsize((rb_iseq_t *)obj);
+        break;
+      case imemo_env:
+        size += RANY(obj)->as.imemo.env.env_size * sizeof(VALUE);
+        break;
+      case imemo_tmpbuf:
+        size += RANY(obj)->as.imemo.alloc.cnt * sizeof(VALUE);
+        break;
+      case imemo_ast:
+        size += rb_ast_memsize(&RANY(obj)->as.imemo.ast);
+        break;
+      case imemo_cref:
+      case imemo_svar:
+      case imemo_throw_data:
+      case imemo_ifunc:
+      case imemo_memo:
+      case imemo_parser_strterm:
+        break;
+      default:
+        /* unreachable */
+        break;
+    }
+    return size;
+}
+
+VALUE
+rb_class_allocate_instance(VALUE klass)
+{
+    return rb_class_instance_allocate_internal(klass, T_OBJECT | ROBJECT_EMBED);
+}
+
+static inline void
+rb_data_object_check(VALUE klass)
+{
+    if (klass != rb_cObject && (rb_get_alloc_func(klass) == rb_class_allocate_instance)) {
+        rb_undef_alloc_func(klass);
+        rb_warn("undefining the allocator of T_DATA class %"PRIsVALUE, klass);
+    }
+}
+
+VALUE
+rb_data_object_wrap(VALUE klass, void *datap, RUBY_DATA_FUNC dmark, RUBY_DATA_FUNC dfree)
+{
+    RUBY_ASSERT_ALWAYS(dfree != (RUBY_DATA_FUNC)1);
+    if (klass) rb_data_object_check(klass);
+    return newobj(klass, T_DATA, (VALUE)dmark, (VALUE)dfree, (VALUE)datap, sizeof(struct RTypedData));
+}
+
+VALUE
+rb_data_object_zalloc(VALUE klass, size_t size, RUBY_DATA_FUNC dmark, RUBY_DATA_FUNC dfree)
+{
+    VALUE obj = rb_data_object_wrap(klass, 0, dmark, dfree);
+    DATA_PTR(obj) = xcalloc(1, size);
+    return obj;
+}
+
+static VALUE
+typed_data_alloc(VALUE klass, uintptr_t typed_flag, void *datap, const rb_data_type_t *type, size_t size)
+{
+    RBIMPL_NONNULL_ARG(type);
+    if (klass) rb_data_object_check(klass);
+    return newobj(klass, T_DATA, (VALUE)type, (VALUE)(1 | typed_flag), (VALUE)datap, size);
+}
+
+VALUE
+rb_data_typed_object_wrap(VALUE klass, void *datap, const rb_data_type_t *type)
+{
+    if (UNLIKELY(type->flags & RUBY_TYPED_EMBEDDABLE)) {
+        rb_raise(rb_eTypeError, "Cannot wrap an embeddable TypedData");
+    }
+
+    return typed_data_alloc(klass, 0, datap, type, sizeof(struct RTypedData));
+}
+
+VALUE
+rb_data_typed_object_zalloc(VALUE klass, size_t size, const rb_data_type_t *type)
+{
+    if (type->flags & RUBY_TYPED_EMBEDDABLE) {
+        if (!(type->flags & RUBY_TYPED_FREE_IMMEDIATELY)) {
+            rb_raise(rb_eTypeError, "Embeddable TypedData must be freed immediately");
+        }
+
+        size_t embed_size = offsetof(struct RTypedData, data) + size;
+        if (rb_gc_size_allocatable_p(embed_size)) {
+            VALUE obj = typed_data_alloc(klass, TYPED_DATA_EMBEDDED, 0, type, embed_size);
+            memset((char *)obj + offsetof(struct RTypedData, data), 0, size);
+            return obj;
+        }
+    }
+
+    VALUE obj = typed_data_alloc(klass, 0, NULL, type, sizeof(struct RTypedData));
+    DATA_PTR(obj) = xcalloc(1, size);
+    return obj;
+}
+
+size_t
+rb_objspace_data_type_memsize(VALUE obj)
+{
+    size_t size = 0;
+    if (RTYPEDDATA_P(obj)) {
+        const rb_data_type_t *type = RTYPEDDATA_TYPE(obj);
+        const void *ptr = RTYPEDDATA_GET_DATA(obj);
+
+        if (RTYPEDDATA_TYPE(obj)->flags & RUBY_TYPED_EMBEDDABLE && !RTYPEDDATA_EMBEDDED_P(obj)) {
+#ifdef HAVE_MALLOC_USABLE_SIZE
+            size += malloc_usable_size((void *)ptr);
+#endif
+        }
+
+        if (ptr && type->function.dsize) {
+            size += type->function.dsize(ptr);
+        }
+    }
+
+    return size;
+}
+
+const char *
+rb_objspace_data_type_name(VALUE obj)
+{
+    if (RTYPEDDATA_P(obj)) {
+        return RTYPEDDATA_TYPE(obj)->wrap_struct_name;
+    }
+    else {
+        return 0;
+    }
+}
+
+static enum rb_id_table_iterator_result
+free_const_entry_i(VALUE value, void *data)
+{
+    rb_const_entry_t *ce = (rb_const_entry_t *)value;
+    xfree(ce);
+    return ID_TABLE_CONTINUE;
+}
+
+void
+rb_free_const_table(struct rb_id_table *tbl)
+{
+    rb_id_table_foreach_values(tbl, free_const_entry_i, 0);
+    rb_id_table_free(tbl);
+}
+
+static void
+vm_ccs_free(struct rb_class_cc_entries *ccs)
+{
+    if (ccs->entries) {
+        for (int i=0; i<ccs->len; i++) {
+            const struct rb_callcache *cc = ccs->entries[i].cc;
+            VM_ASSERT(!vm_cc_super_p(cc) && !vm_cc_refinement_p(cc));
+            vm_cc_invalidate(cc);
+        }
+        ruby_xfree(ccs->entries);
+    }
+    ruby_xfree(ccs);
+}
+
+void
+rb_vm_ccs_free(struct rb_class_cc_entries *ccs)
+{
+    RB_DEBUG_COUNTER_INC(ccs_free);
+    vm_ccs_free(ccs);
+}
+
+static enum rb_id_table_iterator_result
+cc_table_free_i(VALUE ccs_ptr, void *data_ptr)
+{
+    struct rb_class_cc_entries *ccs = (struct rb_class_cc_entries *)ccs_ptr;
+    VM_ASSERT(vm_ccs_p(ccs));
+    vm_ccs_free(ccs);
+    return ID_TABLE_CONTINUE;
+}
+
+static void
+cc_table_free(VALUE klass)
+{
+    struct rb_id_table *cc_tbl = RCLASS_CC_TBL(klass);
+
+    if (cc_tbl) {
+        rb_id_table_foreach_values(cc_tbl, cc_table_free_i, NULL);
+        rb_id_table_free(cc_tbl);
+    }
+}
+
+static enum rb_id_table_iterator_result
+cvar_table_free_i(VALUE value, void * ctx)
+{
+    xfree((void *) value);
+    return ID_TABLE_CONTINUE;
+}
+
+void
+rb_cc_table_free(VALUE klass)
+{
+    cc_table_free(klass);
+}
+
+void Init_heap(void)
+{
+}
+
+void Init_gc_stress(void)
+{
+}
+
+void
+rb_objspace_each_objects(each_obj_callback *callback, void *data)
+{
+    zerror("rb_objspace_each_objects not implemented");
+}
+
+static int
+internal_object_p(VALUE obj)
+{
+    RVALUE *p = (RVALUE *)obj;
+    void *ptr = obj;
+    bool used_p = p->as.basic.flags;
+
+    if (used_p) {
+        switch (BUILTIN_TYPE(obj)) {
+          case T_NODE:
+            UNEXPECTED_NODE(internal_object_p);
+            break;
+          case T_NONE:
+          case T_MOVED:
+          case T_IMEMO:
+          case T_ICLASS:
+          case T_ZOMBIE:
+            break;
+          case T_CLASS:
+            if (!p->as.basic.klass) break;
+            if (FL_TEST(obj, FL_SINGLETON)) {
+                return rb_singleton_class_internal_p(obj);
+            }
+            return 0;
+          default:
+            if (!p->as.basic.klass) break;
+            return 0;
+        }
+    }
+    return 1;
+}
+
+int
+rb_objspace_internal_object_p(VALUE obj)
+{
+    return internal_object_p(obj);
+}
+
+VALUE
+rb_undefine_finalizer(VALUE obj)
+{
+    struct rb_objspace *objspace = &get_objspace;
+    rb_check_frozen(obj);
+    zweak_map_set(objspace->finalizer_table, obj, NULL);
+    FL_UNSET(obj, FL_FINALIZE);
+    return obj;
+}
+
+static void
+should_be_callable(VALUE block)
+{
+    if (!rb_obj_respond_to(block, idCall, TRUE)) {
+        rb_raise(rb_eArgError, "wrong type argument %"PRIsVALUE" (should be callable)",
+                 rb_obj_class(block));
+    }
+}
+
+static void
+should_be_finalizable(VALUE obj)
+{
+    if (!FL_ABLE(obj)) {
+        rb_raise(rb_eArgError, "cannot define finalizer for %s",
+                 rb_obj_classname(obj));
+    }
+    rb_check_frozen(obj);
+}
+
+VALUE
+rb_define_finalizer_no_check(VALUE obj, VALUE block)
+{
+    struct rb_objspace *objspace = &get_objspace;
+    struct finalizer_box* box;
+
+    RBASIC(obj)->flags |= FL_FINALIZE;
+
+    box = zweak_map_get(objspace->finalizer_table, obj);
+    if (!box) {
+        struct finalizer_box* box = zgc_finq_alloc(objspace->finalizer_queue,
+                                                   sizeof(struct finalizer_box));
+        box->object = obj;
+        zweak_map_set(objspace->finalizer_table, obj, box);
+    }
+
+    if (box->table) {
+        long len = RARRAY_LEN(box->table);
+        long i;
+        for (i = 0; i < len; i++) {
+            VALUE recv = RARRAY_AREF(box->table, i);
+            if (rb_equal(recv, block)) {
+                block = recv;
+                goto end;
+            }
+        }
+        rb_ary_push(box->table, block);
+    } else {
+        box->table = rb_ary_new3(1, block);
+        RBASIC_CLEAR_CLASS(box->table);
+    }
+  end:
+    block = rb_ary_new3(2, INT2FIX(0), block);
+    OBJ_FREEZE(block);
+    return block;
+}
+
+static VALUE
+define_final(int argc, VALUE *argv, VALUE os)
+{
+    VALUE obj, block;
+
+    rb_scan_args(argc, argv, "11", &obj, &block);
+    should_be_finalizable(obj);
+    if (argc == 1) {
+        block = rb_block_proc();
+    }
+    else {
+        should_be_callable(block);
+    }
+
+    if (rb_callable_receiver(block) == obj) {
+        rb_warn("finalizer references object to be finalized");
+    }
+
+    return rb_define_finalizer_no_check(obj, block);
+}
+
+VALUE
+rb_define_finalizer(VALUE obj, VALUE block)
+{
+    should_be_finalizable(obj);
+    should_be_callable(block);
+    return rb_define_finalizer_no_check(obj, block);
+}
+
+void
+rb_gc_copy_finalizer(VALUE dest, VALUE obj)
+{
+    struct rb_objspace *objspace = &get_objspace;
+
+    if (!FL_TEST(obj, FL_FINALIZE)) return;
+
+    struct finalizer_box *box = zweak_map_get(objspace->finalizer_table, obj);
+    if (box) {
+        struct finalizer_box *new_box = zgc_finq_alloc(objspace->finalizer_queue,
+                                                       sizeof(struct finalizer_box));
+        new_box->object = dest;
+        new_box->table = box->table;
+        zweak_map_set(objspace->finalizer_table, dest, new_box);
+    }
+
+    FL_SET(dest, FL_FINALIZE);
+}
+
+void
+rb_objspace_free_objects(struct rb_objspace *objspace)
+{
+}
+
+static void
+finalize_box(struct finalizer_box* box, bool expect_valid)
+{
+    if (expect_valid) {
+        ZASSERT(box->object);
+    } else {
+        if (!box->object) {
+            return;
+        }
+    }
+    if (box->table) {
+        run_finalizer(box->object, box->table);
+    }
+    if (box->is_file) {
+        rb_io_fptr_finalize_internal(RANY(box->object)->as.file.fptr);
+    }
+    box->object = NULL;
+    box->table = NULL;
+    box->is_file = false;
+}
+
+static void
+finalize_deferred(struct rb_objspace *objspace, bool expect_valid)
+{
+    struct finalizer_box* box;
+    while ((box = zgc_finq_poll(objspace->finalizer_queue))) {
+        finalize_box(box, expect_valid);
+    }
+}
+
+static void
+gc_finalize_deferred(void *dmy)
+{
+    struct rb_objspace *objspace = dmy;
+    if (ATOMIC_EXCHANGE(objspace->finalizing, 1)) return;
+    finalize_deferred(objspace, true);
+    ATOMIC_SET(objspace->finalizing, 0);
+}
+
+void
+rb_objspace_call_finalizer(struct rb_objspace *objspace)
+{
+    if (ATOMIC_EXCHANGE(objspace->finalizing, 1)) return;
+    finalize_deferred(objspace, true);
+
+    zweak_map_iter *iter = zweak_map_get_iter(objspace->finalizer_table);
+    while (zweak_map_iter_next(iter)) {
+        finalize_box(zweak_map_iter_value(iter), false);
+    }
+
+    /* If there was a GC that was racing with us, then make sure it finishes, and then process the
+       finalizers one last time. */
+    zgc_wait(zgc_requested_cycle());
+    finalize_deferred(objspace, false);
+    ATOMIC_SET(objspace->finalizing, 0);
+}
+
+int
+rb_objspace_markable_object_p(VALUE obj)
+{
+    zerror("rb_objspace_markable_object_p not implemented");
+    return 0;
+}
+
+int
+rb_objspace_garbage_object_p(VALUE obj)
+{
+    /* FIXME: Any call to this indicates a weak map that isn't weak in the Fil-C port. */
+    return FALSE;
+}
+
+bool
+rb_gc_is_ptr_to_obj(void *ptr)
+{
+    zerror("rb_gc_is_ptr_to_obj not implemented");
+    return false;
+}
+
+VALUE
+rb_gc_id2ref_obj_tbl(VALUE objid)
+{
+    zerror("rb_gc_id2ref_obj_tbl not implemented");
+    return Qnil;
+}
+
+static VALUE
+os_id2ref(VALUE os, VALUE objid)
+{
+    zerror("id2ref not implemented");
+    return Qnil;
+}
+
+static VALUE
+rb_find_object_id(VALUE obj)
+{
+    if (STATIC_SYM_P(obj)) {
+        return (VALUE)((SYM2ID(obj) * sizeof(RVALUE) + (4 << 2)) | FIXNUM_FLAG);
+    }
+    else if (FLONUM_P(obj)) {
+#if SIZEOF_LONG == SIZEOF_VOIDP
+        return LONG2NUM((SIGNED_VALUE)obj);
+#else
+        return LL2NUM((SIGNED_VALUE)obj);
+#endif
+    }
+    else if (SPECIAL_CONST_P(obj)) {
+        return LONG2NUM((SIGNED_VALUE)obj);
+    }
+
+#if SIZEOF_LONG == SIZEOF_VOIDP
+    return (VALUE)((SIGNED_VALUE)(obj)|FIXNUM_FLAG);
+#elif SIZEOF_LONG_LONG == SIZEOF_VOIDP
+    return LL2NUM((SIGNED_VALUE)(obj) / 2);
+#else
+# error not supported
+#endif
+}
+
+VALUE
+rb_memory_id(VALUE obj)
+{
+    return rb_find_object_id(obj);
+}
+
+VALUE
+rb_obj_id(VALUE obj)
+{
+    /*
+     *                32-bit VALUE space
+     *          MSB ------------------------ LSB
+     *  false   00000000000000000000000000000000
+     *  true    00000000000000000000000000000010
+     *  nil     00000000000000000000000000000100
+     *  undef   00000000000000000000000000000110
+     *  symbol  ssssssssssssssssssssssss00001110
+     *  object  oooooooooooooooooooooooooooooo00        = 0 (mod sizeof(RVALUE))
+     *  fixnum  fffffffffffffffffffffffffffffff1
+     *
+     *                    object_id space
+     *                                       LSB
+     *  false   00000000000000000000000000000000
+     *  true    00000000000000000000000000000010
+     *  nil     00000000000000000000000000000100
+     *  undef   00000000000000000000000000000110
+     *  symbol   000SSSSSSSSSSSSSSSSSSSSSSSSSSS0        S...S % A = 4 (S...S = s...s * A + 4)
+     *  object   oooooooooooooooooooooooooooooo0        o...o % A = 0
+     *  fixnum  fffffffffffffffffffffffffffffff1        bignum if required
+     *
+     *  where A = sizeof(RVALUE)/4
+     *
+     *  sizeof(RVALUE) is
+     *  20 if 32-bit, double is 4-byte aligned
+     *  24 if 32-bit, double is 8-byte aligned
+     *  40 if 64-bit
+     */
+
+    return rb_find_object_id(obj);
+}
+
+static enum rb_id_table_iterator_result
+cc_table_memsize_i(VALUE ccs_ptr, void *data_ptr)
+{
+    size_t *total_size = data_ptr;
+    struct rb_class_cc_entries *ccs = (struct rb_class_cc_entries *)ccs_ptr;
+    *total_size += sizeof(*ccs);
+    *total_size += sizeof(ccs->entries[0]) * ccs->capa;
+    return ID_TABLE_CONTINUE;
+}
+
+static size_t
+cc_table_memsize(struct rb_id_table *cc_table)
+{
+    size_t total = rb_id_table_memsize(cc_table);
+    rb_id_table_foreach_values(cc_table, cc_table_memsize_i, &total);
+    return total;
+}
+
+size_t
+rb_gc_obj_slot_size(VALUE obj)
+{
+    return (char*)zgetupper(obj) - (char*)zgetlower(obj);
+}
+
+static size_t
+obj_memsize_of(VALUE obj, int use_all_types)
+{
+    size_t size = 0;
+
+    if (SPECIAL_CONST_P(obj)) {
+        return 0;
+    }
+
+    if (FL_TEST(obj, FL_EXIVAR)) {
+        size += rb_generic_ivar_memsize(obj);
+    }
+
+    switch (BUILTIN_TYPE(obj)) {
+      case T_OBJECT:
+        if (rb_shape_obj_too_complex(obj)) {
+            size += rb_st_memsize(ROBJECT_IV_HASH(obj));
+        }
+        else if (!(RBASIC(obj)->flags & ROBJECT_EMBED)) {
+            size += ROBJECT_IV_CAPACITY(obj) * sizeof(VALUE);
+        }
+        break;
+      case T_MODULE:
+      case T_CLASS:
+        if (RCLASS_M_TBL(obj)) {
+            size += rb_id_table_memsize(RCLASS_M_TBL(obj));
+        }
+        // class IV sizes are allocated as powers of two
+        size += SIZEOF_VALUE << bit_length(RCLASS_IV_COUNT(obj));
+        if (RCLASS_CVC_TBL(obj)) {
+            size += rb_id_table_memsize(RCLASS_CVC_TBL(obj));
+        }
+        if (RCLASS_EXT(obj)->const_tbl) {
+            size += rb_id_table_memsize(RCLASS_EXT(obj)->const_tbl);
+        }
+        if (RCLASS_CC_TBL(obj)) {
+            size += cc_table_memsize(RCLASS_CC_TBL(obj));
+        }
+        if (FL_TEST_RAW(obj, RCLASS_SUPERCLASSES_INCLUDE_SELF)) {
+            size += (RCLASS_SUPERCLASS_DEPTH(obj) + 1) * sizeof(VALUE);
+        }
+        break;
+      case T_ICLASS:
+        if (RICLASS_OWNS_M_TBL_P(obj)) {
+            if (RCLASS_M_TBL(obj)) {
+                size += rb_id_table_memsize(RCLASS_M_TBL(obj));
+            }
+        }
+        if (RCLASS_CC_TBL(obj)) {
+            size += cc_table_memsize(RCLASS_CC_TBL(obj));
+        }
+        break;
+      case T_STRING:
+        size += rb_str_memsize(obj);
+        break;
+      case T_ARRAY:
+        size += rb_ary_memsize(obj);
+        break;
+      case T_HASH:
+        if (RHASH_ST_TABLE_P(obj)) {
+            VM_ASSERT(RHASH_ST_TABLE(obj) != NULL);
+            /* st_table is in the slot */
+            size += st_memsize(RHASH_ST_TABLE(obj)) - sizeof(st_table);
+        }
+        break;
+      case T_REGEXP:
+        if (RREGEXP_PTR(obj)) {
+            size += onig_memsize(RREGEXP_PTR(obj));
+        }
+        break;
+      case T_DATA:
+        if (use_all_types) size += rb_objspace_data_type_memsize(obj);
+        break;
+      case T_MATCH:
+        {
+            rb_matchext_t *rm = RMATCH_EXT(obj);
+            size += onig_region_memsize(&rm->regs);
+            size += sizeof(struct rmatch_offset) * rm->char_offset_num_allocated;
+        }
+        break;
+      case T_FILE:
+        if (RFILE(obj)->fptr) {
+            size += rb_io_memsize(RFILE(obj)->fptr);
+        }
+        break;
+      case T_RATIONAL:
+      case T_COMPLEX:
+        break;
+      case T_IMEMO:
+        size += imemo_memsize(obj);
+        break;
+
+      case T_FLOAT:
+      case T_SYMBOL:
+        break;
+
+      case T_BIGNUM:
+        if (!(RBASIC(obj)->flags & BIGNUM_EMBED_FLAG) && BIGNUM_DIGITS(obj)) {
+            size += BIGNUM_LEN(obj) * sizeof(BDIGIT);
+        }
+        break;
+
+      case T_NODE:
+        UNEXPECTED_NODE(obj_memsize_of);
+        break;
+
+      case T_STRUCT:
+        if ((RBASIC(obj)->flags & RSTRUCT_EMBED_LEN_MASK) == 0 &&
+            RSTRUCT(obj)->as.heap.ptr) {
+            size += sizeof(VALUE) * RSTRUCT_LEN(obj);
+        }
+        break;
+
+      case T_ZOMBIE:
+      case T_MOVED:
+        break;
+
+      default:
+        rb_bug("objspace/memsize_of(): unknown data type 0x%x(%p)",
+               BUILTIN_TYPE(obj), (void*)obj);
+    }
+
+    return size + rb_gc_obj_slot_size(obj);
+}
+
+size_t
+rb_obj_memsize_of(VALUE obj)
+{
+    return obj_memsize_of(obj, TRUE);
+}
+
+static VALUE
+count_objects(int argc, VALUE *argv, VALUE os)
+{
+    return Qnil;
+}
+
+size_t
+ruby_stack_length(VALUE **p)
+{
+    zerror("ruby_stack_length unimplemented");
+    return 0;
+}
+
+int
+rb_ec_stack_check(rb_execution_context_t *ec)
+{
+    return FALSE;
+}
+
+int
+ruby_stack_check(void)
+{
+    return FALSE;
+}
+
+void
+rb_gc_mark_locations(const VALUE *start, const VALUE *end)
+{
+    zerror("rb_gc_mark_locations not supported");
+}
+
+void
+rb_gc_mark_values(long n, const VALUE *values)
+{
+    zerror("rb_gc_mark_values not supported");
+}
+
+void
+rb_gc_mark_vm_stack_values(long n, const VALUE *values)
+{
+    zerror("rb_gc_mark_vm_stack_values not supported");
+}
+
+void
+rb_mark_set(st_table *tbl)
+{
+    zerror("rb_mark_set not supported");
+}
+
+void
+rb_mark_hash(st_table *tbl)
+{
+    zerror("rb_mark_hash not supported");
+}
+
+void
+rb_mark_tbl(st_table *tbl)
+{
+    zerror("rb_mark_tbl not supported");
+}
+
+void
+rb_mark_tbl_no_pin(st_table *tbl)
+{
+    zerror("rb_mark_tbl_no_pin not supported");
+}
+
+void
+rb_gc_mark_maybe(VALUE obj)
+{
+    zerror("rb_gc_mark_maybe not supported");
+}
+
+
+void
+rb_gc_mark_movable(VALUE ptr)
+{
+    zerror("rb_gc_mark_movable not supported");
+}
+
+void
+rb_gc_mark(VALUE ptr)
+{
+    zerror("rb_gc_mark not supported");
+}
+
+void
+rb_gc_mark_and_move(VALUE *ptr)
+{
+    zerror("rb_gc_mark_and_move not supported");
+}
+
+void
+rb_gc_mark_weak(VALUE *ptr)
+{
+    zerror("rb_gc_mark_weak not supported");
+}
+
+void
+rb_gc_remove_weak(VALUE parent_obj, VALUE *ptr)
+{
+    zerror("rb_gc_remove_weak not supported");
+}
+
+int
+rb_objspace_marked_object_p(VALUE obj)
+{
+    zerror("rb_objspace_marked_object_p not supported");
+    return 0;
+}
+
+void
+rb_gc_writebarrier(VALUE a, VALUE b)
+{
+}
+
+void
+rb_gc_writebarrier_unprotect(VALUE obj)
+{
+}
+
+void
+rb_gc_writebarrier_remember(VALUE obj)
+{
+}
+
+void
+rb_copy_wb_protected_attribute(VALUE dest, VALUE obj)
+{
+}
+
+VALUE
+rb_obj_rgengc_writebarrier_protected_p(VALUE obj)
+{
+    return Qfalse;
+}
+
+VALUE
+rb_obj_rgengc_promoted_p(VALUE obj)
+{
+    return Qfalse;
+}
+
+size_t
+rb_obj_gc_flags(VALUE obj, ID* flags, size_t max)
+{
+    return 0;
+}
+
+void
+rb_gc_ractor_newobj_cache_clear(rb_ractor_newobj_cache_t *newobj_cache)
+{
+}
+
+void
+rb_gc_force_recycle(VALUE obj)
+{
+    /* no-op */
+}
+
+void
+rb_gc_register_mark_object(VALUE obj)
+{
+}
+
+void
+rb_gc_register_address(VALUE *addr)
+{
+}
+
+void
+rb_gc_unregister_address(VALUE *addr)
+{
+}
+
+void
+rb_global_variable(VALUE *var)
+{
+}
+
+void
+rb_gc_prepare_heap(void)
+{
+}
+
+void
+rb_gc_ref_update_table_values_only(st_table *tbl)
+{
+    zerror("rb_gc_ref_update_table_values_only not supported");
+}
+
+void
+rb_gc_update_tbl_refs(st_table *ptr)
+{
+    zerror("rb_gc_update_tbl_refs not supported");
+}
+
+void
+rb_gc_update_values(long n, VALUE *values)
+{
+    zerror("rb_gc_update_values not supported");
+}
+
+VALUE
+rb_gc_location(VALUE value)
+{
+    return value;
+}
+
+VALUE
+rb_gc_start(void)
+{
+    zgc_request_fresh();
+    return Qnil;
+}
+
+void
+rb_gc(void)
+{
+    zgc_request_fresh();
+}
+
+int
+rb_during_gc(void)
+{
+    return zgc_requested_cycle() != zgc_completed_cycle();
+}
+
+size_t
+rb_gc_count(void)
+{
+    return zgc_completed_cycle();
+}
+
+static VALUE
+gc_count(rb_execution_context_t *ec, VALUE self)
+{
+    return SIZET2NUM(rb_gc_count());
+}
+
+static VALUE
+gc_info_decode(const VALUE hash_or_key)
+{
+    VALUE hash = Qnil;
+    if (RB_TYPE_P(hash_or_key, T_HASH))
+        hash = hash_or_key;
+    return hash;
+}
+
+VALUE
+rb_gc_latest_gc_info(VALUE key)
+{
+    return gc_info_decode(key);
+}
+
+size_t
+rb_gc_stat(VALUE key)
+{
+    return 0;
+}
+
+VALUE
+rb_gc_enable(void)
+{
+    return Qtrue;
+}
+
+VALUE
+rb_objspace_gc_enable(struct rb_objspace *objspace)
+{
+    return Qtrue;
+}
+
+VALUE
+rb_gc_disable_no_rest(void)
+{
+    return Qtrue;
+}
+
+VALUE
+rb_gc_disable(void)
+{
+    return Qtrue;
+}
+
+void
+ruby_gc_set_params(void)
+{
+}
+
+void
+rb_objspace_reachable_objects_from(VALUE obj, void (func)(VALUE, void *), void *data)
+{
+    zerror("rb_objspace_reachable_objects_from unimplemented");
+}
+
+void
+rb_objspace_reachable_objects_from_root(void (func)(const char *category, VALUE, void *), void *passing_data)
+{
+    zerror("rb_objspace_reachable_objects_from_root unimplemented");
+}
+
+void
+rb_memerror(void)
+{
+    rb_execution_context_t *ec = GET_EC();
+    VALUE exc;
+
+    if (0) {
+        // Print out pid, sleep, so you can attach debugger to see what went wrong:
+        fprintf(stderr, "rb_memerror pid=%"PRI_PIDT_PREFIX"d\n", getpid());
+        sleep(60);
+    }
+
+    exc = nomem_error;
+    if (!exc ||
+        rb_ec_raised_p(ec, RAISED_NOMEMORY)) {
+        fprintf(stderr, "[FATAL] failed to allocate memory\n");
+        exit(EXIT_FAILURE);
+    }
+    if (rb_ec_raised_p(ec, RAISED_NOMEMORY)) {
+        rb_ec_raised_clear(ec);
+    }
+    else {
+        rb_ec_raised_set(ec, RAISED_NOMEMORY);
+        exc = ruby_vm_special_exception_copy(exc);
+    }
+    ec->errinfo = exc;
+    EC_JUMP_TAG(ec, TAG_RAISE);
+}
+
+void *
+rb_aligned_malloc(size_t alignment, size_t size)
+{
+    return zgc_aligned_alloc(alignment, size);
+}
+
+void
+rb_malloc_info_show_results(void)
+{
+}
+
+void *
+ruby_xmalloc_body(size_t size)
+{
+    return malloc(size);
+}
+
+void
+ruby_malloc_size_overflow(size_t count, size_t elsize)
+{
+    rb_raise(rb_eArgError,
+             "malloc: possible integer overflow (%"PRIuSIZE"*%"PRIuSIZE")",
+             count, elsize);
+}
+
+static inline size_t
+xmalloc2_size(const size_t count, const size_t elsize)
+{
+    return size_mul_or_raise(count, elsize, rb_eArgError);
+}
+
+void *
+ruby_xmalloc2_body(size_t n, size_t size)
+{
+    return malloc(xmalloc2_size(n, size));
+}
+
+void *
+ruby_xcalloc_body(size_t n, size_t size)
+{
+    return malloc(xmalloc2_size(n, size));
+}
+
+#ifdef ruby_sized_xrealloc
+#undef ruby_sized_xrealloc
+#endif
+void *
+ruby_sized_xrealloc(void *ptr, size_t new_size, size_t old_size)
+{
+    return realloc(ptr, new_size);
+}
+
+void *
+ruby_xrealloc_body(void *ptr, size_t new_size)
+{
+    return realloc(ptr, new_size);
+}
+
+#ifdef ruby_sized_xrealloc2
+#undef ruby_sized_xrealloc2
+#endif
+void *
+ruby_sized_xrealloc2(void *ptr, size_t n, size_t size, size_t old_n)
+{
+    size_t len = xmalloc2_size(n, size);
+    return realloc(ptr, len);
+}
+
+void *
+ruby_xrealloc2_body(void *ptr, size_t n, size_t size)
+{
+    return ruby_sized_xrealloc2(ptr, n, size, 0);
+}
+
+#ifdef ruby_sized_xfree
+#undef ruby_sized_xfree
+#endif
+void
+ruby_sized_xfree(void *x, size_t size)
+{
+    free(x);
+}
+
+void
+ruby_xfree(void *x)
+{
+    free(x);
+}
+
+void *
+rb_xmalloc_mul_add(size_t x, size_t y, size_t z) /* x * y + z */
+{
+    size_t w = size_mul_add_or_raise(x, y, z, rb_eArgError);
+    return ruby_xmalloc(w);
+}
+
+void *
+rb_xcalloc_mul_add(size_t x, size_t y, size_t z) /* x * y + z */
+{
+    size_t w = size_mul_add_or_raise(x, y, z, rb_eArgError);
+    return ruby_xcalloc(w, 1);
+}
+
+void *
+rb_xrealloc_mul_add(const void *p, size_t x, size_t y, size_t z) /* x * y + z */
+{
+    size_t w = size_mul_add_or_raise(x, y, z, rb_eArgError);
+    return ruby_xrealloc((void *)p, w);
+}
+
+void *
+rb_xmalloc_mul_add_mul(size_t x, size_t y, size_t z, size_t w) /* x * y + z * w */
+{
+    size_t u = size_mul_add_mul_or_raise(x, y, z, w, rb_eArgError);
+    return ruby_xmalloc(u);
+}
+
+void *
+rb_xcalloc_mul_add_mul(size_t x, size_t y, size_t z, size_t w) /* x * y + z * w */
+{
+    size_t u = size_mul_add_mul_or_raise(x, y, z, w, rb_eArgError);
+    return ruby_xcalloc(u, 1);
+}
+
+void *
+ruby_mimmalloc(size_t size)
+{
+    return malloc(size);
+}
+
+void
+ruby_mimfree(void *ptr)
+{
+    free(ptr);
+}
+
+void *
+rb_alloc_tmp_buffer_with_count(volatile VALUE *store, size_t size, size_t cnt)
+{
+    void *ptr;
+    VALUE imemo;
+    rb_imemo_tmpbuf_t *tmpbuf;
+
+    /* Keep the order; allocate an empty imemo first then xmalloc, to
+     * get rid of potential memory leak */
+    imemo = rb_imemo_tmpbuf_auto_free_maybe_mark_buffer(NULL, 0);
+    *store = imemo;
+    ptr = malloc(size);
+    tmpbuf = (rb_imemo_tmpbuf_t *)imemo;
+    tmpbuf->ptr = ptr;
+    tmpbuf->cnt = cnt;
+    return ptr;
+}
+
+void *
+rb_alloc_tmp_buffer(volatile VALUE *store, long len)
+{
+    long cnt;
+
+    if (len < 0 || (cnt = (long)roomof(len, sizeof(VALUE))) < 0) {
+        rb_raise(rb_eArgError, "negative buffer size (or size too big)");
+    }
+
+    return rb_alloc_tmp_buffer_with_count(store, len, cnt);
+}
+
+void
+rb_free_tmp_buffer(volatile VALUE *store)
+{
+    rb_imemo_tmpbuf_t *s = (rb_imemo_tmpbuf_t*)ATOMIC_VALUE_EXCHANGE(*store, 0);
+    if (s) {
+        void *ptr = ATOMIC_PTR_EXCHANGE(s->ptr, 0);
+        s->cnt = 0;
+        ruby_xfree(ptr);
+    }
+}
+
+void
+rb_gc_adjust_memory_usage(ssize_t diff)
+{
+}
+
+const char *
+rb_method_type_name(rb_method_type_t type)
+{
+    switch (type) {
+      case VM_METHOD_TYPE_ISEQ:           return "iseq";
+      case VM_METHOD_TYPE_ATTRSET:        return "attrest";
+      case VM_METHOD_TYPE_IVAR:           return "ivar";
+      case VM_METHOD_TYPE_BMETHOD:        return "bmethod";
+      case VM_METHOD_TYPE_ALIAS:          return "alias";
+      case VM_METHOD_TYPE_REFINED:        return "refined";
+      case VM_METHOD_TYPE_CFUNC:          return "cfunc";
+      case VM_METHOD_TYPE_ZSUPER:         return "zsuper";
+      case VM_METHOD_TYPE_MISSING:        return "missing";
+      case VM_METHOD_TYPE_OPTIMIZED:      return "optimized";
+      case VM_METHOD_TYPE_UNDEF:          return "undef";
+      case VM_METHOD_TYPE_NOTIMPLEMENTED: return "notimplemented";
+    }
+    rb_bug("rb_method_type_name: unreachable (type: %d)", type);
+}
+
+static void
+rb_raw_iseq_info(char *const buff, const size_t buff_size, const rb_iseq_t *iseq)
+{
+    if (buff_size > 0 && ISEQ_BODY(iseq) && ISEQ_BODY(iseq)->location.label && !RB_TYPE_P(ISEQ_BODY(iseq)->location.pathobj, T_MOVED)) {
+        VALUE path = rb_iseq_path(iseq);
+        int n = ISEQ_BODY(iseq)->location.first_lineno;
+        snprintf(buff, buff_size, " %s@%s:%d",
+                 RSTRING_PTR(ISEQ_BODY(iseq)->location.label),
+                 RSTRING_PTR(path), n);
+    }
+}
+
+static const char *
+type_name(int type, VALUE obj)
+{
+    switch (type) {
+#define TYPE_NAME(t) case (t): return #t;
+            TYPE_NAME(T_NONE);
+            TYPE_NAME(T_OBJECT);
+            TYPE_NAME(T_CLASS);
+            TYPE_NAME(T_MODULE);
+            TYPE_NAME(T_FLOAT);
+            TYPE_NAME(T_STRING);
+            TYPE_NAME(T_REGEXP);
+            TYPE_NAME(T_ARRAY);
+            TYPE_NAME(T_HASH);
+            TYPE_NAME(T_STRUCT);
+            TYPE_NAME(T_BIGNUM);
+            TYPE_NAME(T_FILE);
+            TYPE_NAME(T_MATCH);
+            TYPE_NAME(T_COMPLEX);
+            TYPE_NAME(T_RATIONAL);
+            TYPE_NAME(T_NIL);
+            TYPE_NAME(T_TRUE);
+            TYPE_NAME(T_FALSE);
+            TYPE_NAME(T_SYMBOL);
+            TYPE_NAME(T_FIXNUM);
+            TYPE_NAME(T_UNDEF);
+            TYPE_NAME(T_IMEMO);
+            TYPE_NAME(T_ICLASS);
+            TYPE_NAME(T_MOVED);
+            TYPE_NAME(T_ZOMBIE);
+      case T_DATA:
+        if (obj && rb_objspace_data_type_name(obj)) {
+            return rb_objspace_data_type_name(obj);
+        }
+        return "T_DATA";
+#undef TYPE_NAME
+    }
+    return "unknown";
+}
+
+static const char *
+obj_type_name(VALUE obj)
+{
+    return type_name(TYPE(obj), obj);
+}
+
+static int
+str_len_no_raise(VALUE str)
+{
+    long len = RSTRING_LEN(str);
+    if (len < 0) return 0;
+    if (len > INT_MAX) return INT_MAX;
+    return (int)len;
+}
+
+#define BUFF_ARGS buff + pos, buff_size - pos
+#define APPEND_F(...) if ((pos += snprintf(BUFF_ARGS, "" __VA_ARGS__)) >= buff_size) goto end
+#define APPEND_S(s) do { \
+        if ((pos + (int)rb_strlen_lit(s)) >= buff_size) { \
+            goto end; \
+        } \
+        else { \
+            memcpy(buff + pos, (s), rb_strlen_lit(s) + 1); \
+        } \
+    } while (0)
+#define TF(c) ((c) != 0 ? "true" : "false")
+#define C(c, s) ((c) != 0 ? (s) : " ")
+
+static size_t
+rb_raw_obj_info_common(char *const buff, const size_t buff_size, const VALUE obj)
+{
+    size_t pos = 0;
+
+    if (SPECIAL_CONST_P(obj)) {
+        APPEND_F("%s", obj_type_name(obj));
+
+        if (FIXNUM_P(obj)) {
+            APPEND_F(" %ld", FIX2LONG(obj));
+        }
+        else if (SYMBOL_P(obj)) {
+            APPEND_F(" %s", rb_id2name(SYM2ID(obj)));
+        }
+    }
+    else {
+        APPEND_F("%p [%s] %s ",
+                 obj, zptr_to_new_string(obj), obj_type_name(obj));
+        if (internal_object_p(obj)) {
+            /* ignore */
+        }
+        else if (RBASIC(obj)->klass == 0) {
+            APPEND_S("(temporary internal)");
+        }
+        else if (RTEST(RBASIC(obj)->klass)) {
+            VALUE class_path = rb_class_path_cached(RBASIC(obj)->klass);
+            if (!NIL_P(class_path)) {
+                APPEND_F("(%s)", RSTRING_PTR(class_path));
+            }
+        }
+    }
+
+  end:
+    return pos;
+}
+
+static size_t
+rb_raw_obj_info_buitin_type(char *const buff, const size_t buff_size, const VALUE obj, size_t pos)
+{
+    if (LIKELY(pos < buff_size) && !SPECIAL_CONST_P(obj)) {
+        const enum ruby_value_type type = BUILTIN_TYPE(obj);
+
+        switch (type) {
+          case T_NODE:
+            UNEXPECTED_NODE(rb_raw_obj_info);
+            break;
+          case T_ARRAY:
+            if (ARY_SHARED_P(obj)) {
+                APPEND_S("shared -> ");
+                rb_raw_obj_info(BUFF_ARGS, ARY_SHARED_ROOT(obj));
+            }
+            else if (ARY_EMBED_P(obj)) {
+                APPEND_F("[%s%s] len: %ld (embed)",
+                         C(ARY_EMBED_P(obj),  "E"),
+                         C(ARY_SHARED_P(obj), "S"),
+                         RARRAY_LEN(obj));
+            }
+            else {
+                APPEND_F("[%s%s] len: %ld, capa:%ld ptr:%p",
+                         C(ARY_EMBED_P(obj),  "E"),
+                         C(ARY_SHARED_P(obj), "S"),
+                         RARRAY_LEN(obj),
+                         ARY_EMBED_P(obj) ? -1L : RARRAY(obj)->as.heap.aux.capa,
+                         (void *)RARRAY_CONST_PTR(obj));
+            }
+            break;
+          case T_STRING: {
+            if (STR_SHARED_P(obj)) {
+                APPEND_F(" [shared] len: %ld", RSTRING_LEN(obj));
+            }
+            else {
+                if (STR_EMBED_P(obj)) APPEND_S(" [embed]");
+
+                APPEND_F(" len: %ld, capa: %" PRIdSIZE, RSTRING_LEN(obj), rb_str_capacity(obj));
+            }
+            APPEND_F(" \"%.*s\"", str_len_no_raise(obj), RSTRING_PTR(obj));
+            break;
+          }
+          case T_SYMBOL: {
+            VALUE fstr = RSYMBOL(obj)->fstr;
+            ID id = RSYMBOL(obj)->id;
+            if (RB_TYPE_P(fstr, T_STRING)) {
+                APPEND_F(":%s id:%d", RSTRING_PTR(fstr), (unsigned int)id);
+            }
+            else {
+                APPEND_F("(%p) id:%d", (void *)fstr, (unsigned int)id);
+            }
+            break;
+          }
+          case T_MOVED: {
+            APPEND_F("-> %p", (void*)rb_gc_location(obj));
+            break;
+          }
+          case T_HASH: {
+            APPEND_F("[%c] %"PRIdSIZE,
+                     RHASH_AR_TABLE_P(obj) ? 'A' : 'S',
+                     RHASH_SIZE(obj));
+            break;
+          }
+          case T_CLASS:
+          case T_MODULE:
+            {
+                VALUE class_path = rb_class_path_cached(obj);
+                if (!NIL_P(class_path)) {
+                    APPEND_F("%s", RSTRING_PTR(class_path));
+                }
+                else {
+                    APPEND_S("(anon)");
+                }
+                break;
+            }
+          case T_ICLASS:
+            {
+                VALUE class_path = rb_class_path_cached(RBASIC_CLASS(obj));
+                if (!NIL_P(class_path)) {
+                    APPEND_F("src:%s", RSTRING_PTR(class_path));
+                }
+                break;
+            }
+          case T_OBJECT:
+            {
+                if (rb_shape_obj_too_complex(obj)) {
+                    size_t hash_len = rb_st_table_size(ROBJECT_IV_HASH(obj));
+                    APPEND_F("(too_complex) len:%"PRIuSIZE"", hash_len);
+                }
+                else {
+                    uint32_t len = ROBJECT_IV_CAPACITY(obj);
+
+                    if (RANY(obj)->as.basic.flags & ROBJECT_EMBED) {
+                        APPEND_F("(embed) len:%d", len);
+                    }
+                    else {
+                        VALUE *ptr = ROBJECT_IVPTR(obj);
+                        APPEND_F("len:%d ptr:%p", len, (void *)ptr);
+                    }
+                }
+            }
+            break;
+          case T_DATA: {
+            const struct rb_block *block;
+            const rb_iseq_t *iseq;
+            if (rb_obj_is_proc(obj) &&
+                (block = vm_proc_block(obj)) != NULL &&
+                (vm_block_type(block) == block_type_iseq) &&
+                (iseq = vm_block_iseq(block)) != NULL) {
+                rb_raw_iseq_info(BUFF_ARGS, iseq);
+            }
+            else if (rb_ractor_p(obj)) {
+                rb_ractor_t *r = (void *)DATA_PTR(obj);
+                if (r) {
+                    APPEND_F("r:%d", r->pub.id);
+                }
+            }
+            else {
+                const char * const type_name = rb_objspace_data_type_name(obj);
+                if (type_name) {
+                    APPEND_F("%s", type_name);
+                }
+            }
+            break;
+          }
+          case T_IMEMO: {
+            APPEND_F("<%s> ", rb_imemo_name(imemo_type(obj)));
+
+            switch (imemo_type(obj)) {
+              case imemo_ment:
+                {
+                    const rb_method_entry_t *me = &RANY(obj)->as.imemo.ment;
+
+                    APPEND_F(":%s (%s%s%s%s) type:%s aliased:%d owner:%p defined_class:%p",
+                             rb_id2name(me->called_id),
+                             METHOD_ENTRY_VISI(me) == METHOD_VISI_PUBLIC ?  "pub" :
+                             METHOD_ENTRY_VISI(me) == METHOD_VISI_PRIVATE ? "pri" : "pro",
+                             METHOD_ENTRY_COMPLEMENTED(me) ? ",cmp" : "",
+                             METHOD_ENTRY_CACHED(me) ? ",cc" : "",
+                             METHOD_ENTRY_INVALIDATED(me) ? ",inv" : "",
+                             me->def ? rb_method_type_name(me->def->type) : "NULL",
+                             me->def ? me->def->aliased : -1,
+                             (void *)me->owner, // obj_info(me->owner),
+                             (void *)me->defined_class); //obj_info(me->defined_class)));
+
+                    if (me->def) {
+                        switch (me->def->type) {
+                          case VM_METHOD_TYPE_ISEQ:
+                            APPEND_S(" (iseq:");
+                            rb_raw_obj_info(BUFF_ARGS, (VALUE)me->def->body.iseq.iseqptr);
+                            APPEND_S(")");
+                            break;
+                          default:
+                            break;
+                        }
+                    }
+
+                    break;
+                }
+              case imemo_iseq: {
+                const rb_iseq_t *iseq = (const rb_iseq_t *)obj;
+                rb_raw_iseq_info(BUFF_ARGS, iseq);
+                break;
+              }
+              case imemo_callinfo:
+                {
+                    const struct rb_callinfo *ci = (const struct rb_callinfo *)obj;
+                    APPEND_F("(mid:%s, flag:%x argc:%d, kwarg:%s)",
+                             rb_id2name(vm_ci_mid(ci)),
+                             vm_ci_flag(ci),
+                             vm_ci_argc(ci),
+                             vm_ci_kwarg(ci) ? "available" : "NULL");
+                    break;
+                }
+              case imemo_callcache:
+                {
+                    const struct rb_callcache *cc = (const struct rb_callcache *)obj;
+                    VALUE class_path = cc->klass ? rb_class_path_cached(cc->klass) : Qnil;
+                    const rb_callable_method_entry_t *cme = vm_cc_cme(cc);
+
+                    APPEND_F("(klass:%s cme:%s%s (%p) call:%p",
+                             NIL_P(class_path) ? (cc->klass ? "??" : "<NULL>") : RSTRING_PTR(class_path),
+                             cme ? rb_id2name(cme->called_id) : "<NULL>",
+                             cme ? (METHOD_ENTRY_INVALIDATED(cme) ? " [inv]" : "") : "",
+                             (void *)cme,
+                             (void *)vm_cc_call(cc));
+                    break;
+                }
+              default:
+                break;
+            }
+          }
+          default:
+            break;
+        }
+    }
+  end:
+
+    return pos;
+}
+
+#undef TF
+#undef C
+
+const char *
+rb_raw_obj_info(char *const buff, const size_t buff_size, VALUE obj)
+{
+    size_t pos = rb_raw_obj_info_common(buff, buff_size, obj);
+    pos = rb_raw_obj_info_buitin_type(buff, buff_size, obj, pos);
+    if (pos >= buff_size) {} // truncated
+
+    return buff;
+}
+
+#undef APPEND_S
+#undef APPEND_F
+#undef BUFF_ARGS
+
+static const char *
+obj_info(VALUE obj)
+{
+    return obj_type_name(obj);
+}
+
+const char *
+rb_obj_info(VALUE obj)
+{
+    return obj_info(obj);
+}
+
+void
+rb_obj_info_dump(VALUE obj)
+{
+    char buff[0x100];
+    fprintf(stderr, "rb_obj_info_dump: %s\n", rb_raw_obj_info(buff, 0x100, obj));
+}
+
+void
+rb_obj_info_dump_loc(VALUE obj, const char *file, int line, const char *func)
+{
+    char buff[0x100];
+    fprintf(stderr, "<OBJ_INFO:%s@%s:%d> %s\n", func, file, line, rb_raw_obj_info(buff, 0x100, obj));
+}
+
+static VALUE
+gc_profile_clear(VALUE _)
+{
+    return Qnil;
+}
+
+static VALUE
+gc_profile_record_get(VALUE _)
+{
+    return Qnil;
+}
+
+static VALUE
+gc_profile_result(VALUE _)
+{
+    return Qnil;
+}
+
+static VALUE
+gc_profile_report(int argc, VALUE *argv, VALUE self)
+{
+    return Qnil;
+}
+
+static VALUE
+gc_profile_total_time(VALUE self)
+{
+    return DBL2NUM(0);
+}
+
+static VALUE
+gc_profile_enable_get(VALUE self)
+{
+    return Qfalse;
+}
+
+static VALUE
+gc_profile_enable(VALUE _)
+{
+    return Qnil;
+}
+
+static VALUE
+gc_profile_disable(VALUE _)
+{
+    return Qnil;
+}
+
+static VALUE
+gc_verify_internal_consistency_m(VALUE dummy)
+{
+    return Qnil;
+}
+
+static VALUE
+undefine_final(VALUE os, VALUE obj)
+{
+    return rb_undefine_finalizer(obj);
+}
+
+void
+rb_gc_mark_machine_stack(const rb_execution_context_t *ec)
+{
+    zerror("rb_gc_mark_machine_stack not supported");
+}
+
+#include "gc.rbinc"
+
+void
+Init_GC(void)
+{
+#undef rb_intern
+    malloc_offset = gc_compute_malloc_offset();
+
+    VALUE rb_mObjSpace;
+    VALUE rb_mProfiler;
+    VALUE gc_constants;
+
+    rb_mGC = rb_define_module("GC");
+
+    gc_constants = rb_hash_new();
+    rb_hash_aset(gc_constants, ID2SYM(rb_intern("DEBUG")), RBOOL(Qfalse));
+    rb_hash_aset(gc_constants, ID2SYM(rb_intern("BASE_SLOT_SIZE")), SIZET2NUM(sizeof(RVALUE)));
+    rb_hash_aset(gc_constants, ID2SYM(rb_intern("RVALUE_OVERHEAD")), SIZET2NUM(0));
+    rb_hash_aset(gc_constants, ID2SYM(rb_intern("RVALUE_SIZE")), SIZET2NUM(sizeof(RVALUE)));
+    rb_hash_aset(gc_constants, ID2SYM(rb_intern("SIZE_POOL_COUNT")), LONG2FIX(SIZE_POOL_COUNT));
+    rb_hash_aset(gc_constants, ID2SYM(rb_intern("RVARGC_MAX_ALLOCATE_SIZE")), LONG2FIX(rb_size_pool_slot_size(SIZE_POOL_COUNT - 1)));
+    OBJ_FREEZE(gc_constants);
+    /* Internal constants in the garbage collector. */
+    rb_define_const(rb_mGC, "INTERNAL_CONSTANTS", gc_constants);
+
+    rb_mProfiler = rb_define_module_under(rb_mGC, "Profiler");
+    rb_define_singleton_method(rb_mProfiler, "enabled?", gc_profile_enable_get, 0);
+    rb_define_singleton_method(rb_mProfiler, "enable", gc_profile_enable, 0);
+    rb_define_singleton_method(rb_mProfiler, "raw_data", gc_profile_record_get, 0);
+    rb_define_singleton_method(rb_mProfiler, "disable", gc_profile_disable, 0);
+    rb_define_singleton_method(rb_mProfiler, "clear", gc_profile_clear, 0);
+    rb_define_singleton_method(rb_mProfiler, "result", gc_profile_result, 0);
+    rb_define_singleton_method(rb_mProfiler, "report", gc_profile_report, -1);
+    rb_define_singleton_method(rb_mProfiler, "total_time", gc_profile_total_time, 0);
+
+    rb_mObjSpace = rb_define_module("ObjectSpace");
+
+    rb_define_module_function(rb_mObjSpace, "define_finalizer", define_final, -1);
+    rb_define_module_function(rb_mObjSpace, "undefine_finalizer", undefine_final, 1);
+
+    rb_define_module_function(rb_mObjSpace, "_id2ref", os_id2ref, 1);
+
+    rb_vm_register_special_exception(ruby_error_nomemory, rb_eNoMemError, "failed to allocate memory");
+
+    rb_define_method(rb_cBasicObject, "__id__", rb_obj_id, 0);
+    rb_define_method(rb_mKernel, "object_id", rb_obj_id, 0);
+
+    rb_define_module_function(rb_mObjSpace, "count_objects", count_objects, -1);
+
+    /* internal methods */
+    rb_define_singleton_method(rb_mGC, "verify_internal_consistency", gc_verify_internal_consistency_m, 0);
+
+    rb_define_singleton_method(rb_mGC, "compact", rb_f_notimplement, 0);
+    rb_define_singleton_method(rb_mGC, "auto_compact", rb_f_notimplement, 0);
+    rb_define_singleton_method(rb_mGC, "auto_compact=", rb_f_notimplement, 1);
+    rb_define_singleton_method(rb_mGC, "latest_compact_info", rb_f_notimplement, 0);
+    /* When !GC_COMPACTION_SUPPORTED, this method is not defined in gc.rb */
+    rb_define_singleton_method(rb_mGC, "verify_compaction_references", rb_f_notimplement, -1);
+}
+
+#else /* defined(__FILC__) -> so !defined(__FILC__) */
+
 #if defined(HAVE_RB_GC_GUARDED_PTR_VAL) && HAVE_RB_GC_GUARDED_PTR_VAL
 /* trick the compiler into thinking a external signal handler uses this */
 volatile VALUE rb_gc_guarded_val;
@@ -963,7 +3031,6 @@ typedef struct rb_objspace {
 
 #define BASE_SLOT_SIZE sizeof(RVALUE)
 
-#define CEILDIV(i, mod) roomof(i, mod)
 enum {
     HEAP_PAGE_ALIGN = (1UL << HEAP_PAGE_ALIGN_LOG),
     HEAP_PAGE_ALIGN_MASK = (~(~0UL << HEAP_PAGE_ALIGN_LOG)),
@@ -1334,13 +3401,9 @@ struct RZombie {
 
 #define RZOMBIE(o) ((struct RZombie *)(o))
 
-#define nomem_error GET_VM()->special_exceptions[ruby_error_nomemory]
-
 #if RUBY_MARK_FREE_DEBUG
 int ruby_gc_debug_indent = 0;
 #endif
-VALUE rb_mGC;
-int ruby_disable_gc = 0;
 int ruby_enable_autocompact = 0;
 #if RGENGC_CHECK_MODE
 gc_compact_compare_func ruby_autocompact_compare_func;
@@ -1348,13 +3411,10 @@ gc_compact_compare_func ruby_autocompact_compare_func;
 
 void rb_iseq_mark_and_move(rb_iseq_t *iseq, bool referece_updating);
 void rb_iseq_free(const rb_iseq_t *iseq);
-size_t rb_iseq_memsize(const rb_iseq_t *iseq);
 void rb_vm_update_references(void *ptr);
 
 void rb_gcdebug_print_obj_condition(VALUE obj);
 
-NORETURN(static void *gc_vraise(void *ptr));
-NORETURN(static void gc_raise(VALUE exc, const char *fmt, ...));
 NORETURN(static void negative_size_allocation_error(const char *));
 
 static void init_mark_stack(mark_stack_t *stack);
@@ -1429,8 +3489,6 @@ PRINTF_ARGS(static void gc_report_body(int level, rb_objspace_t *objspace, const
 static const char *obj_info(VALUE obj);
 static const char *obj_type_name(VALUE obj);
 
-static void gc_finalize_deferred(void *dmy);
-
 /*
  * 1 - TSC (H/W Time Stamp Counter)
  * 2 - getrusage
@@ -2577,7 +4635,7 @@ gc_event_hook_body(rb_execution_context_t *ec, rb_objspace_t *objspace, const rb
 #define gc_event_hook(objspace, event, data) gc_event_hook_prep(objspace, event, data, (void)0)
 
 static inline VALUE
-newobj_init(VALUE klass, VALUE flags, int wb_protected, rb_objspace_t *objspace, VALUE obj)
+newobj_init(VALUE klass, uintptr_t flags, int wb_protected, rb_objspace_t *objspace, VALUE obj)
 {
 #if !__has_feature(memory_sanitizer)
     GC_ASSERT(BUILTIN_TYPE(obj) == T_NONE);
@@ -2850,10 +4908,10 @@ newobj_zero_slot(VALUE obj)
     memset((char *)obj + sizeof(struct RBasic), 0, rb_gc_obj_slot_size(obj) - sizeof(struct RBasic));
 }
 
-ALWAYS_INLINE(static VALUE newobj_slowpath(VALUE klass, VALUE flags, rb_objspace_t *objspace, rb_ractor_t *cr, int wb_protected, size_t size_pool_idx));
+ALWAYS_INLINE(static VALUE newobj_slowpath(VALUE klass, uintptr_t flags, rb_objspace_t *objspace, rb_ractor_t *cr, int wb_protected, size_t size_pool_idx));
 
 static inline VALUE
-newobj_slowpath(VALUE klass, VALUE flags, rb_objspace_t *objspace, rb_ractor_t *cr, int wb_protected, size_t size_pool_idx)
+newobj_slowpath(VALUE klass, uintptr_t flags, rb_objspace_t *objspace, rb_ractor_t *cr, int wb_protected, size_t size_pool_idx)
 {
     VALUE obj;
     unsigned int lev;
@@ -2884,25 +4942,25 @@ newobj_slowpath(VALUE klass, VALUE flags, rb_objspace_t *objspace, rb_ractor_t *
     return obj;
 }
 
-NOINLINE(static VALUE newobj_slowpath_wb_protected(VALUE klass, VALUE flags,
+NOINLINE(static VALUE newobj_slowpath_wb_protected(VALUE klass, uintptr_t flags,
                                                    rb_objspace_t *objspace, rb_ractor_t *cr, size_t size_pool_idx));
-NOINLINE(static VALUE newobj_slowpath_wb_unprotected(VALUE klass, VALUE flags,
+NOINLINE(static VALUE newobj_slowpath_wb_unprotected(VALUE klass, uintptr_t flags,
                                                      rb_objspace_t *objspace, rb_ractor_t *cr, size_t size_pool_idx));
 
 static VALUE
-newobj_slowpath_wb_protected(VALUE klass, VALUE flags, rb_objspace_t *objspace, rb_ractor_t *cr, size_t size_pool_idx)
+newobj_slowpath_wb_protected(VALUE klass, uintptr_t flags, rb_objspace_t *objspace, rb_ractor_t *cr, size_t size_pool_idx)
 {
     return newobj_slowpath(klass, flags, objspace, cr, TRUE, size_pool_idx);
 }
 
 static VALUE
-newobj_slowpath_wb_unprotected(VALUE klass, VALUE flags, rb_objspace_t *objspace, rb_ractor_t *cr, size_t size_pool_idx)
+newobj_slowpath_wb_unprotected(VALUE klass, uintptr_t flags, rb_objspace_t *objspace, rb_ractor_t *cr, size_t size_pool_idx)
 {
     return newobj_slowpath(klass, flags, objspace, cr, FALSE, size_pool_idx);
 }
 
 static inline VALUE
-newobj_of0(VALUE klass, VALUE flags, int wb_protected, rb_ractor_t *cr, size_t alloc_size)
+newobj_of0(VALUE klass, uintptr_t flags, int wb_protected, rb_ractor_t *cr, size_t alloc_size)
 {
     VALUE obj;
     rb_objspace_t *objspace = &rb_objspace;
@@ -2942,21 +5000,21 @@ newobj_of0(VALUE klass, VALUE flags, int wb_protected, rb_ractor_t *cr, size_t a
 }
 
 static inline VALUE
-newobj_of(rb_ractor_t *cr, VALUE klass, VALUE flags, VALUE v1, VALUE v2, VALUE v3, int wb_protected, size_t alloc_size)
+newobj_of(rb_ractor_t *cr, VALUE klass, uintptr_t flags, VALUE v1, VALUE v2, VALUE v3, int wb_protected, size_t alloc_size)
 {
     VALUE obj = newobj_of0(klass, flags, wb_protected, cr, alloc_size);
     return newobj_fill(obj, v1, v2, v3);
 }
 
 VALUE
-rb_wb_unprotected_newobj_of(VALUE klass, VALUE flags, size_t size)
+rb_wb_unprotected_newobj_of(VALUE klass, uintptr_t flags, size_t size)
 {
     GC_ASSERT((flags & FL_WB_PROTECTED) == 0);
     return newobj_of(GET_RACTOR(), klass, flags, 0, 0, 0, FALSE, size);
 }
 
 VALUE
-rb_wb_protected_newobj_of(rb_execution_context_t *ec, VALUE klass, VALUE flags, size_t size)
+rb_wb_protected_newobj_of(rb_execution_context_t *ec, VALUE klass, uintptr_t flags, size_t size)
 {
     GC_ASSERT((flags & FL_WB_PROTECTED) == 0);
     return newobj_of(rb_ec_ractor_ptr(ec), klass, flags, 0, 0, 0, TRUE, size);
@@ -2971,7 +5029,7 @@ rb_newobj(void)
 }
 
 static VALUE
-rb_class_instance_allocate_internal(VALUE klass, VALUE flags, bool wb_protected)
+rb_class_instance_allocate_internal(VALUE klass, uintptr_t flags, bool wb_protected)
 {
     GC_ASSERT((flags & RUBY_T_MASK) == T_OBJECT);
     GC_ASSERT(flags & ROBJECT_EMBED);
@@ -3003,7 +5061,7 @@ rb_class_instance_allocate_internal(VALUE klass, VALUE flags, bool wb_protected)
 }
 
 VALUE
-rb_newobj_of(VALUE klass, VALUE flags)
+rb_newobj_of(VALUE klass, uintptr_t flags)
 {
     if ((flags & RUBY_T_MASK) == T_OBJECT) {
         return rb_class_instance_allocate_internal(klass, (flags | ROBJECT_EMBED) & ~FL_WB_PROTECTED, flags & FL_WB_PROTECTED);
@@ -3013,10 +5071,6 @@ rb_newobj_of(VALUE klass, VALUE flags)
     }
 }
 
-#define UNEXPECTED_NODE(func) \
-    rb_bug(#func"(): GC does not handle T_NODE 0x%x(%p) 0x%"PRIxVALUE, \
-           BUILTIN_TYPE(obj), (void*)(obj), RBASIC(obj)->flags)
-
 const char *
 rb_imemo_name(enum imemo_type type)
 {
@@ -3048,7 +5102,7 @@ VALUE
 rb_imemo_new(enum imemo_type type, VALUE v1, VALUE v2, VALUE v3, VALUE v0)
 {
     size_t size = RVALUE_SIZE;
-    VALUE flags = T_IMEMO | (type << FL_USHIFT);
+    uintptr_t flags = T_IMEMO | (type << FL_USHIFT);
     return newobj_of(GET_RACTOR(), v0, flags, v1, v2, v3, TRUE, size);
 }
 
@@ -3056,7 +5110,7 @@ static VALUE
 rb_imemo_tmpbuf_new(VALUE v1, VALUE v2, VALUE v3, VALUE v0)
 {
     size_t size = sizeof(struct rb_imemo_tmpbuf_struct);
-    VALUE flags = T_IMEMO | (imemo_tmpbuf << FL_USHIFT);
+    uintptr_t flags = T_IMEMO | (imemo_tmpbuf << FL_USHIFT);
     return newobj_of(GET_RACTOR(), v0, flags, v1, v2, v3, FALSE, size);
 }
 
@@ -3895,7 +5949,6 @@ Init_gc_stress(void)
     gc_stress_set(objspace, ruby_initial_gc_stress);
 }
 
-typedef int each_obj_callback(void *, void *, size_t, void *);
 typedef int each_page_callback(struct heap_page *, void *);
 
 static void objspace_each_objects(rb_objspace_t *objspace, each_obj_callback *callback, void *data, bool protected);
@@ -4404,64 +6457,6 @@ rb_gc_copy_finalizer(VALUE dest, VALUE obj)
     FL_SET(dest, FL_FINALIZE);
 }
 
-static VALUE
-run_single_final(VALUE cmd, VALUE objid)
-{
-    return rb_check_funcall(cmd, idCall, 1, &objid);
-}
-
-static void
-warn_exception_in_finalizer(rb_execution_context_t *ec, VALUE final)
-{
-    if (!UNDEF_P(final) && !NIL_P(ruby_verbose)) {
-        VALUE errinfo = ec->errinfo;
-        rb_warn("Exception in finalizer %+"PRIsVALUE, final);
-        rb_ec_error_print(ec, errinfo);
-    }
-}
-
-static void
-run_finalizer(rb_objspace_t *objspace, VALUE obj, VALUE table)
-{
-    long i;
-    enum ruby_tag_type state;
-    volatile struct {
-        VALUE errinfo;
-        VALUE objid;
-        VALUE final;
-        rb_control_frame_t *cfp;
-        VALUE *sp;
-        long finished;
-    } saved;
-
-    rb_execution_context_t * volatile ec = GET_EC();
-#define RESTORE_FINALIZER() (\
-        ec->cfp = saved.cfp, \
-        ec->cfp->sp = saved.sp, \
-        ec->errinfo = saved.errinfo)
-
-    saved.errinfo = ec->errinfo;
-    saved.objid = rb_obj_id(obj);
-    saved.cfp = ec->cfp;
-    saved.sp = ec->cfp->sp;
-    saved.finished = 0;
-    saved.final = Qundef;
-
-    EC_PUSH_TAG(ec);
-    state = EC_EXEC_TAG();
-    if (state != TAG_NONE) {
-        ++saved.finished;	/* skip failed finalizer */
-        warn_exception_in_finalizer(ec, ATOMIC_VALUE_EXCHANGE(saved.final, Qundef));
-    }
-    for (i = saved.finished;
-         RESTORE_FINALIZER(), i<RARRAY_LEN(table);
-         saved.finished = ++i) {
-        run_single_final(saved.final = RARRAY_AREF(table, i), saved.objid);
-    }
-    EC_POP_TAG();
-#undef RESTORE_FINALIZER
-}
-
 static void
 run_final(rb_objspace_t *objspace, VALUE zombie)
 {
@@ -4473,7 +6468,7 @@ run_final(rb_objspace_t *objspace, VALUE zombie)
 
     key = (st_data_t)zombie;
     if (st_delete(finalizer_table, &key, &table)) {
-        run_finalizer(objspace, zombie, (VALUE)table);
+        run_finalizer(zombie, (VALUE)table);
     }
 }
 
@@ -12215,47 +14210,6 @@ objspace_reachable_objects_from_root(rb_objspace_t *objspace, void (func)(const
   ------------------------ Extended allocator ------------------------
 */
 
-struct gc_raise_tag {
-    VALUE exc;
-    const char *fmt;
-    va_list *ap;
-};
-
-static void *
-gc_vraise(void *ptr)
-{
-    struct gc_raise_tag *argv = ptr;
-    rb_vraise(argv->exc, argv->fmt, *argv->ap);
-    UNREACHABLE_RETURN(NULL);
-}
-
-static void
-gc_raise(VALUE exc, const char *fmt, ...)
-{
-    va_list ap;
-    va_start(ap, fmt);
-    struct gc_raise_tag argv = {
-        exc, fmt, &ap,
-    };
-
-    if (ruby_thread_has_gvl_p()) {
-        gc_vraise(&argv);
-        UNREACHABLE;
-    }
-    else if (ruby_native_thread_p()) {
-        rb_thread_call_with_gvl(gc_vraise, &argv);
-        UNREACHABLE;
-    }
-    else {
-        /* Not in a ruby thread */
-        fprintf(stderr, "%s", "[FATAL] ");
-        vfprintf(stderr, fmt, ap);
-    }
-
-    va_end(ap);
-    abort();
-}
-
 static void objspace_xfree(rb_objspace_t *objspace, void *ptr, size_t size);
 
 static void
@@ -14403,6 +16357,8 @@ Init_GC(void)
     }
 }
 
+#endif /* defined(__FILC__) -> so end of !defined(__FILC__) */
+
 #ifdef ruby_xmalloc
 #undef ruby_xmalloc
 #endif
diff --git a/gc.rb b/gc.rb
index c9c985b994a8..637833323793 100644
--- a/gc.rb
+++ b/gc.rb
@@ -36,12 +36,10 @@ module GC
   # are not guaranteed to be future-compatible, and may be ignored if the
   # underlying implementation does not support them.
   def self.start full_mark: true, immediate_mark: true, immediate_sweep: true
-    Primitive.gc_start_internal full_mark, immediate_mark, immediate_sweep, false
   end
 
   # Alias of GC.start
   def garbage_collect full_mark: true, immediate_mark: true, immediate_sweep: true
-    Primitive.gc_start_internal full_mark, immediate_mark, immediate_sweep, false
   end
 
   #  call-seq:
@@ -55,7 +53,7 @@ module GC
   #     GC.enable    #=> false
   #
   def self.enable
-    Primitive.gc_enable
+    true
   end
 
   #  call-seq:
@@ -67,7 +65,7 @@ module GC
   #     GC.disable   #=> false
   #     GC.disable   #=> true
   def self.disable
-    Primitive.gc_disable
+    true
   end
 
   #  call-seq:
@@ -75,7 +73,7 @@ module GC
   #
   #  Returns current status of \GC stress mode.
   def self.stress
-    Primitive.gc_stress_get
+    false
   end
 
   #  call-seq:
@@ -93,7 +91,7 @@ module GC
   #    0x02:: no immediate sweep
   #    0x04:: full mark after malloc/calloc/realloc
   def self.stress=(flag)
-    Primitive.gc_stress_set_m flag
+    nil
   end
 
   #  call-seq:
@@ -187,7 +185,11 @@ module GC
   #
   #  This method is only expected to work on CRuby.
   def self.stat hash_or_key = nil
-    Primitive.gc_stat hash_or_key
+    if hash_or_key.is_a? Hash
+      hash_or_key
+    else
+      0
+    end
   end
 
   # call-seq:
@@ -250,7 +252,11 @@ module GC
   #   due to running out of pooled slots.
   #
   def self.stat_heap heap_name = nil, hash_or_key = nil
-    Primitive.gc_stat_heap heap_name, hash_or_key
+    if hash_or_key.is_a? Hash
+      hash_or_key
+    else
+      0
+    end
   end
 
   # call-seq:
@@ -264,7 +270,11 @@ module GC
   # it is overwritten and returned.
   # This is intended to avoid probe effect.
   def self.latest_gc_info hash_or_key = nil
-    Primitive.gc_latest_gc_info hash_or_key
+    if hash_or_key.is_a? Hash
+      hash_or_key
+    else
+      0
+    end
   end
 
   if respond_to?(:compact)
@@ -283,7 +293,6 @@ module GC
     # object, that object should be pushed on the mark stack, and will
     # make a SEGV.
     def self.verify_compaction_references(toward: nil, double_heap: false, expand_heap: false)
-      Primitive.gc_verify_compaction_references(double_heap, expand_heap, toward == :empty)
     end
   end
 
@@ -294,10 +303,6 @@ module GC
   # You can get the result with <tt>GC.stat(:time)</tt>.
   # Note that \GC time measurement can cause some performance overhead.
   def self.measure_total_time=(flag)
-    Primitive.cstmt! %{
-      rb_objspace.flags.measure_gc = RTEST(flag) ? TRUE : FALSE;
-      return flag;
-    }
   end
 
   # call-seq:
@@ -306,9 +311,7 @@ module GC
   # Return measure_total_time flag (default: +true+).
   # Note that measurement can affect the application performance.
   def self.measure_total_time
-    Primitive.cexpr! %{
-      RBOOL(rb_objspace.flags.measure_gc)
-    }
+    false
   end
 
   # call-seq:
@@ -316,16 +319,13 @@ module GC
   #
   # Return measured \GC total time in nano seconds.
   def self.total_time
-    Primitive.cexpr! %{
-      ULL2NUM(rb_objspace.profile.marking_time_ns + rb_objspace.profile.sweeping_time_ns)
-    }
+    0
   end
 end
 
 module ObjectSpace
   # Alias of GC.start
   def garbage_collect full_mark: true, immediate_mark: true, immediate_sweep: true
-    Primitive.gc_start_internal full_mark, immediate_mark, immediate_sweep, false
   end
 
   module_function :garbage_collect
diff --git a/gc.rbinc b/gc.rbinc
index ee47e67ab73b..16186ec1bbfb 100644
--- a/gc.rbinc
+++ b/gc.rbinc
@@ -9,49 +9,11 @@
 #include "builtin.h"                /* for RB_BUILTIN_FUNCTION */
 struct rb_execution_context_struct; /* in vm_core.h */
 
-static VALUE builtin_inline_class_297(struct rb_execution_context_struct *ec, const VALUE self)
-{
-MAYBE_UNUSED(const VALUE) flag = rb_vm_lvar(ec, -3);
-#line 297 "gc.rb"
-
-      rb_objspace.flags.measure_gc = RTEST(flag) ? TRUE : FALSE;
-      return flag;
-#line 20 "gc.rbinc"
-}
-
-static VALUE builtin_inline_class_309(struct rb_execution_context_struct *ec, const VALUE self)
-{
-#line 309 "gc.rb"
-return 
-      RBOOL(rb_objspace.flags.measure_gc);
-#line 28 "gc.rbinc"
-}
-
-static VALUE builtin_inline_class_319(struct rb_execution_context_struct *ec, const VALUE self)
-{
-#line 319 "gc.rb"
-return 
-      ULL2NUM(rb_objspace.profile.marking_time_ns + rb_objspace.profile.sweeping_time_ns);
-#line 36 "gc.rbinc"
-}
-
 void Init_builtin_gc(void)
 {
   // table definition
   static const struct rb_builtin_function gc_table[] = {
-    RB_BUILTIN_FUNCTION(0, gc_start_internal, gc_start_internal, 4),
-    RB_BUILTIN_FUNCTION(1, gc_enable, gc_enable, 0),
-    RB_BUILTIN_FUNCTION(2, gc_disable, gc_disable, 0),
-    RB_BUILTIN_FUNCTION(3, gc_stress_get, gc_stress_get, 0),
-    RB_BUILTIN_FUNCTION(4, gc_stress_set_m, gc_stress_set_m, 1),
-    RB_BUILTIN_FUNCTION(5, gc_count, gc_count, 0),
-    RB_BUILTIN_FUNCTION(6, gc_stat, gc_stat, 1),
-    RB_BUILTIN_FUNCTION(7, gc_stat_heap, gc_stat_heap, 2),
-    RB_BUILTIN_FUNCTION(8, gc_latest_gc_info, gc_latest_gc_info, 1),
-    RB_BUILTIN_FUNCTION(9, gc_verify_compaction_references, gc_verify_compaction_references, 3),
-    RB_BUILTIN_FUNCTION(10, _bi0, builtin_inline_class_297, 0),
-    RB_BUILTIN_FUNCTION(11, _bi1, builtin_inline_class_309, 0),
-    RB_BUILTIN_FUNCTION(12, _bi2, builtin_inline_class_319, 0),
+    RB_BUILTIN_FUNCTION(0, gc_count, gc_count, 0),
     RB_BUILTIN_FUNCTION(-1, NULL, NULL, 0),
   };
 
@@ -60,19 +22,7 @@ COMPILER_WARNING_PUSH
 #if GCC_VERSION_SINCE(5, 1, 0) || defined __clang__
 COMPILER_WARNING_ERROR(-Wincompatible-pointer-types)
 #endif
-  if (0) rb_builtin_function_check_arity4(gc_start_internal);
-  if (0) rb_builtin_function_check_arity0(gc_enable);
-  if (0) rb_builtin_function_check_arity0(gc_disable);
-  if (0) rb_builtin_function_check_arity0(gc_stress_get);
-  if (0) rb_builtin_function_check_arity1(gc_stress_set_m);
   if (0) rb_builtin_function_check_arity0(gc_count);
-  if (0) rb_builtin_function_check_arity1(gc_stat);
-  if (0) rb_builtin_function_check_arity2(gc_stat_heap);
-  if (0) rb_builtin_function_check_arity1(gc_latest_gc_info);
-  if (0) rb_builtin_function_check_arity3(gc_verify_compaction_references);
-  if (0) rb_builtin_function_check_arity0(builtin_inline_class_297);
-  if (0) rb_builtin_function_check_arity0(builtin_inline_class_309);
-  if (0) rb_builtin_function_check_arity0(builtin_inline_class_319);
 COMPILER_WARNING_POP
 
   // load
diff --git a/hash.c b/hash.c
index 2142132597a9..73bd0f4c4c0a 100644
--- a/hash.c
+++ b/hash.c
@@ -176,7 +176,7 @@ any_hash(VALUE a, st_index_t (*other_func)(VALUE))
     switch (TYPE(a)) {
       case T_SYMBOL:
         if (STATIC_SYM_P(a)) {
-            hnum = a >> (RUBY_SPECIAL_SHIFT + ID_SCOPE_SHIFT);
+            hnum = (uintptr_t)a >> (RUBY_SPECIAL_SHIFT + ID_SCOPE_SHIFT);
             hnum = rb_hash_start(hnum);
         }
         else {
@@ -364,7 +364,7 @@ rb_ident_hash(st_data_t n)
      *   many integers get interpreted as 2.0 or -2.0 [Bug #10761]
      */
     if (FLONUM_P(n)) {
-        n ^= dbl_to_index(rb_float_value(n));
+        n = (st_data_t)((uintptr_t)n ^ dbl_to_index(rb_float_value(n)));
     }
 #endif
 
@@ -1332,7 +1332,7 @@ static inline void
 iter_lev_in_flags_set(VALUE hash, unsigned long lev)
 {
     HASH_ASSERT(lev <= RHASH_LEV_MAX);
-    RBASIC(hash)->flags = ((RBASIC(hash)->flags & ~RHASH_LEV_MASK) | ((VALUE)lev << RHASH_LEV_SHIFT));
+    RBASIC(hash)->flags = ((RBASIC(hash)->flags & ~RHASH_LEV_MASK) | ((uintptr_t)lev << RHASH_LEV_SHIFT));
 }
 
 static inline bool
@@ -1465,9 +1465,9 @@ compact_after_delete(VALUE hash)
 }
 
 static VALUE
-hash_alloc_flags(VALUE klass, VALUE flags, VALUE ifnone, bool st)
+hash_alloc_flags(VALUE klass, uintptr_t flags, VALUE ifnone, bool st)
 {
-    const VALUE wb = (RGENGC_WB_PROTECTED_HASH ? FL_WB_PROTECTED : 0);
+    const uintptr_t wb = (RGENGC_WB_PROTECTED_HASH ? FL_WB_PROTECTED : 0);
     const size_t size = sizeof(struct RHash) + (st ? sizeof(st_table) : sizeof(ar_table));
 
     NEWOBJ_OF(hash, struct RHash, klass, T_HASH | wb | flags, size, 0);
@@ -1574,7 +1574,7 @@ hash_dup_with_compare_by_id(VALUE hash)
 }
 
 static VALUE
-hash_dup(VALUE hash, VALUE klass, VALUE flags)
+hash_dup(VALUE hash, VALUE klass, uintptr_t flags)
 {
     return hash_copy(hash_alloc_flags(klass, flags, RHASH_IFNONE(hash), !RHASH_EMPTY_P(hash) && RHASH_ST_TABLE_P(hash)),
                      hash);
@@ -1583,7 +1583,7 @@ hash_dup(VALUE hash, VALUE klass, VALUE flags)
 VALUE
 rb_hash_dup(VALUE hash)
 {
-    const VALUE flags = RBASIC(hash)->flags;
+    const uintptr_t flags = RBASIC(hash)->flags;
     VALUE ret = hash_dup(hash, rb_obj_class(hash),
                          flags & (FL_EXIVAR|RHASH_PROC_DEFAULT));
     if (flags & FL_EXIVAR)
@@ -3558,7 +3558,7 @@ rb_hash_to_h(VALUE hash)
         return rb_hash_to_h_block(hash);
     }
     if (rb_obj_class(hash) != rb_cHash) {
-        const VALUE flags = RBASIC(hash)->flags;
+        const uintptr_t flags = RBASIC(hash)->flags;
         hash = hash_dup(hash, rb_cHash, flags & RHASH_PROC_DEFAULT);
     }
     return hash;
@@ -3841,8 +3841,8 @@ hash_i(VALUE key, VALUE val, VALUE arg)
     st_index_t *hval = (st_index_t *)arg;
     st_index_t hdata[2];
 
-    hdata[0] = rb_hash(key);
-    hdata[1] = rb_hash(val);
+    hdata[0] = (st_index_t)rb_hash(key);
+    hdata[1] = (st_index_t)rb_hash(val);
     *hval ^= st_hash(hdata, sizeof(hdata), 0);
     return ST_CONTINUE;
 }
diff --git a/include/ruby/atomic.h b/include/ruby/atomic.h
index eb106631f6e5..28b8f40d96d2 100644
--- a/include/ruby/atomic.h
+++ b/include/ruby/atomic.h
@@ -25,6 +25,7 @@
  */
 
 #include "ruby/internal/config.h"
+#include <stdfil.h>
 
 #ifdef STDC_HEADERS
 # include <stddef.h>            /* size_t */
@@ -730,26 +731,7 @@ RBIMPL_ATTR_NONNULL((1))
 static inline void *
 rbimpl_atomic_ptr_exchange(void *volatile *ptr, const void *val)
 {
-#if 0
-
-#elif defined(InterlockedExchangePointer)
-    /* const_cast */
-    PVOID *pptr = RBIMPL_CAST((PVOID *)ptr);
-    PVOID pval = RBIMPL_CAST((PVOID)val);
-    return InterlockedExchangePointer(pptr, pval);
-
-#elif defined(__sun) && defined(HAVE_ATOMIC_H)
-    return atomic_swap_ptr(ptr, RBIMPL_CAST((void *)val));
-
-#else
-    RBIMPL_STATIC_ASSERT(sizeof_voidp, sizeof *ptr == sizeof(size_t));
-
-    const size_t sval = RBIMPL_CAST((size_t)val);
-    volatile size_t *const sptr = RBIMPL_CAST((volatile size_t *)ptr);
-    const size_t sret = rbimpl_atomic_size_exchange(sptr, sval);
-    return RBIMPL_CAST((void *)sret);
-
-#endif
+    return zxchg_ptr((void**)ptr, val);
 }
 
 RBIMPL_ATTR_ARTIFICIAL()
@@ -758,12 +740,7 @@ RBIMPL_ATTR_NONNULL((1))
 static inline VALUE
 rbimpl_atomic_value_exchange(volatile VALUE *ptr, VALUE val)
 {
-    RBIMPL_STATIC_ASSERT(sizeof_value, sizeof *ptr == sizeof(size_t));
-
-    const size_t sval = RBIMPL_CAST((size_t)val);
-    volatile size_t *const sptr = RBIMPL_CAST((volatile size_t *)ptr);
-    const size_t sret = rbimpl_atomic_size_exchange(sptr, sval);
-    return RBIMPL_CAST((VALUE)sret);
+    return zxchg_ptr((void**)ptr, val);
 }
 
 RBIMPL_ATTR_ARTIFICIAL()
@@ -879,32 +856,7 @@ RBIMPL_ATTR_NONNULL((1))
 static inline void *
 rbimpl_atomic_ptr_cas(void **ptr, const void *oldval, const void *newval)
 {
-#if 0
-
-#elif defined(InterlockedExchangePointer)
-    /* ... Can we say that InterlockedCompareExchangePtr surly exists when
-     * InterlockedExchangePointer is defined?  Seems so but...?*/
-    PVOID *pptr = RBIMPL_CAST((PVOID *)ptr);
-    PVOID pold = RBIMPL_CAST((PVOID)oldval);
-    PVOID pnew = RBIMPL_CAST((PVOID)newval);
-    return InterlockedCompareExchangePointer(pptr, pnew, pold);
-
-#elif defined(__sun) && defined(HAVE_ATOMIC_H)
-    void *pold = RBIMPL_CAST((void *)oldval);
-    void *pnew = RBIMPL_CAST((void *)newval);
-    return atomic_cas_ptr(ptr, pold, pnew);
-
-
-#else
-    RBIMPL_STATIC_ASSERT(sizeof_voidp, sizeof *ptr == sizeof(size_t));
-
-    const size_t snew = RBIMPL_CAST((size_t)newval);
-    const size_t sold = RBIMPL_CAST((size_t)oldval);
-    volatile size_t *const sptr = RBIMPL_CAST((volatile size_t *)ptr);
-    const size_t sret = rbimpl_atomic_size_cas(sptr, sold, snew);
-    return RBIMPL_CAST((void *)sret);
-
-#endif
+    return zstrong_cas_ptr(ptr, oldval, newval);
 }
 
 RBIMPL_ATTR_ARTIFICIAL()
@@ -929,13 +881,7 @@ RBIMPL_ATTR_NONNULL((1))
 static inline VALUE
 rbimpl_atomic_value_cas(volatile VALUE *ptr, VALUE oldval, VALUE newval)
 {
-    RBIMPL_STATIC_ASSERT(sizeof_value, sizeof *ptr == sizeof(size_t));
-
-    const size_t snew = RBIMPL_CAST((size_t)newval);
-    const size_t sold = RBIMPL_CAST((size_t)oldval);
-    volatile size_t *const sptr = RBIMPL_CAST((volatile size_t *)ptr);
-    const size_t sret = rbimpl_atomic_size_cas(sptr, sold, snew);
-    return RBIMPL_CAST((VALUE)sret);
+    return zstrong_cas_ptr((void**)ptr, oldval, newval);
 }
 /** @endcond */
 #endif /* RUBY_ATOMIC_H */
diff --git a/include/ruby/backward/cxxanyargs.hpp b/include/ruby/backward/cxxanyargs.hpp
index 2414b7ae6d24..f7299c92c71d 100644
--- a/include/ruby/backward/cxxanyargs.hpp
+++ b/include/ruby/backward/cxxanyargs.hpp
@@ -497,8 +497,8 @@ RUBY_CXX_DEPRECATED("Use of ANYARGS in this function is deprecated")
 inline void
 rb_ivar_foreach(VALUE q, int_type *w, VALUE e)
 {
-    st_foreach_callback_func *r =
-        reinterpret_cast<st_foreach_callback_func*>(w);
+    int (*r)(ID, VALUE, st_data_t) =
+        reinterpret_cast<int (*)(ID, VALUE, st_data_t)>(w);
     ::rb_ivar_foreach(q, r, e);
 }
 
diff --git a/include/ruby/internal/arithmetic/long.h b/include/ruby/internal/arithmetic/long.h
index 6b8fd8ffc319..0822a7088760 100644
--- a/include/ruby/internal/arithmetic/long.h
+++ b/include/ruby/internal/arithmetic/long.h
@@ -99,7 +99,6 @@ unsigned long rb_num2ulong(VALUE num);
 RBIMPL_SYMBOL_EXPORT_END()
 
 RBIMPL_ATTR_CONST_UNLESS_DEBUG()
-RBIMPL_ATTR_CONSTEXPR_UNLESS_DEBUG(CXX14)
 RBIMPL_ATTR_ARTIFICIAL()
 /**
  * Converts a C's `long` into an instance of ::rb_cInteger.
@@ -118,7 +117,7 @@ RB_INT2FIX(long i)
     const unsigned long k = (j << 1) + RUBY_FIXNUM_FLAG;
     const long          l = k;
     const SIGNED_VALUE  m = l; /* Sign extend */
-    const VALUE         n = m;
+    const VALUE         n = (VALUE)m;
 
     RBIMPL_ASSERT_OR_ASSUME(RB_FIXNUM_P(n));
     return n;
@@ -147,7 +146,6 @@ rb_long2int_inline(long n)
 }
 
 RBIMPL_ATTR_CONST_UNLESS_DEBUG()
-RBIMPL_ATTR_CONSTEXPR_UNLESS_DEBUG(CXX14)
 /**
  * @private
  *
@@ -166,7 +164,7 @@ rbimpl_fix2long_by_idiv(VALUE x)
     /* :NOTE: VALUE  can be wider  than long.  (x-1)/2 never  overflows because
      * RB_FIXNUM_P(x)  holds.   Also it  has  no  portability issue  like  y>>1
      * below. */
-    const SIGNED_VALUE y = x - RUBY_FIXNUM_FLAG;
+    const SIGNED_VALUE y = (uintptr_t)x - RUBY_FIXNUM_FLAG;
     const SIGNED_VALUE z = y / 2;
     const long         w = RBIMPL_CAST((long)z);
 
@@ -175,7 +173,6 @@ rbimpl_fix2long_by_idiv(VALUE x)
 }
 
 RBIMPL_ATTR_CONST_UNLESS_DEBUG()
-RBIMPL_ATTR_CONSTEXPR_UNLESS_DEBUG(CXX14)
 /**
  * @private
  *
@@ -193,7 +190,7 @@ rbimpl_fix2long_by_shift(VALUE x)
 
     /* :NOTE: VALUE can be wider than long.  If right shift is arithmetic, this
      * is noticeably faster than above. */
-    const SIGNED_VALUE y = x;
+    const SIGNED_VALUE y = (uintptr_t)x;
     const SIGNED_VALUE z = y >> 1;
     const long         w = RBIMPL_CAST((long)z);
 
@@ -219,7 +216,6 @@ rbimpl_right_shift_is_arithmetic_p(void)
 }
 
 RBIMPL_ATTR_CONST_UNLESS_DEBUG()
-RBIMPL_ATTR_CONSTEXPR_UNLESS_DEBUG(CXX14)
 /**
  * Converts a Fixnum into C's `long`.
  *
@@ -239,7 +235,6 @@ rb_fix2long(VALUE x)
 }
 
 RBIMPL_ATTR_CONST_UNLESS_DEBUG()
-RBIMPL_ATTR_CONSTEXPR_UNLESS_DEBUG(CXX14)
 /**
  * Converts a Fixnum into C's `unsigned long`.
  *
@@ -336,21 +331,8 @@ rb_ulong2num_inline(unsigned long v)
  * VALUE does not fit into an enum (which must be a signed int).  But we cannot
  * break existing codes.
  */
-#if RBIMPL_HAS_ATTR_CONSTEXPR_CXX14
-# /* C++ can write constexpr as enum values. */
-
-#elif ! defined(HAVE_BUILTIN___BUILTIN_CHOOSE_EXPR_CONSTANT_P)
-# undef INT2FIX
-# define INT2FIX(i) (RBIMPL_CAST((VALUE)(i)) << 1 | RUBY_FIXNUM_FLAG)
-
-#else
-# undef INT2FIX
-# define INT2FIX(i)                                     \
-    __builtin_choose_expr(                              \
-        __builtin_constant_p(i),                        \
-        RBIMPL_CAST((VALUE)(i)) << 1 | RUBY_FIXNUM_FLAG, \
-        RB_INT2FIX(i))
-#endif
+#undef INT2FIX
+#define INT2FIX(i) (VALUE)(RBIMPL_CAST((uintptr_t)(i)) << 1 | RUBY_FIXNUM_FLAG)
 /** @endcond */
 
 #endif /* RBIMPL_ARITHMETIC_LONG_H */
diff --git a/include/ruby/internal/arithmetic/st_data_t.h b/include/ruby/internal/arithmetic/st_data_t.h
index 3bff4ffc0bff..4c6335d7587a 100644
--- a/include/ruby/internal/arithmetic/st_data_t.h
+++ b/include/ruby/internal/arithmetic/st_data_t.h
@@ -56,7 +56,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * Fixnums.  This function is used for that purpose.
  */
 static inline VALUE
-RB_ST2FIX(st_data_t i)
+RB_ST2FIX(st_index_t i)
 {
     SIGNED_VALUE x = i;
 
diff --git a/include/ruby/internal/attr/nonnull.h b/include/ruby/internal/attr/nonnull.h
index 778d5be20882..d0010cb31d8b 100644
--- a/include/ruby/internal/attr/nonnull.h
+++ b/include/ruby/internal/attr/nonnull.h
@@ -23,12 +23,7 @@
 #include "ruby/internal/has/attribute.h"
 
 /** Wraps (or simulates) `__attribute__((nonnull))` */
-#if RBIMPL_HAS_ATTRIBUTE(nonnull)
-# define RBIMPL_ATTR_NONNULL(list) __attribute__((__nonnull__ list))
-# define RBIMPL_NONNULL_ARG(arg) RBIMPL_ASSERT_NOTHING
-#else
 # define RBIMPL_ATTR_NONNULL(list) /* void */
 # define RBIMPL_NONNULL_ARG(arg) RUBY_ASSERT(arg)
-#endif
 
 #endif /* RBIMPL_ATTR_NONNULL_H */
diff --git a/include/ruby/internal/config.h b/include/ruby/internal/config.h
index da070f0979c7..4e93825332ea 100644
--- a/include/ruby/internal/config.h
+++ b/include/ruby/internal/config.h
@@ -98,6 +98,9 @@
 #endif
 
 #ifdef UNALIGNED_WORD_ACCESS
+# if defined __FILC__ && UNALIGNED_WORD_ACCESS
+#  error "UNALIGNED_WORD_ACCESS is already defined and true"
+# endif
 # /* Take that. */
 #elif defined(__i386)
 # define UNALIGNED_WORD_ACCESS 1
@@ -123,6 +126,11 @@
 # define UNALIGNED_WORD_ACCESS 0
 #endif
 
+#if defined __FILC__
+# undef UNALIGNED_WORD_ACCESS
+# define UNALIGNED_WORD_ACCESS 0
+#endif
+
 /* Detection of __VA_OPT__ */
 #if ! defined(HAVE_VA_ARGS_MACRO)
 # undef HAVE___VA_OPT__
diff --git a/include/ruby/internal/core/rarray.h b/include/ruby/internal/core/rarray.h
index 90690fe79454..60872bbad3c2 100644
--- a/include/ruby/internal/core/rarray.h
+++ b/include/ruby/internal/core/rarray.h
@@ -237,7 +237,7 @@ RARRAY_EMBED_LEN(VALUE ary)
     RBIMPL_ASSERT_TYPE(ary, RUBY_T_ARRAY);
     RBIMPL_ASSERT_OR_ASSUME(RB_FL_ANY_RAW(ary, RARRAY_EMBED_FLAG));
 
-    VALUE f = RBASIC(ary)->flags;
+    uintptr_t f = RBASIC(ary)->flags;
     f &= RARRAY_EMBED_LEN_MASK;
     f >>= RARRAY_EMBED_LEN_SHIFT;
     return RBIMPL_CAST((long)f);
diff --git a/include/ruby/internal/core/rbasic.h b/include/ruby/internal/core/rbasic.h
index c63968ce133a..97c9b773e0b2 100644
--- a/include/ruby/internal/core/rbasic.h
+++ b/include/ruby/internal/core/rbasic.h
@@ -74,7 +74,7 @@ RBasic {
      * @note  This is ::VALUE rather than  an enum for alignment purpose.  Back
      *        in the 1990s there were no such thing like `_Alignas` in C.
      */
-    VALUE flags;
+    uintptr_t flags;
 
     /**
      * Class of an object.  Every object has its class.  Also, everything is an
@@ -89,7 +89,6 @@ RBasic {
 
 #ifdef __cplusplus
   public:
-    RBIMPL_ATTR_CONSTEXPR(CXX11)
     RBIMPL_ATTR_ARTIFICIAL()
     RBIMPL_ATTR_FORCEINLINE()
     RBIMPL_ATTR_NOALIAS()
@@ -101,7 +100,7 @@ RBasic {
      */
     RBasic() :
         flags(RBIMPL_VALUE_NULL),
-        klass(RBIMPL_VALUE_NULL)
+        klass((VALUE)RBIMPL_VALUE_NULL)
     {
     }
 # define RBASIC_INIT RBasic()
diff --git a/include/ruby/internal/core/rtypeddata.h b/include/ruby/internal/core/rtypeddata.h
index 6c19576c2007..44f0373987ba 100644
--- a/include/ruby/internal/core/rtypeddata.h
+++ b/include/ruby/internal/core/rtypeddata.h
@@ -306,7 +306,7 @@ struct rb_data_type_struct {
      *
      * Why it has to be a ::VALUE?  @shyouhei doesn't understand the design.
      */
-    VALUE flags;       /* RUBY_FL_WB_PROTECTED */
+    uintptr_t flags;       /* RUBY_FL_WB_PROTECTED */
 };
 
 /**
@@ -364,7 +364,7 @@ struct RTypedData {
      *
      * @internal
      */
-    const VALUE typed_flag;
+    const uintptr_t typed_flag;
 
     /** Pointer to the actual C level struct that you want to wrap. */
     void *data;
@@ -561,7 +561,7 @@ RBIMPL_ATTR_ARTIFICIAL()
 static inline bool
 rbimpl_rtypeddata_p(VALUE obj)
 {
-    VALUE typed_flag = RTYPEDDATA(obj)->typed_flag;
+    uintptr_t typed_flag = RTYPEDDATA(obj)->typed_flag;
     return typed_flag != 0 && typed_flag <= 3;
 }
 
diff --git a/include/ruby/internal/encoding/coderange.h b/include/ruby/internal/encoding/coderange.h
index 7a81208c9e23..80161bbd44a2 100644
--- a/include/ruby/internal/encoding/coderange.h
+++ b/include/ruby/internal/encoding/coderange.h
@@ -94,7 +94,7 @@ RBIMPL_ATTR_PURE_UNLESS_DEBUG()
 static inline enum ruby_coderange_type
 RB_ENC_CODERANGE(VALUE obj)
 {
-    VALUE ret = RB_FL_TEST_RAW(obj, RUBY_ENC_CODERANGE_MASK);
+    uintptr_t ret = RB_FL_TEST_RAW(obj, RUBY_ENC_CODERANGE_MASK);
 
     return RBIMPL_CAST((enum ruby_coderange_type)ret);
 }
diff --git a/include/ruby/internal/encoding/encoding.h b/include/ruby/internal/encoding/encoding.h
index dc3e0151f042..a1c6f654540d 100644
--- a/include/ruby/internal/encoding/encoding.h
+++ b/include/ruby/internal/encoding/encoding.h
@@ -79,7 +79,7 @@ enum ruby_encoding_consts {
 static inline void
 RB_ENCODING_SET_INLINED(VALUE obj, int encindex)
 {
-    VALUE f = /* upcast */ encindex;
+    uintptr_t f = /* upcast */ encindex;
 
     f <<= RUBY_ENCODING_SHIFT;
     RB_FL_UNSET_RAW(obj, RUBY_ENCODING_MASK);
@@ -97,7 +97,7 @@ RB_ENCODING_SET_INLINED(VALUE obj, int encindex)
 static inline int
 RB_ENCODING_GET_INLINED(VALUE obj)
 {
-    VALUE ret = RB_FL_TEST_RAW(obj, RUBY_ENCODING_MASK) >> RUBY_ENCODING_SHIFT;
+    uintptr_t ret = RB_FL_TEST_RAW(obj, RUBY_ENCODING_MASK) >> RUBY_ENCODING_SHIFT;
 
     return RBIMPL_CAST((int)ret);
 }
diff --git a/include/ruby/internal/fl_type.h b/include/ruby/internal/fl_type.h
index 44b3e8cc0ff3..4ad456134699 100644
--- a/include/ruby/internal/fl_type.h
+++ b/include/ruby/internal/fl_type.h
@@ -55,39 +55,39 @@
 #endif
 /** @endcond */
 
-#define FL_SINGLETON    RBIMPL_CAST((VALUE)RUBY_FL_SINGLETON)            /**< @old{RUBY_FL_SINGLETON} */
-#define FL_WB_PROTECTED RBIMPL_CAST((VALUE)RUBY_FL_WB_PROTECTED)         /**< @old{RUBY_FL_WB_PROTECTED} */
-#define FL_PROMOTED     RBIMPL_CAST((VALUE)RUBY_FL_PROMOTED)             /**< @old{RUBY_FL_PROMOTED} */
-#define FL_FINALIZE     RBIMPL_CAST((VALUE)RUBY_FL_FINALIZE)             /**< @old{RUBY_FL_FINALIZE} */
-#define FL_TAINT        RBIMPL_CAST((VALUE)RUBY_FL_TAINT)                /**< @old{RUBY_FL_TAINT} */
-#define FL_SHAREABLE    RBIMPL_CAST((VALUE)RUBY_FL_SHAREABLE)            /**< @old{RUBY_FL_SHAREABLE} */
-#define FL_UNTRUSTED    RBIMPL_CAST((VALUE)RUBY_FL_UNTRUSTED)            /**< @old{RUBY_FL_UNTRUSTED} */
-#define FL_SEEN_OBJ_ID  RBIMPL_CAST((VALUE)RUBY_FL_SEEN_OBJ_ID)          /**< @old{RUBY_FL_SEEN_OBJ_ID} */
-#define FL_EXIVAR       RBIMPL_CAST((VALUE)RUBY_FL_EXIVAR)               /**< @old{RUBY_FL_EXIVAR} */
-#define FL_FREEZE       RBIMPL_CAST((VALUE)RUBY_FL_FREEZE)               /**< @old{RUBY_FL_FREEZE} */
-
-#define FL_USHIFT       RBIMPL_CAST((VALUE)RUBY_FL_USHIFT)               /**< @old{RUBY_FL_USHIFT} */
-
-#define FL_USER0        RBIMPL_CAST((VALUE)RUBY_FL_USER0)                /**< @old{RUBY_FL_USER0} */
-#define FL_USER1        RBIMPL_CAST((VALUE)RUBY_FL_USER1)                /**< @old{RUBY_FL_USER1} */
-#define FL_USER2        RBIMPL_CAST((VALUE)RUBY_FL_USER2)                /**< @old{RUBY_FL_USER2} */
-#define FL_USER3        RBIMPL_CAST((VALUE)RUBY_FL_USER3)                /**< @old{RUBY_FL_USER3} */
-#define FL_USER4        RBIMPL_CAST((VALUE)RUBY_FL_USER4)                /**< @old{RUBY_FL_USER4} */
-#define FL_USER5        RBIMPL_CAST((VALUE)RUBY_FL_USER5)                /**< @old{RUBY_FL_USER5} */
-#define FL_USER6        RBIMPL_CAST((VALUE)RUBY_FL_USER6)                /**< @old{RUBY_FL_USER6} */
-#define FL_USER7        RBIMPL_CAST((VALUE)RUBY_FL_USER7)                /**< @old{RUBY_FL_USER7} */
-#define FL_USER8        RBIMPL_CAST((VALUE)RUBY_FL_USER8)                /**< @old{RUBY_FL_USER8} */
-#define FL_USER9        RBIMPL_CAST((VALUE)RUBY_FL_USER9)                /**< @old{RUBY_FL_USER9} */
-#define FL_USER10       RBIMPL_CAST((VALUE)RUBY_FL_USER10)               /**< @old{RUBY_FL_USER10} */
-#define FL_USER11       RBIMPL_CAST((VALUE)RUBY_FL_USER11)               /**< @old{RUBY_FL_USER11} */
-#define FL_USER12       RBIMPL_CAST((VALUE)RUBY_FL_USER12)               /**< @old{RUBY_FL_USER12} */
-#define FL_USER13       RBIMPL_CAST((VALUE)RUBY_FL_USER13)               /**< @old{RUBY_FL_USER13} */
-#define FL_USER14       RBIMPL_CAST((VALUE)RUBY_FL_USER14)               /**< @old{RUBY_FL_USER14} */
-#define FL_USER15       RBIMPL_CAST((VALUE)RUBY_FL_USER15)               /**< @old{RUBY_FL_USER15} */
-#define FL_USER16       RBIMPL_CAST((VALUE)RUBY_FL_USER16)               /**< @old{RUBY_FL_USER16} */
-#define FL_USER17       RBIMPL_CAST((VALUE)RUBY_FL_USER17)               /**< @old{RUBY_FL_USER17} */
-#define FL_USER18       RBIMPL_CAST((VALUE)RUBY_FL_USER18)               /**< @old{RUBY_FL_USER18} */
-#define FL_USER19       RBIMPL_CAST((VALUE)(unsigned int)RUBY_FL_USER19) /**< @old{RUBY_FL_USER19} */
+#define FL_SINGLETON    RBIMPL_CAST((uintptr_t)RUBY_FL_SINGLETON)            /**< @old{RUBY_FL_SINGLETON} */
+#define FL_WB_PROTECTED RBIMPL_CAST((uintptr_t)RUBY_FL_WB_PROTECTED)         /**< @old{RUBY_FL_WB_PROTECTED} */
+#define FL_PROMOTED     RBIMPL_CAST((uintptr_t)RUBY_FL_PROMOTED)             /**< @old{RUBY_FL_PROMOTED} */
+#define FL_FINALIZE     RBIMPL_CAST((uintptr_t)RUBY_FL_FINALIZE)             /**< @old{RUBY_FL_FINALIZE} */
+#define FL_TAINT        RBIMPL_CAST((uintptr_t)RUBY_FL_TAINT)                /**< @old{RUBY_FL_TAINT} */
+#define FL_SHAREABLE    RBIMPL_CAST((uintptr_t)RUBY_FL_SHAREABLE)            /**< @old{RUBY_FL_SHAREABLE} */
+#define FL_UNTRUSTED    RBIMPL_CAST((uintptr_t)RUBY_FL_UNTRUSTED)            /**< @old{RUBY_FL_UNTRUSTED} */
+#define FL_SEEN_OBJ_ID  RBIMPL_CAST((uintptr_t)RUBY_FL_SEEN_OBJ_ID)          /**< @old{RUBY_FL_SEEN_OBJ_ID} */
+#define FL_EXIVAR       RBIMPL_CAST((uintptr_t)RUBY_FL_EXIVAR)               /**< @old{RUBY_FL_EXIVAR} */
+#define FL_FREEZE       RBIMPL_CAST((uintptr_t)RUBY_FL_FREEZE)               /**< @old{RUBY_FL_FREEZE} */
+
+#define FL_USHIFT       RBIMPL_CAST((uintptr_t)RUBY_FL_USHIFT)               /**< @old{RUBY_FL_USHIFT} */
+
+#define FL_USER0        RBIMPL_CAST((uintptr_t)RUBY_FL_USER0)                /**< @old{RUBY_FL_USER0} */
+#define FL_USER1        RBIMPL_CAST((uintptr_t)RUBY_FL_USER1)                /**< @old{RUBY_FL_USER1} */
+#define FL_USER2        RBIMPL_CAST((uintptr_t)RUBY_FL_USER2)                /**< @old{RUBY_FL_USER2} */
+#define FL_USER3        RBIMPL_CAST((uintptr_t)RUBY_FL_USER3)                /**< @old{RUBY_FL_USER3} */
+#define FL_USER4        RBIMPL_CAST((uintptr_t)RUBY_FL_USER4)                /**< @old{RUBY_FL_USER4} */
+#define FL_USER5        RBIMPL_CAST((uintptr_t)RUBY_FL_USER5)                /**< @old{RUBY_FL_USER5} */
+#define FL_USER6        RBIMPL_CAST((uintptr_t)RUBY_FL_USER6)                /**< @old{RUBY_FL_USER6} */
+#define FL_USER7        RBIMPL_CAST((uintptr_t)RUBY_FL_USER7)                /**< @old{RUBY_FL_USER7} */
+#define FL_USER8        RBIMPL_CAST((uintptr_t)RUBY_FL_USER8)                /**< @old{RUBY_FL_USER8} */
+#define FL_USER9        RBIMPL_CAST((uintptr_t)RUBY_FL_USER9)                /**< @old{RUBY_FL_USER9} */
+#define FL_USER10       RBIMPL_CAST((uintptr_t)RUBY_FL_USER10)               /**< @old{RUBY_FL_USER10} */
+#define FL_USER11       RBIMPL_CAST((uintptr_t)RUBY_FL_USER11)               /**< @old{RUBY_FL_USER11} */
+#define FL_USER12       RBIMPL_CAST((uintptr_t)RUBY_FL_USER12)               /**< @old{RUBY_FL_USER12} */
+#define FL_USER13       RBIMPL_CAST((uintptr_t)RUBY_FL_USER13)               /**< @old{RUBY_FL_USER13} */
+#define FL_USER14       RBIMPL_CAST((uintptr_t)RUBY_FL_USER14)               /**< @old{RUBY_FL_USER14} */
+#define FL_USER15       RBIMPL_CAST((uintptr_t)RUBY_FL_USER15)               /**< @old{RUBY_FL_USER15} */
+#define FL_USER16       RBIMPL_CAST((uintptr_t)RUBY_FL_USER16)               /**< @old{RUBY_FL_USER16} */
+#define FL_USER17       RBIMPL_CAST((uintptr_t)RUBY_FL_USER17)               /**< @old{RUBY_FL_USER17} */
+#define FL_USER18       RBIMPL_CAST((uintptr_t)RUBY_FL_USER18)               /**< @old{RUBY_FL_USER18} */
+#define FL_USER19       RBIMPL_CAST((uintptr_t)(unsigned int)RUBY_FL_USER19) /**< @old{RUBY_FL_USER19} */
 
 #define ELTS_SHARED          RUBY_ELTS_SHARED     /**< @old{RUBY_ELTS_SHARED} */
 #define RB_OBJ_FREEZE        rb_obj_freeze_inline /**< @alias{rb_obj_freeze_inline} */
@@ -465,8 +465,8 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @pre        The object must not be an enum ::ruby_special_consts.
  * @return     `obj`'s flags, masked by `flags`.
  */
-static inline VALUE
-RB_FL_TEST_RAW(VALUE obj, VALUE flags)
+static inline uintptr_t
+RB_FL_TEST_RAW(VALUE obj, uintptr_t flags)
 {
     RBIMPL_ASSERT_OR_ASSUME(RB_FL_ABLE(obj));
     return RBASIC(obj)->flags & flags;
@@ -491,8 +491,8 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @note       It  is intentional  for this  function to  return ::VALUE.   The
  *             return value could be passed to RB_FL_STE() etc.
  */
-static inline VALUE
-RB_FL_TEST(VALUE obj, VALUE flags)
+static inline uintptr_t
+RB_FL_TEST(VALUE obj, uintptr_t flags)
 {
     if (RB_FL_ABLE(obj)) {
         return RB_FL_TEST_RAW(obj, flags);
@@ -515,7 +515,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @pre        The object must not be an enum ::ruby_special_consts.
  */
 static inline bool
-RB_FL_ANY_RAW(VALUE obj, VALUE flags)
+RB_FL_ANY_RAW(VALUE obj, uintptr_t flags)
 {
     return RB_FL_TEST_RAW(obj, flags);
 }
@@ -531,7 +531,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @retval     false  No it doesn't at all.
  */
 static inline bool
-RB_FL_ANY(VALUE obj, VALUE flags)
+RB_FL_ANY(VALUE obj, uintptr_t flags)
 {
     return RB_FL_TEST(obj, flags);
 }
@@ -549,7 +549,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @pre        The object must not be an enum ::ruby_special_consts.
  */
 static inline bool
-RB_FL_ALL_RAW(VALUE obj, VALUE flags)
+RB_FL_ALL_RAW(VALUE obj, uintptr_t flags)
 {
     return RB_FL_TEST_RAW(obj, flags) == flags;
 }
@@ -565,7 +565,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @retval     false  The object lacks any of the flags.
  */
 static inline bool
-RB_FL_ALL(VALUE obj, VALUE flags)
+RB_FL_ALL(VALUE obj, uintptr_t flags)
 {
     return RB_FL_TEST(obj, flags) == flags;
 }
@@ -588,7 +588,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * `__declspec(noalias)`.
  */
 static inline void
-rbimpl_fl_set_raw_raw(struct RBasic *obj, VALUE flags)
+rbimpl_fl_set_raw_raw(struct RBasic *obj, uintptr_t flags)
 {
     obj->flags |= flags;
 }
@@ -603,7 +603,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @post        `obj` has `flags` set.
  */
 static inline void
-RB_FL_SET_RAW(VALUE obj, VALUE flags)
+RB_FL_SET_RAW(VALUE obj, uintptr_t flags)
 {
     RBIMPL_ASSERT_OR_ASSUME(RB_FL_ABLE(obj));
     rbimpl_fl_set_raw_raw(RBASIC(obj), flags);
@@ -623,7 +623,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @post        `obj` has `flags` set.
  */
 static inline void
-RB_FL_SET(VALUE obj, VALUE flags)
+RB_FL_SET(VALUE obj, uintptr_t flags)
 {
     if (RB_FL_ABLE(obj)) {
         RB_FL_SET_RAW(obj, flags);
@@ -648,7 +648,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * `__declspec(noalias)`.
  */
 static inline void
-rbimpl_fl_unset_raw_raw(struct RBasic *obj, VALUE flags)
+rbimpl_fl_unset_raw_raw(struct RBasic *obj, uintptr_t flags)
 {
     obj->flags &= ~flags;
 }
@@ -663,7 +663,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @post        `obj` has `flags` cleared.
  */
 static inline void
-RB_FL_UNSET_RAW(VALUE obj, VALUE flags)
+RB_FL_UNSET_RAW(VALUE obj, uintptr_t flags)
 {
     RBIMPL_ASSERT_OR_ASSUME(RB_FL_ABLE(obj));
     rbimpl_fl_unset_raw_raw(RBASIC(obj), flags);
@@ -678,7 +678,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @post        `obj` has `flags` cleard.
  */
 static inline void
-RB_FL_UNSET(VALUE obj, VALUE flags)
+RB_FL_UNSET(VALUE obj, uintptr_t flags)
 {
     if (RB_FL_ABLE(obj)) {
         RB_FL_UNSET_RAW(obj, flags);
@@ -703,7 +703,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * `__declspec(noalias)`.
  */
 static inline void
-rbimpl_fl_reverse_raw_raw(struct RBasic *obj, VALUE flags)
+rbimpl_fl_reverse_raw_raw(struct RBasic *obj, uintptr_t flags)
 {
     obj->flags ^= flags;
 }
@@ -718,7 +718,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @post        `obj` has `flags` cleared.
  */
 static inline void
-RB_FL_REVERSE_RAW(VALUE obj, VALUE flags)
+RB_FL_REVERSE_RAW(VALUE obj, uintptr_t flags)
 {
     RBIMPL_ASSERT_OR_ASSUME(RB_FL_ABLE(obj));
     rbimpl_fl_reverse_raw_raw(RBASIC(obj), flags);
@@ -734,7 +734,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * @post        `obj` has `flags` reversed.
  */
 static inline void
-RB_FL_REVERSE(VALUE obj, VALUE flags)
+RB_FL_REVERSE(VALUE obj, uintptr_t flags)
 {
     if (RB_FL_ABLE(obj)) {
         RB_FL_REVERSE_RAW(obj, flags);
@@ -774,7 +774,7 @@ static inline VALUE
 RB_OBJ_TAINTED_RAW(VALUE obj)
 {
     (void)obj;
-    return false;
+    return (VALUE)false;
 }
 
 RBIMPL_ATTR_PURE_UNLESS_DEBUG()
@@ -879,7 +879,7 @@ RBIMPL_ATTR_ARTIFICIAL()
  * (namely `class.c:singleton_class_of()`) where return  value of this function
  * is passed to RB_FL_SET_RAW().
  */
-static inline VALUE
+static inline uintptr_t
 RB_OBJ_FROZEN_RAW(VALUE obj)
 {
     return RB_FL_TEST_RAW(obj, RUBY_FL_FREEZE);
diff --git a/include/ruby/internal/memory.h b/include/ruby/internal/memory.h
index 8f0078751205..1918c8dc6800 100644
--- a/include/ruby/internal/memory.h
+++ b/include/ruby/internal/memory.h
@@ -107,69 +107,8 @@ typedef uint128_t DSIZE_T;
 # define RUBY_ALLOCV_LIMIT 1024
 #endif
 
-/**
- * Prevents premature  destruction of local objects.   Ruby's garbage collector
- * is conservative; it  scans the C level machine stack  as well.  Possible in-
- * use Ruby  objects must  remain visible  on stack, to  be properly  marked as
- * such.  However  contemporary C  compilers do not  interface well  with this.
- * Consider the following example:
- *
- * ```CXX
- * auto s = rb_str_new_cstr(" world");
- * auto sptr = RSTRING_PTR(s);
- * auto t = rb_str_new_cstr("hello,"); // Possible GC invocation
- * auto u = rb_str_cat_cstr(t, sptr);
- *
- * RB_GC_GUARD(s); // ensure `s` (and thus `sptr`) do not get GC-ed
- * ```
- *
- * Here, without the #RB_GC_GUARD, the last use of `s` is _before_ the last use
- * of `sptr`.  Compilers  could thus think `s` and `t`  are allowed to overlap.
- * That would eliminate `s`  from the stack, while `sptr` is  still in use.  If
- * our GC  ran at  that very moment,  `s` gets swept  out, which  also destroys
- * `sptr`.  Boom!  You got a SEGV.
- *
- * In order  to prevent this scenario  #RB_GC_GUARD must be placed  _after_ the
- * last use of `sptr`.  Placing  #RB_GC_GUARD before dereferencing `sptr` would
- * be of no use.
- *
- * #RB_GC_GUARD would  not be  necessary at  all in the  above example  if non-
- * inlined  function  calls are  made  on  the  `s`  variable after  `sptr`  is
- * dereferenced.  Thus, in  the above example, calling  any un-inlined function
- * on `s`  such as `rb_str_modify(s);`  will ensure `s`  stays on the  stack or
- * register to prevent a GC invocation from prematurely freeing it.
- *
- * Using the #RB_GC_GUARD  macro is preferable to using  the `volatile` keyword
- * in C.  #RB_GC_GUARD has the following advantages:
- *
- *  - the intent of the macro use is clear.
- *
- *  - #RB_GC_GUARD only affects its call  site.  OTOH `volatile` generates some
- *    extra code every time the variable is used, hurting optimisation.
- *
- *  - `volatile` implementations  may be  buggy/inconsistent in  some compilers
- *    and   architectures.     #RB_GC_GUARD   is   customisable    for   broken
- *    systems/compilers without negatively affecting other systems.
- *
- *  - C++  since C++20  deprecates  `volatile`.  If  you  write your  extension
- *    library in that language there is no escape but to use this macro.
- *
- * @param  v  A variable of ::VALUE type.
- * @post   `v` is still alive.
- */
-#ifdef __GNUC__
-#define RB_GC_GUARD(v) \
-    (*__extension__ ({ \
-        volatile VALUE *rb_gc_guarded_ptr = &(v); \
-        __asm__("" : : "m"(rb_gc_guarded_ptr)); \
-        rb_gc_guarded_ptr; \
-    }))
-#elif defined _MSC_VER
-#define RB_GC_GUARD(v) (*rb_gc_guarded_ptr(&(v)))
-#else
-#define HAVE_RB_GC_GUARDED_PTR_VAL 1
-#define RB_GC_GUARD(v) (*rb_gc_guarded_ptr_val(&(v),(v)))
-#endif
+/* Fil-C GC is accurate, so we don't need to do anything special here. */
+#define RB_GC_GUARD(v) (v)
 
 /* Casts needed because void* is NOT compatible with others in C++. */
 
diff --git a/include/ruby/internal/newobj.h b/include/ruby/internal/newobj.h
index ba1d7cbe59ae..4621b1303a79 100644
--- a/include/ruby/internal/newobj.h
+++ b/include/ruby/internal/newobj.h
@@ -80,7 +80,7 @@ VALUE rb_newobj(void);
  * @exception  rb_eNoMemError  No space left.
  * @return     An allocated object, filled with the arguments.
  */
-VALUE rb_newobj_of(VALUE klass, VALUE flags);
+VALUE rb_newobj_of(VALUE klass, uintptr_t flags);
 
 /**
  * Fills common fields in the object.
@@ -103,7 +103,7 @@ VALUE rb_newobj_of(VALUE klass, VALUE flags);
  * They normally only concern ::RUBY_T_DATA.   This argument is mainly used for
  * specifying flags, @shyouhei suspects.
  */
-VALUE rb_obj_setup(VALUE obj, VALUE klass, VALUE type);
+VALUE rb_obj_setup(VALUE obj, VALUE klass, uintptr_t type);
 
 /**
  * Queries  the  class  of  an  object.    This  is  not  always  identical  to
diff --git a/include/ruby/internal/special_consts.h b/include/ruby/internal/special_consts.h
index dc0a6b41d6ba..38789c9ef31d 100644
--- a/include/ruby/internal/special_consts.h
+++ b/include/ruby/internal/special_consts.h
@@ -120,7 +120,6 @@ ruby_special_consts {
 };
 
 RBIMPL_ATTR_CONST()
-RBIMPL_ATTR_CONSTEXPR(CXX11)
 RBIMPL_ATTR_ARTIFICIAL()
 /**
  * Emulates Ruby's "if" statement.
@@ -156,11 +155,10 @@ RB_TEST(VALUE obj)
      *
      *  RTEST(v) can be 0 if and only if (v == Qfalse || v == Qnil).
      */
-    return obj & ~RUBY_Qnil;
+    return (uintptr_t)obj & ~RUBY_Qnil;
 }
 
 RBIMPL_ATTR_CONST()
-RBIMPL_ATTR_CONSTEXPR(CXX11)
 RBIMPL_ATTR_ARTIFICIAL()
 /**
  * Checks if the given object is nil.
@@ -172,11 +170,10 @@ RBIMPL_ATTR_ARTIFICIAL()
 static inline bool
 RB_NIL_P(VALUE obj)
 {
-    return obj == RUBY_Qnil;
+    return (uintptr_t)obj == RUBY_Qnil;
 }
 
 RBIMPL_ATTR_CONST()
-RBIMPL_ATTR_CONSTEXPR(CXX11)
 RBIMPL_ATTR_ARTIFICIAL()
 /**
  * Checks if the given object is undef.
@@ -188,11 +185,10 @@ RBIMPL_ATTR_ARTIFICIAL()
 static inline bool
 RB_UNDEF_P(VALUE obj)
 {
-    return obj == RUBY_Qundef;
+    return (uintptr_t)obj == RUBY_Qundef;
 }
 
 RBIMPL_ATTR_CONST()
-RBIMPL_ATTR_CONSTEXPR(CXX14)
 RBIMPL_ATTR_ARTIFICIAL()
 /**
  * Checks if the given object is nil or undef.  Can be used to see if
@@ -226,13 +222,12 @@ RB_NIL_OR_UNDEF_P(VALUE obj)
      *
      *  NIL_OR_UNDEF_P(v) can be true only when v is Qundef or Qnil.
      */
-    const VALUE mask = ~(RUBY_Qundef ^ RUBY_Qnil);
-    const VALUE common_bits = RUBY_Qundef & RUBY_Qnil;
-    return (obj & mask) == common_bits;
+    const uintptr_t mask = ~(RUBY_Qundef ^ RUBY_Qnil);
+    const uintptr_t common_bits = RUBY_Qundef & RUBY_Qnil;
+    return ((uintptr_t)obj & mask) == common_bits;
 }
 
 RBIMPL_ATTR_CONST()
-RBIMPL_ATTR_CONSTEXPR(CXX11)
 RBIMPL_ATTR_ARTIFICIAL()
 /**
  * Checks if the given object is a so-called Fixnum.
@@ -246,11 +241,10 @@ RBIMPL_ATTR_ARTIFICIAL()
 static inline bool
 RB_FIXNUM_P(VALUE obj)
 {
-    return obj & RUBY_FIXNUM_FLAG;
+    return (uintptr_t)obj & RUBY_FIXNUM_FLAG;
 }
 
 RBIMPL_ATTR_CONST()
-RBIMPL_ATTR_CONSTEXPR(CXX14)
 RBIMPL_ATTR_ARTIFICIAL()
 /**
  * Checks if the given object is a static symbol.
@@ -266,13 +260,11 @@ RBIMPL_ATTR_ARTIFICIAL()
 static inline bool
 RB_STATIC_SYM_P(VALUE obj)
 {
-    RBIMPL_ATTR_CONSTEXPR(CXX14)
-    const VALUE mask = ~(RBIMPL_VALUE_FULL << RUBY_SPECIAL_SHIFT);
-    return (obj & mask) == RUBY_SYMBOL_FLAG;
+    const uintptr_t mask = ~(RBIMPL_VALUE_FULL << RUBY_SPECIAL_SHIFT);
+    return ((uintptr_t)obj & mask) == RUBY_SYMBOL_FLAG;
 }
 
 RBIMPL_ATTR_CONST()
-RBIMPL_ATTR_CONSTEXPR(CXX11)
 RBIMPL_ATTR_ARTIFICIAL()
 /**
  * Checks if the given object is a so-called Flonum.
@@ -288,14 +280,13 @@ static inline bool
 RB_FLONUM_P(VALUE obj)
 {
 #if USE_FLONUM
-    return (obj & RUBY_FLONUM_MASK) == RUBY_FLONUM_FLAG;
+    return ((uintptr_t)obj & RUBY_FLONUM_MASK) == RUBY_FLONUM_FLAG;
 #else
     return false;
 #endif
 }
 
 RBIMPL_ATTR_CONST()
-RBIMPL_ATTR_CONSTEXPR(CXX11)
 RBIMPL_ATTR_ARTIFICIAL()
 /**
  * Checks if  the given  object is  an immediate  i.e. an  object which  has no
@@ -310,11 +301,10 @@ RBIMPL_ATTR_ARTIFICIAL()
 static inline bool
 RB_IMMEDIATE_P(VALUE obj)
 {
-    return obj & RUBY_IMMEDIATE_MASK;
+    return (uintptr_t)obj & RUBY_IMMEDIATE_MASK;
 }
 
 RBIMPL_ATTR_CONST()
-RBIMPL_ATTR_CONSTEXPR(CXX11)
 RBIMPL_ATTR_ARTIFICIAL()
 /**
  * Checks if the given object is of enum ::ruby_special_consts.
@@ -326,11 +316,10 @@ RBIMPL_ATTR_ARTIFICIAL()
 static inline bool
 RB_SPECIAL_CONST_P(VALUE obj)
 {
-    return RB_IMMEDIATE_P(obj) || obj == RUBY_Qfalse;
+    return RB_IMMEDIATE_P(obj) || (uintptr_t)obj == RUBY_Qfalse;
 }
 
 RBIMPL_ATTR_CONST()
-RBIMPL_ATTR_CONSTEXPR(CXX11)
 /**
  * Identical to RB_SPECIAL_CONST_P, except it returns a ::VALUE.
  *
@@ -346,7 +335,7 @@ RBIMPL_ATTR_CONSTEXPR(CXX11)
 static inline VALUE
 rb_special_const_p(VALUE obj)
 {
-    return RB_SPECIAL_CONST_P(obj) * RUBY_Qtrue;
+    return (VALUE)(uintptr_t)(RB_SPECIAL_CONST_P(obj) * RUBY_Qtrue);
 }
 
 /**
diff --git a/include/ruby/internal/value.h b/include/ruby/internal/value.h
index 805cd835131c..8b093571cbbb 100644
--- a/include/ruby/internal/value.h
+++ b/include/ruby/internal/value.h
@@ -24,7 +24,16 @@
 #include "ruby/backward/2/long_long.h"
 #include "ruby/backward/2/limits.h"
 
-#if defined(__DOXYGEN__)
+#if defined(__DOXYGEN__) || defined(__FILC__)
+
+#ifndef RB_VALUE_UNIT_STRUCT
+struct rb_value_unit_struct {
+    char c;
+};
+
+typedef struct rb_value_unit_struct rb_value_unit;
+#define RB_VALUE_UNIT_STRUCT
+#endif
 
 /**
  * Type that represents a Ruby object.  It is an unsigned integer of some kind,
@@ -37,7 +46,7 @@
  * @warning  ::VALUE is not a pointer.
  * @warning  ::VALUE can be wider than `long`.
  */
-typedef uintptr_t VALUE;
+typedef rb_value_unit* VALUE;
 
 /**
  * Type that represents a Ruby identifier such as a variable name.
@@ -73,14 +82,14 @@ typedef intptr_t SIGNED_VALUE;
  *
  * A compile-time constant of type ::VALUE whose value is 0.
  */
-#define RBIMPL_VALUE_NULL UINTPTR_C(0)
+#define RBIMPL_VALUE_NULL ((uintptr_t)0)
 
 /**
  * @private
  *
  * A compile-time constant of type ::VALUE whose value is 1.
  */
-#define RBIMPL_VALUE_ONE  UINTPTR_C(1)
+#define RBIMPL_VALUE_ONE  ((void*)(uintptr_t)1)
 
 /**
  * @private
diff --git a/include/ruby/internal/value_type.h b/include/ruby/internal/value_type.h
index 977f60a0094d..e17c3f457ab4 100644
--- a/include/ruby/internal/value_type.h
+++ b/include/ruby/internal/value_type.h
@@ -187,7 +187,7 @@ RB_BUILTIN_TYPE(VALUE obj)
      * RB_SPECIAL_CONST_P check. */
     __asm volatile("": : :"memory");
 #endif
-    VALUE ret = RBASIC(obj)->flags & RUBY_T_MASK;
+    uintptr_t ret = RBASIC(obj)->flags & RUBY_T_MASK;
     return RBIMPL_CAST((enum ruby_value_type)ret);
 }
 
diff --git a/include/ruby/st.h b/include/ruby/st.h
index ba69c066c926..b68e6fa59b1a 100644
--- a/include/ruby/st.h
+++ b/include/ruby/st.h
@@ -18,13 +18,15 @@ extern "C" {
 
 RUBY_SYMBOL_EXPORT_BEGIN
 
-#if SIZEOF_LONG == SIZEOF_VOIDP
-typedef unsigned long st_data_t;
-#elif SIZEOF_LONG_LONG == SIZEOF_VOIDP
-typedef unsigned LONG_LONG st_data_t;
-#else
-# error ---->> st.c requires sizeof(void*) == sizeof(long) or sizeof(LONG_LONG) to be compiled. <<----
+#ifndef RB_VALUE_UNIT_STRUCT
+struct rb_value_unit_struct {
+    char c;
+};
+
+typedef struct rb_value_unit_struct rb_value_unit;
+#define RB_VALUE_UNIT_STRUCT
 #endif
+typedef rb_value_unit* st_data_t;
 #define ST_DATA_T_DEFINED
 
 #ifndef CHAR_BIT
@@ -47,7 +49,7 @@ typedef unsigned LONG_LONG st_data_t;
 
 typedef struct st_table st_table;
 
-typedef st_data_t st_index_t;
+typedef uintptr_t st_index_t;
 
 /* Maximal value of unsigned integer type st_index_t.  */
 #define MAX_ST_INDEX_VAL (~(st_index_t) 0)
diff --git a/insns.def b/insns.def
index 5f6cb314ffeb..75e243c976fb 100644
--- a/insns.def
+++ b/insns.def
@@ -769,7 +769,7 @@ defineclass
     rb_iseq_check(class_iseq);
 
     /* enter scope */
-    vm_push_frame(ec, class_iseq, VM_FRAME_MAGIC_CLASS | VM_ENV_FLAG_LOCAL, klass,
+    vm_push_frame(ec, class_iseq, (VALUE)(VM_FRAME_MAGIC_CLASS | VM_ENV_FLAG_LOCAL), klass,
                   GET_BLOCK_HANDLER(),
                   (VALUE)vm_cref_push(ec, klass, NULL, FALSE, FALSE),
                   ISEQ_BODY(class_iseq)->iseq_encoded, GET_SP(),
diff --git a/insns_info.inc b/insns_info.inc
index 79e06c90dd83..0a09f98c3955 100644
--- a/insns_info.inc
+++ b/insns_info.inc
@@ -73,7 +73,7 @@ ISEQ_IS_ENTRY_START(const struct rb_iseq_constant_body *body, char op_type)
     return &body->is_entries[relative_ic_offset];
 }
 
-CONSTFUNC(MAYBE_UNUSED(static const char *insn_name(VALUE insn)));
+CONSTFUNC(MAYBE_UNUSED(static const char *insn_name(uintptr_t insn)));
 
 RUBY_SYMBOL_EXPORT_BEGIN /* for debuggers */
 extern const int rb_vm_max_insn_name_size;
@@ -315,12 +315,12 @@ ASSERT_VM_INSTRUCTION_SIZE(rb_vm_insn_name_offset);
 #endif
 
 const char *
-insn_name(VALUE i)
+insn_name(uintptr_t i)
 {
     return &rb_vm_insn_name_base[rb_vm_insn_name_offset[i]];
 }
 
-CONSTFUNC(MAYBE_UNUSED(static int insn_len(VALUE insn)));
+CONSTFUNC(MAYBE_UNUSED(static int insn_len(uintptr_t insn)));
 
 RUBY_SYMBOL_EXPORT_BEGIN /* for debuggers */
 extern const uint8_t rb_vm_insn_len_info[VM_INSTRUCTION_SIZE];
@@ -343,13 +343,13 @@ ASSERT_VM_INSTRUCTION_SIZE(rb_vm_insn_len_info);
 #endif
 
 int
-insn_len(VALUE i)
+insn_len(uintptr_t i)
 {
     return rb_vm_insn_len_info[i];
 }
 
-CONSTFUNC(MAYBE_UNUSED(static const char *insn_op_types(VALUE insn)));
-CONSTFUNC(MAYBE_UNUSED(static int insn_op_type(VALUE insn, long pos)));
+CONSTFUNC(MAYBE_UNUSED(static const char *insn_op_types(uintptr_t insn)));
+CONSTFUNC(MAYBE_UNUSED(static int insn_op_type(uintptr_t insn, long pos)));
 
 RUBY_SYMBOL_EXPORT_BEGIN /* for debuggers */
 extern const char rb_vm_insn_op_base[];
@@ -425,13 +425,13 @@ ASSERT_VM_INSTRUCTION_SIZE(rb_vm_insn_op_offset);
 #endif
 
 const char *
-insn_op_types(VALUE i)
+insn_op_types(uintptr_t i)
 {
     return &rb_vm_insn_op_base[rb_vm_insn_op_offset[i]];
 }
 
 int
-insn_op_type(VALUE i, long j)
+insn_op_type(uintptr_t i, long j)
 {
     if (j >= insn_len(i)) {
         return 0;
diff --git a/internal/bignum.h b/internal/bignum.h
index db8d3aee8385..d568e1fdf7ac 100644
--- a/internal/bignum.h
+++ b/internal/bignum.h
@@ -75,10 +75,10 @@
 
 #define RBIGNUM(obj) ((struct RBignum *)(obj))
 #define BIGNUM_SIGN_BIT FL_USER1
-#define BIGNUM_EMBED_FLAG ((VALUE)FL_USER2)
+#define BIGNUM_EMBED_FLAG ((uintptr_t)FL_USER2)
 #define BIGNUM_EMBED_LEN_NUMBITS 3
 #define BIGNUM_EMBED_LEN_MASK \
-    (~(~(VALUE)0U << BIGNUM_EMBED_LEN_NUMBITS) << BIGNUM_EMBED_LEN_SHIFT)
+    (~(~(uintptr_t)0U << BIGNUM_EMBED_LEN_NUMBITS) << BIGNUM_EMBED_LEN_SHIFT)
 #define BIGNUM_EMBED_LEN_SHIFT \
     (FL_USHIFT+3) /* bit offset of BIGNUM_EMBED_LEN_MASK */
 #ifndef BIGNUM_EMBED_LEN_MAX
diff --git a/internal/bits.h b/internal/bits.h
index 1fe98fa430ef..c136554e30ae 100644
--- a/internal/bits.h
+++ b/internal/bits.h
@@ -175,8 +175,8 @@ static inline unsigned rb_popcount_intptr(uintptr_t x);
 static inline int ntz_int32(uint32_t x);
 static inline int ntz_int64(uint64_t x);
 static inline int ntz_intptr(uintptr_t x);
-static inline VALUE RUBY_BIT_ROTL(VALUE, int);
-static inline VALUE RUBY_BIT_ROTR(VALUE, int);
+static inline uintptr_t RUBY_BIT_ROTL(uintptr_t, int);
+static inline uintptr_t RUBY_BIT_ROTR(uintptr_t, int);
 
 static inline uint16_t
 ruby_swap16(uint16_t x)
@@ -517,8 +517,8 @@ ntz_intptr(uintptr_t x)
     }
 }
 
-static inline VALUE
-RUBY_BIT_ROTL(VALUE v, int n)
+static inline uintptr_t
+RUBY_BIT_ROTL(uintptr_t v, int n)
 {
 #if __has_builtin(__builtin_rotateleft32) && (SIZEOF_VALUE * CHAR_BIT == 32)
     return __builtin_rotateleft32(v, n);
@@ -541,8 +541,8 @@ RUBY_BIT_ROTL(VALUE v, int n)
 #endif
 }
 
-static inline VALUE
-RUBY_BIT_ROTR(VALUE v, int n)
+static inline uintptr_t
+RUBY_BIT_ROTR(uintptr_t v, int n)
 {
 #if __has_builtin(__builtin_rotateright32) && (SIZEOF_VALUE * CHAR_BIT == 32)
     return __builtin_rotateright32(v, n);
diff --git a/internal/compile.h b/internal/compile.h
index 2ece5396f655..1c3e4ff0c469 100644
--- a/internal/compile.h
+++ b/internal/compile.h
@@ -17,7 +17,7 @@ struct rb_iseq_struct;          /* in vm_core.h */
 /* compile.c */
 int rb_dvar_defined(ID, const struct rb_iseq_struct *);
 int rb_local_defined(ID, const struct rb_iseq_struct *);
-int rb_insn_len(VALUE insn);
+int rb_insn_len(uintptr_t insn);
 const char *rb_insns_name(int i);
 VALUE rb_insns_name_array(void);
 int rb_iseq_cdhash_cmp(VALUE val, VALUE lit);
diff --git a/internal/gc.h b/internal/gc.h
index 34a6043e8a1f..3a5d3232abf2 100644
--- a/internal/gc.h
+++ b/internal/gc.h
@@ -16,7 +16,9 @@
 #include "ruby/ruby.h"          /* for rb_event_flag_t */
 #include "vm_core.h"            /* for GET_EC() */
 
-#if defined(__x86_64__) && !defined(_ILP32) && defined(__GNUC__)
+#if defined(__FILC__)
+#define SET_MACHINE_STACK_END(p)
+#elif defined(__x86_64__) && !defined(_ILP32) && defined(__GNUC__)
 #define SET_MACHINE_STACK_END(p) __asm__ __volatile__ ("movq\t%%rsp, %0" : "=r" (*(p)))
 #elif defined(__i386) && defined(__GNUC__)
 #define SET_MACHINE_STACK_END(p) __asm__ __volatile__ ("movl\t%%esp, %0" : "=r" (*(p)))
@@ -282,8 +284,8 @@ VALUE rb_gc_disable_no_rest(void);
 
 /* gc.c (export) */
 const char *rb_objspace_data_type_name(VALUE obj);
-VALUE rb_wb_protected_newobj_of(struct rb_execution_context_struct *, VALUE, VALUE, size_t);
-VALUE rb_wb_unprotected_newobj_of(VALUE, VALUE, size_t);
+VALUE rb_wb_protected_newobj_of(struct rb_execution_context_struct *, VALUE, uintptr_t, size_t);
+VALUE rb_wb_unprotected_newobj_of(VALUE, uintptr_t, size_t);
 size_t rb_obj_memsize_of(VALUE);
 void rb_gc_verify_internal_consistency(void);
 size_t rb_obj_gc_flags(VALUE, ID[], size_t);
diff --git a/internal/hash.h b/internal/hash.h
index fe859cb716b9..b07c3f271d17 100644
--- a/internal/hash.h
+++ b/internal/hash.h
@@ -183,7 +183,7 @@ RHASH_ST_CLEAR(VALUE h)
 static inline unsigned
 RHASH_AR_TABLE_SIZE_RAW(VALUE h)
 {
-    VALUE ret = FL_TEST_RAW(h, RHASH_AR_TABLE_SIZE_MASK);
+    uintptr_t ret = FL_TEST_RAW(h, RHASH_AR_TABLE_SIZE_MASK);
     ret >>= RHASH_AR_TABLE_SIZE_SHIFT;
     return (unsigned)ret;
 }
diff --git a/internal/imemo.h b/internal/imemo.h
index 65335285abc7..36814d1cc7d3 100644
--- a/internal/imemo.h
+++ b/internal/imemo.h
@@ -59,7 +59,7 @@ struct vm_svar {
 
 /*! THROW_DATA */
 struct vm_throw_data {
-    VALUE flags;
+    uintptr_t flags;
     VALUE reserved;
     const VALUE throw_obj;
     const struct rb_control_frame_struct *catch_frame;
@@ -101,7 +101,7 @@ struct rb_imemo_tmpbuf_struct {
  * @see imemo_type
  * */
 struct MEMO {
-    VALUE flags;
+    uintptr_t flags;
     VALUE reserved;
     const VALUE v1;
     const VALUE v2;
@@ -161,8 +161,8 @@ imemo_type_p(VALUE imemo, enum imemo_type imemo_type)
 {
     if (LIKELY(!RB_SPECIAL_CONST_P(imemo))) {
         /* fixed at compile time if imemo_type is given. */
-        const VALUE mask = (IMEMO_MASK << FL_USHIFT) | RUBY_T_MASK;
-        const VALUE expected_type = (imemo_type << FL_USHIFT) | T_IMEMO;
+        const uintptr_t mask = (IMEMO_MASK << FL_USHIFT) | RUBY_T_MASK;
+        const uintptr_t expected_type = (imemo_type << FL_USHIFT) | T_IMEMO;
         /* fixed at runtime. */
         return expected_type == (RBASIC(imemo)->flags & mask);
     }
diff --git a/internal/numeric.h b/internal/numeric.h
index f7b8d0ad2da0..2155c2798868 100644
--- a/internal/numeric.h
+++ b/internal/numeric.h
@@ -206,11 +206,11 @@ rb_float_flonum_value(VALUE v)
             VALUE v;
         } t;
 
-        VALUE b63 = (v >> 63);
+        uintptr_t b63 = ((uintptr_t)v >> 63);
         /* e: xx1... -> 011... */
         /*    xx0... -> 100... */
         /*      ^b63           */
-        t.v = RUBY_BIT_ROTR((2 - b63) | (v & ~(VALUE)0x03), 3);
+        t.v = (VALUE)(RUBY_BIT_ROTR((2 - b63) | ((uintptr_t)v & ~(uintptr_t)0x03), 3));
         return t.d;
     }
 #endif
@@ -251,19 +251,19 @@ rb_float_new_inline(double d)
     int bits;
 
     t.d = d;
-    bits = (int)((VALUE)(t.v >> 60) & 0x7);
+    bits = (int)((uintptr_t)((uintptr_t)t.v >> 60) & 0x7);
     /* bits contains 3 bits of b62..b60. */
     /* bits - 3 = */
     /*   b011 -> b000 */
     /*   b100 -> b001 */
 
-    if (t.v != 0x3000000000000000 /* 1.72723e-77 */ &&
+    if (t.v != (VALUE)0x3000000000000000 /* 1.72723e-77 */ &&
         !((bits-3) & ~0x01)) {
-        return (RUBY_BIT_ROTL(t.v, 3) & ~(VALUE)0x01) | 0x02;
+        return (VALUE)((RUBY_BIT_ROTL((uintptr_t)t.v, 3) & ~0x01) | 0x02);
     }
     else if (t.v == (VALUE)0) {
         /* +0.0 */
-        return 0x8000000000000002;
+        return (VALUE)0x8000000000000002;
     }
     /* out of range */
 #endif
diff --git a/internal/parse.h b/internal/parse.h
index bd6d295be1a6..63c693653ba0 100644
--- a/internal/parse.h
+++ b/internal/parse.h
@@ -40,7 +40,7 @@ typedef struct rb_strterm_heredoc_struct {
 #define HERETERM_LENGTH_MAX UINT_MAX
 
 typedef struct rb_strterm_struct {
-    VALUE flags;
+    uintptr_t flags;
     union {
         rb_strterm_literal_t literal;
         rb_strterm_heredoc_t heredoc;
diff --git a/internal/rational.h b/internal/rational.h
index f11fab4583b3..90503a037460 100644
--- a/internal/rational.h
+++ b/internal/rational.h
@@ -31,7 +31,7 @@ VALUE rb_rational_div(VALUE self, VALUE other);
 VALUE rb_lcm(VALUE x, VALUE y);
 VALUE rb_rational_reciprocal(VALUE x);
 VALUE rb_cstr_to_rat(const char *, int);
-VALUE rb_rational_hash(VALUE self);
+st_index_t rb_rational_hash(VALUE self);
 VALUE rb_rational_abs(VALUE self);
 VALUE rb_rational_cmp(VALUE self, VALUE other);
 VALUE rb_rational_pow(VALUE self, VALUE other);
diff --git a/io.c b/io.c
index b4b262b6ac80..e01461b5ade7 100644
--- a/io.c
+++ b/io.c
@@ -1174,7 +1174,7 @@ internal_read_func(void *ptr)
 
     if (iis->timeout && !iis->nonblock) {
         if (io_internal_wait(iis->th, iis->fptr, 0, RB_WAITFD_IN, iis->timeout) == -1) {
-            return -1;
+            return (VALUE)-1;
         }
     }
 
@@ -1184,7 +1184,7 @@ internal_read_func(void *ptr)
     if (result < 0 && !iis->nonblock) {
         if (io_again_p(errno)) {
             if (io_internal_wait(iis->th, iis->fptr, errno, RB_WAITFD_IN, iis->timeout) == -1) {
-                return -1;
+                return (VALUE)-1;
             }
             else {
                 goto retry;
@@ -1192,7 +1192,7 @@ internal_read_func(void *ptr)
         }
     }
 
-    return result;
+    return (VALUE)result;
 }
 
 #if defined __APPLE__
@@ -1209,7 +1209,7 @@ internal_write_func(void *ptr)
 
     if (iis->timeout && !iis->nonblock) {
         if (io_internal_wait(iis->th, iis->fptr, 0, RB_WAITFD_OUT, iis->timeout) == -1) {
-            return -1;
+            return (VALUE)-1;
         }
     }
 
@@ -1220,7 +1220,7 @@ internal_write_func(void *ptr)
         int e = errno;
         if (io_again_p(e)) {
             if (io_internal_wait(iis->th, iis->fptr, errno, RB_WAITFD_OUT, iis->timeout) == -1) {
-                return -1;
+                return (VALUE)-1;
             }
             else {
                 goto retry;
@@ -1228,7 +1228,7 @@ internal_write_func(void *ptr)
         }
     }
 
-    return result;
+    return (VALUE)result;
 }
 
 #ifdef HAVE_WRITEV
@@ -1240,7 +1240,7 @@ internal_writev_func(void *ptr)
 
     if (iis->timeout && !iis->nonblock) {
         if (io_internal_wait(iis->th, iis->fptr, 0, RB_WAITFD_OUT, iis->timeout) == -1) {
-            return -1;
+            return (VALUE)-1;
         }
     }
 
@@ -1250,7 +1250,7 @@ internal_writev_func(void *ptr)
     if (result < 0 && !iis->nonblock) {
         if (io_again_p(errno)) {
             if (io_internal_wait(iis->th, iis->fptr, errno, RB_WAITFD_OUT, iis->timeout) == -1) {
-                return -1;
+                return (VALUE)-1;
             }
             else {
                 goto retry;
@@ -1258,7 +1258,7 @@ internal_writev_func(void *ptr)
         }
     }
 
-    return result;
+    return (VALUE)result;
 }
 #endif
 
@@ -1816,11 +1816,11 @@ io_binwrite_string(VALUE arg)
         }
         else {
             // The error was unrelated to waiting for it to become writable, so we fail:
-            return -1;
+            return (VALUE)-1;
         }
     }
 
-    return p->length;
+    return (VALUE)p->length;
 }
 
 inline static void
@@ -1873,10 +1873,10 @@ io_binwrite(VALUE str, const char *ptr, long len, rb_io_t *fptr, int nosync)
         arg.length = len;
 
         if (!NIL_P(fptr->write_lock)) {
-            return rb_mutex_synchronize(fptr->write_lock, io_binwrite_string, (VALUE)&arg);
+            return (long)rb_mutex_synchronize(fptr->write_lock, io_binwrite_string, (VALUE)&arg);
         }
         else {
-            return io_binwrite_string((VALUE)&arg);
+            return (long)io_binwrite_string((VALUE)&arg);
         }
     }
     else {
@@ -2060,7 +2060,7 @@ io_binwritev_internal(VALUE arg)
             }
 
             if (offset == p->total) {
-                return p->total;
+                return (VALUE)p->total;
             }
 
             while (result >= (ssize_t)iov->iov_len) {
@@ -2071,7 +2071,7 @@ io_binwritev_internal(VALUE arg)
 
                 if (!--iovcnt) {
                     // I don't believe this code path can ever occur.
-                    return offset;
+                    return (VALUE)offset;
                 }
             }
 
@@ -2082,11 +2082,11 @@ io_binwritev_internal(VALUE arg)
             rb_io_check_closed(fptr);
         }
         else {
-            return -1;
+            return (VALUE)-1;
         }
     }
 
-    return offset;
+    return (VALUE)offset;
 }
 
 static long
@@ -2138,10 +2138,10 @@ io_binwritev(struct iovec *iov, int iovcnt, rb_io_t *fptr)
     arg.total = total;
 
     if (!NIL_P(fptr->write_lock)) {
-        return rb_mutex_synchronize(fptr->write_lock, io_binwritev_internal, (VALUE)&arg);
+        return (long)rb_mutex_synchronize(fptr->write_lock, io_binwritev_internal, (VALUE)&arg);
     }
     else {
-        return io_binwritev_internal((VALUE)&arg);
+        return (long)io_binwritev_internal((VALUE)&arg);
     }
 }
 
@@ -3591,7 +3591,7 @@ io_readpartial(int argc, VALUE *argv, VALUE io)
 {
     VALUE ret;
 
-    ret = io_getpartial(argc, argv, io, Qnil, 0);
+    ret = io_getpartial(argc, argv, io, (int)Qnil, 0);
     if (NIL_P(ret))
         rb_eof_error();
     return ret;
@@ -6163,7 +6163,7 @@ pread_internal_call(VALUE _arg)
         VALUE result = rb_fiber_scheduler_io_pread_memory(scheduler, arg->io, arg->offset, arg->buf, arg->count, 0);
 
         if (!UNDEF_P(result)) {
-            return rb_fiber_scheduler_io_result_apply(result);
+            return (VALUE)rb_fiber_scheduler_io_result_apply(result);
         }
     }
 
@@ -6245,7 +6245,7 @@ internal_pwrite_func(void *_arg)
         VALUE result = rb_fiber_scheduler_io_pwrite_memory(scheduler, arg->io, arg->offset, arg->buf, arg->count, 0);
 
         if (!UNDEF_P(result)) {
-            return rb_fiber_scheduler_io_result_apply(result);
+            return (VALUE)rb_fiber_scheduler_io_result_apply(result);
         }
     }
 
@@ -7090,8 +7090,8 @@ io_strip_bom(VALUE io)
     GetOpenFile(io, fptr);
     if (!(fptr->mode & FMODE_READABLE)) return 0;
     if (NIL_P(b1 = rb_io_getbyte(io))) return 0;
-    switch (b1) {
-      case INT2FIX(0xEF):
+    switch ((uintptr_t)b1) {
+      case (uintptr_t)INT2FIX(0xEF):
         if (NIL_P(b2 = rb_io_getbyte(io))) break;
         if (b2 == INT2FIX(0xBB) && !NIL_P(b3 = rb_io_getbyte(io))) {
             if (b3 == INT2FIX(0xBF)) {
@@ -7102,7 +7102,7 @@ io_strip_bom(VALUE io)
         rb_io_ungetbyte(io, b2);
         break;
 
-      case INT2FIX(0xFE):
+      case (uintptr_t)INT2FIX(0xFE):
         if (NIL_P(b2 = rb_io_getbyte(io))) break;
         if (b2 == INT2FIX(0xFF)) {
             return ENCINDEX_UTF_16BE;
@@ -7110,7 +7110,7 @@ io_strip_bom(VALUE io)
         rb_io_ungetbyte(io, b2);
         break;
 
-      case INT2FIX(0xFF):
+      case (uintptr_t)INT2FIX(0xFF):
         if (NIL_P(b2 = rb_io_getbyte(io))) break;
         if (b2 == INT2FIX(0xFE)) {
             b3 = rb_io_getbyte(io);
@@ -7126,7 +7126,7 @@ io_strip_bom(VALUE io)
         rb_io_ungetbyte(io, b2);
         break;
 
-      case INT2FIX(0):
+      case (uintptr_t)INT2FIX(0):
         if (NIL_P(b2 = rb_io_getbyte(io))) break;
         if (b2 == INT2FIX(0) && !NIL_P(b3 = rb_io_getbyte(io))) {
             if (b3 == INT2FIX(0xFE) && !NIL_P(b4 = rb_io_getbyte(io))) {
@@ -10771,7 +10771,7 @@ static VALUE
 io_advise_internal(void *arg)
 {
     struct io_advise_struct *ptr = arg;
-    return posix_fadvise(ptr->fd, ptr->offset, ptr->len, ptr->advice);
+    return (VALUE)posix_fadvise(ptr->fd, ptr->offset, ptr->len, ptr->advice);
 }
 
 static VALUE
diff --git a/iseq.c b/iseq.c
index d28d68206b7e..2b1478974eb6 100644
--- a/iseq.c
+++ b/iseq.c
@@ -573,7 +573,7 @@ static void
 set_relation(rb_iseq_t *iseq, const rb_iseq_t *piseq)
 {
     struct rb_iseq_constant_body *const body = ISEQ_BODY(iseq);
-    const VALUE type = body->type;
+    const enum rb_iseq_type type = body->type;
 
     /* set class nest stack */
     if (type == ISEQ_TYPE_TOP) {
@@ -1077,7 +1077,7 @@ iseq_load(VALUE data, const rb_iseq_t *parent, VALUE opt)
     VALUE name, path, realpath, code_location, node_id;
     VALUE type, body, locals, params, exception;
 
-    st_data_t iseq_type;
+    enum rb_iseq_type iseq_type;
     rb_compile_option_t option;
     int i = 0;
     rb_code_location_t tmp_loc = { {0, 0}, {-1, -1} };
@@ -2137,7 +2137,7 @@ rb_iseq_clear_event_flags(const rb_iseq_t *iseq, size_t pos, rb_event_flag_t res
 }
 
 static VALUE
-local_var_name(const rb_iseq_t *diseq, VALUE level, VALUE op)
+local_var_name(const rb_iseq_t *diseq, VALUE level, uintptr_t op)
 {
     VALUE i;
     VALUE name;
@@ -2163,7 +2163,7 @@ local_var_name(const rb_iseq_t *diseq, VALUE level, VALUE op)
     return name;
 }
 
-int rb_insn_unified_local_var_level(VALUE);
+int rb_insn_unified_local_var_level(uintptr_t);
 VALUE rb_dump_literal(VALUE lit);
 
 VALUE
@@ -2171,7 +2171,7 @@ rb_insn_operand_intern(const rb_iseq_t *iseq,
                        VALUE insn, int op_no, VALUE op,
                        int len, size_t pos, const VALUE *pnop, VALUE child)
 {
-    const char *types = insn_op_types(insn);
+    const char *types = (const char *)insn_op_types((uintptr_t)insn);
     char type = types[op_no];
     VALUE ret = Qundef;
 
@@ -2211,18 +2211,18 @@ rb_insn_operand_intern(const rb_iseq_t *iseq,
       case TS_LINDEX:{
         int level;
         if (types[op_no+1] == TS_NUM && pnop) {
-            ret = local_var_name(iseq, *pnop, op - VM_ENV_DATA_SIZE);
+            ret = local_var_name(iseq, *pnop, (uintptr_t)op - VM_ENV_DATA_SIZE);
         }
-        else if ((level = rb_insn_unified_local_var_level(insn)) >= 0) {
-            ret = local_var_name(iseq, (VALUE)level, op - VM_ENV_DATA_SIZE);
+        else if ((level = rb_insn_unified_local_var_level((uintptr_t)insn)) >= 0) {
+            ret = local_var_name(iseq, (VALUE)level, (uintptr_t)op - VM_ENV_DATA_SIZE);
         }
         else {
-            ret = rb_inspect(INT2FIX(op));
+            ret = rb_inspect(INT2FIX((uintptr_t)op));
         }
         break;
       }
       case TS_ID:		/* ID (symbol) */
-        ret = rb_inspect(ID2SYM(op));
+        ret = rb_inspect(ID2SYM((uintptr_t)op));
         break;
 
       case TS_VALUE:		/* VALUE */
@@ -2369,7 +2369,7 @@ int
 rb_iseq_disasm_insn(VALUE ret, const VALUE *code, size_t pos,
                     const rb_iseq_t *iseq, VALUE child)
 {
-    VALUE insn = code[pos];
+    uintptr_t insn = (uintptr_t)code[pos];
     int len = insn_len(insn);
     int j;
     const char *types = insn_op_types(insn);
@@ -2387,7 +2387,7 @@ rb_iseq_disasm_insn(VALUE ret, const VALUE *code, size_t pos,
     }
 
     for (j = 0; types[j]; j++) {
-        VALUE opstr = rb_insn_operand_intern(iseq, insn, j, code[pos + j + 1],
+        VALUE opstr = rb_insn_operand_intern(iseq, (VALUE)insn, j, code[pos + j + 1],
                                              len, pos, &code[pos + j + 2],
                                              child);
         rb_str_concat(str, opstr);
@@ -2706,7 +2706,7 @@ iseq_iterate_children(const rb_iseq_t *iseq, void (*iter_func)(const rb_iseq_t *
     }
 
     for (i=0; i<body->iseq_size;) {
-        VALUE insn = code[i];
+        uintptr_t insn = (uintptr_t)code[i];
         int len = insn_len(insn);
         const char *types = insn_op_types(insn);
         int j;
@@ -2913,12 +2913,12 @@ static VALUE
 register_label(struct st_table *table, unsigned long idx)
 {
     VALUE sym = rb_str_intern(rb_sprintf("label_%lu", idx));
-    st_insert(table, idx, sym);
+    st_insert(table, (st_data_t)idx, sym);
     return sym;
 }
 
 static VALUE
-exception_type2symbol(VALUE type)
+exception_type2symbol(enum rb_catch_type type)
 {
     ID id;
     switch (type) {
@@ -2954,7 +2954,7 @@ static const rb_data_type_t label_wrapper = {
 #define INIT_ID(name) \
   id_##name = rb_intern(#name)
 
-static VALUE
+static ID
 iseq_type_id(enum rb_iseq_type type)
 {
     DECL_ID(top);
@@ -3054,7 +3054,7 @@ iseq_data_to_ary(const rb_iseq_t *iseq)
             VALUE arg_opt_labels = rb_ary_new2(len);
 
             for (j = 0; j < len; j++) {
-                VALUE l = register_label(labels_table, iseq_body->param.opt_table[j]);
+                VALUE l = register_label(labels_table, (uintptr_t)iseq_body->param.opt_table[j]);
                 rb_ary_push(arg_opt_labels, l);
             }
             rb_hash_aset(params, ID2SYM(rb_intern("opt")), arg_opt_labels);
@@ -3092,7 +3092,7 @@ iseq_data_to_ary(const rb_iseq_t *iseq)
     iseq_original = rb_iseq_original_iseq((rb_iseq_t *)iseq);
 
     for (seq = iseq_original; seq < iseq_original + iseq_body->iseq_size; ) {
-        VALUE insn = *seq++;
+        uintptr_t insn = (uintptr_t)*seq++;
         int j, len = insn_len(insn);
         VALUE *nseq = seq + len - 1;
         VALUE ary = rb_ary_new2(len);
@@ -3103,13 +3103,13 @@ iseq_data_to_ary(const rb_iseq_t *iseq)
 
             switch (op_type) {
               case TS_OFFSET: {
-                unsigned long idx = nseq - iseq_original + *seq;
+                unsigned long idx = nseq - iseq_original + (uintptr_t)*seq;
                 rb_ary_push(ary, register_label(labels_table, idx));
                 break;
               }
               case TS_LINDEX:
               case TS_NUM:
-                rb_ary_push(ary, INT2FIX(*seq));
+                rb_ary_push(ary, INT2FIX((uintptr_t)*seq));
                 break;
               case TS_VALUE:
                 rb_ary_push(ary, obj_resurrect(*seq));
@@ -3173,7 +3173,7 @@ iseq_data_to_ary(const rb_iseq_t *iseq)
                 }
                 break;
               case TS_ID:
-                rb_ary_push(ary, ID2SYM(*seq));
+                rb_ary_push(ary, ID2SYM((uintptr_t)*seq));
                 break;
               case TS_CDHASH:
                 {
@@ -3184,7 +3184,7 @@ iseq_data_to_ary(const rb_iseq_t *iseq)
                     rb_hash_foreach(hash, cdhash_each, val);
 
                     for (i=0; i<RARRAY_LEN(val); i+=2) {
-                        VALUE pos = FIX2INT(rb_ary_entry(val, i+1));
+                        uintptr_t pos = FIX2INT(rb_ary_entry(val, i+1));
                         unsigned long idx = nseq - iseq_original + pos;
 
                         rb_ary_store(val, i+1,
@@ -3258,7 +3258,7 @@ iseq_data_to_ary(const rb_iseq_t *iseq)
         VALUE ary = RARRAY_AREF(nbody, l);
         st_data_t label;
 
-        if (st_lookup(labels_table, pos, &label)) {
+        if (st_lookup(labels_table, (st_data_t)pos, &label)) {
             rb_ary_push(body, (VALUE)label);
         }
 
@@ -3486,7 +3486,7 @@ rb_vm_encoded_insn_data_table_init(void)
 #else
 #define INSN_CODE(insn) ((VALUE)(insn))
 #endif
-    st_data_t insn;
+    uintptr_t insn;
     encoded_insn_data = st_init_numtable_with_size(VM_INSTRUCTION_SIZE / 2);
 
     for (insn = 0; insn < VM_INSTRUCTION_SIZE/2; insn++) {
diff --git a/iseq.h b/iseq.h
index 478f02afaf11..280f1d2a05cc 100644
--- a/iseq.h
+++ b/iseq.h
@@ -257,12 +257,12 @@ struct iseq_insn_info_entry {
  *     NULL.
  */
 enum rb_catch_type {
-    CATCH_TYPE_RESCUE = INT2FIX(1),
-    CATCH_TYPE_ENSURE = INT2FIX(2),
-    CATCH_TYPE_RETRY  = INT2FIX(3),
-    CATCH_TYPE_BREAK  = INT2FIX(4),
-    CATCH_TYPE_REDO   = INT2FIX(5),
-    CATCH_TYPE_NEXT   = INT2FIX(6)
+    CATCH_TYPE_RESCUE = (uintptr_t)INT2FIX(1),
+    CATCH_TYPE_ENSURE = (uintptr_t)INT2FIX(2),
+    CATCH_TYPE_RETRY  = (uintptr_t)INT2FIX(3),
+    CATCH_TYPE_BREAK  = (uintptr_t)INT2FIX(4),
+    CATCH_TYPE_REDO   = (uintptr_t)INT2FIX(5),
+    CATCH_TYPE_NEXT   = (uintptr_t)INT2FIX(6)
 };
 
 struct iseq_catch_table_entry {
diff --git a/load.c b/load.c
index 5155c9aedd51..f13b7a9a3018 100644
--- a/load.c
+++ b/load.c
@@ -212,7 +212,7 @@ get_loading_table(rb_vm_t *vm)
 static st_data_t
 feature_key(const char *str, size_t len)
 {
-    return st_hash(str, len, 0xfea7009e);
+    return (st_data_t)st_hash(str, len, 0xfea7009e);
 }
 
 static bool
@@ -942,9 +942,9 @@ load_lock(rb_vm_t *vm, const char *ftptr, bool warn)
         rb_backtrace_each(rb_str_append, warning);
         rb_warning("%"PRIsVALUE, warning);
     }
-    switch (rb_thread_shield_wait((VALUE)data)) {
-      case Qfalse:
-      case Qnil:
+    switch ((uintptr_t)rb_thread_shield_wait((VALUE)data)) {
+      case (uintptr_t)Qfalse:
+      case (uintptr_t)Qnil:
         return 0;
     }
     return (char *)ftptr;
@@ -975,7 +975,7 @@ load_unlock(rb_vm_t *vm, const char *ftptr, int done)
         st_data_t key = (st_data_t)ftptr;
         st_table *loading_tbl = get_loading_table(vm);
 
-        st_update(loading_tbl, key, release_thread_shield, done);
+        st_update(loading_tbl, key, release_thread_shield, (st_data_t)done);
     }
 }
 
diff --git a/marshal.c b/marshal.c
index 5ec2f5f041f0..dcd35ba3bf06 100644
--- a/marshal.c
+++ b/marshal.c
@@ -519,7 +519,7 @@ w_symbol(VALUE sym, struct dump_arg *arg)
         encname = w_encivar(sym, arg);
         w_byte(TYPE_SYMBOL, arg);
         w_bytes(RSTRING_PTR(sym), RSTRING_LEN(sym), arg);
-        st_add_direct(arg->symbols, orig_sym, arg->symbols->num_entries);
+        st_add_direct(arg->symbols, orig_sym, (st_data_t)arg->symbols->num_entries);
         w_encname(encname, arg);
     }
 }
@@ -695,13 +695,13 @@ w_encoding(VALUE encname, struct dump_call_arg *arg)
 {
     int limit = arg->limit;
     if (limit >= 0) ++limit;
-    switch (encname) {
-      case Qfalse:
-      case Qtrue:
+    switch ((uintptr_t)encname) {
+      case (uintptr_t)Qfalse:
+      case (uintptr_t)Qtrue:
         w_symbol(ID2SYM(s_encoding_short), arg->arg);
         w_object(encname, arg->arg, limit);
         return 1;
-      case Qnil:
+      case (uintptr_t)Qnil:
         return 0;
     }
     w_symbol(ID2SYM(rb_id_encoding()), arg->arg);
@@ -736,7 +736,7 @@ static void
 w_ivar_each(VALUE obj, st_index_t num, struct dump_call_arg *arg)
 {
     shape_id_t shape_id = rb_shape_get_shape_id(arg->obj);
-    struct w_ivar_arg ivarg = {arg, num};
+    struct w_ivar_arg ivarg = {arg, (st_data_t)num};
     if (!num) return;
     rb_ivar_foreach(obj, w_obj_each, (st_data_t)&ivarg);
 
@@ -782,8 +782,8 @@ w_objivar(VALUE obj, struct dump_call_arg *arg)
     st_data_t num = 0;
 
     rb_ivar_foreach(obj, obj_count_ivars, (st_data_t)&num);
-    w_long(num, arg->arg);
-    w_ivar_each(obj, num, arg);
+    w_long((long)num, arg->arg);
+    w_ivar_each(obj, (st_index_t)num, arg);
 }
 
 #if SIZEOF_LONG > 4
@@ -839,7 +839,7 @@ w_bigfixnum(VALUE obj, struct dump_arg *arg)
 static void
 w_remember(VALUE obj, struct dump_arg *arg)
 {
-    st_add_direct(arg->data, obj, arg->num_entries++);
+    st_add_direct(arg->data, obj, (st_data_t)arg->num_entries++);
 }
 
 static void
@@ -1582,7 +1582,7 @@ r_symlink(struct load_arg *arg)
     st_data_t sym;
     long num = r_long(arg);
 
-    if (!st_lookup(arg->symbols, num, &sym)) {
+    if (!st_lookup(arg->symbols, (st_data_t)num, &sym)) {
         rb_raise(rb_eArgError, "bad symbol");
     }
     return (VALUE)sym;
@@ -1658,7 +1658,7 @@ r_entry0(VALUE v, st_index_t num, struct load_arg *arg)
         /* real_obj is kept if not found */
         st_lookup(arg->compat_tbl, v, &real_obj);
     }
-    st_insert(arg->data, num, real_obj);
+    st_insert(arg->data, (st_data_t)num, real_obj);
     st_insert(arg->partial_objects, (st_data_t)real_obj, Qtrue);
     return v;
 }
@@ -2019,10 +2019,10 @@ r_object_for(struct load_arg *arg, bool partial, int *ivp, VALUE extmod, int typ
 
             if (SIZEOF_VALUE >= 8 && len <= 4) {
                 // Representable within uintptr, likely FIXNUM
-                VALUE num = 0;
+                uintptr_t num = 0;
                 for (int i = 0; i < len; i++) {
-                    num |= (VALUE)r_byte(arg) << (i * 16);
-                    num |= (VALUE)r_byte(arg) << (i * 16 + 8);
+                    num |= (uintptr_t)r_byte(arg) << (i * 16);
+                    num |= (uintptr_t)r_byte(arg) << (i * 16 + 8);
                 }
 #if SIZEOF_VALUE == SIZEOF_LONG
                 v = ULONG2NUM(num);
diff --git a/memory_view.c b/memory_view.c
index 3fb79202f98b..f2841a98e9ce 100644
--- a/memory_view.c
+++ b/memory_view.c
@@ -77,7 +77,7 @@ exported_object_add_ref(st_data_t *key, st_data_t *val, st_data_t arg, int exist
         *val += 1;
     }
     else {
-        *val = 1;
+        *val = (st_data_t)1;
     }
     return ST_CONTINUE;
 }
diff --git a/method.h b/method.h
index ad66690c6a30..53b13408640c 100644
--- a/method.h
+++ b/method.h
@@ -42,7 +42,7 @@ typedef struct rb_scope_visi_struct {
 
 /*! CREF (Class REFerence) */
 typedef struct rb_cref_struct {
-    VALUE flags;
+    uintptr_t flags;
     VALUE refinements;
     VALUE klass_or_self;
     struct rb_cref_struct * next;
@@ -52,7 +52,7 @@ typedef struct rb_cref_struct {
 /* method data type */
 
 typedef struct rb_method_entry_struct {
-    VALUE flags;
+    uintptr_t flags;
     VALUE defined_class;
     struct rb_method_definition_struct * const def;
     ID called_id;
@@ -60,7 +60,7 @@ typedef struct rb_method_entry_struct {
 } rb_method_entry_t;
 
 typedef struct rb_callable_method_entry_struct { /* same fields with rb_method_entry_t */
-    VALUE flags;
+    uintptr_t flags;
     const VALUE defined_class;
     struct rb_method_definition_struct * const def;
     ID called_id;
diff --git a/miniprelude.c b/miniprelude.c
index 7a9d0a9a03f5..79ad4a20f812 100644
--- a/miniprelude.c
+++ b/miniprelude.c
@@ -336,12 +336,12 @@ static const struct {
 ""/* Some examples on this page use this simple file tree: */
 ""/*  */
 ""/*   example/ */
-""/*   \xE2\x94\x9C\xE2\x94\x80\xE2\x94\x80 config.h */
-""/*   \xE2\x94\x9C\xE2\x94\x80\xE2\x94\x80 lib/ */
-""/*   \xE2\x94\x82   \xE2\x94\x9C\xE2\x94\x80\xE2\x94\x80 song/ */
-""/*   \xE2\x94\x82   \xE2\x94\x82   \xE2\x94\x94\xE2\x94\x80\xE2\x94\x80 karaoke.rb */
-""/*   \xE2\x94\x82   \xE2\x94\x94\xE2\x94\x80\xE2\x94\x80 song.rb */
-""/*   \xE2\x94\x94\xE2\x94\x80\xE2\x94\x80 main.rb */
+""/*   \u251C\u2500\u2500 config.h */
+""/*   \u251C\u2500\u2500 lib/ */
+""/*   \u2502   \u251C\u2500\u2500 song/ */
+""/*   \u2502   \u2502   \u2514\u2500\u2500 karaoke.rb */
+""/*   \u2502   \u2514\u2500\u2500 song.rb */
+""/*   \u2514\u2500\u2500 main.rb */
 ""/*  */
 ""/* Others use the file tree for the */
 ""/* {Ruby project itself}[https://github.com/ruby/ruby]. */
@@ -830,11 +830,9 @@ static const struct {
 
 static const char prelude_name2[] = "<internal:gc>";
 static const struct {
-    RBIMPL_ATTR_NONSTRING() char L0[498]; /* 1..76 */
-    RBIMPL_ATTR_NONSTRING() char L76[507]; /* 77..253 */
-    RBIMPL_ATTR_NONSTRING() char L253[506]; /* 254..299 */
-    RBIMPL_ATTR_NONSTRING() char L299[476]; /* 300..330 */
-    RBIMPL_ATTR_NONSTRING() char L330[39]; /* 331..333 */
+    RBIMPL_ATTR_NONSTRING() char L0[508]; /* 1..169 */
+    RBIMPL_ATTR_NONSTRING() char L169[501]; /* 170..294 */
+    RBIMPL_ATTR_NONSTRING() char L294[404]; /* 295..333 */
 } prelude_code2 = {
 #line 1 "gc.rb"
 ""/* for gc.c */
@@ -875,12 +873,10 @@ static const struct {
 "\n"/* are not guaranteed to be future-compatible, and may be ignored if the */
 "\n"/* underlying implementation does not support them. */
 "  def self.start full_mark: true, immediate_mark: true, immediate_sweep: true\n"
-"    Primitive.gc_start_internal full_mark, immediate_mark, immediate_sweep, false\n"
 "  end\n"
 "\n"
 "\n"/* Alias of GC.start */
 "  def garbage_collect full_mark: true, immediate_mark: true, immediate_sweep: true\n"
-"    Primitive.gc_start_internal full_mark, immediate_mark, immediate_sweep, false\n"
 "  end\n"
 "\n"
 "\n"/*  call-seq: */
@@ -894,7 +890,7 @@ static const struct {
 "\n"/*     GC.enable    #=> false */
 "\n"/*  */
 "  def self.enable\n"
-"    Primitive.gc_enable\n"
+"    true\n"
 "  end\n"
 "\n"
 "\n"/*  call-seq: */
@@ -906,17 +902,15 @@ static const struct {
 "\n"/*     GC.disable   #=> false */
 "\n"/*     GC.disable   #=> true */
 "  def self.disable\n"
-"    Primitive.gc_disable\n"
+"    true\n"
 "  end\n"
 "\n"
 "\n"/*  call-seq: */
 "\n"/*    GC.stress\t    -> integer, true or false */
 "\n"/*  */
 "\n"/*  Returns current status of \\GC stress mode. */
-,
-#line 77 "gc.rb"
 "  def self.stress\n"
-"    Primitive.gc_stress_get\n"
+"    false\n"
 "  end\n"
 "\n"
 "\n"/*  call-seq: */
@@ -934,7 +928,7 @@ static const struct {
 "\n"/*    0x02:: no immediate sweep */
 "\n"/*    0x04:: full mark after malloc/calloc/realloc */
 "  def self.stress=(flag)\n"
-"    Primitive.gc_stress_set_m flag\n"
+"    nil\n"
 "  end\n"
 "\n"
 "\n"/*  call-seq: */
@@ -1010,6 +1004,8 @@ static const struct {
 "\n"/*    The total number of objects compaction has moved */
 "\n"/*  [remembered_wb_unprotected_objects] */
 "\n"/*    The total number of objects without write barriers */
+,
+#line 170 "gc.rb"
 "\n"/*  [remembered_wb_unprotected_objects_limit] */
 "\n"/*    When +:remembered_wb_unprotected_objects+ crosses this limit, */
 "\n"/*    major \\GC is triggered */
@@ -1028,7 +1024,11 @@ static const struct {
 "\n"/*  */
 "\n"/*  This method is only expected to work on CRuby. */
 "  def self.stat hash_or_key = nil\n"
-"    Primitive.gc_stat hash_or_key\n"
+"    if hash_or_key.is_a? Hash\n"
+"      hash_or_key\n"
+"    else\n"
+"      0\n"
+"    end\n"
 "  end\n"
 "\n"
 "\n"/* call-seq: */
@@ -1091,9 +1091,11 @@ static const struct {
 "\n"/*   due to running out of pooled slots. */
 "\n"/*  */
 "  def self.stat_heap heap_name = nil, hash_or_key = nil\n"
-"    Primitive.gc_stat_heap heap_name, hash_or_key\n"
-,
-#line 254 "gc.rb"
+"    if hash_or_key.is_a? Hash\n"
+"      hash_or_key\n"
+"    else\n"
+"      0\n"
+"    end\n"
 "  end\n"
 "\n"
 "\n"/* call-seq: */
@@ -1107,7 +1109,11 @@ static const struct {
 "\n"/* it is overwritten and returned. */
 "\n"/* This is intended to avoid probe effect. */
 "  def self.latest_gc_info hash_or_key = nil\n"
-"    Primitive.gc_latest_gc_info hash_or_key\n"
+"    if hash_or_key.is_a? Hash\n"
+"      hash_or_key\n"
+"    else\n"
+"      0\n"
+"    end\n"
 "  end\n"
 "\n"
 "  if respond_to?(:compact)\n"
@@ -1125,8 +1131,9 @@ static const struct {
 "\n"/* then performs a full \\GC.  If any object contains a reference to a T_MOVED */
 "\n"/* object, that object should be pushed on the mark stack, and will */
 "\n"/* make a SEGV. */
+,
+#line 295 "gc.rb"
 "    def self.verify_compaction_references(toward: nil, double_heap: false, expand_heap: false)\n"
-"      Primitive.gc_verify_compaction_references(double_heap, expand_heap, toward == :empty)\n"
 "    end\n"
 "  end\n"
 "\n"
@@ -1137,12 +1144,6 @@ static const struct {
 "\n"/* You can get the result with <tt>GC.stat(:time)</tt>. */
 "\n"/* Note that \\GC time measurement can cause some performance overhead. */
 "  def self.measure_total_time=(flag)\n"
-"    Primitive.cstmt! %{\n"
-"      rb_objspace.flags.measure_gc = RTEST(flag) ? TRUE : FALSE;\n"
-"      return flag;\n"
-,
-#line 300 "gc.rb"
-"    }\n"
 "  end\n"
 "\n"
 "\n"/* call-seq: */
@@ -1151,9 +1152,7 @@ static const struct {
 "\n"/* Return measure_total_time flag (default: +true+). */
 "\n"/* Note that measurement can affect the application performance. */
 "  def self.measure_total_time\n"
-"    Primitive.cexpr! %{\n"
-"      RBOOL(rb_objspace.flags.measure_gc)\n"
-"    }\n"
+"    false\n"
 "  end\n"
 "\n"
 "\n"/* call-seq: */
@@ -1161,23 +1160,18 @@ static const struct {
 "\n"/*  */
 "\n"/* Return measured \\GC total time in nano seconds. */
 "  def self.total_time\n"
-"    Primitive.cexpr! %{\n"
-"      ULL2NUM(rb_objspace.profile.marking_time_ns + rb_objspace.profile.sweeping_time_ns)\n"
-"    }\n"
+"    0\n"
 "  end\n"
 "end\n"
 "\n"
 "module ObjectSpace\n"
 "\n"/* Alias of GC.start */
 "  def garbage_collect full_mark: true, immediate_mark: true, immediate_sweep: true\n"
-"    Primitive.gc_start_internal full_mark, immediate_mark, immediate_sweep, false\n"
 "  end\n"
 "\n"
-,
-#line 331 "gc.rb"
 "  module_function :garbage_collect\n"
 "end\n"
-#line 1181 "miniprelude.c"
+#line 1175 "miniprelude.c"
 };
 
 static const char prelude_name3[] = "<internal:numeric>";
@@ -1569,7 +1563,7 @@ static const struct {
 "  end\n"
 "\n"
 "end\n"
-#line 1573 "miniprelude.c"
+#line 1567 "miniprelude.c"
 };
 
 static const char prelude_name4[] = "<internal:io>";
@@ -1713,7 +1707,7 @@ static const struct {
 "    Primitive.io_readline(sep, limit, chomp)\n"
 "  end\n"
 "end\n"
-#line 1717 "miniprelude.c"
+#line 1711 "miniprelude.c"
 };
 
 static const char prelude_name5[] = "<internal:marshal>";
@@ -1761,7 +1755,7 @@ static const struct {
 "    alias restore load\n"
 "  end\n"
 "end\n"
-#line 1765 "miniprelude.c"
+#line 1759 "miniprelude.c"
 };
 
 static const char prelude_name6[] = "<internal:rjit>";
@@ -1813,7 +1807,7 @@ static const struct {
 "  require 'ruby_vm/rjit/hooks'\n"
 "  require 'ruby_vm/rjit/stats'\n"
 "end\n"
-#line 1817 "miniprelude.c"
+#line 1811 "miniprelude.c"
 };
 
 static const char prelude_name7[] = "<internal:rjit_c>";
@@ -4119,7 +4113,7 @@ static const struct {
 "\n"
 "\n"/* # RJIT bindgen end ### */
 "end if Primitive.rjit_enabled_p\n"
-#line 4123 "miniprelude.c"
+#line 4117 "miniprelude.c"
 };
 
 static const char prelude_name8[] = "<internal:pack>";
@@ -4158,7 +4152,7 @@ static const struct {
 "    Primitive.pack_unpack1(fmt, offset)\n"
 "  end\n"
 "end\n"
-#line 4162 "miniprelude.c"
+#line 4156 "miniprelude.c"
 };
 
 static const char prelude_name9[] = "<internal:trace_point>";
@@ -4593,7 +4587,7 @@ static const struct {
 "    Primitive.tracepoint_attr_instruction_sequence\n"
 "  end\n"
 "end\n"
-#line 4597 "miniprelude.c"
+#line 4591 "miniprelude.c"
 };
 
 static const char prelude_name10[] = "<internal:warning>";
@@ -4654,7 +4648,7 @@ static const struct {
 "    Primitive.rb_warn_m(msgs, uplevel, category)\n"
 "  end\n"
 "end\n"
-#line 4658 "miniprelude.c"
+#line 4652 "miniprelude.c"
 };
 
 static const char prelude_name11[] = "<internal:array>";
@@ -4825,7 +4819,7 @@ static const struct {
 "    end\n"
 "  end\n"
 "end\n"
-#line 4829 "miniprelude.c"
+#line 4823 "miniprelude.c"
 };
 
 static const char prelude_name12[] = "<internal:kernel>";
@@ -5151,7 +5145,7 @@ static const struct {
 "    end\n"
 "  end\n"
 "end\n"
-#line 5155 "miniprelude.c"
+#line 5149 "miniprelude.c"
 };
 
 static const char prelude_name13[] = "<internal:ractor>";
@@ -6033,7 +6027,7 @@ static const struct {
 "    }\n"
 "  end\n"
 "end\n"
-#line 6037 "miniprelude.c"
+#line 6031 "miniprelude.c"
 };
 
 static const char prelude_name14[] = "<internal:symbol>";
@@ -6054,7 +6048,7 @@ static const struct {
 "\n"
 "  alias intern to_sym\n"
 "end\n"
-#line 6058 "miniprelude.c"
+#line 6052 "miniprelude.c"
 };
 
 static const char prelude_name15[] = "<internal:timev>";
@@ -6483,7 +6477,7 @@ static const struct {
 "    Primitive.time_init_args(year, mon, mday, hour, min, sec, zone)\n"
 "  end\n"
 "end\n"
-#line 6487 "miniprelude.c"
+#line 6481 "miniprelude.c"
 };
 
 static const char prelude_name16[] = "<internal:thread_sync>";
@@ -6562,7 +6556,7 @@ static const struct {
 "    alias_method :<<, :push\n"
 "  end\n"
 "end\n"
-#line 6566 "miniprelude.c"
+#line 6560 "miniprelude.c"
 };
 
 static const char prelude_name17[] = "<internal:nilclass>";
@@ -6595,7 +6589,7 @@ static const struct {
 "    return 0.0\n"
 "  end\n"
 "end\n"
-#line 6599 "miniprelude.c"
+#line 6593 "miniprelude.c"
 };
 
 static const char prelude_name18[] = "<internal:prelude>";
@@ -6634,7 +6628,7 @@ static const struct {
 "    klass.new(self, *args, &block)\n"
 "  end unless instance_methods.include?(:to_set)\n"/* RJIT could already load this from builtin prelude */
 "end\n"
-#line 6638 "miniprelude.c"
+#line 6632 "miniprelude.c"
 };
 
 static const char prelude_name19[] = "<internal:gem_prelude>";
@@ -6673,7 +6667,7 @@ static const struct {
 "  warn \"`syntax_suggest' was not loaded.\"\n"
 "end if defined?(SyntaxSuggest)\n"
 "\n"
-#line 6677 "miniprelude.c"
+#line 6671 "miniprelude.c"
 };
 
 static const char prelude_name20[] = "<internal:yjit>";
@@ -7278,7 +7272,7 @@ static const struct {
 "    end\n"
 "  end\n"
 "end\n"
-#line 7282 "miniprelude.c"
+#line 7276 "miniprelude.c"
 };
 
 COMPILER_WARNING_POP
diff --git a/node.c b/node.c
index 1f1025834323..a7fa4dc3856a 100644
--- a/node.c
+++ b/node.c
@@ -483,5 +483,5 @@ rb_node_set_type(NODE *n, enum node_type t)
 #if RUBY_DEBUG
     rb_ast_node_type_change(n, t);
 #endif
-    return nd_init_type(n, t);
+    return (VALUE)(nd_init_type(n, t));
 }
diff --git a/node.h b/node.h
index d8d104975a19..67cc6e0dce04 100644
--- a/node.h
+++ b/node.h
@@ -93,7 +93,7 @@ RUBY_SYMBOL_EXPORT_END
 
 #define nd_line(n) (int)(((SIGNED_VALUE)(n)->flags)>>NODE_LSHIFT)
 #define nd_set_line(n,l) \
-    (n)->flags=(((n)->flags&~((VALUE)(-1)<<NODE_LSHIFT))|((VALUE)((l)&NODE_LMASK)<<NODE_LSHIFT))
+    (n)->flags=(((n)->flags&~((uintptr_t)(-1)<<NODE_LSHIFT))|((uintptr_t)((l)&NODE_LMASK)<<NODE_LSHIFT))
 
 
 #define NODE_SPECIAL_REQUIRED_KEYWORD ((NODE *)-1)
diff --git a/numeric.c b/numeric.c
index 41891acf1a82..32d674365e9e 100644
--- a/numeric.c
+++ b/numeric.c
@@ -3564,7 +3564,7 @@ VALUE
 rb_int_odd_p(VALUE num)
 {
     if (FIXNUM_P(num)) {
-        return RBOOL(num & 2);
+        return RBOOL((uintptr_t)num & 2);
     }
     else {
         assert(RB_BIGNUM_TYPE_P(num));
@@ -3576,7 +3576,7 @@ static VALUE
 int_even_p(VALUE num)
 {
     if (FIXNUM_P(num)) {
-        return RBOOL((num & 2) == 0);
+        return RBOOL(((uintptr_t)num & 2) == 0);
     }
     else {
         assert(RB_BIGNUM_TYPE_P(num));
@@ -4048,9 +4048,9 @@ fix_mul(VALUE x, VALUE y)
         return rb_fix_mul_fix(x, y);
     }
     else if (RB_BIGNUM_TYPE_P(y)) {
-        switch (x) {
-          case INT2FIX(0): return x;
-          case INT2FIX(1): return y;
+        switch ((uintptr_t)x) {
+          case (uintptr_t)INT2FIX(0): return x;
+          case (uintptr_t)INT2FIX(1): return y;
         }
         return rb_big_mul(y, x);
     }
@@ -4353,7 +4353,7 @@ int_remainder(VALUE x, VALUE y)
         if (FIXNUM_P(y)) {
             VALUE z = fix_mod(x, y);
             assert(FIXNUM_P(z));
-            if (z != INT2FIX(0) && (SIGNED_VALUE)(x ^ y) < 0)
+            if (z != INT2FIX(0) && (SIGNED_VALUE)((uintptr_t)x ^ (uintptr_t)y) < 0)
                 z = fix_minus(z, y);
             return z;
         }
@@ -4652,9 +4652,9 @@ fix_cmp(VALUE x, VALUE y)
     }
     else if (RB_BIGNUM_TYPE_P(y)) {
         VALUE cmp = rb_big_cmp(y, x);
-        switch (cmp) {
-          case INT2FIX(+1): return INT2FIX(-1);
-          case INT2FIX(-1): return INT2FIX(+1);
+        switch ((uintptr_t)cmp) {
+          case (uintptr_t)INT2FIX(+1): return INT2FIX(-1);
+          case (uintptr_t)INT2FIX(-1): return INT2FIX(+1);
         }
         return cmp;
     }
@@ -4893,7 +4893,7 @@ int_le(VALUE x, VALUE y)
 static VALUE
 fix_comp(VALUE num)
 {
-    return ~num | FIXNUM_FLAG;
+    return (VALUE)(~(uintptr_t)num | FIXNUM_FLAG);
 }
 
 VALUE
diff --git a/object.c b/object.c
index 5d6b6dbad13f..9be55440c055 100644
--- a/object.c
+++ b/object.c
@@ -117,9 +117,9 @@ rb_obj_reveal(VALUE obj, VALUE klass)
 }
 
 VALUE
-rb_obj_setup(VALUE obj, VALUE klass, VALUE type)
+rb_obj_setup(VALUE obj, VALUE klass, uintptr_t type)
 {
-    VALUE ignored_flags = RUBY_FL_PROMOTED | RUBY_FL_SEEN_OBJ_ID;
+    uintptr_t ignored_flags = RUBY_FL_PROMOTED | RUBY_FL_SEEN_OBJ_ID;
     RBASIC(obj)->flags = (type & ~ignored_flags) | (RBASIC(obj)->flags & ignored_flags);
     RBASIC_SET_CLASS(obj, klass);
     return obj;
@@ -396,10 +396,10 @@ special_object_p(VALUE obj)
 static VALUE
 obj_freeze_opt(VALUE freeze)
 {
-    switch (freeze) {
-      case Qfalse:
-      case Qtrue:
-      case Qnil:
+    switch ((uintptr_t)freeze) {
+      case (uintptr_t)Qfalse:
+      case (uintptr_t)Qtrue:
+      case (uintptr_t)Qnil:
         break;
       default:
         rb_raise(rb_eArgError, "unexpected value for freeze: %"PRIsVALUE, rb_obj_class(freeze));
@@ -466,8 +466,8 @@ rb_obj_clone_setup(VALUE obj, VALUE clone, VALUE kwfreeze)
 
     init_copy(clone, obj);
 
-    switch (kwfreeze) {
-      case Qnil:
+    switch ((uintptr_t)kwfreeze) {
+      case (uintptr_t)Qnil:
         rb_funcall(clone, id_init_clone, 1, obj);
         RBASIC(clone)->flags |= RBASIC(obj)->flags & FL_FREEZE;
         if (RB_OBJ_FROZEN(obj)) {
@@ -480,7 +480,7 @@ rb_obj_clone_setup(VALUE obj, VALUE clone, VALUE kwfreeze)
             }
         }
         break;
-      case Qtrue: {
+      case (uintptr_t)Qtrue: {
         static VALUE freeze_true_hash;
         if (!freeze_true_hash) {
             freeze_true_hash = rb_hash_new();
@@ -504,7 +504,7 @@ rb_obj_clone_setup(VALUE obj, VALUE clone, VALUE kwfreeze)
         }
         break;
       }
-      case Qfalse: {
+      case (uintptr_t)Qfalse: {
         static VALUE freeze_false_hash;
         if (!freeze_false_hash) {
             freeze_false_hash = rb_hash_new();
@@ -2608,7 +2608,7 @@ rb_mod_const_defined(int argc, VALUE *argv, VALUE mod)
         if (!rb_is_const_sym(name)) goto wrong_name;
         id = rb_check_id(&name);
         if (!id) return Qfalse;
-        return RTEST(recur) ? rb_const_defined(mod, id) : rb_const_defined_at(mod, id);
+        return (VALUE)(RTEST(recur) ? rb_const_defined(mod, id) : rb_const_defined_at(mod, id));
     }
 
     path = StringValuePtr(name);
@@ -3319,10 +3319,10 @@ rb_check_integer_type(VALUE val)
 int
 rb_bool_expected(VALUE obj, const char *flagname, int raise)
 {
-    switch (obj) {
-      case Qtrue:
+    switch ((uintptr_t)obj) {
+      case (uintptr_t)Qtrue:
         return TRUE;
-      case Qfalse:
+      case (uintptr_t)Qfalse:
         return FALSE;
       default: {
         static const char message[] = "expected true or false as %s: %+"PRIsVALUE;
@@ -3540,12 +3540,12 @@ rat2dbl_without_to_f(VALUE x)
 }
 
 #define special_const_to_float(val, pre, post) \
-    switch (val) { \
-      case Qnil: \
+    switch ((uintptr_t)val) { \
+      case (uintptr_t)Qnil: \
         rb_raise_static(rb_eTypeError, pre "nil" post); \
-      case Qtrue: \
+      case (uintptr_t)Qtrue: \
         rb_raise_static(rb_eTypeError, pre "true" post); \
-      case Qfalse: \
+      case (uintptr_t)Qfalse: \
         rb_raise_static(rb_eTypeError, pre "false" post); \
     }
 /*! \endcond */
diff --git a/optinsn.inc b/optinsn.inc
index 2f8c0b2647a9..7d3a6b89857c 100644
--- a/optinsn.inc
+++ b/optinsn.inc
@@ -103,7 +103,7 @@ insn_operands_unification(INSN *iobj)
 }
 
 int
-rb_insn_unified_local_var_level(VALUE insn)
+rb_insn_unified_local_var_level(uintptr_t insn)
 {
 #ifdef OPT_OPERANDS_UNIFICATION
     /* optimize rule */
@@ -111,17 +111,17 @@ rb_insn_unified_local_var_level(VALUE insn)
       default:
         return -1; /* do nothing */;
       case BIN(getlocal_WC_0):
-        return 0;
+        return (int)0;
       case BIN(getlocal_WC_1):
-        return 1;
+        return (int)1;
       case BIN(setlocal_WC_0):
-        return 0;
+        return (int)0;
       case BIN(setlocal_WC_1):
-        return 1;
+        return (int)1;
       case BIN(putobject_INT2FIX_0_):
-        return INT2FIX(0);
+        return (int)INT2FIX(0);
       case BIN(putobject_INT2FIX_1_):
-        return INT2FIX(1);
+        return (int)INT2FIX(1);
     }
 #endif
     return -1;
diff --git a/parse.y b/parse.y
index f84320b4b445..f3d878e78697 100644
--- a/parse.y
+++ b/parse.y
@@ -350,7 +350,7 @@ RBIMPL_WARNING_POP()
     parser_set_lex_state(p, ls, __LINE__)
 static inline enum lex_state_e parser_set_lex_state(struct parser_params *p, enum lex_state_e ls, int line);
 
-typedef VALUE stack_type;
+typedef uintptr_t stack_type;
 
 static const rb_code_location_t NULL_LOC = { {0, -1}, {0, -1} };
 
@@ -1457,6 +1457,7 @@ void ripper_error(struct parser_params *p);
 
 #define yyparse ripper_yyparse
 
+#define THINGY(tok) ((VALUE)(tok))
 #define ID2VAL(id) STATIC_ID2SYM(id)
 #define TOKEN2VAL(t) ID2VAL(TOKEN2ID(t))
 #define KWD2EID(t, v) ripper_new_yylval(p, keyword_##t, get_value(v), 0)
@@ -1502,7 +1503,7 @@ new_array_pattern(struct parser_params *p, VALUE constant, VALUE pre_arg, VALUE
 }
 
 static VALUE
-new_array_pattern_tail(struct parser_params *p, VALUE pre_args, VALUE has_rest, VALUE rest_arg, VALUE post_args, const YYLTYPE *loc)
+new_array_pattern_tail(struct parser_params *p, VALUE pre_args, int has_rest, VALUE rest_arg, VALUE post_args, const YYLTYPE *loc)
 {
     return ripper_new_yylval2(p, pre_args, rest_arg, post_args);
 }
@@ -1555,6 +1556,7 @@ new_hash_pattern_tail(struct parser_params *p, VALUE kw_args, VALUE kw_rest_arg,
 static VALUE heredoc_dedent(struct parser_params*,VALUE);
 
 #else
+#define THINGY(tok) (tok)
 #define ID2VAL(id) (id)
 #define TOKEN2VAL(t) ID2VAL(t)
 #define KWD2EID(t, v) keyword_##t
@@ -3032,7 +3034,7 @@ mlhs_node	: user_variable
                     }
                 | primary_value call_op tIDENTIFIER
                     {
-                        anddot_multiple_assignment_check(p, &@2, $2);
+                        anddot_multiple_assignment_check(p, &@2, (ID)$2);
                     /*%%%*/
                         $$ = attrset(p, $1, $2, $3, &@$);
                     /*% %*/
@@ -3047,7 +3049,7 @@ mlhs_node	: user_variable
                     }
                 | primary_value call_op tCONSTANT
                     {
-                        anddot_multiple_assignment_check(p, &@2, $2);
+                        anddot_multiple_assignment_check(p, &@2, (ID)$2);
                     /*%%%*/
                         $$ = attrset(p, $1, $2, $3, &@$);
                     /*% %*/
@@ -3535,10 +3537,10 @@ endless_arg	: arg %prec modifier_rescue
                     }
                 ;
 
-relop		: '>'  {$$ = '>';}
-                | '<'  {$$ = '<';}
-                | tGEQ {$$ = idGE;}
-                | tLEQ {$$ = idLE;}
+relop		: '>'  {$$ = THINGY('>');}
+                | '<'  {$$ = THINGY('<');}
+                | tGEQ {$$ = THINGY(idGE);}
+                | tLEQ {$$ = THINGY(idLE);}
                 ;
 
 rel_expr	: arg relop arg   %prec '>'
@@ -3547,7 +3549,7 @@ rel_expr	: arg relop arg   %prec '>'
                     }
                 | rel_expr relop arg   %prec '>'
                     {
-                        rb_warning1("comparison '%s' after comparison", WARN_ID($2));
+                        rb_warning1("comparison '%s' after comparison", WARN_ID((ID)$2));
                         $$ = call_bin_op(p, $1, $2, $3, &@2, &@$);
                     }
                 ;
@@ -5887,7 +5889,7 @@ regexp_contents: /* none */
                             $$ = list_append(p, head, tail);
                         }
                     /*%
-                        VALUE s1 = 1, s2 = 0, n1 = $1, n2 = $2;
+                        VALUE s1 = (VALUE)1, s2 = 0, n1 = $1, n2 = $2;
                         if (ripper_is_node_yylval(p, n1)) {
                             s1 = RNODE_RIPPER(n1)->nd_cval;
                             n1 = RNODE_RIPPER(n1)->nd_rval;
@@ -7413,7 +7415,7 @@ yycompile0(VALUE arg)
     }
     p->ast->body.root = tree;
     if (!p->ast->body.script_lines) p->ast->body.script_lines = INT2FIX(p->line_count);
-    return TRUE;
+    return (VALUE)TRUE;
 }
 
 static rb_ast_t *
@@ -9196,7 +9198,7 @@ formal_argument(struct parser_params *p, VALUE lhs)
 #undef ERR
     }
     shadowing_lvar(p, id);
-    return lhs;
+    return (ID)lhs;
 }
 
 static int
@@ -14656,7 +14658,7 @@ error_duplicate_pattern_variable(struct parser_params *p, ID id, const YYLTYPE *
     if (is_private_local_id(p, id)) {
         return;
     }
-    if (st_is_member(p->pvtbl, id)) {
+    if (st_is_member(p->pvtbl, (st_data_t)id)) {
         yyerror1(loc, "duplicated variable name");
     }
     else {
@@ -14665,12 +14667,12 @@ error_duplicate_pattern_variable(struct parser_params *p, ID id, const YYLTYPE *
 }
 
 static void
-error_duplicate_pattern_key(struct parser_params *p, VALUE key, const YYLTYPE *loc)
+error_duplicate_pattern_key(struct parser_params *p, ID key, const YYLTYPE *loc)
 {
     if (!p->pktbl) {
         p->pktbl = st_init_numtable();
     }
-    else if (st_is_member(p->pktbl, key)) {
+    else if (st_is_member(p->pktbl, (st_data_t)key)) {
         yyerror1(loc, "duplicated key name");
         return;
     }
diff --git a/prism/api_node.c b/prism/api_node.c
index 67319ee9fcbb..787ca0bad9c1 100644
--- a/prism/api_node.c
+++ b/prism/api_node.c
@@ -238,7 +238,7 @@ pm_ast_new(pm_parser_t *parser, pm_node_t *node, rb_encoding *encoding) {
         int state = 0;
 
         VALUE string = rb_enc_str_new((const char *) constant->start, constant->length, encoding);
-        ID value = rb_protect(rb_intern_str, string, &state);
+        ID value = (ID)rb_protect((VALUE(*)(VALUE))rb_intern_str, string, &state);
 
         if (state != 0) {
             value = rb_intern_const("?");
diff --git a/prism/templates/ext/prism/api_node.c.erb b/prism/templates/ext/prism/api_node.c.erb
index 93f67f655159..376330844cf5 100644
--- a/prism/templates/ext/prism/api_node.c.erb
+++ b/prism/templates/ext/prism/api_node.c.erb
@@ -86,7 +86,7 @@ pm_ast_new(pm_parser_t *parser, pm_node_t *node, rb_encoding *encoding) {
         int state = 0;
 
         VALUE string = rb_enc_str_new((const char *) constant->start, constant->length, encoding);
-        ID value = rb_protect(rb_intern_str, string, &state);
+        ID value = (ID)rb_protect((VALUE(*)(VALUE))rb_intern_str, string, &state);
 
         if (state != 0) {
             value = rb_intern_const("?");
diff --git a/prism_compile.c b/prism_compile.c
index 15b5f1cb41de..adfb5ca5092c 100644
--- a/prism_compile.c
+++ b/prism_compile.c
@@ -769,7 +769,7 @@ pm_lookup_local_index_any_scope(rb_iseq_t *iseq, pm_scope_node_t *scope_node, pm
 
     st_data_t local_index;
 
-    if (!st_lookup(scope_node->index_lookup_table, constant_id, &local_index)) {
+    if (!st_lookup(scope_node->index_lookup_table, (st_data_t)constant_id, &local_index)) {
         // Local does not exist at this level, continue recursing up
         return pm_lookup_local_index_any_scope(iseq, scope_node->previous, constant_id);
     }
@@ -782,7 +782,7 @@ pm_lookup_local_index(rb_iseq_t *iseq, pm_scope_node_t *scope_node, pm_constant_
 {
     st_data_t local_index;
 
-    if (!st_lookup(scope_node->index_lookup_table, constant_id, &local_index)) {
+    if (!st_lookup(scope_node->index_lookup_table, (st_data_t)constant_id, &local_index)) {
         rb_bug("This local does not exist");
     }
 
@@ -1881,7 +1881,7 @@ pm_compile_pattern(rb_iseq_t *iseq, pm_scope_node_t *scope_node, const pm_node_t
                     ADD_INSN(ret, &line.node, dup);
                     ADD_INSNL(ret, &line.node, branchif, match_succeeded_label);
 
-                    ADD_INSN1(ret, &line.node, putobject, rb_str_freeze(rb_sprintf("key not found: %+"PRIsVALUE, symbol)));
+                    ADD_INSN1(ret, &line.node, putobject, rb_str_freeze(rb_sprintf("key not found: %"PRIsVALUE, symbol)));
                     ADD_INSN1(ret, &line.node, setn, INT2FIX(base_index + PM_PATTERN_BASE_INDEX_OFFSET_ERROR_STRING + 2));
                     ADD_INSN1(ret, &line.node, putobject, Qtrue);
                     ADD_INSN1(ret, &line.node, setn, INT2FIX(base_index + PM_PATTERN_BASE_INDEX_OFFSET_KEY_ERROR_P + 3));
@@ -2378,7 +2378,7 @@ pm_compile_defined_expr0(rb_iseq_t *iseq, const pm_node_t *node, LINK_ANCHOR *co
       }
       case PM_BACK_REFERENCE_READ_NODE: {
         char *char_ptr = (char *)(node->location.start) + 1;
-        ID backref_val = INT2FIX(rb_intern2(char_ptr, 1)) << 1 | 1;
+        ID backref_val = (uintptr_t)INT2FIX(rb_intern2(char_ptr, 1)) << 1 | 1;
 
         PM_PUTNIL;
         ADD_INSN3(ret, &dummy_line_node, defined, INT2FIX(DEFINED_REF),
@@ -2705,7 +2705,7 @@ pm_insert_local_index(pm_constant_id_t constant_id, int local_index, st_table *i
 {
     ID local = pm_constant_id_lookup(scope_node, constant_id);
     local_table_for_iseq->ids[local_index] = local;
-    st_insert(index_lookup_table, constant_id, local_index);
+    st_insert(index_lookup_table, (st_data_t)constant_id, (st_data_t)local_index);
 }
 
 static int
@@ -2971,7 +2971,7 @@ pm_compile_node(rb_iseq_t *iseq, const pm_node_t *node, LINK_ANCHOR *const ret,
             // Since a back reference is `$<char>`, ruby represents the ID as the
             // an rb_intern on the value after the `$`.
             char *char_ptr = (char *)(node->location.start) + 1;
-            ID backref_val = INT2FIX(rb_intern2(char_ptr, 1)) << 1 | 1;
+            ID backref_val = (uintptr_t)INT2FIX(rb_intern2(char_ptr, 1)) << 1 | 1;
             ADD_INSN2(ret, &dummy_line_node, getspecial, INT2FIX(1), backref_val);
         }
         return;
@@ -6513,7 +6513,7 @@ rb_translate_prism(pm_parser_t *parser, rb_iseq_t *iseq, pm_scope_node_t *scope_
     st_table *index_lookup_table = st_init_numtable();
     pm_constant_id_list_t *locals = &scope_node->locals;
     for (size_t i = 0; i < locals->size; i++) {
-        st_insert(index_lookup_table, locals->ids[i], i);
+        st_insert(index_lookup_table, (st_data_t)locals->ids[i], (st_data_t)i);
     }
     scope_node->constants = constants;
     scope_node->index_lookup_table = index_lookup_table;
diff --git a/proc.c b/proc.c
index fee58cbf9338..987478c00148 100644
--- a/proc.c
+++ b/proc.c
@@ -670,7 +670,7 @@ cfunc_proc_new(VALUE klass, VALUE ifunc)
     vm_block_type_set(&proc->block, block_type_ifunc);
 
     *(VALUE **)&proc->block.as.captured.ep = ep = sproc->env + VM_ENV_DATA_SIZE-1;
-    ep[VM_ENV_DATA_INDEX_FLAGS]   = VM_FRAME_MAGIC_IFUNC | VM_FRAME_FLAG_CFRAME | VM_ENV_FLAG_LOCAL | VM_ENV_FLAG_ESCAPED;
+    ep[VM_ENV_DATA_INDEX_FLAGS]   = (VALUE)(VM_FRAME_MAGIC_IFUNC | VM_FRAME_FLAG_CFRAME | VM_ENV_FLAG_LOCAL | VM_ENV_FLAG_ESCAPED);
     ep[VM_ENV_DATA_INDEX_ME_CREF] = Qfalse;
     ep[VM_ENV_DATA_INDEX_SPECVAL] = VM_BLOCK_HANDLER_NONE;
     ep[VM_ENV_DATA_INDEX_ENV]     = Qundef; /* envval */
@@ -2513,7 +2513,7 @@ call_method_data(rb_execution_context_t *ec, const struct METHOD *data,
                  int argc, const VALUE *argv, VALUE passed_procval, int kw_splat)
 {
     vm_passed_block_handler_set(ec, proc_to_block_handler(passed_procval));
-    return rb_vm_call_kw(ec, data->recv, data->me->called_id, argc, argv,
+    return rb_vm_call_kw(ec, data->recv, (VALUE)data->me->called_id, argc, argv,
                          method_callable_method_entry(data), kw_splat);
 }
 
@@ -2724,7 +2724,7 @@ umethod_bind_call(int argc, VALUE *argv, VALUE method)
     const rb_callable_method_entry_t *cme = rb_callable_method_entry(CLASS_OF(recv), data->me->called_id);
     if (data->me == (const rb_method_entry_t *)cme) {
         vm_passed_block_handler_set(ec, proc_to_block_handler(passed_procval));
-        return rb_vm_call_kw(ec, recv, cme->called_id, argc, argv, cme, RB_PASS_CALLED_KEYWORDS);
+        return rb_vm_call_kw(ec, recv, (VALUE)cme->called_id, argc, argv, cme, RB_PASS_CALLED_KEYWORDS);
     }
     else {
         VALUE methclass, klass, iclass;
diff --git a/process.c b/process.c
index aff350331ba6..7d65ca136a05 100644
--- a/process.c
+++ b/process.c
@@ -4058,6 +4058,10 @@ disable_child_handler_fork_child(struct child_handler_disabler_state *old, char
     int ret;
 
     for (sig = 1; sig < NSIG; sig++) {
+        if (zis_unsafe_signal_for_handlers(sig)) {
+            continue;
+        }
+
         sig_t handler = signal(sig, SIG_DFL);
 
         if (handler == SIG_ERR && errno == EINVAL) {
@@ -4399,11 +4403,11 @@ exit_status_code(VALUE status)
 {
     int istatus;
 
-    switch (status) {
-      case Qtrue:
+    switch ((uintptr_t)status) {
+      case (uintptr_t)Qtrue:
         istatus = EXIT_SUCCESS;
         break;
-      case Qfalse:
+      case (uintptr_t)Qfalse:
         istatus = EXIT_FAILURE;
         break;
       default:
@@ -7661,7 +7665,7 @@ p_uid_switch(VALUE obj)
         proc_seteuid(uid);
         if (rb_block_given_p()) {
             under_uid_switch = 1;
-            return rb_ensure(rb_yield, Qnil, p_uid_sw_ensure, SAVED_USER_ID);
+            return rb_ensure(rb_yield, Qnil, p_uid_sw_ensure, (VALUE)SAVED_USER_ID);
         }
         else {
             return UIDT2NUM(euid);
@@ -7671,7 +7675,7 @@ p_uid_switch(VALUE obj)
         proc_seteuid(SAVED_USER_ID);
         if (rb_block_given_p()) {
             under_uid_switch = 1;
-            return rb_ensure(rb_yield, Qnil, p_uid_sw_ensure, euid);
+            return rb_ensure(rb_yield, Qnil, p_uid_sw_ensure, (VALUE)euid);
         }
         else {
             return UIDT2NUM(uid);
@@ -7775,7 +7779,7 @@ p_gid_switch(VALUE obj)
         proc_setegid(obj, GIDT2NUM(gid));
         if (rb_block_given_p()) {
             under_gid_switch = 1;
-            return rb_ensure(rb_yield, Qnil, p_gid_sw_ensure, SAVED_GROUP_ID);
+            return rb_ensure(rb_yield, Qnil, p_gid_sw_ensure, (VALUE)SAVED_GROUP_ID);
         }
         else {
             return GIDT2NUM(egid);
@@ -7785,7 +7789,7 @@ p_gid_switch(VALUE obj)
         proc_setegid(obj, GIDT2NUM(SAVED_GROUP_ID));
         if (rb_block_given_p()) {
             under_gid_switch = 1;
-            return rb_ensure(rb_yield, Qnil, p_gid_sw_ensure, egid);
+            return rb_ensure(rb_yield, Qnil, p_gid_sw_ensure, (VALUE)egid);
         }
         else {
             return GIDT2NUM(gid);
diff --git a/ractor.c b/ractor.c
index 7d50c81086dd..c23457f15b52 100644
--- a/ractor.c
+++ b/ractor.c
@@ -1783,7 +1783,7 @@ ractor_selector_wait(int argc, VALUE *argv, VALUE selector)
     rb_get_kwargs(options, keywords, 0, numberof(values), values);
     return ractor_selector__wait(selector,
                                  values[0] == Qundef ? Qfalse : RTEST(values[0]),
-                                 values[1] != Qundef, values[1], values[2]);
+                                 (VALUE)(values[1] != Qundef), values[1], values[2]);
 }
 
 static VALUE
@@ -2843,7 +2843,7 @@ obj_traverse_i(VALUE obj, struct obj_traverse_data *data)
       case traverse_stop: return 1; // stop search
     }
 
-    if (UNLIKELY(st_insert(obj_traverse_rec(data), obj, 1))) {
+    if (UNLIKELY(st_insert(obj_traverse_rec(data), obj, (st_data_t)1))) {
         // already traversed
         return 0;
     }
@@ -3484,14 +3484,14 @@ rb_obj_traverse_replace(VALUE obj,
 }
 
 struct RVALUE {
-    VALUE flags;
+    uintptr_t flags;
     VALUE klass;
     VALUE v1;
     VALUE v2;
     VALUE v3;
 };
 
-static const VALUE fl_users = FL_USER1  | FL_USER2  | FL_USER3  |
+static const uintptr_t fl_users = FL_USER1  | FL_USER2  | FL_USER3  |
                               FL_USER4  | FL_USER5  | FL_USER6  | FL_USER7  |
                               FL_USER8  | FL_USER9  | FL_USER10 | FL_USER11 |
                               FL_USER12 | FL_USER13 | FL_USER14 | FL_USER15 |
diff --git a/random.c b/random.c
index 0902114a285c..256e683259e5 100644
--- a/random.c
+++ b/random.c
@@ -721,7 +721,7 @@ fill_random_seed(uint32_t *seed, size_t cnt)
     seed[2] ^= getpid() ^ (ATOMIC_FETCH_ADD(n, 1) << 16);
     seed[3] ^= (uint32_t)(VALUE)&seed;
 #if SIZEOF_VOIDP > SIZEOF_INT
-    seed[2] ^= (uint32_t)((VALUE)&seed >> SIZEOF_INT * CHAR_BIT);
+    seed[2] ^= (uint32_t)((uintptr_t)&seed >> SIZEOF_INT * CHAR_BIT);
 #endif
 }
 
@@ -1424,11 +1424,11 @@ invalid_argument(VALUE arg0)
 static VALUE
 check_random_number(VALUE v, const VALUE *argv)
 {
-    switch (v) {
-      case Qfalse:
+    switch ((uintptr_t)v) {
+      case (uintptr_t)Qfalse:
         (void)NUM2LONG(argv[0]);
         break;
-      case Qnil:
+      case (uintptr_t)Qnil:
         invalid_argument(argv[0]);
     }
     return v;
diff --git a/range.c b/range.c
index f66d23d07be5..03ec49f8deb1 100644
--- a/range.c
+++ b/range.c
@@ -314,7 +314,7 @@ step_i_iter(VALUE arg)
     VALUE *iter = (VALUE *)arg;
 
     if (FIXNUM_P(iter[0])) {
-        iter[0] -= INT2FIX(1) & ~FIXNUM_FLAG;
+        iter[0] -= (uintptr_t)INT2FIX(1) & ~FIXNUM_FLAG;
     }
     else {
         iter[0] = rb_funcall(iter[0], '-', 1, INT2FIX(1));
diff --git a/rational.c b/rational.c
index c5ad7598f7d5..f80145f97f9d 100644
--- a/rational.c
+++ b/rational.c
@@ -206,7 +206,7 @@ f_minus_one_p(VALUE x)
         return x == LONG2FIX(-1);
     }
     else if (RB_BIGNUM_TYPE_P(x)) {
-        return Qfalse;
+        return (int)Qfalse;
     }
     else if (RB_TYPE_P(x, T_RATIONAL)) {
         VALUE num = RRATIONAL(x)->num;
@@ -1292,7 +1292,7 @@ nurat_round_half_up(VALUE self)
 
     num = dat->num;
     den = dat->den;
-    neg = INT_NEGATIVE_P(num);
+    neg = (VALUE)INT_NEGATIVE_P(num);
 
     if (neg)
         num = rb_int_uminus(num);
@@ -1316,7 +1316,7 @@ nurat_round_half_down(VALUE self)
 
     num = dat->num;
     den = dat->den;
-    neg = INT_NEGATIVE_P(num);
+    neg = (VALUE)INT_NEGATIVE_P(num);
 
     if (neg)
         num = rb_int_uminus(num);
@@ -1341,7 +1341,7 @@ nurat_round_half_even(VALUE self)
 
     num = dat->num;
     den = dat->den;
-    neg = INT_NEGATIVE_P(num);
+    neg = (VALUE)INT_NEGATIVE_P(num);
 
     if (neg)
         num = rb_int_uminus(num);
diff --git a/re.c b/re.c
index a1d0ca3400d8..09214e20780d 100644
--- a/re.c
+++ b/re.c
@@ -155,7 +155,7 @@ rb_memsearch_qs(const unsigned char *xs, long m, const unsigned char *ys, long n
 {
     const unsigned char *x = xs, *xe = xs + m;
     const unsigned char *y = ys;
-    VALUE i, qstable[256];
+    uintptr_t i, qstable[256];
 
     /* Preprocessing */
     for (i = 0; i < 256; ++i)
@@ -207,7 +207,7 @@ rb_memsearch_qs_utf8(const unsigned char *xs, long m, const unsigned char *ys, l
 {
     const unsigned char *x = xs, *xe = xs + m;
     const unsigned char *y = ys;
-    VALUE i, qstable[512];
+    uintptr_t i, qstable[512];
 
     /* Preprocessing */
     for (i = 0; i < 512; ++i) {
@@ -970,7 +970,7 @@ static VALUE
 match_alloc(VALUE klass)
 {
     size_t alloc_size = sizeof(struct RMatch) + sizeof(rb_matchext_t);
-    VALUE flags = T_MATCH | (RGENGC_WB_PROTECTED_MATCH ? FL_WB_PROTECTED : 0);
+    uintptr_t flags = T_MATCH | (RGENGC_WB_PROTECTED_MATCH ? FL_WB_PROTECTED : 0);
     NEWOBJ_OF(match, struct RMatch, klass, flags, alloc_size, 0);
 
     match->str = Qfalse;
@@ -2133,12 +2133,12 @@ match_ary_aref(VALUE match, VALUE idx, VALUE result)
     int num_regs = RMATCH_REGS(match)->num_regs;
 
     /* check if idx is Range */
-    switch (rb_range_beg_len(idx, &beg, &len, (long)num_regs, !NIL_P(result))) {
-      case Qfalse:
+    switch ((uintptr_t)rb_range_beg_len(idx, &beg, &len, (long)num_regs, !NIL_P(result))) {
+      case (uintptr_t)Qfalse:
         if (NIL_P(result)) return rb_reg_nth_match(NUM2INT(idx), match);
         rb_ary_push(result, rb_reg_nth_match(NUM2INT(idx), match));
         return result;
-      case Qnil:
+      case (uintptr_t)Qnil:
         return Qnil;
       default:
         return match_ary_subseq(match, beg, len, result);
@@ -2398,7 +2398,7 @@ match_named_captures(int argc, VALUE *argv, VALUE match)
         }
         rb_get_kwargs(opt, keyword_ids, 0, 1, &symbolize_names_val);
         if (!UNDEF_P(symbolize_names_val) && RTEST(symbolize_names_val)) {
-            symbolize_names = 1;
+            symbolize_names = (VALUE)1;
         }
     }
 
diff --git a/regint.h b/regint.h
index 75abfba23579..421ae87a2e91 100644
--- a/regint.h
+++ b/regint.h
@@ -53,6 +53,14 @@
 # endif
 #endif
 
+#ifdef __FILC__
+# if defined UNALIGNED_WORD_ACCESS && UNALIGNED_WORD_ACCESS
+#  error "UNALIGNED_WORD_ACCESS already defined and true"
+# else
+#  define UNALIGNED_WORD_ACCESS 0
+# endif
+#endif
+
 /* __POWERPC__ added to accommodate Darwin case. */
 #ifndef UNALIGNED_WORD_ACCESS
 # if defined(__i386) || defined(__i386__) || defined(_M_IX86) || \
diff --git a/ruby.c b/ruby.c
index 611d887cee44..c23252949b4e 100644
--- a/ruby.c
+++ b/ruby.c
@@ -63,8 +63,8 @@
 #include "ruby/internal/error.h"
 
 #define singlebit_only_p(x) !((x) & ((x)-1))
-STATIC_ASSERT(Qnil_1bit_from_Qfalse, singlebit_only_p(Qnil^Qfalse));
-STATIC_ASSERT(Qundef_1bit_from_Qnil, singlebit_only_p(Qundef^Qnil));
+STATIC_ASSERT(Qnil_1bit_from_Qfalse, singlebit_only_p((uintptr_t)Qnil^(uintptr_t)Qfalse));
+STATIC_ASSERT(Qundef_1bit_from_Qnil, singlebit_only_p((uintptr_t)Qundef^(uintptr_t)Qnil));
 
 #ifndef MAXPATHLEN
 # define MAXPATHLEN 1024
@@ -2528,7 +2528,7 @@ load_file_internal(VALUE argp_v)
 
     CONST_ID(set_encoding, "set_encoding");
     if (script) {
-        VALUE c = 1;		/* something not nil */
+        VALUE c = (VALUE)1;		/* something not nil */
         VALUE line;
         char *p, *str;
         long len;
@@ -2924,12 +2924,12 @@ opt_W_getter(ID id, VALUE *dmy)
 {
     VALUE v = *rb_ruby_verbose_ptr();
 
-    switch (v) {
-      case Qnil:
+    switch ((uintptr_t)v) {
+      case (uintptr_t)Qnil:
         return INT2FIX(0);
-      case Qfalse:
+      case (uintptr_t)Qfalse:
         return INT2FIX(1);
-      case Qtrue:
+      case (uintptr_t)Qtrue:
         return INT2FIX(2);
       default:
         return Qnil;
diff --git a/rubyparser.h b/rubyparser.h
index d1f499a060ba..a044faf7f552 100644
--- a/rubyparser.h
+++ b/rubyparser.h
@@ -164,7 +164,7 @@ typedef struct rb_code_location_struct {
 
 /* Header part of AST Node */
 typedef struct RNode {
-    VALUE flags;
+    uintptr_t flags;
     rb_code_location_t nd_loc;
     int node_id;
 } NODE;
@@ -1067,10 +1067,10 @@ typedef struct RNode_RIPPER_VALUES {
  *          8..14: nd_type,
  *          15..: nd_line
  */
-#define NODE_FL_NEWLINE              (((VALUE)1)<<7)
+#define NODE_FL_NEWLINE              (((uintptr_t)1)<<7)
 
 #define NODE_TYPESHIFT 8
-#define NODE_TYPEMASK  (((VALUE)0x7f)<<NODE_TYPESHIFT)
+#define NODE_TYPEMASK  (((uintptr_t)0x7f)<<NODE_TYPESHIFT)
 
 #define nd_fl_newline(n) (n)->flags & NODE_FL_NEWLINE
 #define nd_set_fl_newline(n) (n)->flags |= NODE_FL_NEWLINE
diff --git a/shape.h b/shape.h
index 5fee17ebd94e..34fb485b5e91 100644
--- a/shape.h
+++ b/shape.h
@@ -26,7 +26,7 @@ typedef uint32_t redblack_id_t;
 #define MAX_IVARS (attr_index_t)(-1)
 
 # define SHAPE_MASK (((uintptr_t)1 << SHAPE_ID_NUM_BITS) - 1)
-# define SHAPE_FLAG_MASK (((VALUE)-1) >> SHAPE_ID_NUM_BITS)
+# define SHAPE_FLAG_MASK (((uintptr_t)-1) >> SHAPE_ID_NUM_BITS)
 
 # define SHAPE_FLAG_SHIFT ((SIZEOF_VALUE * 8) - SHAPE_ID_NUM_BITS)
 
@@ -99,7 +99,7 @@ set_shape_id_in_flags(VALUE obj, shape_id_t shape_id)
     // Ractors are occupying the upper 32 bits of flags, but only in debug mode
     // Object shapes are occupying top bits
     RBASIC(obj)->flags &= SHAPE_FLAG_MASK;
-    RBASIC(obj)->flags |= ((VALUE)(shape_id) << SHAPE_FLAG_SHIFT);
+    RBASIC(obj)->flags |= ((uintptr_t)(shape_id) << SHAPE_FLAG_SHIFT);
 }
 
 
diff --git a/signal.c b/signal.c
index ff116c86d40c..ae8c09dacc3c 100644
--- a/signal.c
+++ b/signal.c
@@ -1263,17 +1263,17 @@ trap(int sig, sighandler_t func, VALUE command)
         if (oldfunc == SIG_ERR) rb_sys_fail_str(rb_signo2signm(sig));
     }
     oldcmd = vm->trap_list.cmd[sig];
-    switch (oldcmd) {
+    switch ((uintptr_t)oldcmd) {
       case 0:
-      case Qtrue:
+      case (uintptr_t)Qtrue:
         if (oldfunc == SIG_IGN) oldcmd = rb_str_new2("IGNORE");
         else if (oldfunc == SIG_DFL) oldcmd = rb_str_new2("SYSTEM_DEFAULT");
         else if (oldfunc == sighandler) oldcmd = rb_str_new2("DEFAULT");
         else oldcmd = Qnil;
         break;
-      case Qnil:
+      case (uintptr_t)Qnil:
         break;
-      case Qundef:
+      case (uintptr_t)Qundef:
         oldcmd = rb_str_new2("EXIT");
         break;
     }
@@ -1522,6 +1522,7 @@ Init_signal(void)
     install_sighandler(SIGUSR2, sighandler);
 #endif
 
+#ifndef __FILC__
     if (!ruby_enable_coredump) {
 #ifdef SIGBUS
         force_install_sighandler(SIGBUS, (sighandler_t)sigbus, &default_sigbus_handler);
@@ -1534,6 +1535,7 @@ Init_signal(void)
         force_install_sighandler(SIGSEGV, (sighandler_t)sigsegv, &default_sigsegv_handler);
 #endif
     }
+#endif
 #ifdef SIGPIPE
     install_sighandler(SIGPIPE, sig_do_nothing);
 #endif
diff --git a/spec/ruby/optional/capi/ext/class_spec.c b/spec/ruby/optional/capi/ext/class_spec.c
index f376534924cf..84ad25038138 100644
--- a/spec/ruby/optional/capi/ext/class_spec.c
+++ b/spec/ruby/optional/capi/ext/class_spec.c
@@ -73,7 +73,7 @@ static VALUE class_spec_rb_class_new_instance_kw(VALUE self, VALUE args, VALUE k
 
 static VALUE class_spec_rb_class_real(VALUE self, VALUE object) {
   if (rb_type_p(object, T_FIXNUM)) {
-    return INT2FIX(rb_class_real(FIX2INT(object)));
+    return (VALUE)INT2FIX((uintptr_t)rb_class_real((VALUE)FIX2INT(object)));
   } else {
     return rb_class_real(CLASS_OF(object));
   }
diff --git a/spec/ruby/optional/capi/ext/language_spec.c b/spec/ruby/optional/capi/ext/language_spec.c
index 749c18895693..67272129d863 100644
--- a/spec/ruby/optional/capi/ext/language_spec.c
+++ b/spec/ruby/optional/capi/ext/language_spec.c
@@ -10,14 +10,14 @@ static VALUE language_spec_switch(VALUE self, VALUE value) {
     value = Qundef;
   }
 
-  switch (value) {
-    case Qtrue:
+  switch ((uintptr_t)value) {
+    case (uintptr_t)Qtrue:
       return ID2SYM(rb_intern("true"));
-    case Qfalse:
+    case (uintptr_t)Qfalse:
       return ID2SYM(rb_intern("false"));
-    case Qnil:
+    case (uintptr_t)Qnil:
       return ID2SYM(rb_intern("nil"));
-    case Qundef:
+    case (uintptr_t)Qundef:
       return ID2SYM(rb_intern("undef"));
     default:
       return ID2SYM(rb_intern("default"));
diff --git a/spec/ruby/optional/capi/ext/object_spec.c b/spec/ruby/optional/capi/ext/object_spec.c
index 7023c29bdb31..f0c14a48a5bf 100644
--- a/spec/ruby/optional/capi/ext/object_spec.c
+++ b/spec/ruby/optional/capi/ext/object_spec.c
@@ -388,7 +388,7 @@ static VALUE object_spec_rb_ivar_foreach(VALUE self, VALUE obj) {
 }
 
 static VALUE speced_allocator(VALUE klass) {
-  VALUE flags = 0;
+  uintptr_t flags = 0;
   VALUE instance;
   if (RTEST(rb_class_inherited_p(klass, rb_cString))) {
     flags = T_STRING;
diff --git a/spec/ruby/optional/capi/ext/rbasic_spec.c b/spec/ruby/optional/capi/ext/rbasic_spec.c
index 26be2fed6d37..98d0d6e6f037 100644
--- a/spec/ruby/optional/capi/ext/rbasic_spec.c
+++ b/spec/ruby/optional/capi/ext/rbasic_spec.c
@@ -14,11 +14,11 @@ extern "C" {
 #endif
 
 #ifndef FL_SHAREABLE
-static const VALUE VISIBLE_BITS = FL_TAINT | FL_FREEZE;
-static const VALUE DATA_VISIBLE_BITS = FL_TAINT | FL_FREEZE | ~(FL_USER0 - 1);
+static const uintptr_t VISIBLE_BITS = FL_TAINT | FL_FREEZE;
+static const uintptr_t DATA_VISIBLE_BITS = FL_TAINT | FL_FREEZE | ~(FL_USER0 - 1);
 #else
-static const VALUE VISIBLE_BITS = FL_FREEZE;
-static const VALUE DATA_VISIBLE_BITS = FL_FREEZE | ~(FL_USER0 - 1);
+static const uintptr_t VISIBLE_BITS = FL_FREEZE;
+static const uintptr_t DATA_VISIBLE_BITS = FL_FREEZE | ~(FL_USER0 - 1);
 #endif
 
 #if SIZEOF_VALUE == SIZEOF_LONG
@@ -42,12 +42,12 @@ VALUE rbasic_spec_freeze_flag(VALUE self) {
   return VALUE2NUM(RUBY_FL_FREEZE);
 }
 
-static VALUE spec_get_flags(VALUE obj, VALUE visible_bits) {
-  VALUE flags = RB_FL_TEST(obj, visible_bits);
+static VALUE spec_get_flags(VALUE obj, uintptr_t visible_bits) {
+  uintptr_t flags = RB_FL_TEST(obj, visible_bits);
   return VALUE2NUM(flags);
 }
 
-static VALUE spec_set_flags(VALUE obj, VALUE flags, VALUE visible_bits) {
+static VALUE spec_set_flags(VALUE obj, uintptr_t flags, uintptr_t visible_bits) {
   flags &= visible_bits;
 
   // Could also be done like:
diff --git a/spec/ruby/optional/capi/ext/st_spec.c b/spec/ruby/optional/capi/ext/st_spec.c
index 0fb5b5dc2d58..e844b51808c5 100644
--- a/spec/ruby/optional/capi/ext/st_spec.c
+++ b/spec/ruby/optional/capi/ext/st_spec.c
@@ -34,7 +34,7 @@ VALUE st_spec_st_init_numtable_with_size(VALUE self) {
 VALUE st_spec_st_insert(VALUE self) {
   st_index_t entries;
   st_table *tbl = st_init_numtable_with_size(128);
-  st_insert(tbl, 1, 1);
+  st_insert(tbl, (st_data_t)1, (st_data_t)1);
   entries = tbl->num_entries;
   st_free_table(tbl);
   return ST2NUM(entries);
@@ -48,8 +48,8 @@ static int sum(st_data_t key, st_data_t value, st_data_t arg) {
 VALUE st_spec_st_foreach(VALUE self) {
   int total = 0;
   st_table *tbl = st_init_numtable_with_size(128);
-  st_insert(tbl, 1, 3);
-  st_insert(tbl, 2, 4);
+  st_insert(tbl, (st_data_t)1, (st_data_t)3);
+  st_insert(tbl, (st_data_t)2, (st_data_t)4);
   st_foreach(tbl, sum, (st_data_t)&total);
   st_free_table(tbl);
   return INT2FIX(total);
@@ -58,14 +58,14 @@ VALUE st_spec_st_foreach(VALUE self) {
 VALUE st_spec_st_lookup(VALUE self) {
   st_data_t result = (st_data_t)0;
   st_table *tbl = st_init_numtable_with_size(128);
-  st_insert(tbl, 7, 42);
-  st_insert(tbl, 2, 4);
+  st_insert(tbl, (st_data_t)7, (st_data_t)42);
+  st_insert(tbl, (st_data_t)2, (st_data_t)4);
   st_lookup(tbl, (st_data_t)7, &result);
   st_free_table(tbl);
 #if SIZEOF_LONG == SIZEOF_VOIDP
-  return ULONG2NUM(result);
+  return ULONG2NUM((unsigned long)result);
 #else
-  return ULL2NUM(result);
+  return ULL2NUM((unsigned long long)result);
 #endif
 }
 
diff --git a/sprintf.c b/sprintf.c
index b13530614fd7..80e2a4043253 100644
--- a/sprintf.c
+++ b/sprintf.c
@@ -31,6 +31,7 @@
 #include "ruby/encoding.h"
 #include "ruby/re.h"
 #include "ruby/util.h"
+#include <stdfil.h>
 
 #define BIT_DIGITS(N)   (((N)*146)/485 + 1)  /* log2(10) =~ 146/485 */
 
@@ -1107,8 +1108,8 @@ ruby__sfvextra(rb_printf_buffer *fp, size_t valsize, void *valp, long *sz, int s
     if (sign == '+') {
 # define LITERAL(str) (*sz = rb_strlen_lit(str), str)
         /* optimize special const cases */
-        switch (value) {
-# define LITERAL_CASE(x) case Q##x: return LITERAL(#x)
+        switch ((uintptr_t)value) {
+# define LITERAL_CASE(x) case (uintptr_t)Q##x: return LITERAL(#x)
           LITERAL_CASE(nil);
           LITERAL_CASE(true);
           LITERAL_CASE(false);
diff --git a/st.c b/st.c
index ab361e1ca8f3..502325ea5784 100644
--- a/st.c
+++ b/st.c
@@ -1842,7 +1842,7 @@ st_hash(const void *ptr, size_t len, st_index_t h)
 #undef SKIP_TAIL
     if (len >= sizeof(st_index_t)) {
 #if !UNALIGNED_WORD_ACCESS
-        int align = (int)((st_data_t)data % sizeof(st_index_t));
+        int align = (int)((st_index_t)data % sizeof(st_index_t));
         if (align) {
             st_index_t d = 0;
             int sl, sr, pack;
@@ -2102,7 +2102,7 @@ st_index_t
 st_numhash(st_data_t n)
 {
     enum {s1 = 11, s2 = 3};
-    return (st_index_t)((n>>s1|(n<<s2)) ^ (n>>s2));
+    return ((st_index_t)n>>s1|((st_index_t)n<<s2)) ^ ((st_index_t)n>>s2);
 }
 
 #ifdef RUBY
diff --git a/string.c b/string.c
index 44734c695ec4..a502d5da8373 100644
--- a/string.c
+++ b/string.c
@@ -345,6 +345,7 @@ fstr_update_callback(st_data_t *key, st_data_t *value, st_data_t data, int exist
 
         if (rb_objspace_garbage_object_p(str)) {
             arg->fstr = Qundef;
+            // FIXME: Sounds like the frozen string table needs to be weak!
             // When RSTRING_FSTR strings are swept, they call `st_delete`.
             // To avoid a race condition if an equivalent string was inserted
             // we must remove the flag immediately.
@@ -1715,11 +1716,11 @@ ec_str_alloc_heap(struct rb_execution_context_struct *ec, VALUE klass)
 static inline VALUE
 str_duplicate_setup(VALUE klass, VALUE str, VALUE dup)
 {
-    const VALUE flag_mask =
+    const uintptr_t flag_mask =
         ENC_CODERANGE_MASK | ENCODING_MASK |
         FL_FREEZE
         ;
-    VALUE flags = FL_TEST_RAW(str, flag_mask);
+    uintptr_t flags = FL_TEST_RAW(str, flag_mask);
     int encidx = 0;
     if (STR_EMBED_P(str)) {
         long len = RSTRING_LEN(str);
@@ -5242,10 +5243,10 @@ rb_str_aref(VALUE str, VALUE indx)
     else {
         /* check if indx is Range */
         long beg, len = str_strlen(str, NULL);
-        switch (rb_range_beg_len(indx, &beg, &len, len, 0)) {
-          case Qfalse:
+        switch ((uintptr_t)rb_range_beg_len(indx, &beg, &len, len, 0)) {
+          case (uintptr_t)Qfalse:
             break;
-          case Qnil:
+          case (uintptr_t)Qnil:
             return Qnil;
           default:
             return rb_str_substr(str, beg, len);
@@ -5624,10 +5625,10 @@ rb_str_slice_bang(int argc, VALUE *argv, VALUE str)
         goto squash;
     }
     else {
-        switch (rb_range_beg_len(indx, &beg, &len, str_strlen(str, NULL), 0)) {
-          case Qnil:
+        switch ((uintptr_t)rb_range_beg_len(indx, &beg, &len, str_strlen(str, NULL), 0)) {
+          case (uintptr_t)Qnil:
             return Qnil;
-          case Qfalse:
+          case (uintptr_t)Qfalse:
             beg = NUM2LONG(indx);
             if (!(p = rb_str_subpos(str, beg, &len))) return Qnil;
             if (!len) return Qnil;
@@ -6265,10 +6266,10 @@ str_byte_aref(VALUE str, VALUE indx)
         /* check if indx is Range */
         long beg, len = RSTRING_LEN(str);
 
-        switch (rb_range_beg_len(indx, &beg, &len, len, 0)) {
-          case Qfalse:
+        switch ((uintptr_t)rb_range_beg_len(indx, &beg, &len, len, 0)) {
+          case (uintptr_t)Qfalse:
             break;
-          case Qnil:
+          case (uintptr_t)Qnil:
             return Qnil;
           default:
             return str_byte_substr(str, beg, len, TRUE);
@@ -9046,7 +9047,7 @@ rb_str_enumerate_lines(int argc, VALUE *argv, VALUE str, VALUE ary)
             keywords[0] = rb_intern_const("chomp");
         }
         rb_get_kwargs(opts, keywords, 0, 1, &chomp);
-        chomp = (!UNDEF_P(chomp) && RTEST(chomp));
+        chomp = (VALUE)(!UNDEF_P(chomp) && RTEST(chomp));
     }
 
     if (NIL_P(rs)) {
diff --git a/struct.c b/struct.c
index 23420d5e8cc6..3afb1806b00d 100644
--- a/struct.c
+++ b/struct.c
@@ -750,16 +750,16 @@ rb_struct_initialize_m(int argc, const VALUE *argv, VALUE self)
     }
 
     bool keyword_init = false;
-    switch (rb_struct_s_keyword_init(klass)) {
+    switch ((uintptr_t)rb_struct_s_keyword_init(klass)) {
       default:
         if (argc > 1 || !RB_TYPE_P(argv[0], T_HASH)) {
             rb_error_arity(argc, 0, 0);
         }
         keyword_init = true;
         break;
-      case Qfalse:
+      case (uintptr_t)Qfalse:
         break;
-      case Qnil:
+      case (uintptr_t)Qnil:
         if (argc > 1 || !RB_TYPE_P(argv[0], T_HASH)) {
             break;
         }
@@ -811,7 +811,7 @@ struct_alloc(VALUE klass)
 {
     long n = num_members(klass);
     size_t embedded_size = offsetof(struct RStruct, as.ary) + (sizeof(VALUE) * n);
-    VALUE flags = T_STRUCT | (RGENGC_WB_PROTECTED_STRUCT ? FL_WB_PROTECTED : 0);
+    uintptr_t flags = T_STRUCT | (RGENGC_WB_PROTECTED_STRUCT ? FL_WB_PROTECTED : 0);
 
     if (n > 0 && rb_gc_size_allocatable_p(embedded_size)) {
         flags |= n << RSTRUCT_EMBED_LEN_SHIFT;
@@ -1435,7 +1435,7 @@ rb_struct_hash(VALUE s)
     st_index_t h;
     VALUE n;
 
-    h = rb_hash_start(rb_hash(rb_obj_class(s)));
+    h = rb_hash_start((st_index_t)rb_hash(rb_obj_class(s)));
     len = RSTRUCT_LEN(s);
     for (i = 0; i < len; i++) {
         n = rb_hash(RSTRUCT_GET(s, i));
diff --git a/symbol.c b/symbol.c
index 03ca9cf15084..f84540d5671e 100644
--- a/symbol.c
+++ b/symbol.c
@@ -44,7 +44,7 @@
 
 #define SYMBOL_PINNED_P(sym) (RSYMBOL(sym)->id&~ID_SCOPE_MASK)
 
-#define STATIC_SYM2ID(sym) RSHIFT((VALUE)(sym), RUBY_SPECIAL_SHIFT)
+#define STATIC_SYM2ID(sym) RSHIFT((uintptr_t)(sym), RUBY_SPECIAL_SHIFT)
 
 static ID register_static_symid(ID, const char *, long, rb_encoding *);
 static ID register_static_symid_str(ID, VALUE);
diff --git a/symbol.h b/symbol.h
index 3649f125bfbe..45dde87a4df2 100644
--- a/symbol.h
+++ b/symbol.h
@@ -15,7 +15,7 @@
 #include "ruby/encoding.h"
 
 #define DYNAMIC_ID_P(id) (!(id&ID_STATIC_SYM)&&id>tLAST_OP_ID)
-#define STATIC_ID2SYM(id)  (((VALUE)(id)<<RUBY_SPECIAL_SHIFT)|SYMBOL_FLAG)
+#define STATIC_ID2SYM(id)  ((VALUE)(((uintptr_t)(id)<<RUBY_SPECIAL_SHIFT)|SYMBOL_FLAG))
 
 #ifdef HAVE_BUILTIN___BUILTIN_CONSTANT_P
 #define rb_id2sym(id) \
@@ -81,7 +81,7 @@ sym_type(VALUE sym)
 {
     ID id;
     if (STATIC_SYM_P(sym)) {
-        id = RSHIFT(sym, RUBY_SPECIAL_SHIFT);
+        id = RSHIFT((uintptr_t)sym, RUBY_SPECIAL_SHIFT);
         if (id<=tLAST_OP_ID) {
             return -1;
         }
diff --git a/thread.c b/thread.c
index 1fe1e0159596..3e0cc9c3d81f 100644
--- a/thread.c
+++ b/thread.c
@@ -1115,8 +1115,8 @@ thread_join(rb_thread_t *target_th, VALUE timeout, rb_hrtime_t *limit)
         VALUE err = target_th->ec->errinfo;
 
         if (FIXNUM_P(err)) {
-            switch (err) {
-              case INT2FIX(TAG_FATAL):
+            switch ((uintptr_t)err) {
+              case (uintptr_t)INT2FIX(TAG_FATAL):
                 RUBY_DEBUG_LOG("terminated target_th:%u status:%s", rb_th_serial(target_th), thread_status_name(target_th, TRUE));
 
                 /* OK. killed. */
@@ -4952,7 +4952,7 @@ rb_thread_shield_waiting_inc(VALUE b)
     if (w > THREAD_SHIELD_WAITING_MAX)
         rb_raise(rb_eRuntimeError, "waiting count overflow");
     RBASIC(b)->flags &= ~THREAD_SHIELD_WAITING_MASK;
-    RBASIC(b)->flags |= ((VALUE)w << THREAD_SHIELD_WAITING_SHIFT);
+    RBASIC(b)->flags |= ((uintptr_t)w << THREAD_SHIELD_WAITING_SHIFT);
 }
 
 static inline void
@@ -4962,7 +4962,7 @@ rb_thread_shield_waiting_dec(VALUE b)
     if (!w) rb_raise(rb_eRuntimeError, "waiting count underflow");
     w--;
     RBASIC(b)->flags &= ~THREAD_SHIELD_WAITING_MASK;
-    RBASIC(b)->flags |= ((VALUE)w << THREAD_SHIELD_WAITING_SHIFT);
+    RBASIC(b)->flags |= ((uintptr_t)w << THREAD_SHIELD_WAITING_SHIFT);
 }
 
 VALUE
diff --git a/tool/ruby_vm/views/_insn_len_info.erb b/tool/ruby_vm/views/_insn_len_info.erb
index 569dca5845bb..85054ad473ab 100644
--- a/tool/ruby_vm/views/_insn_len_info.erb
+++ b/tool/ruby_vm/views/_insn_len_info.erb
@@ -5,7 +5,7 @@
 %# granted, to either  redistribute and/or modify this file,  provided that the
 %# conditions mentioned  in the  file COPYING  are met.   Consult the  file for
 %# details.
-CONSTFUNC(MAYBE_UNUSED(static int insn_len(VALUE insn)));
+CONSTFUNC(MAYBE_UNUSED(static int insn_len(uintptr_t insn)));
 
 RUBY_SYMBOL_EXPORT_BEGIN /* for debuggers */
 extern const uint8_t rb_vm_insn_len_info[VM_INSTRUCTION_SIZE];
@@ -22,7 +22,7 @@ ASSERT_VM_INSTRUCTION_SIZE(rb_vm_insn_len_info);
 #endif
 
 int
-insn_len(VALUE i)
+insn_len(uintptr_t i)
 {
     return rb_vm_insn_len_info[i];
 }
diff --git a/tool/ruby_vm/views/_insn_name_info.erb b/tool/ruby_vm/views/_insn_name_info.erb
index e7ded75e6576..434ea089357a 100644
--- a/tool/ruby_vm/views/_insn_name_info.erb
+++ b/tool/ruby_vm/views/_insn_name_info.erb
@@ -11,7 +11,7 @@
 % c = a.inject([0]) {|r, i| r << (r[-1] + i.length + 1) }
 % c.pop
 %
-CONSTFUNC(MAYBE_UNUSED(static const char *insn_name(VALUE insn)));
+CONSTFUNC(MAYBE_UNUSED(static const char *insn_name(uintptr_t insn)));
 
 RUBY_SYMBOL_EXPORT_BEGIN /* for debuggers */
 extern const int rb_vm_max_insn_name_size;
@@ -38,7 +38,7 @@ ASSERT_VM_INSTRUCTION_SIZE(rb_vm_insn_name_offset);
 #endif
 
 const char *
-insn_name(VALUE i)
+insn_name(uintptr_t i)
 {
     return &rb_vm_insn_name_base[rb_vm_insn_name_offset[i]];
 }
diff --git a/tool/ruby_vm/views/_insn_operand_info.erb b/tool/ruby_vm/views/_insn_operand_info.erb
index 996c33e96053..d1197bb42dbb 100644
--- a/tool/ruby_vm/views/_insn_operand_info.erb
+++ b/tool/ruby_vm/views/_insn_operand_info.erb
@@ -11,8 +11,8 @@
 % c = a.inject([0]) {|r, i| r << (r[-1] + i.length + 1) }
 % c.pop
 %
-CONSTFUNC(MAYBE_UNUSED(static const char *insn_op_types(VALUE insn)));
-CONSTFUNC(MAYBE_UNUSED(static int insn_op_type(VALUE insn, long pos)));
+CONSTFUNC(MAYBE_UNUSED(static const char *insn_op_types(uintptr_t insn)));
+CONSTFUNC(MAYBE_UNUSED(static int insn_op_type(uintptr_t insn, long pos)));
 
 RUBY_SYMBOL_EXPORT_BEGIN /* for debuggers */
 extern const char rb_vm_insn_op_base[];
@@ -36,13 +36,13 @@ ASSERT_VM_INSTRUCTION_SIZE(rb_vm_insn_op_offset);
 #endif
 
 const char *
-insn_op_types(VALUE i)
+insn_op_types(uintptr_t i)
 {
     return &rb_vm_insn_op_base[rb_vm_insn_op_offset[i]];
 }
 
 int
-insn_op_type(VALUE i, long j)
+insn_op_type(uintptr_t i, long j)
 {
     if (j >= insn_len(i)) {
         return 0;
diff --git a/tool/ruby_vm/views/optinsn.inc.erb b/tool/ruby_vm/views/optinsn.inc.erb
index de7bb210eae3..035c8cbd02a5 100644
--- a/tool/ruby_vm/views/optinsn.inc.erb
+++ b/tool/ruby_vm/views/optinsn.inc.erb
@@ -49,7 +49,7 @@ insn_operands_unification(INSN *iobj)
 }
 
 int
-rb_insn_unified_local_var_level(VALUE insn)
+rb_insn_unified_local_var_level(uintptr_t insn)
 {
 #ifdef OPT_OPERANDS_UNIFICATION
     /* optimize rule */
@@ -60,7 +60,7 @@ rb_insn_unified_local_var_level(VALUE insn)
 %   unifs.each do|insn|
       case <%= insn.bin %>:
 %     insn.spec.map{|(var,val)|val}.reject{|i| i == '*' }.each do |val|
-        return <%= val %>;
+        return (int)<%= val %>;
 %       break
 %     end
 %   end
diff --git a/transcode.c b/transcode.c
index 892814ee3ba0..ded55330a7ab 100644
--- a/transcode.c
+++ b/transcode.c
@@ -581,12 +581,12 @@ transcode_restartable0(const unsigned char **in_pos, unsigned char **out_pos,
         next_byte = (unsigned char)*in_p++;
       follow_byte:
         if (next_byte < BL_MIN_BYTE || BL_MAX_BYTE < next_byte)
-            next_info = INVALID;
+            next_info = (VALUE)INVALID;
         else {
             next_info = (VALUE)BL_ACTION(next_byte);
         }
       follow_info:
-        switch (next_info & 0x1F) {
+        switch ((uintptr_t)next_info & 0x1F) {
           case NOMAP:
             {
                 const unsigned char *p = inchar_start;
@@ -616,33 +616,33 @@ transcode_restartable0(const unsigned char **in_pos, unsigned char **out_pos,
           case ZERObt: /* drop input */
             continue;
           case ONEbt:
-            SUSPEND_OBUF(9); *out_p++ = getBT1(next_info);
+              SUSPEND_OBUF(9); *out_p++ = getBT1((uintptr_t)next_info);
             continue;
           case TWObt:
-            SUSPEND_OBUF(10); *out_p++ = getBT1(next_info);
-            SUSPEND_OBUF(21); *out_p++ = getBT2(next_info);
+            SUSPEND_OBUF(10); *out_p++ = getBT1((uintptr_t)next_info);
+            SUSPEND_OBUF(21); *out_p++ = getBT2((uintptr_t)next_info);
             continue;
           case THREEbt:
-            SUSPEND_OBUF(11); *out_p++ = getBT1(next_info);
-            SUSPEND_OBUF(15); *out_p++ = getBT2(next_info);
-            SUSPEND_OBUF(16); *out_p++ = getBT3(next_info);
+            SUSPEND_OBUF(11); *out_p++ = getBT1((uintptr_t)next_info);
+            SUSPEND_OBUF(15); *out_p++ = getBT2((uintptr_t)next_info);
+            SUSPEND_OBUF(16); *out_p++ = getBT3((uintptr_t)next_info);
             continue;
           case FOURbt:
-            SUSPEND_OBUF(12); *out_p++ = getBT0(next_info);
-            SUSPEND_OBUF(17); *out_p++ = getBT1(next_info);
-            SUSPEND_OBUF(18); *out_p++ = getBT2(next_info);
-            SUSPEND_OBUF(19); *out_p++ = getBT3(next_info);
+            SUSPEND_OBUF(12); *out_p++ = getBT0((uintptr_t)next_info);
+            SUSPEND_OBUF(17); *out_p++ = getBT1((uintptr_t)next_info);
+            SUSPEND_OBUF(18); *out_p++ = getBT2((uintptr_t)next_info);
+            SUSPEND_OBUF(19); *out_p++ = getBT3((uintptr_t)next_info);
             continue;
           case GB4bt:
-            SUSPEND_OBUF(29); *out_p++ = getGB4bt0(next_info);
-            SUSPEND_OBUF(30); *out_p++ = getGB4bt1(next_info);
-            SUSPEND_OBUF(31); *out_p++ = getGB4bt2(next_info);
-            SUSPEND_OBUF(32); *out_p++ = getGB4bt3(next_info);
+            SUSPEND_OBUF(29); *out_p++ = getGB4bt0((uintptr_t)next_info);
+            SUSPEND_OBUF(30); *out_p++ = getGB4bt1((uintptr_t)next_info);
+            SUSPEND_OBUF(31); *out_p++ = getGB4bt2((uintptr_t)next_info);
+            SUSPEND_OBUF(32); *out_p++ = getGB4bt3((uintptr_t)next_info);
             continue;
           case STR1:
             tc->output_index = 0;
-            while (tc->output_index < STR1_LENGTH(BYTE_ADDR(STR1_BYTEINDEX(next_info)))) {
-                SUSPEND_OBUF(28); *out_p++ = BYTE_ADDR(STR1_BYTEINDEX(next_info))[1+tc->output_index];
+            while (tc->output_index < STR1_LENGTH(BYTE_ADDR(STR1_BYTEINDEX((uintptr_t)next_info)))) {
+                SUSPEND_OBUF(28); *out_p++ = BYTE_ADDR(STR1_BYTEINDEX((uintptr_t)next_info))[1+tc->output_index];
                 tc->output_index++;
             }
             continue;
diff --git a/variable.c b/variable.c
index 4d442ff9e314..be45f9eb9216 100644
--- a/variable.c
+++ b/variable.c
@@ -320,11 +320,11 @@ static VALUE
 make_temporary_path(VALUE obj, VALUE klass)
 {
     VALUE path;
-    switch (klass) {
-      case Qnil:
+    switch ((uintptr_t)klass) {
+      case (uintptr_t)Qnil:
         path = rb_sprintf("#<Class:%p>", (void*)obj);
         break;
-      case Qfalse:
+      case (uintptr_t)Qfalse:
         path = rb_sprintf("#<Module:%p>", (void*)obj);
         break;
       default:
@@ -1964,7 +1964,7 @@ rb_ivar_defined(VALUE obj, ID id)
           }
         }
 
-        if (!table || !rb_st_lookup(table, id, &idx)) {
+        if (!table || !rb_st_lookup(table, (st_data_t)id, &idx)) {
             return Qfalse;
         }
 
@@ -2737,7 +2737,7 @@ autoload_delete(VALUE module, ID name)
 {
     RUBY_ASSERT_CRITICAL_SECTION_ENTER();
 
-    st_data_t load = 0, key = name;
+    st_data_t load = 0, key = (st_data_t)name;
 
     RUBY_ASSERT(RB_TYPE_P(module, T_CLASS) || RB_TYPE_P(module, T_MODULE));
 
@@ -3982,7 +3982,7 @@ static void
 check_for_cvar_table(VALUE subclass, VALUE key)
 {
     // Must not check ivar on ICLASS
-    if (!RB_TYPE_P(subclass, T_ICLASS) && RTEST(rb_ivar_defined(subclass, key))) {
+    if (!RB_TYPE_P(subclass, T_ICLASS) && RTEST(rb_ivar_defined(subclass, (ID)key))) {
         RB_DEBUG_COUNTER_INC(cvar_class_invalidate);
         ruby_vm_global_cvar_state++;
         return;
@@ -4040,7 +4040,7 @@ rb_cvar_set(VALUE klass, ID id, VALUE val)
     if (result == 0) {
         if (RB_TYPE_P(target, T_CLASS)) {
             if (RCLASS_SUBCLASSES(target)) {
-                rb_class_foreach_subclass(target, check_for_cvar_table, id);
+                rb_class_foreach_subclass(target, check_for_cvar_table, (VALUE)id);
             }
         }
     }
diff --git a/vm.c b/vm.c
index 259d16b85a38..140e7f9d2b3c 100644
--- a/vm.c
+++ b/vm.c
@@ -734,7 +734,7 @@ vm_set_top_stack(rb_execution_context_t *ec, const rb_iseq_t *iseq)
     }
 
     /* for return */
-    vm_push_frame(ec, iseq, VM_FRAME_MAGIC_TOP | VM_ENV_FLAG_LOCAL | VM_FRAME_FLAG_FINISH, rb_ec_thread_ptr(ec)->top_self,
+    vm_push_frame(ec, iseq, (VALUE)(VM_FRAME_MAGIC_TOP | VM_ENV_FLAG_LOCAL | VM_FRAME_FLAG_FINISH), rb_ec_thread_ptr(ec)->top_self,
                   VM_BLOCK_HANDLER_NONE,
                   (VALUE)vm_cref_new_toplevel(ec), /* cref or me */
                   ISEQ_BODY(iseq)->iseq_encoded, ec->cfp->sp,
@@ -744,7 +744,7 @@ vm_set_top_stack(rb_execution_context_t *ec, const rb_iseq_t *iseq)
 static void
 vm_set_eval_stack(rb_execution_context_t *ec, const rb_iseq_t *iseq, const rb_cref_t *cref, const struct rb_block *base_block)
 {
-    vm_push_frame(ec, iseq, VM_FRAME_MAGIC_EVAL | VM_FRAME_FLAG_FINISH,
+    vm_push_frame(ec, iseq, (VALUE)(VM_FRAME_MAGIC_EVAL | VM_FRAME_FLAG_FINISH),
                   vm_block_self(base_block), VM_GUARDED_PREV_EP(vm_block_ep(base_block)),
                   (VALUE)cref, /* cref or me */
                   ISEQ_BODY(iseq)->iseq_encoded,
@@ -1233,7 +1233,7 @@ env_copy(const VALUE *src_ep, VALUE read_only_variables)
 
     // Copy after allocations above, since they can move objects in src_ep.
     RB_OBJ_WRITE(copied_env, &ep[VM_ENV_DATA_INDEX_ME_CREF], src_ep[VM_ENV_DATA_INDEX_ME_CREF]);
-    ep[VM_ENV_DATA_INDEX_FLAGS] = src_ep[VM_ENV_DATA_INDEX_FLAGS] | VM_ENV_FLAG_ISOLATED;
+    ep[VM_ENV_DATA_INDEX_FLAGS] = (VALUE)((uintptr_t)src_ep[VM_ENV_DATA_INDEX_FLAGS] | VM_ENV_FLAG_ISOLATED);
     if (!VM_ENV_LOCAL_P(src_ep)) {
         VM_ENV_FLAGS_SET(ep, VM_ENV_FLAG_LOCAL);
     }
@@ -1407,7 +1407,7 @@ rb_vm_make_proc_lambda(const rb_execution_context_t *ec, const struct rb_capture
             }
             else {
                 VM_ASSERT(FIXNUM_P(ep0));
-                if (ep0 & VM_ENV_FLAG_ESCAPED) {
+                if ((uintptr_t)ep0 & VM_ENV_FLAG_ESCAPED) {
                     // ok. do nothing
                 }
                 else {
@@ -1504,11 +1504,11 @@ rb_binding_add_dynavars(VALUE bindval, rb_binding_t *bind, int dyncount, const I
 /* C -> Ruby: block */
 
 static inline VALUE
-invoke_block(rb_execution_context_t *ec, const rb_iseq_t *iseq, VALUE self, const struct rb_captured_block *captured, const rb_cref_t *cref, VALUE type, int opt_pc)
+invoke_block(rb_execution_context_t *ec, const rb_iseq_t *iseq, VALUE self, const struct rb_captured_block *captured, const rb_cref_t *cref, uintptr_t type, int opt_pc)
 {
     int arg_size = ISEQ_BODY(iseq)->param.size;
 
-    vm_push_frame(ec, iseq, type | VM_FRAME_FLAG_FINISH, self,
+    vm_push_frame(ec, iseq, (VALUE)(type | VM_FRAME_FLAG_FINISH), self,
                   VM_GUARDED_PREV_EP(captured->ep),
                   (VALUE)cref, /* cref or method */
                   ISEQ_BODY(iseq)->iseq_encoded + opt_pc,
@@ -1519,7 +1519,7 @@ invoke_block(rb_execution_context_t *ec, const rb_iseq_t *iseq, VALUE self, cons
 }
 
 static VALUE
-invoke_bmethod(rb_execution_context_t *ec, const rb_iseq_t *iseq, VALUE self, const struct rb_captured_block *captured, const rb_callable_method_entry_t *me, VALUE type, int opt_pc)
+invoke_bmethod(rb_execution_context_t *ec, const rb_iseq_t *iseq, VALUE self, const struct rb_captured_block *captured, const rb_callable_method_entry_t *me, uintptr_t type, int opt_pc)
 {
     /* bmethod call from outside the VM */
     int arg_size = ISEQ_BODY(iseq)->param.size;
@@ -1527,7 +1527,7 @@ invoke_bmethod(rb_execution_context_t *ec, const rb_iseq_t *iseq, VALUE self, co
 
     VM_ASSERT(me->def->type == VM_METHOD_TYPE_BMETHOD);
 
-    vm_push_frame(ec, iseq, type | VM_FRAME_FLAG_BMETHOD, self,
+    vm_push_frame(ec, iseq, (VALUE)(type | VM_FRAME_FLAG_BMETHOD), self,
                   VM_GUARDED_PREV_EP(captured->ep),
                   (VALUE)me,
                   ISEQ_BODY(iseq)->iseq_encoded + opt_pc,
@@ -1553,7 +1553,7 @@ invoke_iseq_block_from_c(rb_execution_context_t *ec, const struct rb_captured_bl
 {
     const rb_iseq_t *iseq = rb_iseq_check(captured->code.iseq);
     int opt_pc;
-    VALUE type = VM_FRAME_MAGIC_BLOCK | (is_lambda ? VM_FRAME_FLAG_LAMBDA : 0);
+    uintptr_t type = VM_FRAME_MAGIC_BLOCK | (is_lambda ? VM_FRAME_FLAG_LAMBDA : 0);
     rb_control_frame_t *cfp = ec->cfp;
     VALUE *sp = cfp->sp;
     int flags = (kw_splat ? VM_CALL_KW_SPLAT : 0);
@@ -1777,13 +1777,13 @@ rb_vm_svar_lep(const rb_execution_context_t *ec, const rb_control_frame_t *cfp)
 static VALUE
 vm_cfp_svar_get(const rb_execution_context_t *ec, rb_control_frame_t *cfp, VALUE key)
 {
-    return lep_svar_get(ec, rb_vm_svar_lep(ec, cfp), key);
+    return lep_svar_get(ec, rb_vm_svar_lep(ec, cfp), (rb_num_t)key);
 }
 
 static void
 vm_cfp_svar_set(const rb_execution_context_t *ec, rb_control_frame_t *cfp, VALUE key, const VALUE val)
 {
-    lep_svar_set(ec, rb_vm_svar_lep(ec, cfp), key, val);
+    lep_svar_set(ec, rb_vm_svar_lep(ec, cfp), (rb_num_t)key, val);
 }
 
 static VALUE
@@ -1801,13 +1801,13 @@ vm_svar_set(const rb_execution_context_t *ec, VALUE key, VALUE val)
 VALUE
 rb_backref_get(void)
 {
-    return vm_svar_get(GET_EC(), VM_SVAR_BACKREF);
+    return vm_svar_get(GET_EC(), (VALUE)VM_SVAR_BACKREF);
 }
 
 void
 rb_backref_set(VALUE val)
 {
-    vm_svar_set(GET_EC(), VM_SVAR_BACKREF, val);
+    vm_svar_set(GET_EC(), (VALUE)VM_SVAR_BACKREF, val);
 }
 
 VALUE
@@ -2134,7 +2134,7 @@ rb_vm_check_redefinition_opt_method(const rb_method_entry_t *me, VALUE klass)
             if (flag != 0) {
                 rb_yjit_bop_redefined(flag, (enum ruby_basic_operators)bop);
                 rb_rjit_bop_redefined(flag, (enum ruby_basic_operators)bop);
-                ruby_vm_redefined_flag[bop] |= flag;
+                ruby_vm_redefined_flag[(uintptr_t)bop] |= flag;
             }
         }
     }
@@ -2160,7 +2160,7 @@ rb_vm_check_redefinition_by_prepend(VALUE klass)
 }
 
 static void
-add_opt_method(VALUE klass, ID mid, VALUE bop)
+add_opt_method(VALUE klass, ID mid, uintptr_t bop)
 {
     const rb_method_entry_t *me = rb_method_entry_at(klass, mid);
 
@@ -2177,7 +2177,7 @@ static void
 vm_init_redefined_flag(void)
 {
     ID mid;
-    VALUE bop;
+    uintptr_t bop;
 
     vm_opt_method_def_table = st_init_numtable();
     vm_opt_mid_table = st_init_numtable();
@@ -2542,7 +2542,7 @@ vm_exec_handle_exception(rb_execution_context_t *ec, enum ruby_tag_type state, V
         const struct iseq_catch_table *ct;
         unsigned long epc, cont_pc, cont_sp;
         const rb_iseq_t *catch_iseq;
-        VALUE type;
+        enum rb_catch_type type;
         const rb_control_frame_t *escape_cfp;
 
         cont_pc = cont_sp = 0;
@@ -2708,7 +2708,7 @@ vm_exec_handle_exception(rb_execution_context_t *ec, enum ruby_tag_type state, V
 
             /* push block frame */
             cfp->sp[0] = (VALUE)err;
-            vm_push_frame(ec, catch_iseq, VM_FRAME_MAGIC_RESCUE,
+            vm_push_frame(ec, catch_iseq, (VALUE)VM_FRAME_MAGIC_RESCUE,
                           cfp->self,
                           VM_GUARDED_PREV_EP(cfp->ep),
                           0, /* cref or me */
@@ -2800,7 +2800,7 @@ rb_vm_call_cfunc(VALUE recv, VALUE (*func)(VALUE), VALUE arg,
     const rb_iseq_t *iseq = rb_iseq_new(0, filename, filename, Qnil, 0, ISEQ_TYPE_TOP);
     VALUE val;
 
-    vm_push_frame(ec, iseq, VM_FRAME_MAGIC_TOP | VM_ENV_FLAG_LOCAL | VM_FRAME_FLAG_FINISH,
+    vm_push_frame(ec, iseq, (VALUE)(VM_FRAME_MAGIC_TOP | VM_ENV_FLAG_LOCAL | VM_FRAME_FLAG_FINISH),
                   recv, block_handler,
                   (VALUE)vm_cref_new_toplevel(ec), /* cref or me */
                   0, reg_cfp->sp, 0, 0);
@@ -3519,7 +3519,7 @@ rb_ec_initialize_vm_stack(rb_execution_context_t *ec, VALUE *stack, size_t size)
 
     vm_push_frame(ec,
         NULL /* dummy iseq */,
-        VM_FRAME_MAGIC_DUMMY | VM_ENV_FLAG_LOCAL | VM_FRAME_FLAG_FINISH | VM_FRAME_FLAG_CFRAME /* dummy frame */,
+        (VALUE)(VM_FRAME_MAGIC_DUMMY | VM_ENV_FLAG_LOCAL | VM_FRAME_FLAG_FINISH | VM_FRAME_FLAG_CFRAME) /* dummy frame */,
         Qnil /* dummy self */, VM_BLOCK_HANDLER_NONE /* dummy block ptr */,
         0 /* dummy cref/me */,
         0 /* dummy pc */, ec->vm_stack, 0, 0
diff --git a/vm.inc b/vm.inc
index b72a9ea80c06..be1fcd4bfbc9 100644
--- a/vm.inc
+++ b/vm.inc
@@ -2128,7 +2128,7 @@ INSN_ENTRY(defineclass)
     rb_iseq_check(class_iseq);
 
     /* enter scope */
-    vm_push_frame(ec, class_iseq, VM_FRAME_MAGIC_CLASS | VM_ENV_FLAG_LOCAL, klass,
+    vm_push_frame(ec, class_iseq, (VALUE)(VM_FRAME_MAGIC_CLASS | VM_ENV_FLAG_LOCAL), klass,
                   GET_BLOCK_HANDLER(),
                   (VALUE)vm_cref_push(ec, klass, NULL, FALSE, FALSE),
                   ISEQ_BODY(class_iseq)->iseq_encoded, GET_SP(),
diff --git a/vm_args.c b/vm_args.c
index 1b720a89c484..5a34d677a045 100644
--- a/vm_args.c
+++ b/vm_args.c
@@ -710,7 +710,7 @@ setup_parameters_complex(rb_execution_context_t * const ec, const rb_iseq_t * co
     if (ISEQ_BODY(iseq)->param.flags.has_rest) {
         args_setup_rest_parameter(args, locals + ISEQ_BODY(iseq)->param.rest_start);
         VALUE ary = *(locals + ISEQ_BODY(iseq)->param.rest_start);
-        VALUE index = RARRAY_LEN(ary) - 1;
+        uintptr_t index = RARRAY_LEN(ary) - 1;
         if (splat_flagged_keyword_hash &&
             !ISEQ_BODY(iseq)->param.flags.ruby2_keywords &&
             !ISEQ_BODY(iseq)->param.flags.has_kw &&
@@ -779,7 +779,7 @@ raise_argument_error(rb_execution_context_t *ec, const rb_iseq_t *iseq, const VA
     VALUE at;
 
     if (iseq) {
-        vm_push_frame(ec, iseq, VM_FRAME_MAGIC_DUMMY | VM_ENV_FLAG_LOCAL, Qnil /* self */,
+        vm_push_frame(ec, iseq, (VALUE)(VM_FRAME_MAGIC_DUMMY | VM_ENV_FLAG_LOCAL), Qnil /* self */,
                       VM_BLOCK_HANDLER_NONE /* specval*/, Qfalse /* me or cref */,
                       ISEQ_BODY(iseq)->iseq_encoded,
                       ec->cfp->sp, 0, 0 /* stack_max */);
diff --git a/vm_backtrace.c b/vm_backtrace.c
index 6e9436f76a33..976e52c6e395 100644
--- a/vm_backtrace.c
+++ b/vm_backtrace.c
@@ -1102,8 +1102,8 @@ ec_backtrace_to_ary(const rb_execution_context_t *ec, int argc, const VALUE *arg
       case 1:
         {
             long beg, len, bt_size = backtrace_size(ec);
-            switch (rb_range_beg_len(level, &beg, &len, bt_size - lev_plus, 0)) {
-              case Qfalse:
+            switch ((uintptr_t)rb_range_beg_len(level, &beg, &len, bt_size - lev_plus, 0)) {
+              case (uintptr_t)Qfalse:
                 lev = NUM2LONG(level);
                 if (lev < 0) {
                     rb_raise(rb_eArgError, "negative level (%ld)", lev);
@@ -1111,7 +1111,7 @@ ec_backtrace_to_ary(const rb_execution_context_t *ec, int argc, const VALUE *arg
                 lev += lev_plus;
                 n = ALL_BACKTRACE_LINES;
                 break;
-              case Qnil:
+              case (uintptr_t)Qnil:
                 return Qnil;
               default:
                 lev = beg + lev_plus;
diff --git a/vm_callinfo.h b/vm_callinfo.h
index ab7c199e3c22..2c1803441926 100644
--- a/vm_callinfo.h
+++ b/vm_callinfo.h
@@ -59,11 +59,11 @@ rb_callinfo_kwarg_bytes(int keyword_len)
 
 // imemo_callinfo
 struct rb_callinfo {
-    VALUE flags;
+    uintptr_t flags;
     const struct rb_callinfo_kwarg *kwarg;
-    VALUE mid;
-    VALUE flag;
-    VALUE argc;
+    uintptr_t mid;
+    uintptr_t flag;
+    uintptr_t argc;
 };
 
 #if !defined(USE_EMBED_CI) || (USE_EMBED_CI+0)
@@ -92,11 +92,11 @@ struct rb_callinfo {
 
 #define CI_EMBED_FLAG 0x01
 #define CI_EMBED_ARGC_SHFT (CI_EMBED_TAG_bits)
-#define CI_EMBED_ARGC_MASK ((((VALUE)1)<<CI_EMBED_ARGC_bits) - 1)
+#define CI_EMBED_ARGC_MASK ((((uintptr_t)1)<<CI_EMBED_ARGC_bits) - 1)
 #define CI_EMBED_FLAG_SHFT (CI_EMBED_TAG_bits + CI_EMBED_ARGC_bits)
-#define CI_EMBED_FLAG_MASK ((((VALUE)1)<<CI_EMBED_FLAG_bits) - 1)
+#define CI_EMBED_FLAG_MASK ((((uintptr_t)1)<<CI_EMBED_FLAG_bits) - 1)
 #define CI_EMBED_ID_SHFT   (CI_EMBED_TAG_bits + CI_EMBED_ARGC_bits + CI_EMBED_FLAG_bits)
-#define CI_EMBED_ID_MASK   ((((VALUE)1)<<CI_EMBED_ID_bits) - 1)
+#define CI_EMBED_ID_MASK   ((((uintptr_t)1)<<CI_EMBED_ID_bits) - 1)
 
 static inline bool
 vm_ci_packed_p(const struct rb_callinfo *ci)
@@ -104,7 +104,7 @@ vm_ci_packed_p(const struct rb_callinfo *ci)
     if (!USE_EMBED_CI) {
         return 0;
     }
-    if (LIKELY(((VALUE)ci) & 0x01)) {
+    if (LIKELY(((uintptr_t)ci) & 0x01)) {
         return 1;
     }
     else {
@@ -128,7 +128,7 @@ static inline ID
 vm_ci_mid(const struct rb_callinfo *ci)
 {
     if (vm_ci_packed_p(ci)) {
-        return (((VALUE)ci) >> CI_EMBED_ID_SHFT) & CI_EMBED_ID_MASK;
+        return (((uintptr_t)ci) >> CI_EMBED_ID_SHFT) & CI_EMBED_ID_MASK;
     }
     else {
         return (ID)ci->mid;
@@ -139,7 +139,7 @@ static inline unsigned int
 vm_ci_flag(const struct rb_callinfo *ci)
 {
     if (vm_ci_packed_p(ci)) {
-        return (unsigned int)((((VALUE)ci) >> CI_EMBED_FLAG_SHFT) & CI_EMBED_FLAG_MASK);
+        return (unsigned int)((((uintptr_t)ci) >> CI_EMBED_FLAG_SHFT) & CI_EMBED_FLAG_MASK);
     }
     else {
         return (unsigned int)ci->flag;
@@ -150,7 +150,7 @@ static inline unsigned int
 vm_ci_argc(const struct rb_callinfo *ci)
 {
     if (vm_ci_packed_p(ci)) {
-        return (unsigned int)((((VALUE)ci) >> CI_EMBED_ARGC_SHFT) & CI_EMBED_ARGC_MASK);
+        return (unsigned int)((((uintptr_t)ci) >> CI_EMBED_ARGC_SHFT) & CI_EMBED_ARGC_MASK);
     }
     else {
         return (unsigned int)ci->argc;
@@ -192,9 +192,9 @@ vm_ci_dump(const struct rb_callinfo *ci)
 
 #define vm_ci_new_id(mid, flag, argc, must_zero) \
     ((const struct rb_callinfo *)                \
-     ((((VALUE)(mid )) << CI_EMBED_ID_SHFT)   |  \
-      (((VALUE)(flag)) << CI_EMBED_FLAG_SHFT) |  \
-      (((VALUE)(argc)) << CI_EMBED_ARGC_SHFT) |  \
+     ((((uintptr_t)(mid )) << CI_EMBED_ID_SHFT)   |  \
+      (((uintptr_t)(flag)) << CI_EMBED_FLAG_SHFT) |  \
+      (((uintptr_t)(argc)) << CI_EMBED_ARGC_SHFT) |  \
       RUBY_FIXNUM_FLAG))
 
 // vm_method.c
@@ -271,7 +271,7 @@ typedef VALUE (*vm_call_handler)(
 // imemo_callcache
 
 struct rb_callcache {
-    const VALUE flags;
+    uintptr_t flags;
 
     /* inline cache: key */
     const VALUE klass; // should not mark it because klass can not be free'd
@@ -332,10 +332,10 @@ vm_cc_new(VALUE klass,
       case cc_type_normal:
         break;
       case cc_type_super:
-        *(VALUE *)&cc->flags |= VM_CALLCACHE_SUPER;
+        *(uintptr_t*)&cc->flags |= VM_CALLCACHE_SUPER;
         break;
       case cc_type_refinement:
-        *(VALUE *)&cc->flags |= VM_CALLCACHE_REFINEMENT;
+        *(uintptr_t*)&cc->flags |= VM_CALLCACHE_REFINEMENT;
         break;
     }
 
@@ -486,7 +486,7 @@ vm_cc_call_set(const struct rb_callcache *cc, vm_call_handler call)
 static inline void
 set_vm_cc_ivar(const struct rb_callcache *cc)
 {
-    *(VALUE *)&cc->flags |= VM_CALLCACHE_IVAR;
+    *(uintptr_t *)&cc->flags |= VM_CALLCACHE_IVAR;
 }
 
 static inline void
@@ -535,7 +535,7 @@ vm_cc_bf_set(const struct rb_callcache *cc, const struct rb_builtin_function *bf
     VM_ASSERT(IMEMO_TYPE_P(cc, imemo_callcache));
     VM_ASSERT(cc != vm_cc_empty());
     *(const struct rb_builtin_function **)&cc->aux_.bf = bf;
-    *(VALUE *)&cc->flags |= VM_CALLCACHE_BF;
+    *(uintptr_t *)&cc->flags |= VM_CALLCACHE_BF;
 }
 
 static inline bool
diff --git a/vm_core.h b/vm_core.h
index c29791a6c46d..b89e638c5f50 100644
--- a/vm_core.h
+++ b/vm_core.h
@@ -50,6 +50,7 @@
 #include <stddef.h>
 #include <signal.h>
 #include <stdarg.h>
+#include <stdfil.h>
 
 #include "ruby_assert.h"
 
@@ -137,7 +138,7 @@ extern int ruby_assert_critical_section_entered;
 #  define RUBY_SIGCHLD (SIGCHLD)
 #endif
 
-#if defined(SIGSEGV) && defined(HAVE_SIGALTSTACK) && defined(SA_SIGINFO) && !defined(__NetBSD__)
+#if defined(SIGSEGV) && defined(HAVE_SIGALTSTACK) && defined(SA_SIGINFO) && !defined(__NetBSD__) && !defined(__FILC__)
 #  define USE_SIGALTSTACK
 void *rb_allocate_sigaltstack(void);
 void *rb_register_sigaltstack(void *);
@@ -231,7 +232,7 @@ union ic_serial_entry {
 
 // imemo_constcache
 struct iseq_inline_constant_cache_entry {
-    VALUE flags;
+    uintptr_t flags;
 
     VALUE value;              // v0
     VALUE _unused1;           // v1
@@ -532,7 +533,7 @@ struct rb_iseq_constant_body {
 /* T_IMEMO/iseq */
 /* typedef rb_iseq_t is in method.h */
 struct rb_iseq_struct {
-    VALUE flags; /* 1 */
+    uintptr_t flags; /* 1 */
     VALUE wrapper; /* 2 */
 
     struct rb_iseq_constant_body *body;  /* 3 */
@@ -1297,8 +1298,8 @@ typedef VALUE CDHASH;
 typedef rb_control_frame_t *
   (FUNC_FASTCALL(*rb_insn_func_t))(rb_execution_context_t *, rb_control_frame_t *);
 
-#define VM_TAGGED_PTR_SET(p, tag)  ((VALUE)(p) | (tag))
-#define VM_TAGGED_PTR_REF(v, mask) ((void *)((v) & ~mask))
+#define VM_TAGGED_PTR_SET(p, tag)  (zorptr((VALUE)(p), (tag)))
+#define VM_TAGGED_PTR_REF(v, mask) ((void *)(zandptr((v),  ~mask)))
 
 #define GC_GUARDED_PTR(p)     VM_TAGGED_PTR_SET((p), 0x01)
 #define GC_GUARDED_PTR_REF(p) VM_TAGGED_PTR_REF((p), 0x03)
@@ -1355,19 +1356,19 @@ enum vm_frame_env_flags {
 static inline void VM_FORCE_WRITE_SPECIAL_CONST(const VALUE *ptr, VALUE special_const_value);
 
 static inline void
-VM_ENV_FLAGS_SET(const VALUE *ep, VALUE flag)
+VM_ENV_FLAGS_SET(const VALUE *ep, uintptr_t flag)
 {
     VALUE flags = ep[VM_ENV_DATA_INDEX_FLAGS];
     VM_ASSERT(FIXNUM_P(flags));
-    VM_FORCE_WRITE_SPECIAL_CONST(&ep[VM_ENV_DATA_INDEX_FLAGS], flags | flag);
+    VM_FORCE_WRITE_SPECIAL_CONST(&ep[VM_ENV_DATA_INDEX_FLAGS], zorptr(flags, flag));
 }
 
 static inline void
-VM_ENV_FLAGS_UNSET(const VALUE *ep, VALUE flag)
+VM_ENV_FLAGS_UNSET(const VALUE *ep, uintptr_t flag)
 {
     VALUE flags = ep[VM_ENV_DATA_INDEX_FLAGS];
     VM_ASSERT(FIXNUM_P(flags));
-    VM_FORCE_WRITE_SPECIAL_CONST(&ep[VM_ENV_DATA_INDEX_FLAGS], flags & ~flag);
+    VM_FORCE_WRITE_SPECIAL_CONST(&ep[VM_ENV_DATA_INDEX_FLAGS], zandptr(flags, ~flag));
 }
 
 static inline unsigned long
@@ -1375,7 +1376,7 @@ VM_ENV_FLAGS(const VALUE *ep, long flag)
 {
     VALUE flags = ep[VM_ENV_DATA_INDEX_FLAGS];
     VM_ASSERT(FIXNUM_P(flags));
-    return flags & flag;
+    return (uintptr_t)flags & flag;
 }
 
 static inline unsigned long
@@ -1553,7 +1554,7 @@ RUBY_VM_CONTROL_FRAME_STACK_OVERFLOW_P(const rb_execution_context_t *ec, const r
 static inline int
 VM_BH_ISEQ_BLOCK_P(VALUE block_handler)
 {
-    if ((block_handler & 0x03) == 0x01) {
+    if (((uintptr_t)block_handler & 0x03) == 0x01) {
 #if VM_CHECK_MODE > 0
         struct rb_captured_block *captured = VM_TAGGED_PTR_REF(block_handler, 0x03);
         VM_ASSERT(imemo_type_p(captured->code.val, imemo_iseq));
@@ -1584,7 +1585,7 @@ VM_BH_TO_ISEQ_BLOCK(VALUE block_handler)
 static inline int
 VM_BH_IFUNC_P(VALUE block_handler)
 {
-    if ((block_handler & 0x03) == 0x03) {
+    if (((uintptr_t)block_handler & 0x03) == 0x03) {
 #if VM_CHECK_MODE > 0
         struct rb_captured_block *captured = (void *)(block_handler & ~0x03);
         VM_ASSERT(imemo_type_p(captured->code.val, imemo_ifunc));
diff --git a/vm_eval.c b/vm_eval.c
index 937f0582c4a6..09a954916ede 100644
--- a/vm_eval.c
+++ b/vm_eval.c
@@ -164,7 +164,7 @@ vm_call0_cfunc_with_frame(rb_execution_context_t* ec, struct rb_calling_info *ca
     {
         rb_control_frame_t *reg_cfp = ec->cfp;
 
-        vm_push_frame(ec, 0, frame_flags, recv,
+        vm_push_frame(ec, 0, (VALUE)frame_flags, recv,
                       block_handler, (VALUE)me,
                       0, reg_cfp->sp, 0, 0);
 
@@ -327,7 +327,7 @@ vm_call0_body(rb_execution_context_t *ec, struct rb_calling_info *calling, const
 VALUE
 rb_vm_call_kw(rb_execution_context_t *ec, VALUE recv, VALUE id, int argc, const VALUE *argv, const rb_callable_method_entry_t *me, int kw_splat)
 {
-    return rb_vm_call0(ec, recv, id, argc, argv, me, kw_splat);
+    return rb_vm_call0(ec, recv, (ID)id, argc, argv, me, kw_splat);
 }
 
 static inline VALUE
@@ -351,7 +351,7 @@ vm_call_super(rb_execution_context_t *ec, int argc, const VALUE *argv, int kw_sp
     if (!me) {
         return method_missing(ec, recv, id, argc, argv, MISSING_SUPER, kw_splat);
     }
-    return rb_vm_call_kw(ec, recv, id, argc, argv, me, kw_splat);
+    return rb_vm_call_kw(ec, recv, (VALUE)id, argc, argv, me, kw_splat);
 }
 
 VALUE
@@ -442,10 +442,10 @@ cc_new(VALUE klass, ID mid, int argc, const rb_callable_method_entry_t *cme)
     return cc;
 }
 
-static VALUE
+static uintptr_t
 gccct_hash(VALUE klass, ID mid)
 {
-    return (klass >> 3) ^ (VALUE)mid;
+    return ((uintptr_t)klass >> 3) ^ (uintptr_t)mid;
 }
 
 NOINLINE(static const struct rb_callcache *gccct_method_search_slowpath(rb_vm_t *vm, VALUE klass, ID mid, int argc, unsigned int index));
@@ -557,7 +557,7 @@ rb_call0(rb_execution_context_t *ec,
         }
         else if (UNLIKELY(cc_cme != cme)) { // refinement is solved
             stack_check(ec);
-            return rb_vm_call_kw(ec, recv, mid, argc, argv, cme, kw_splat);
+            return rb_vm_call_kw(ec, recv, (VALUE)mid, argc, argv, cme, kw_splat);
         }
     }
     else {
@@ -710,7 +710,7 @@ rb_check_funcall_default_kw(VALUE recv, ID mid, int argc, const VALUE *argv, VAL
         return ret;
     }
     stack_check(ec);
-    return rb_vm_call_kw(ec, recv, mid, argc, argv, me, kw_splat);
+    return rb_vm_call_kw(ec, recv, (VALUE)mid, argc, argv, me, kw_splat);
 }
 
 VALUE
@@ -742,7 +742,7 @@ rb_check_funcall_with_hook_kw(VALUE recv, ID mid, int argc, const VALUE *argv,
     }
     stack_check(ec);
     (*hook)(TRUE, recv, mid, argc, argv, arg);
-    return rb_vm_call_kw(ec, recv, mid, argc, argv, me, kw_splat);
+    return rb_vm_call_kw(ec, recv, (VALUE)mid, argc, argv, me, kw_splat);
 }
 
 VALUE
@@ -793,7 +793,7 @@ rb_type_str(enum ruby_value_type type)
 static void
 uncallable_object(VALUE recv, ID mid)
 {
-    VALUE flags;
+    uintptr_t flags;
     int type;
     const char *typestr;
     VALUE mname = rb_id2str(mid);
@@ -1048,7 +1048,7 @@ method_missing(rb_execution_context_t *ec, VALUE obj, ID id, int argc, const VAL
     me = rb_callable_method_entry(klass, idMethodMissing);
     if (!me || METHOD_ENTRY_BASIC(me)) goto missing;
     vm_passed_block_handler_set(ec, block_handler);
-    result = rb_vm_call_kw(ec, obj, idMethodMissing, argc, argv, me, kw_splat);
+    result = rb_vm_call_kw(ec, obj, (VALUE)idMethodMissing, argc, argv, me, kw_splat);
     if (work) ALLOCV_END(work);
     return result;
   missing:
diff --git a/vm_insnhelper.c b/vm_insnhelper.c
index 1af20721a733..85533f640ab0 100644
--- a/vm_insnhelper.c
+++ b/vm_insnhelper.c
@@ -431,7 +431,7 @@ vm_pop_frame(rb_execution_context_t *ec, rb_control_frame_t *cfp, const VALUE *e
     RUBY_VM_CHECK_INTS(ec);
     ec->cfp = RUBY_VM_PREVIOUS_CONTROL_FRAME(cfp);
 
-    return flags & VM_FRAME_FLAG_FINISH;
+    return (uintptr_t)flags & VM_FRAME_FLAG_FINISH;
 }
 
 void
@@ -449,7 +449,7 @@ rb_vm_push_frame_fname(rb_execution_context_t *ec, VALUE fname)
 
     vm_push_frame(ec,
                   dmy_iseq, //const rb_iseq_t *iseq,
-                  VM_FRAME_MAGIC_DUMMY | VM_ENV_FLAG_LOCAL | VM_FRAME_FLAG_FINISH, // VALUE type,
+                  (VALUE)(VM_FRAME_MAGIC_DUMMY | VM_ENV_FLAG_LOCAL | VM_FRAME_FLAG_FINISH), // VALUE type,
                   ec->cfp->self, // VALUE self,
                   VM_BLOCK_HANDLER_NONE, // VALUE specval,
                   Qfalse, // VALUE cref_or_me,
@@ -503,7 +503,7 @@ static inline void
 vm_env_write(const VALUE *ep, int index, VALUE v)
 {
     VALUE flags = ep[VM_ENV_DATA_INDEX_FLAGS];
-    if (LIKELY((flags & VM_ENV_FLAG_WB_REQUIRED) == 0)) {
+    if (LIKELY(((uintptr_t)flags & VM_ENV_FLAG_WB_REQUIRED) == 0)) {
         VM_STACK_ENV_WRITE(ep, index, v);
     }
     else {
@@ -1058,14 +1058,14 @@ vm_get_ev_const(rb_execution_context_t *ec, VALUE orig_klass, ID id, bool allow_
                     if (UNDEF_P(val)) {
                         if (am == klass) break;
                         am = klass;
-                        if (is_defined) return 1;
+                        if (is_defined) return (VALUE)1;
                         if (rb_autoloading_value(klass, id, &av, NULL)) return av;
                         rb_autoload_load(klass, id);
                         goto search_continue;
                     }
                     else {
                         if (is_defined) {
-                            return 1;
+                            return (VALUE)1;
                         }
                         else {
                             if (UNLIKELY(!rb_ractor_main_p())) {
@@ -1090,7 +1090,7 @@ vm_get_ev_const(rb_execution_context_t *ec, VALUE orig_klass, ID id, bool allow_
         }
 
         if (is_defined) {
-            return rb_const_defined(klass, id);
+            return (VALUE)rb_const_defined(klass, id);
         }
         else {
             return rb_const_get(klass, id);
@@ -1099,7 +1099,7 @@ vm_get_ev_const(rb_execution_context_t *ec, VALUE orig_klass, ID id, bool allow_
     else {
         vm_check_if_namespace(orig_klass);
         if (is_defined) {
-            return rb_public_const_defined_from(orig_klass, id);
+            return (VALUE)rb_public_const_defined_from(orig_klass, id);
         }
         else {
             return rb_public_const_get_from(orig_klass, id);
@@ -1312,7 +1312,7 @@ vm_getivar(VALUE obj, ID id, const rb_iseq_t *iseq, IVC ic, const struct rb_call
               }
             }
 
-            if (!table || !st_lookup(table, id, &val)) {
+            if (!table || !st_lookup(table, (st_data_t)id, &val)) {
                 val = default_value;
             }
         }
@@ -1712,7 +1712,7 @@ vm_throw_start(const rb_execution_context_t *ec, rb_control_frame_t *const reg_c
             while (escape_cfp < eocfp) {
                 if (escape_cfp->ep == ep) {
                     const rb_iseq_t *const iseq = escape_cfp->iseq;
-                    const VALUE epc = escape_cfp->pc - ISEQ_BODY(iseq)->iseq_encoded;
+                    const VALUE epc = (VALUE)(escape_cfp->pc - ISEQ_BODY(iseq)->iseq_encoded);
                     const struct iseq_catch_table *const ct = ISEQ_BODY(iseq)->catch_table;
                     unsigned int i;
 
@@ -2303,8 +2303,8 @@ FIXNUM_2_P(VALUE a, VALUE b)
     /* FIXNUM_P(a) && FIXNUM_P(b)
      * == ((a & 1) && (b & 1))
      * == a & b & 1 */
-    SIGNED_VALUE x = a;
-    SIGNED_VALUE y = b;
+    SIGNED_VALUE x = (SIGNED_VALUE)a;
+    SIGNED_VALUE y = (SIGNED_VALUE)b;
     SIGNED_VALUE z = x & y & 1;
     return z == 1;
 }
@@ -2317,8 +2317,8 @@ FLONUM_2_P(VALUE a, VALUE b)
      * == ((a & 3) == 2) && ((b & 3) == 2)
      * == ! ((a ^ 2) | (b ^ 2) & 3)
      */
-    SIGNED_VALUE x = a;
-    SIGNED_VALUE y = b;
+    SIGNED_VALUE x = (SIGNED_VALUE)a;
+    SIGNED_VALUE y = (SIGNED_VALUE)b;
     SIGNED_VALUE z = ((x ^ 2) | (y ^ 2)) & 3;
     return !z;
 #else
@@ -3081,7 +3081,7 @@ vm_call_iseq_setup_normal(rb_execution_context_t *ec, rb_control_frame_t *cfp, s
     VALUE *sp = argv + param_size;
     cfp->sp = argv - 1 /* recv */;
 
-    vm_push_frame(ec, iseq, VM_FRAME_MAGIC_METHOD | VM_ENV_FLAG_LOCAL, calling->recv,
+    vm_push_frame(ec, iseq, (VALUE)(VM_FRAME_MAGIC_METHOD | VM_ENV_FLAG_LOCAL), calling->recv,
                   calling->block_handler, (VALUE)me,
                   ISEQ_BODY(iseq)->iseq_encoded + opt_pc, sp,
                   local_size - param_size,
@@ -3099,7 +3099,7 @@ vm_call_iseq_setup_tailcall(rb_execution_context_t *ec, rb_control_frame_t *cfp,
     const rb_iseq_t *iseq = def_iseq_ptr(me->def);
     VALUE *src_argv = argv;
     VALUE *sp_orig, *sp;
-    VALUE finish_flag = VM_FRAME_FINISHED_P(cfp) ? VM_FRAME_FLAG_FINISH : 0;
+    uintptr_t finish_flag = VM_FRAME_FINISHED_P(cfp) ? VM_FRAME_FLAG_FINISH : 0;
 
     if (VM_BH_FROM_CFP_P(calling->block_handler, cfp)) {
         struct rb_captured_block *dst_captured = VM_CFP_TO_CAPTURED_BLOCK(RUBY_VM_PREVIOUS_CONTROL_FRAME(cfp));
@@ -3127,7 +3127,7 @@ vm_call_iseq_setup_tailcall(rb_execution_context_t *ec, rb_control_frame_t *cfp,
         *sp++ = src_argv[i];
     }
 
-    vm_push_frame(ec, iseq, VM_FRAME_MAGIC_METHOD | VM_ENV_FLAG_LOCAL | finish_flag,
+vm_push_frame(ec, iseq, (VALUE)(VM_FRAME_MAGIC_METHOD | VM_ENV_FLAG_LOCAL | finish_flag),
                   calling->recv, calling->block_handler, (VALUE)me,
                   ISEQ_BODY(iseq)->iseq_encoded + opt_pc, sp,
                   ISEQ_BODY(iseq)->local_table_size - ISEQ_BODY(iseq)->param.size,
@@ -3473,7 +3473,7 @@ vm_call_cfunc_with_frame_(rb_execution_context_t *ec, rb_control_frame_t *reg_cf
 
     VALUE recv = calling->recv;
     VALUE block_handler = calling->block_handler;
-    VALUE frame_type = VM_FRAME_MAGIC_CFUNC | VM_FRAME_FLAG_CFRAME | VM_ENV_FLAG_LOCAL;
+    uintptr_t frame_type = VM_FRAME_MAGIC_CFUNC | VM_FRAME_FLAG_CFRAME | VM_ENV_FLAG_LOCAL;
 
     if (UNLIKELY(calling->kw_splat)) {
         frame_type |= VM_FRAME_FLAG_CFRAME_KW;
@@ -3484,7 +3484,7 @@ vm_call_cfunc_with_frame_(rb_execution_context_t *ec, rb_control_frame_t *reg_cf
     RUBY_DTRACE_CMETHOD_ENTRY_HOOK(ec, me->owner, me->def->original_id);
     EXEC_EVENT_HOOK(ec, RUBY_EVENT_C_CALL, recv, me->def->original_id, vm_ci_mid(ci), me->owner, Qundef);
 
-    vm_push_frame(ec, NULL, frame_type, recv,
+    vm_push_frame(ec, NULL, (VALUE)frame_type, recv,
                   block_handler, (VALUE)me,
                   0, ec->cfp->sp, 0, 0);
 
@@ -3699,7 +3699,7 @@ vm_call_bmethod_body(rb_execution_context_t *ec, struct rb_calling_info *calling
 }
 
 static int vm_callee_setup_block_arg(rb_execution_context_t *ec, struct rb_calling_info *calling, const struct rb_callinfo *ci, const rb_iseq_t *iseq, VALUE *argv, const enum arg_setup_type arg_setup_type);
-static VALUE invoke_bmethod(rb_execution_context_t *ec, const rb_iseq_t *iseq, VALUE self, const struct rb_captured_block *captured, const rb_callable_method_entry_t *me, VALUE type, int opt_pc);
+static VALUE invoke_bmethod(rb_execution_context_t *ec, const rb_iseq_t *iseq, VALUE self, const struct rb_captured_block *captured, const rb_callable_method_entry_t *me, uintptr_t type, int opt_pc);
 
 static VALUE
 vm_call_iseq_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp, struct rb_calling_info *calling)
@@ -3740,7 +3740,7 @@ vm_call_iseq_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp, struct
     cfp->sp = argv - 1; // -1 for the receiver
 
     vm_push_frame(ec, iseq,
-                  VM_FRAME_MAGIC_BLOCK | VM_FRAME_FLAG_BMETHOD | VM_FRAME_FLAG_LAMBDA,
+                  (VALUE)(VM_FRAME_MAGIC_BLOCK | VM_FRAME_FLAG_BMETHOD | VM_FRAME_FLAG_LAMBDA),
                   calling->recv,
                   VM_GUARDED_PREV_EP(captured->ep),
                   (VALUE)cme,
@@ -4780,7 +4780,7 @@ vm_yield_with_cfunc(rb_execution_context_t *ec,
     }
 
     vm_push_frame(ec, (const rb_iseq_t *)captured->code.ifunc,
-                  frame_flag,
+                  (VALUE)frame_flag,
                   self,
                   VM_GUARDED_PREV_EP(captured->ep),
                   (VALUE)me,
@@ -4905,7 +4905,7 @@ vm_invoke_iseq_block(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
     SET_SP(rsp);
 
     vm_push_frame(ec, iseq,
-                  VM_FRAME_MAGIC_BLOCK | (is_lambda ? VM_FRAME_FLAG_LAMBDA : 0),
+                  (VALUE)(VM_FRAME_MAGIC_BLOCK | (is_lambda ? VM_FRAME_FLAG_LAMBDA : 0)),
                   captured->self,
                   VM_GUARDED_PREV_EP(captured->ep), 0,
                   ISEQ_BODY(iseq)->iseq_encoded + opt_pc,
@@ -5850,7 +5850,7 @@ vm_ic_track_const_chain(rb_control_frame_t *cfp, IC ic, const ID *segments)
 
 // For RJIT inlining
 static inline bool
-vm_inlined_ic_hit_p(VALUE flags, VALUE value, const rb_cref_t *ic_cref, const VALUE *reg_ep)
+vm_inlined_ic_hit_p(uintptr_t flags, VALUE value, const rb_cref_t *ic_cref, const VALUE *reg_ep)
 {
     if ((flags & IMEMO_CONST_CACHE_SHAREABLE) || rb_ractor_main_p()) {
         VM_ASSERT(ractor_incidental_shareable_p(flags & IMEMO_CONST_CACHE_SHAREABLE, value));
@@ -6282,7 +6282,7 @@ vm_opt_and(VALUE recv, VALUE obj)
     // will be 1 on both.  1 & 1 == 1, so the result value will also
     // be a fixnum.  If either side is *not* a fixnum, then the tag bit
     // will be 0, and we return Qundef.
-    VALUE ret = ((SIGNED_VALUE) recv) & ((SIGNED_VALUE) obj);
+    VALUE ret = (VALUE)(((SIGNED_VALUE) recv) & ((SIGNED_VALUE) obj));
 
     if (FIXNUM_P(ret) &&
         BASIC_OP_UNREDEFINED_P(BOP_AND, INTEGER_REDEFINED_OP_FLAG)) {
@@ -6298,7 +6298,7 @@ vm_opt_or(VALUE recv, VALUE obj)
 {
     if (FIXNUM_2_P(recv, obj) &&
         BASIC_OP_UNREDEFINED_P(BOP_OR, INTEGER_REDEFINED_OP_FLAG)) {
-        return recv | obj;
+        return (VALUE)((uintptr_t)recv | (uintptr_t)obj);
     }
     else {
         return Qundef;
@@ -6419,9 +6419,9 @@ vm_opt_length(VALUE recv, int bop)
 static VALUE
 vm_opt_empty_p(VALUE recv)
 {
-    switch (vm_opt_length(recv, BOP_EMPTY_P)) {
-      case Qundef: return Qundef;
-      case INT2FIX(0): return Qtrue;
+    switch ((uintptr_t)vm_opt_length(recv, BOP_EMPTY_P)) {
+      case (uintptr_t)Qundef: return Qundef;
+      case (uintptr_t)INT2FIX(0): return Qtrue;
       default: return Qfalse;
     }
 }
@@ -6446,12 +6446,12 @@ vm_opt_nil_p(const rb_iseq_t *iseq, CALL_DATA cd, VALUE recv)
 static VALUE
 fix_succ(VALUE x)
 {
-    switch (x) {
-      case ~0UL:
+    switch ((uintptr_t)x) {
+      case (uintptr_t)~0UL:
         /* 0xFFFF_FFFF == INT2FIX(-1)
          * `-1.succ` is of course 0. */
         return INT2FIX(0);
-      case RSHIFT(~0UL, 1):
+      case (uintptr_t)RSHIFT(~0UL, 1):
         /* 0x7FFF_FFFF == LONG2FIX(0x3FFF_FFFF)
          * 0x3FFF_FFFF + 1 == 0x4000_0000, which is a Bignum. */
         return rb_uint2big(1UL << (SIZEOF_LONG * CHAR_BIT - 2));
diff --git a/vm_insnhelper.h b/vm_insnhelper.h
index e4a6c5b492ac..b3bb7a2498fb 100644
--- a/vm_insnhelper.h
+++ b/vm_insnhelper.h
@@ -107,7 +107,7 @@ enum vm_regan_acttype {
 /* deal with variables                                    */
 /**********************************************************/
 
-#define GET_PREV_EP(ep)                ((VALUE *)((ep)[VM_ENV_DATA_INDEX_SPECVAL] & ~0x03))
+#define GET_PREV_EP(ep)                ((VALUE *)((uintptr_t)(ep)[VM_ENV_DATA_INDEX_SPECVAL] & ~0x03))
 
 /**********************************************************/
 /* deal with values                                       */
@@ -224,6 +224,246 @@ THROW_DATA_CATCH_FRAME_SET(struct vm_throw_data *obj, const rb_control_frame_t *
 
 static inline void
 THROW_DATA_STATE_SET(struct vm_throw_data *obj, int st)
+#ifndef INTERNAL_IMEMO_H                                 /*-*-C-*-vi:se ft=c:*/
+#define INTERNAL_IMEMO_H
+/**
+ * @author     Ruby developers <ruby-core@ruby-lang.org>
+ * @copyright  This  file  is   a  part  of  the   programming  language  Ruby.
+ *             Permission  is hereby  granted,  to  either redistribute  and/or
+ *             modify this file, provided that  the conditions mentioned in the
+ *             file COPYING are met.  Consult the file for details.
+ * @brief      IMEMO: Internal memo object.
+ */
+#include "ruby/internal/config.h"
+#include <stddef.h>             /* for size_t */
+#include "internal/array.h"     /* for rb_ary_hidden_new_fill */
+#include "ruby/internal/stdbool.h"     /* for bool */
+#include "ruby/ruby.h"          /* for rb_block_call_func_t */
+
+#ifndef IMEMO_DEBUG
+# define IMEMO_DEBUG 0
+#endif
+
+#define IMEMO_MASK   0x0f
+
+/* FL_USER0 to FL_USER3 is for type */
+#define IMEMO_FL_USHIFT (FL_USHIFT + 4)
+#define IMEMO_FL_USER0 FL_USER4
+#define IMEMO_FL_USER1 FL_USER5
+#define IMEMO_FL_USER2 FL_USER6
+#define IMEMO_FL_USER3 FL_USER7
+#define IMEMO_FL_USER4 FL_USER8
+#define IMEMO_FL_USER5 FL_USER9
+
+enum imemo_type {
+    imemo_env            =  0,
+    imemo_cref           =  1, /*!< class reference */
+    imemo_svar           =  2, /*!< special variable */
+    imemo_throw_data     =  3,
+    imemo_ifunc          =  4, /*!< iterator function */
+    imemo_memo           =  5,
+    imemo_ment           =  6,
+    imemo_iseq           =  7,
+    imemo_tmpbuf         =  8,
+    imemo_ast            =  9,
+    imemo_parser_strterm = 10,
+    imemo_callinfo       = 11,
+    imemo_callcache      = 12,
+    imemo_constcache     = 13,
+};
+
+/* CREF (Class REFerence) is defined in method.h */
+
+/*! SVAR (Special VARiable) */
+struct vm_svar {
+    VALUE flags;
+    const VALUE cref_or_me; /*!< class reference or rb_method_entry_t */
+    const VALUE lastline;
+    const VALUE backref;
+    const VALUE others;
+};
+
+/*! THROW_DATA */
+struct vm_throw_data {
+    uintptr_t flags;
+    VALUE reserved;
+    const VALUE throw_obj;
+    const struct rb_control_frame_struct *catch_frame;
+    int throw_state;
+};
+
+#define THROW_DATA_CONSUMED IMEMO_FL_USER0
+
+/* IFUNC (Internal FUNCtion) */
+
+struct vm_ifunc_argc {
+#if SIZEOF_INT * 2 > SIZEOF_VALUE
+    signed int min: (SIZEOF_VALUE * CHAR_BIT) / 2;
+    signed int max: (SIZEOF_VALUE * CHAR_BIT) / 2;
+#else
+    int min, max;
+#endif
+};
+
+/*! IFUNC (Internal FUNCtion) */
+struct vm_ifunc {
+    VALUE flags;
+    VALUE *svar_lep;
+    rb_block_call_func_t func;
+    const void *data;
+    struct vm_ifunc_argc argc;
+};
+
+struct rb_imemo_tmpbuf_struct {
+    VALUE flags;
+    VALUE reserved;
+    VALUE *ptr; /* malloc'ed buffer */
+    struct rb_imemo_tmpbuf_struct *next; /* next imemo */
+    size_t cnt; /* buffer size in VALUE */
+};
+
+/*! MEMO
+ *
+ * @see imemo_type
+ * */
+struct MEMO {
+    uintptr_t flags;
+    VALUE reserved;
+    const VALUE v1;
+    const VALUE v2;
+    union {
+        long cnt;
+        long state;
+        const VALUE value;
+        void (*func)(void);
+    } u3;
+};
+
+/* ment is in method.h */
+
+#define THROW_DATA_P(err) imemo_throw_data_p((VALUE)err)
+#define MEMO_CAST(m) ((struct MEMO *)(m))
+#define MEMO_NEW(a, b, c) ((struct MEMO *)rb_imemo_new(imemo_memo, (VALUE)(a), (VALUE)(b), (VALUE)(c), 0))
+#define MEMO_FOR(type, value) ((type *)RARRAY_PTR(value))
+#define NEW_MEMO_FOR(type, value) \
+  ((value) = rb_ary_hidden_new_fill(type_roomof(type, VALUE)), MEMO_FOR(type, value))
+#define NEW_PARTIAL_MEMO_FOR(type, value, member) \
+  ((value) = rb_ary_hidden_new_fill(type_roomof(type, VALUE)), \
+   rb_ary_set_len((value), offsetof(type, member) / sizeof(VALUE)), \
+   MEMO_FOR(type, value))
+
+typedef struct rb_imemo_tmpbuf_struct rb_imemo_tmpbuf_t;
+rb_imemo_tmpbuf_t *rb_imemo_tmpbuf_parser_heap(void *buf, rb_imemo_tmpbuf_t *old_heap, size_t cnt);
+struct vm_ifunc *rb_vm_ifunc_new(rb_block_call_func_t func, const void *data, int min_argc, int max_argc);
+static inline enum imemo_type imemo_type(VALUE imemo);
+static inline int imemo_type_p(VALUE imemo, enum imemo_type imemo_type);
+static inline bool imemo_throw_data_p(VALUE imemo);
+static inline struct vm_ifunc *rb_vm_ifunc_proc_new(rb_block_call_func_t func, const void *data);
+static inline VALUE rb_imemo_tmpbuf_auto_free_pointer(void);
+static inline void *RB_IMEMO_TMPBUF_PTR(VALUE v);
+static inline void *rb_imemo_tmpbuf_set_ptr(VALUE v, void *ptr);
+static inline VALUE rb_imemo_tmpbuf_auto_free_pointer_new_from_an_RString(VALUE str);
+static inline void MEMO_V1_SET(struct MEMO *m, VALUE v);
+static inline void MEMO_V2_SET(struct MEMO *m, VALUE v);
+
+RUBY_SYMBOL_EXPORT_BEGIN
+#if IMEMO_DEBUG
+VALUE rb_imemo_new_debug(enum imemo_type type, VALUE v1, VALUE v2, VALUE v3, VALUE v0, const char *file, int line);
+#define rb_imemo_new(type, v1, v2, v3, v0) rb_imemo_new_debug(type, v1, v2, v3, v0, __FILE__, __LINE__)
+#else
+VALUE rb_imemo_new(enum imemo_type type, VALUE v1, VALUE v2, VALUE v3, VALUE v0);
+#endif
+const char *rb_imemo_name(enum imemo_type type);
+RUBY_SYMBOL_EXPORT_END
+
+static inline enum imemo_type
+imemo_type(VALUE imemo)
+{
+    return (RBASIC(imemo)->flags >> FL_USHIFT) & IMEMO_MASK;
+}
+
+static inline int
+imemo_type_p(VALUE imemo, enum imemo_type imemo_type)
+{
+    if (LIKELY(!RB_SPECIAL_CONST_P(imemo))) {
+        /* fixed at compile time if imemo_type is given. */
+        const uintptr_t mask = (IMEMO_MASK << FL_USHIFT) | RUBY_T_MASK;
+        const uintptr_t expected_type = (imemo_type << FL_USHIFT) | T_IMEMO;
+        /* fixed at runtime. */
+        return expected_type == (RBASIC(imemo)->flags & mask);
+    }
+    else {
+        return 0;
+    }
+}
+
+#define IMEMO_TYPE_P(v, t) imemo_type_p((VALUE)v, t)
+
+static inline bool
+imemo_throw_data_p(VALUE imemo)
+{
+    return RB_TYPE_P(imemo, T_IMEMO);
+}
+
+static inline struct vm_ifunc *
+rb_vm_ifunc_proc_new(rb_block_call_func_t func, const void *data)
+{
+    return rb_vm_ifunc_new(func, data, 0, UNLIMITED_ARGUMENTS);
+}
+
+static inline VALUE
+rb_imemo_tmpbuf_auto_free_pointer(void)
+{
+    return rb_imemo_new(imemo_tmpbuf, 0, 0, 0, 0);
+}
+
+static inline void *
+RB_IMEMO_TMPBUF_PTR(VALUE v)
+{
+    const struct rb_imemo_tmpbuf_struct *p = (const void *)v;
+    return p->ptr;
+}
+
+static inline void *
+rb_imemo_tmpbuf_set_ptr(VALUE v, void *ptr)
+{
+    return ((rb_imemo_tmpbuf_t *)v)->ptr = ptr;
+}
+
+static inline VALUE
+rb_imemo_tmpbuf_auto_free_pointer_new_from_an_RString(VALUE str)
+{
+    const void *src;
+    VALUE imemo;
+    rb_imemo_tmpbuf_t *tmpbuf;
+    void *dst;
+    size_t len;
+
+    SafeStringValue(str);
+    /* create tmpbuf to keep the pointer before xmalloc */
+    imemo = rb_imemo_tmpbuf_auto_free_pointer();
+    tmpbuf = (rb_imemo_tmpbuf_t *)imemo;
+    len = RSTRING_LEN(str);
+    src = RSTRING_PTR(str);
+    dst = ruby_xmalloc(len);
+    memcpy(dst, src, len);
+    tmpbuf->ptr = dst;
+    return imemo;
+}
+
+static inline void
+MEMO_V1_SET(struct MEMO *m, VALUE v)
+{
+    RB_OBJ_WRITE(m, &m->v1, v);
+}
+
+static inline void
+MEMO_V2_SET(struct MEMO *m, VALUE v)
+{
+    RB_OBJ_WRITE(m, &m->v2, v);
+}
+
+#endif /* INTERNAL_IMEMO_H */
 {
     VM_ASSERT(THROW_DATA_P(obj));
     obj->throw_state = st;
diff --git a/vm_method.c b/vm_method.c
index d09c7aab9b6e..1f67d52d4542 100644
--- a/vm_method.c
+++ b/vm_method.c
@@ -300,10 +300,10 @@ rb_clear_method_cache(VALUE klass_or_module, ID mid)
         if (FL_TEST(module, RMODULE_IS_REFINEMENT)) {
             VALUE refined_class = rb_refinement_module_get_refined_class(module);
             rb_clear_method_cache(refined_class, mid);
-            rb_class_foreach_subclass(refined_class, clear_iclass_method_cache_by_id_for_refinements, mid);
+            rb_class_foreach_subclass(refined_class, clear_iclass_method_cache_by_id_for_refinements, (VALUE)mid);
             rb_clear_all_refinement_method_cache();
         }
-        rb_class_foreach_subclass(module, clear_iclass_method_cache_by_id, mid);
+        rb_class_foreach_subclass(module, clear_iclass_method_cache_by_id, (VALUE)mid);
     }
     else {
         clear_method_cache_by_id_in_class(klass_or_module, mid);
@@ -347,7 +347,7 @@ vm_ci_hash(VALUE v)
     h = rb_hash_uint(h, ci->argc);
     if (ci->kwarg) {
         for (int i = 0; i < ci->kwarg->keyword_len; i++) {
-            h = rb_hash_uint(h, ci->kwarg->keywords[i]);
+            h = (st_index_t)rb_hash_uint(h, (uintptr_t)ci->kwarg->keywords[i]);
         }
     }
     return h;
@@ -2358,7 +2358,7 @@ rb_mod_alias_method(VALUE mod, VALUE newname, VALUE oldname)
     if (!oldid) {
         rb_print_undef_str(mod, oldname);
     }
-    VALUE id = rb_to_id(newname);
+    ID id = rb_to_id(newname);
     rb_alias(mod, id, oldid);
     return ID2SYM(id);
 }
@@ -2830,7 +2830,7 @@ call_method_entry(rb_execution_context_t *ec, VALUE defined_class, VALUE obj, ID
                   const rb_callable_method_entry_t *cme, int argc, const VALUE *argv, int kw_splat)
 {
     VALUE passed_block_handler = vm_passed_block_handler(ec);
-    VALUE result = rb_vm_call_kw(ec, obj, id, argc, argv, cme, kw_splat);
+    VALUE result = rb_vm_call_kw(ec, obj, (VALUE)id, argc, argv, cme, kw_splat);
     vm_passed_block_handler_set(ec, passed_block_handler);
     return result;
 }
diff --git a/vsnprintf.c b/vsnprintf.c
index ecd5573dd581..c5fe06cf7de1 100644
--- a/vsnprintf.c
+++ b/vsnprintf.c
@@ -551,6 +551,7 @@ BSD_vfprintf(FILE *fp, const char *fmt0, va_list ap)
 	char expstr[7];		/* buffer for exponent string */
 #endif
 	u_long MAYBE_UNUSED(ulval) = 0; /* integer arguments %[diouxX] */
+        void *MAYBE_UNUSED(pval) = NULL;
 #ifdef _HAVE_SANE_QUAD_
 	u_quad_t MAYBE_UNUSED(uqval) = 0; /* %q integers */
 #endif /* _HAVE_SANE_QUAD_ */
@@ -822,7 +823,10 @@ reswitch:	switch (ch) {
 			    IS_PRI_EXTRA_MARK(fmt)) {
 				fmt += PRI_EXTRA_MARK_LEN;
 				FLUSH();
-#if defined _HAVE_SANE_QUAD_ && SIZEOF_VOIDP == SIZEOF_LONG_LONG
+#if defined __FILC__
+                                pval = va_arg(ap, void*);
+				cp = (*fp->vextra)(fp, sizeof(pval), &pval, &fieldsz, sign);
+#elif defined _HAVE_SANE_QUAD_ && SIZEOF_VOIDP == SIZEOF_LONG_LONG
 				uqval = va_arg(ap, u_quad_t);
 				cp = (*fp->vextra)(fp, sizeof(uqval), &uqval, &fieldsz, sign);
 #else
