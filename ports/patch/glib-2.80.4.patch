diff --git a/gio/gdbus-2.0/codegen/codegen.py b/gio/gdbus-2.0/codegen/codegen.py
index 2e8ef8e2ac1e..3c60e3889030 100644
--- a/gio/gdbus-2.0/codegen/codegen.py
+++ b/gio/gdbus-2.0/codegen/codegen.py
@@ -114,6 +114,7 @@ class HeaderCodeGenerator:
 
         self.outfile.write("\n")
         self.outfile.write("#include <gio/gio.h>\n")
+        self.outfile.write("#include <inttypes.h>\n")
         self.outfile.write("\n")
         self.outfile.write("G_BEGIN_DECLS\n")
         self.outfile.write("\n")
@@ -1654,27 +1655,27 @@ class CodeGenerator:
             "{\n"
             "  gboolean ret = FALSE;\n"
             "  g_assert (G_VALUE_TYPE (a) == G_VALUE_TYPE (b));\n"
-            "  switch (G_VALUE_TYPE (a))\n"
+            "  switch ((uintptr_t) G_VALUE_TYPE (a))\n"
             "    {\n"
-            "      case G_TYPE_BOOLEAN:\n"
+            "      case (uintptr_t) G_TYPE_BOOLEAN:\n"
             "        ret = (g_value_get_boolean (a) == g_value_get_boolean (b));\n"
             "        break;\n"
-            "      case G_TYPE_UCHAR:\n"
+            "      case (uintptr_t) G_TYPE_UCHAR:\n"
             "        ret = (g_value_get_uchar (a) == g_value_get_uchar (b));\n"
             "        break;\n"
-            "      case G_TYPE_INT:\n"
+            "      case (uintptr_t) G_TYPE_INT:\n"
             "        ret = (g_value_get_int (a) == g_value_get_int (b));\n"
             "        break;\n"
-            "      case G_TYPE_UINT:\n"
+            "      case (uintptr_t) G_TYPE_UINT:\n"
             "        ret = (g_value_get_uint (a) == g_value_get_uint (b));\n"
             "        break;\n"
-            "      case G_TYPE_INT64:\n"
+            "      case (uintptr_t) G_TYPE_INT64:\n"
             "        ret = (g_value_get_int64 (a) == g_value_get_int64 (b));\n"
             "        break;\n"
-            "      case G_TYPE_UINT64:\n"
+            "      case (uintptr_t) G_TYPE_UINT64:\n"
             "        ret = (g_value_get_uint64 (a) == g_value_get_uint64 (b));\n"
             "        break;\n"
-            "      case G_TYPE_DOUBLE:\n"
+            "      case (uintptr_t) G_TYPE_DOUBLE:\n"
             "        {\n"
             "          /* Avoid -Wfloat-equal warnings by doing a direct bit compare */\n"
             "          gdouble da = g_value_get_double (a);\n"
@@ -1682,10 +1683,10 @@ class CodeGenerator:
             "          ret = memcmp (&da, &db, sizeof (gdouble)) == 0;\n"
             "        }\n"
             "        break;\n"
-            "      case G_TYPE_STRING:\n"
+            "      case (uintptr_t) G_TYPE_STRING:\n"
             "        ret = (g_strcmp0 (g_value_get_string (a), g_value_get_string (b)) == 0);\n"
             "        break;\n"
-            "      case G_TYPE_VARIANT:\n"
+            "      case (uintptr_t) G_TYPE_VARIANT:\n"
             "        ret = _g_variant_equal0 (g_value_get_variant (a), g_value_get_variant (b));\n"
             "        break;\n"
             "      default:\n"
diff --git a/gio/gdbusproxy.c b/gio/gdbusproxy.c
index 5d9a637c3556..193171fd6b4a 100644
--- a/gio/gdbusproxy.c
+++ b/gio/gdbusproxy.c
@@ -45,6 +45,7 @@
 
 #include "glibintl.h"
 #include "gmarshal-internal.h"
+#include <inttypes.h>
 
 /**
  * GDBusProxy:
@@ -565,7 +566,7 @@ g_dbus_proxy_class_init (GDBusProxyClass *klass)
                                                      G_TYPE_NONE,
                                                      2,
                                                      G_TYPE_VARIANT,
-                                                     G_TYPE_STRV | G_SIGNAL_TYPE_STATIC_SCOPE);
+                                                     (GType) ((uintptr_t) G_TYPE_STRV | (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE));
   g_signal_set_va_marshaller (signals[PROPERTIES_CHANGED_SIGNAL],
                               G_TYPE_FROM_CLASS (klass),
                               _g_cclosure_marshal_VOID__VARIANT_BOXEDv);
diff --git a/gio/gmarshal-internal.c b/gio/gmarshal-internal.c
index 9ef05cd6ab32..6682c78bcf7c 100644
--- a/gio/gmarshal-internal.c
+++ b/gio/gmarshal-internal.c
@@ -20,6 +20,7 @@
 
 #include <glib-object.h>
 #include "gmarshal-internal.h"
+#include <inttypes.h>
 
 #ifdef G_ENABLE_DEBUG
 #define g_marshal_value_peek_boolean(v)  g_value_get_boolean (v)
@@ -496,7 +497,7 @@ _g_cclosure_marshal_BOOLEAN__STRINGv (GClosure *closure,
 
   va_copy (args_copy, args);
   arg0 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     arg0 = g_strdup (arg0);
   va_end (args_copy);
 
@@ -515,7 +516,7 @@ _g_cclosure_marshal_BOOLEAN__STRINGv (GClosure *closure,
   v_return = callback (data1,
                        arg0,
                        data2);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     g_free (arg0);
 
   g_value_set_boolean (return_value, v_return);
@@ -739,8 +740,8 @@ _g_cclosure_marshal_INT__BOXEDv (GClosure *closure,
 
   va_copy (args_copy, args);
   arg0 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
-    arg0 = g_boxed_copy (param_types[0] & ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+    arg0 = g_boxed_copy ((GType) ((uintptr_t) param_types[0] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE), arg0);
   va_end (args_copy);
 
   g_return_if_fail (return_value != NULL);
@@ -760,8 +761,8 @@ _g_cclosure_marshal_INT__BOXEDv (GClosure *closure,
   v_return = callback (data1,
                        arg0,
                        data2);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
-    g_boxed_free (param_types[0] & ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+    g_boxed_free ((GType) ((uintptr_t) param_types[0] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE), arg0);
 
   g_value_set_int (return_value, v_return);
 }
@@ -913,8 +914,8 @@ _g_cclosure_marshal_VOID__BOOLEAN_BOXEDv (GClosure *closure,
   va_copy (args_copy, args);
   arg0 = (gboolean) va_arg (args_copy, gboolean);
   arg1 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[1] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
-    arg1 = g_boxed_copy (param_types[1] & ~G_SIGNAL_TYPE_STATIC_SCOPE, arg1);
+  if (((uintptr_t) param_types[1] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
+    arg1 = g_boxed_copy ((GType) ((uintptr_t) param_types[1] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE), arg1);
   va_end (args_copy);
 
 
@@ -934,8 +935,8 @@ _g_cclosure_marshal_VOID__BOOLEAN_BOXEDv (GClosure *closure,
             arg0,
             arg1,
             data2);
-  if ((param_types[1] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
-    g_boxed_free (param_types[1] & ~G_SIGNAL_TYPE_STATIC_SCOPE, arg1);
+  if (((uintptr_t) param_types[1] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
+    g_boxed_free ((GType) ((uintptr_t) param_types[1] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE), arg1);
 }
 
 /* VOID:ENUM,OBJECT */
@@ -1467,13 +1468,13 @@ _g_cclosure_marshal_VOID__OBJECT_OBJECT_STRING_STRING_VARIANTv (GClosure *closur
   if (arg1 != NULL)
     arg1 = g_object_ref (arg1);
   arg2 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[2] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
+  if (((uintptr_t) param_types[2] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
     arg2 = g_strdup (arg2);
   arg3 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[3] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg3 != NULL)
+  if (((uintptr_t) param_types[3] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg3 != NULL)
     arg3 = g_strdup (arg3);
   arg4 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[4] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg4 != NULL)
+  if (((uintptr_t) param_types[4] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg4 != NULL)
     arg4 = g_variant_ref_sink (arg4);
   va_end (args_copy);
 
@@ -1501,11 +1502,11 @@ _g_cclosure_marshal_VOID__OBJECT_OBJECT_STRING_STRING_VARIANTv (GClosure *closur
     g_object_unref (arg0);
   if (arg1 != NULL)
     g_object_unref (arg1);
-  if ((param_types[2] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
+  if (((uintptr_t) param_types[2] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
     g_free (arg2);
-  if ((param_types[3] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg3 != NULL)
+  if (((uintptr_t) param_types[3] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg3 != NULL)
     g_free (arg3);
-  if ((param_types[4] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg4 != NULL)
+  if (((uintptr_t) param_types[4] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg4 != NULL)
     g_variant_unref (arg4);
 }
 
@@ -1582,11 +1583,11 @@ _g_cclosure_marshal_VOID__OBJECT_OBJECT_VARIANT_BOXEDv (GClosure *closure,
   if (arg1 != NULL)
     arg1 = g_object_ref (arg1);
   arg2 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[2] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
+  if (((uintptr_t) param_types[2] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
     arg2 = g_variant_ref_sink (arg2);
   arg3 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[3] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg3 != NULL)
-    arg3 = g_boxed_copy (param_types[3] & ~G_SIGNAL_TYPE_STATIC_SCOPE, arg3);
+  if (((uintptr_t) param_types[3] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg3 != NULL)
+    arg3 = g_boxed_copy ((GType) ((uintptr_t) param_types[3] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE), arg3);
   va_end (args_copy);
 
 
@@ -1612,10 +1613,10 @@ _g_cclosure_marshal_VOID__OBJECT_OBJECT_VARIANT_BOXEDv (GClosure *closure,
     g_object_unref (arg0);
   if (arg1 != NULL)
     g_object_unref (arg1);
-  if ((param_types[2] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
+  if (((uintptr_t) param_types[2] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
     g_variant_unref (arg2);
-  if ((param_types[3] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg3 != NULL)
-    g_boxed_free (param_types[3] & ~G_SIGNAL_TYPE_STATIC_SCOPE, arg3);
+  if (((uintptr_t) param_types[3] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg3 != NULL)
+    g_boxed_free ((GType) ((uintptr_t) param_types[3] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE), arg3);
 }
 
 /* VOID:OBJECT,VARIANT */
@@ -1680,7 +1681,7 @@ _g_cclosure_marshal_VOID__OBJECT_VARIANTv (GClosure *closure,
   if (arg0 != NULL)
     arg0 = g_object_ref (arg0);
   arg1 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[1] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
+  if (((uintptr_t) param_types[1] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
     arg1 = g_variant_ref_sink (arg1);
   va_end (args_copy);
 
@@ -1703,7 +1704,7 @@ _g_cclosure_marshal_VOID__OBJECT_VARIANTv (GClosure *closure,
             data2);
   if (arg0 != NULL)
     g_object_unref (arg0);
-  if ((param_types[1] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
+  if (((uintptr_t) param_types[1] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
     g_variant_unref (arg1);
 }
 
@@ -1772,7 +1773,7 @@ _g_cclosure_marshal_VOID__POINTER_INT_STRINGv (GClosure *closure,
   arg0 = (gpointer) va_arg (args_copy, gpointer);
   arg1 = (gint) va_arg (args_copy, gint);
   arg2 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[2] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
+  if (((uintptr_t) param_types[2] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
     arg2 = g_strdup (arg2);
   va_end (args_copy);
 
@@ -1794,7 +1795,7 @@ _g_cclosure_marshal_VOID__POINTER_INT_STRINGv (GClosure *closure,
             arg1,
             arg2,
             data2);
-  if ((param_types[2] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
+  if (((uintptr_t) param_types[2] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
     g_free (arg2);
 }
 
@@ -1857,7 +1858,7 @@ _g_cclosure_marshal_VOID__STRING_BOOLEANv (GClosure *closure,
 
   va_copy (args_copy, args);
   arg0 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     arg0 = g_strdup (arg0);
   arg1 = (gboolean) va_arg (args_copy, gboolean);
   va_end (args_copy);
@@ -1879,7 +1880,7 @@ _g_cclosure_marshal_VOID__STRING_BOOLEANv (GClosure *closure,
             arg0,
             arg1,
             data2);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     g_free (arg0);
 }
 
@@ -1942,11 +1943,11 @@ _g_cclosure_marshal_VOID__STRING_BOXEDv (GClosure *closure,
 
   va_copy (args_copy, args);
   arg0 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     arg0 = g_strdup (arg0);
   arg1 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[1] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
-    arg1 = g_boxed_copy (param_types[1] & ~G_SIGNAL_TYPE_STATIC_SCOPE, arg1);
+  if (((uintptr_t) param_types[1] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
+    arg1 = g_boxed_copy ((GType) ((uintptr_t) param_types[1] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE), arg1);
   va_end (args_copy);
 
 
@@ -1966,10 +1967,10 @@ _g_cclosure_marshal_VOID__STRING_BOXEDv (GClosure *closure,
             arg0,
             arg1,
             data2);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     g_free (arg0);
-  if ((param_types[1] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
-    g_boxed_free (param_types[1] & ~G_SIGNAL_TYPE_STATIC_SCOPE, arg1);
+  if (((uintptr_t) param_types[1] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
+    g_boxed_free ((GType) ((uintptr_t) param_types[1] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE), arg1);
 }
 
 /* VOID:STRING,BOXED,BOXED */
@@ -2035,14 +2036,14 @@ _g_cclosure_marshal_VOID__STRING_BOXED_BOXEDv (GClosure *closure,
 
   va_copy (args_copy, args);
   arg0 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     arg0 = g_strdup (arg0);
   arg1 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[1] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
-    arg1 = g_boxed_copy (param_types[1] & ~G_SIGNAL_TYPE_STATIC_SCOPE, arg1);
+  if (((uintptr_t) param_types[1] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
+    arg1 = g_boxed_copy ((GType) ((uintptr_t) param_types[1] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE), arg1);
   arg2 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[2] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
-    arg2 = g_boxed_copy (param_types[2] & ~G_SIGNAL_TYPE_STATIC_SCOPE, arg2);
+  if (((uintptr_t) param_types[2] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
+    arg2 = g_boxed_copy ((GType) ((uintptr_t) param_types[2] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE), arg2);
   va_end (args_copy);
 
 
@@ -2063,12 +2064,12 @@ _g_cclosure_marshal_VOID__STRING_BOXED_BOXEDv (GClosure *closure,
             arg1,
             arg2,
             data2);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     g_free (arg0);
-  if ((param_types[1] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
-    g_boxed_free (param_types[1] & ~G_SIGNAL_TYPE_STATIC_SCOPE, arg1);
-  if ((param_types[2] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
-    g_boxed_free (param_types[2] & ~G_SIGNAL_TYPE_STATIC_SCOPE, arg2);
+  if (((uintptr_t) param_types[1] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
+    g_boxed_free ((GType) ((uintptr_t) param_types[1] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE), arg1);
+  if (((uintptr_t) param_types[2] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
+    g_boxed_free ((GType) ((uintptr_t) param_types[2] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE), arg2);
 }
 
 /* VOID:STRING,INT64,INT64 */
@@ -2134,7 +2135,7 @@ _g_cclosure_marshal_VOID__STRING_INT64_INT64v (GClosure *closure,
 
   va_copy (args_copy, args);
   arg0 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     arg0 = g_strdup (arg0);
   arg1 = (gint64) va_arg (args_copy, gint64);
   arg2 = (gint64) va_arg (args_copy, gint64);
@@ -2158,7 +2159,7 @@ _g_cclosure_marshal_VOID__STRING_INT64_INT64v (GClosure *closure,
             arg1,
             arg2,
             data2);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     g_free (arg0);
 }
 
@@ -2229,13 +2230,13 @@ _g_cclosure_marshal_VOID__STRING_STRING_STRING_FLAGSv (GClosure *closure,
 
   va_copy (args_copy, args);
   arg0 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     arg0 = g_strdup (arg0);
   arg1 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[1] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
+  if (((uintptr_t) param_types[1] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
     arg1 = g_strdup (arg1);
   arg2 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[2] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
+  if (((uintptr_t) param_types[2] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
     arg2 = g_strdup (arg2);
   arg3 = (guint) va_arg (args_copy, guint);
   va_end (args_copy);
@@ -2259,11 +2260,11 @@ _g_cclosure_marshal_VOID__STRING_STRING_STRING_FLAGSv (GClosure *closure,
             arg2,
             arg3,
             data2);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     g_free (arg0);
-  if ((param_types[1] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
+  if (((uintptr_t) param_types[1] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
     g_free (arg1);
-  if ((param_types[2] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
+  if (((uintptr_t) param_types[2] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
     g_free (arg2);
 }
 
@@ -2330,13 +2331,13 @@ _g_cclosure_marshal_VOID__STRING_STRING_VARIANTv (GClosure *closure,
 
   va_copy (args_copy, args);
   arg0 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     arg0 = g_strdup (arg0);
   arg1 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[1] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
+  if (((uintptr_t) param_types[1] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
     arg1 = g_strdup (arg1);
   arg2 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[2] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
+  if (((uintptr_t) param_types[2] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
     arg2 = g_variant_ref_sink (arg2);
   va_end (args_copy);
 
@@ -2358,11 +2359,11 @@ _g_cclosure_marshal_VOID__STRING_STRING_VARIANTv (GClosure *closure,
             arg1,
             arg2,
             data2);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     g_free (arg0);
-  if ((param_types[1] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
+  if (((uintptr_t) param_types[1] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
     g_free (arg1);
-  if ((param_types[2] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
+  if (((uintptr_t) param_types[2] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg2 != NULL)
     g_variant_unref (arg2);
 }
 
@@ -2425,10 +2426,10 @@ _g_cclosure_marshal_VOID__STRING_VARIANTv (GClosure *closure,
 
   va_copy (args_copy, args);
   arg0 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     arg0 = g_strdup (arg0);
   arg1 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[1] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
+  if (((uintptr_t) param_types[1] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
     arg1 = g_variant_ref_sink (arg1);
   va_end (args_copy);
 
@@ -2449,9 +2450,9 @@ _g_cclosure_marshal_VOID__STRING_VARIANTv (GClosure *closure,
             arg0,
             arg1,
             data2);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     g_free (arg0);
-  if ((param_types[1] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
+  if (((uintptr_t) param_types[1] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
     g_variant_unref (arg1);
 }
 
@@ -2602,11 +2603,11 @@ _g_cclosure_marshal_VOID__VARIANT_BOXEDv (GClosure *closure,
 
   va_copy (args_copy, args);
   arg0 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     arg0 = g_variant_ref_sink (arg0);
   arg1 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[1] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
-    arg1 = g_boxed_copy (param_types[1] & ~G_SIGNAL_TYPE_STATIC_SCOPE, arg1);
+  if (((uintptr_t) param_types[1] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
+    arg1 = g_boxed_copy ((GType) ((uintptr_t) param_types[1] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE), arg1);
   va_end (args_copy);
 
 
@@ -2626,8 +2627,8 @@ _g_cclosure_marshal_VOID__VARIANT_BOXEDv (GClosure *closure,
             arg0,
             arg1,
             data2);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     g_variant_unref (arg0);
-  if ((param_types[1] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
-    g_boxed_free (param_types[1] & ~G_SIGNAL_TYPE_STATIC_SCOPE, arg1);
+  if (((uintptr_t) param_types[1] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
+    g_boxed_free ((GType) ((uintptr_t) param_types[1] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE), arg1);
 }
diff --git a/gio/gpropertyaction.c b/gio/gpropertyaction.c
index 6b671f54bf53..dd2f4c383fa6 100644
--- a/gio/gpropertyaction.c
+++ b/gio/gpropertyaction.c
@@ -26,6 +26,7 @@
 #include "gsettings-mapping.h"
 #include "gaction.h"
 #include "glibintl.h"
+#include <inttypes.h>
 
 /**
  * GPropertyAction:
@@ -258,22 +259,22 @@ g_property_action_determine_type (GParamSpec *pspec)
   if (G_TYPE_IS_ENUM (pspec->value_type))
     return G_VARIANT_TYPE_STRING;
 
-  switch (pspec->value_type)
+  switch ((uintptr_t) pspec->value_type)
     {
-    case G_TYPE_BOOLEAN:
+    case (uintptr_t) G_TYPE_BOOLEAN:
       return G_VARIANT_TYPE_BOOLEAN;
 
-    case G_TYPE_INT:
+    case (uintptr_t) G_TYPE_INT:
       return G_VARIANT_TYPE_INT32;
 
-    case G_TYPE_UINT:
+    case (uintptr_t) G_TYPE_UINT:
       return G_VARIANT_TYPE_UINT32;
 
-    case G_TYPE_DOUBLE:
-    case G_TYPE_FLOAT:
+    case (uintptr_t) G_TYPE_DOUBLE:
+    case (uintptr_t) G_TYPE_FLOAT:
       return G_VARIANT_TYPE_DOUBLE;
 
-    case G_TYPE_STRING:
+    case (uintptr_t) G_TYPE_STRING:
       return G_VARIANT_TYPE_STRING;
 
     default:
diff --git a/gio/gsettings.c b/gio/gsettings.c
index a14ba809481f..737377d14fce 100644
--- a/gio/gsettings.c
+++ b/gio/gsettings.c
@@ -35,6 +35,7 @@
 #include "gmarshal-internal.h"
 
 #include "strinfo.c"
+#include <inttypes.h>
 
 /**
  * GSettings:
@@ -738,7 +739,7 @@ g_settings_class_init (GSettingsClass *class)
                   G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
                   G_STRUCT_OFFSET (GSettingsClass, changed),
                   NULL, NULL, NULL, G_TYPE_NONE,
-                  1, G_TYPE_STRING | G_SIGNAL_TYPE_STATIC_SCOPE);
+                  1, (GType) ((uintptr_t)G_TYPE_STRING | (uintptr_t)G_SIGNAL_TYPE_STATIC_SCOPE));
 
   /**
    * GSettings::change-event:
@@ -795,7 +796,7 @@ g_settings_class_init (GSettingsClass *class)
                   G_SIGNAL_RUN_LAST | G_SIGNAL_DETAILED,
                   G_STRUCT_OFFSET (GSettingsClass, writable_changed),
                   NULL, NULL, NULL, G_TYPE_NONE,
-                  1, G_TYPE_STRING | G_SIGNAL_TYPE_STATIC_SCOPE);
+                  1, (GType) ((uintptr_t) G_TYPE_STRING | (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE));
 
   /**
    * GSettings::writable-change-event:
diff --git a/gio/tests/glistmodel.c b/gio/tests/glistmodel.c
index cd6ae91e2eb6..325fc0822be1 100644
--- a/gio/tests/glistmodel.c
+++ b/gio/tests/glistmodel.c
@@ -54,7 +54,7 @@ test_store_properties (void)
 
   store = g_list_store_new (G_TYPE_MENU_ITEM);
   g_object_get (store, "item-type", &item_type, NULL);
-  g_assert_cmpint (item_type, ==, G_TYPE_MENU_ITEM);
+  g_assert_cmpint ((uintptr_t) item_type, ==, (uintptr_t) G_TYPE_MENU_ITEM);
 
   g_clear_object (&store);
 }
diff --git a/gio/tests/meson.build b/gio/tests/meson.build
index 3bfb33307b20..69dfa7e96c18 100644
--- a/gio/tests/meson.build
+++ b/gio/tests/meson.build
@@ -940,7 +940,9 @@ if not meson.is_cross_build()
 
   ld = find_program('ld', required : false)
 
-  if build_machine.system() != 'linux'
+  if true
+    why_no_external_data = 'Fil-C'
+  elif build_machine.system() != 'linux'
     why_no_external_data = 'only works on Linux'
   elif not objcopy.found()
     why_no_external_data = 'objcopy not found'
diff --git a/girepository/gdump.c b/girepository/gdump.c
index 2388626d8434..13b8df2d9787 100644
--- a/girepository/gdump.c
+++ b/girepository/gdump.c
@@ -39,6 +39,7 @@
 #include <stdint.h>
 #include <stdio.h>
 #include <string.h>
+#include <inttypes.h>
 
 /* Analogue of g_output_stream_write_all(). */
 static gboolean
@@ -172,7 +173,7 @@ invoke_error_quark (GModule *self, const char *symbol, GError **error)
                    G_FILE_ERROR,
                    G_FILE_ERROR_FAILED,
                    "Failed to find symbol '%s'", symbol);
-      return G_TYPE_INVALID;
+      return 0;
     }
 
   return sym ();
@@ -221,23 +222,23 @@ value_to_string (const GValue *value)
     {
       GType value_type = G_VALUE_TYPE (value);
 
-      switch (G_TYPE_FUNDAMENTAL (value_type))
+      switch ((uintptr_t) G_TYPE_FUNDAMENTAL (value_type))
         {
-        case G_TYPE_BOXED:
+        case (uintptr_t) G_TYPE_BOXED:
           if (g_value_get_boxed (value) == NULL)
             return NULL;
           else
             return value_transform_to_string (value);
           break;
 
-        case G_TYPE_OBJECT:
+        case (uintptr_t) G_TYPE_OBJECT:
           if (g_value_get_object (value) == NULL)
             return NULL;
           else
             return value_transform_to_string (value);
           break;
 
-        case G_TYPE_POINTER:
+        case (uintptr_t) G_TYPE_POINTER:
           return NULL;
 
         default:
@@ -544,24 +545,24 @@ dump_fundamental_type (GType type, const char *symbol, FILE *out)
 static void
 dump_type (GType type, const char *symbol, FILE *out)
 {
-  switch (g_type_fundamental (type))
+  switch ((uintptr_t) g_type_fundamental (type))
     {
-    case G_TYPE_OBJECT:
+    case (uintptr_t) G_TYPE_OBJECT:
       dump_object_type (type, symbol, out);
       break;
-    case G_TYPE_INTERFACE:
+    case (uintptr_t) G_TYPE_INTERFACE:
       dump_interface_type (type, symbol, out);
       break;
-    case G_TYPE_BOXED:
+    case (uintptr_t) G_TYPE_BOXED:
       dump_boxed_type (type, symbol, out);
       break;
-    case G_TYPE_FLAGS:
+    case (uintptr_t) G_TYPE_FLAGS:
       dump_flags_type (type, symbol, out);
       break;
-    case G_TYPE_ENUM:
+    case (uintptr_t) G_TYPE_ENUM:
       dump_enum_type (type, symbol, out);
       break;
-    case G_TYPE_POINTER:
+    case (uintptr_t) G_TYPE_POINTER:
       /* GValue, etc.  Just skip them. */
       break;
     default:
diff --git a/girepository/ginvoke.c b/girepository/ginvoke.c
index 20d882cdcf8d..c0cc3cc26870 100644
--- a/girepository/ginvoke.c
+++ b/girepository/ginvoke.c
@@ -30,6 +30,7 @@
 
 #include <girepository/girepository.h>
 #include "girffi.h"
+#include <inttypes.h>
 
 /**
  * value_to_ffi_type:
@@ -50,48 +51,48 @@ value_to_ffi_type (const GValue *gvalue, void **value)
   GType type = g_type_fundamental (G_VALUE_TYPE (gvalue));
   g_assert (type != G_TYPE_INVALID);
 
-  switch (type)
+  switch ((uintptr_t) type)
     {
-    case G_TYPE_BOOLEAN:
-    case G_TYPE_CHAR:
-    case G_TYPE_INT:
+    case (uintptr_t) G_TYPE_BOOLEAN:
+    case (uintptr_t) G_TYPE_CHAR:
+    case (uintptr_t) G_TYPE_INT:
       rettype = &ffi_type_sint;
       *value = (void *) &(gvalue->data[0].v_int);
       break;
-    case G_TYPE_UCHAR:
-    case G_TYPE_UINT:
+    case (uintptr_t) G_TYPE_UCHAR:
+    case (uintptr_t) G_TYPE_UINT:
       rettype = &ffi_type_uint;
       *value = (void *) &(gvalue->data[0].v_uint);
       break;
-    case G_TYPE_STRING:
-    case G_TYPE_OBJECT:
-    case G_TYPE_BOXED:
-    case G_TYPE_POINTER:
-    case G_TYPE_PARAM:
+    case (uintptr_t) G_TYPE_STRING:
+    case (uintptr_t) G_TYPE_OBJECT:
+    case (uintptr_t) G_TYPE_BOXED:
+    case (uintptr_t) G_TYPE_POINTER:
+    case (uintptr_t) G_TYPE_PARAM:
       rettype = &ffi_type_pointer;
       *value = (void *) &(gvalue->data[0].v_pointer);
       break;
-    case G_TYPE_FLOAT:
+    case (uintptr_t) G_TYPE_FLOAT:
       rettype = &ffi_type_float;
       *value = (void *) &(gvalue->data[0].v_float);
       break;
-    case G_TYPE_DOUBLE:
+    case (uintptr_t) G_TYPE_DOUBLE:
       rettype = &ffi_type_double;
       *value = (void *) &(gvalue->data[0].v_double);
       break;
-    case G_TYPE_LONG:
+    case (uintptr_t) G_TYPE_LONG:
       rettype = &ffi_type_slong;
       *value = (void *) &(gvalue->data[0].v_long);
       break;
-    case G_TYPE_ULONG:
+    case (uintptr_t) G_TYPE_ULONG:
       rettype = &ffi_type_ulong;
       *value = (void *) &(gvalue->data[0].v_ulong);
       break;
-    case G_TYPE_INT64:
+    case (uintptr_t) G_TYPE_INT64:
       rettype = &ffi_type_sint64;
       *value = (void *) &(gvalue->data[0].v_int64);
       break;
-    case G_TYPE_UINT64:
+    case (uintptr_t) G_TYPE_UINT64:
       rettype = &ffi_type_uint64;
       *value = (void *) &(gvalue->data[0].v_uint64);
       break;
@@ -130,46 +131,46 @@ g_value_to_ffi_return_type (const GValue *gvalue,
 
   *value = (void *) &(ffi_value->v_long);
 
-  switch (type) {
-  case G_TYPE_CHAR:
+  switch ((uintptr_t) type) {
+  case (uintptr_t) G_TYPE_CHAR:
     rettype = &ffi_type_sint8;
     break;
-  case G_TYPE_UCHAR:
+  case (uintptr_t) G_TYPE_UCHAR:
     rettype = &ffi_type_uint8;
     break;
-  case G_TYPE_BOOLEAN:
-  case G_TYPE_INT:
+  case (uintptr_t) G_TYPE_BOOLEAN:
+  case (uintptr_t) G_TYPE_INT:
     rettype = &ffi_type_sint;
     break;
-  case G_TYPE_UINT:
+  case (uintptr_t) G_TYPE_UINT:
     rettype = &ffi_type_uint;
     break;
-  case G_TYPE_STRING:
-  case G_TYPE_OBJECT:
-  case G_TYPE_BOXED:
-  case G_TYPE_POINTER:
-  case G_TYPE_PARAM:
+  case (uintptr_t) G_TYPE_STRING:
+  case (uintptr_t) G_TYPE_OBJECT:
+  case (uintptr_t) G_TYPE_BOXED:
+  case (uintptr_t) G_TYPE_POINTER:
+  case (uintptr_t) G_TYPE_PARAM:
     rettype = &ffi_type_pointer;
     break;
-  case G_TYPE_FLOAT:
+  case (uintptr_t) G_TYPE_FLOAT:
     rettype = &ffi_type_float;
     *value = (void *) &(ffi_value->v_float);
     break;
-  case G_TYPE_DOUBLE:
+  case (uintptr_t) G_TYPE_DOUBLE:
     rettype = &ffi_type_double;
     *value = (void *) &(ffi_value->v_double);
     break;
-  case G_TYPE_LONG:
+  case (uintptr_t) G_TYPE_LONG:
     rettype = &ffi_type_slong;
     break;
-  case G_TYPE_ULONG:
+  case (uintptr_t) G_TYPE_ULONG:
     rettype = &ffi_type_ulong;
     break;
-  case G_TYPE_INT64:
+  case (uintptr_t) G_TYPE_INT64:
     rettype = &ffi_type_sint64;
     *value = (void *) &(ffi_value->v_int64);
     break;
-  case G_TYPE_UINT64:
+  case (uintptr_t) G_TYPE_UINT64:
     rettype = &ffi_type_uint64;
     *value = (void *) &(ffi_value->v_uint64);
     break;
@@ -198,50 +199,50 @@ static void
 g_value_from_ffi_value (GValue           *gvalue,
                         const GIArgument *value)
 {
-  switch (g_type_fundamental (G_VALUE_TYPE (gvalue))) {
-  case G_TYPE_INT:
+  switch ((uintptr_t) g_type_fundamental (G_VALUE_TYPE (gvalue))) {
+  case (uintptr_t) G_TYPE_INT:
       g_value_set_int (gvalue, (gint)value->v_long);
       break;
-  case G_TYPE_FLOAT:
+  case (uintptr_t) G_TYPE_FLOAT:
       g_value_set_float (gvalue, (gfloat)value->v_float);
       break;
-  case G_TYPE_DOUBLE:
+  case (uintptr_t) G_TYPE_DOUBLE:
       g_value_set_double (gvalue, (gdouble)value->v_double);
       break;
-  case G_TYPE_BOOLEAN:
+  case (uintptr_t) G_TYPE_BOOLEAN:
       g_value_set_boolean (gvalue, (gboolean)value->v_long);
       break;
-  case G_TYPE_STRING:
+  case (uintptr_t) G_TYPE_STRING:
       g_value_set_string (gvalue, (char*)value->v_pointer);
       break;
-  case G_TYPE_CHAR:
+  case (uintptr_t) G_TYPE_CHAR:
       g_value_set_schar (gvalue, (char)value->v_long);
       break;
-  case G_TYPE_UCHAR:
+  case (uintptr_t) G_TYPE_UCHAR:
       g_value_set_uchar (gvalue, (guchar)value->v_ulong);
       break;
-  case G_TYPE_UINT:
+  case (uintptr_t) G_TYPE_UINT:
       g_value_set_uint (gvalue, (guint)value->v_ulong);
       break;
-  case G_TYPE_POINTER:
+  case (uintptr_t) G_TYPE_POINTER:
       g_value_set_pointer (gvalue, (gpointer)value->v_pointer);
       break;
-  case G_TYPE_LONG:
+  case (uintptr_t) G_TYPE_LONG:
       g_value_set_long (gvalue, (glong)value->v_long);
       break;
-  case G_TYPE_ULONG:
+  case (uintptr_t) G_TYPE_ULONG:
       g_value_set_ulong (gvalue, (gulong)value->v_ulong);
       break;
-  case G_TYPE_INT64:
+  case (uintptr_t) G_TYPE_INT64:
       g_value_set_int64 (gvalue, (gint64)value->v_int64);
       break;
-  case G_TYPE_UINT64:
+  case (uintptr_t) G_TYPE_UINT64:
       g_value_set_uint64 (gvalue, (guint64)value->v_uint64);
       break;
-  case G_TYPE_BOXED:
+  case (uintptr_t) G_TYPE_BOXED:
       g_value_set_boxed (gvalue, (gpointer)value->v_pointer);
       break;
-  case G_TYPE_PARAM:
+  case (uintptr_t) G_TYPE_PARAM:
       g_value_set_param (gvalue, (gpointer)value->v_pointer);
       break;
   default:
diff --git a/girepository/giregisteredtypeinfo.c b/girepository/giregisteredtypeinfo.c
index 4312cbac29e3..e257e7f16fe5 100644
--- a/girepository/giregisteredtypeinfo.c
+++ b/girepository/giregisteredtypeinfo.c
@@ -192,7 +192,7 @@ gi_registered_type_info_is_boxed (GIRegisteredTypeInfo *info)
   GIBaseInfo *base_info = GI_BASE_INFO (info);
   const RegisteredTypeBlob *blob;
 
-  g_return_val_if_fail (GI_IS_REGISTERED_TYPE_INFO (info), G_TYPE_INVALID);
+  g_return_val_if_fail (GI_IS_REGISTERED_TYPE_INFO (info), FALSE);
 
   blob = (const RegisteredTypeBlob *) &base_info->typelib->data[base_info->offset];
 
diff --git a/glib/gatomic.c b/glib/gatomic.c
index 2d3755e684bf..df6388f1f7d9 100644
--- a/glib/gatomic.c
+++ b/glib/gatomic.c
@@ -503,7 +503,7 @@ gpointer
  *
  * Since: 2.30
  **/
-gintptr
+gpointer
 (g_atomic_pointer_add) (volatile void *atomic,
                         gssize         val)
 {
@@ -534,7 +534,7 @@ gintptr
  *
  * Since: 2.30
  **/
-guintptr
+gpointer
 (g_atomic_pointer_and) (volatile void *atomic,
                         gsize          val)
 {
@@ -565,7 +565,7 @@ guintptr
  *
  * Since: 2.30
  **/
-guintptr
+gpointer
 (g_atomic_pointer_or) (volatile void *atomic,
                        gsize          val)
 {
@@ -596,7 +596,7 @@ guintptr
  *
  * Since: 2.30
  **/
-guintptr
+gpointer
 (g_atomic_pointer_xor) (volatile void *atomic,
                         gsize          val)
 {
diff --git a/glib/gatomic.h b/glib/gatomic.h
index 93998880cbec..ddc648dac343 100644
--- a/glib/gatomic.h
+++ b/glib/gatomic.h
@@ -83,16 +83,16 @@ GLIB_AVAILABLE_IN_2_74
 gpointer                g_atomic_pointer_exchange             (void           *atomic,
                                                                gpointer        newval);
 GLIB_AVAILABLE_IN_ALL
-gintptr                 g_atomic_pointer_add                  (volatile void  *atomic,
+gpointer                g_atomic_pointer_add                  (volatile void  *atomic,
                                                                gssize          val);
 GLIB_AVAILABLE_IN_2_30
-guintptr                g_atomic_pointer_and                  (volatile void  *atomic,
+gpointer                g_atomic_pointer_and                  (volatile void  *atomic,
                                                                gsize           val);
 GLIB_AVAILABLE_IN_2_30
-guintptr                g_atomic_pointer_or                   (volatile void  *atomic,
+gpointer                g_atomic_pointer_or                   (volatile void  *atomic,
                                                                gsize           val);
 GLIB_AVAILABLE_IN_ALL
-guintptr                g_atomic_pointer_xor                  (volatile void  *atomic,
+gpointer                g_atomic_pointer_xor                  (volatile void  *atomic,
                                                                gsize           val);
 
 GLIB_DEPRECATED_IN_2_30_FOR(g_atomic_int_add)
@@ -280,34 +280,75 @@ G_END_DECLS
     G_STATIC_ASSERT (sizeof *(atomic) == sizeof (gpointer));                 \
     (void) (0 ? (gpointer) *(atomic) : NULL);                                \
     (void) (0 ? (val) ^ (val) : 1);                                          \
-    (gintptr) __atomic_fetch_add ((atomic), (val), __ATOMIC_SEQ_CST);        \
+    gpointer *_gat_ptr = (gpointer*)(atomic);                                \
+    gpointer _gat_result = 0;                                                \
+    gssize _gat_val = (val);                                                 \
+    for (;;)                                                                 \
+      {                                                                      \
+        gpointer _gat_new_value;                                             \
+        _gat_result = *_gat_ptr;                                             \
+        _gat_new_value = (char *) _gat_result + _gat_val;                    \
+        if (g_atomic_pointer_compare_and_exchange(_gat_ptr, _gat_result, _gat_new_value)) \
+          break;                                                             \
+      }                                                                      \
+    _gat_result;                                                             \
   }))
 #define g_atomic_pointer_and(atomic, val) \
   (G_GNUC_EXTENSION ({                                                       \
-    guintptr *gapa_atomic = (guintptr *) (atomic);                           \
     G_STATIC_ASSERT (sizeof *(atomic) == sizeof (gpointer));                 \
     G_STATIC_ASSERT (sizeof *(atomic) == sizeof (guintptr));                 \
     (void) (0 ? (gpointer) *(atomic) : NULL);                                \
     (void) (0 ? (val) ^ (val) : 1);                                          \
-    (guintptr) __atomic_fetch_and (gapa_atomic, (val), __ATOMIC_SEQ_CST);    \
+    gpointer *_gat_ptr = (gpointer*)(atomic);                                \
+    gpointer _gat_result = 0;                                                \
+    gsize _gat_val = (val);                                                  \
+    for (;;)                                                                 \
+      {                                                                      \
+        gpointer _gat_new_value;                                             \
+        _gat_result = *_gat_ptr;                                             \
+        _gat_new_value = (gpointer) ((gsize) _gat_result & _gat_val);        \
+        if (g_atomic_pointer_compare_and_exchange(_gat_ptr, _gat_result, _gat_new_value)) \
+          break;                                                             \
+      }                                                                      \
+    _gat_result;                                                             \
   }))
 #define g_atomic_pointer_or(atomic, val) \
   (G_GNUC_EXTENSION ({                                                       \
-    guintptr *gapo_atomic = (guintptr *) (atomic);                           \
     G_STATIC_ASSERT (sizeof *(atomic) == sizeof (gpointer));                 \
     G_STATIC_ASSERT (sizeof *(atomic) == sizeof (guintptr));                 \
     (void) (0 ? (gpointer) *(atomic) : NULL);                                \
     (void) (0 ? (val) ^ (val) : 1);                                          \
-    (guintptr) __atomic_fetch_or (gapo_atomic, (val), __ATOMIC_SEQ_CST);     \
+    gpointer *_gat_ptr = (gpointer*)(atomic);                                \
+    gpointer _gat_result = 0;                                                \
+    gsize _gat_val = (val);                                                  \
+    for (;;)                                                                 \
+      {                                                                      \
+        gpointer _gat_new_value;                                             \
+        _gat_result = *_gat_ptr;                                             \
+        _gat_new_value = (gpointer) ((gsize) _gat_result | _gat_val);        \
+        if (g_atomic_pointer_compare_and_exchange(_gat_ptr, _gat_result, _gat_new_value)) \
+          break;                                                             \
+      }                                                                      \
+    _gat_result;                                                             \
   }))
 #define g_atomic_pointer_xor(atomic, val) \
   (G_GNUC_EXTENSION ({                                                       \
-    guintptr *gapx_atomic = (guintptr *) (atomic);                           \
     G_STATIC_ASSERT (sizeof *(atomic) == sizeof (gpointer));                 \
     G_STATIC_ASSERT (sizeof *(atomic) == sizeof (guintptr));                 \
     (void) (0 ? (gpointer) *(atomic) : NULL);                                \
     (void) (0 ? (val) ^ (val) : 1);                                          \
-    (guintptr) __atomic_fetch_xor (gapx_atomic, (val), __ATOMIC_SEQ_CST);    \
+    gpointer *_gat_ptr = (gpointer*)(atomic);                                \
+    gpointer _gat_result = 0;                                                \
+    gsize _gat_val = (val);                                                  \
+    for (;;)                                                                 \
+      {                                                                      \
+        gpointer _gat_new_value;                                             \
+        _gat_result = *_gat_ptr;                                             \
+        _gat_new_value = (gpointer) ((gsize) _gat_result ^ _gat_val);        \
+        if (g_atomic_pointer_compare_and_exchange(_gat_ptr, _gat_result, _gat_new_value)) \
+          break;                                                             \
+      }                                                                      \
+    _gat_result;                                                             \
   }))
 
 #else /* defined(__ATOMIC_SEQ_CST) */
diff --git a/glib/gbitlock.c b/glib/gbitlock.c
index 900897517e04..f0e453e433e2 100644
--- a/glib/gbitlock.c
+++ b/glib/gbitlock.c
@@ -33,6 +33,8 @@
 
 #include "gthreadprivate.h"
 
+#include <stdfil.h>
+
 #ifdef G_BIT_LOCK_FORCE_FUTEX_EMULATION
 #undef HAVE_FUTEX
 #undef HAVE_FUTEX_TIME64
@@ -413,13 +415,13 @@ pointer_bit_lock_mask_ptr (gpointer ptr, guint lock_bit, gboolean set, guintptr
     }
 
   if (lock_bit == G_MAXUINT)
-    return (gpointer) x_ptr;
+      return (gpointer) zmkptr (ptr, x_ptr);
 
   lock_mask = (guintptr) (1u << lock_bit);
   if (set)
-    return (gpointer) (x_ptr | lock_mask);
+    return (gpointer) zmkptr (ptr, (x_ptr | lock_mask));
   else
-    return (gpointer) (x_ptr & ~lock_mask);
+    return (gpointer) zmkptr (ptr, (x_ptr & ~lock_mask));
 }
 
 /**
@@ -442,44 +444,19 @@ pointer_bit_lock_mask_ptr (gpointer ptr, guint lock_bit, gboolean set, guintptr
 void
 (g_pointer_bit_lock_and_get) (gpointer address,
                               guint lock_bit,
-                              guintptr *out_ptr)
+                              gpointer *out_ptr)
 {
   guint class = bit_lock_contended_class (address);
   guintptr mask;
-  guintptr v;
+  gpointer v;
 
   g_return_if_fail (lock_bit < 32);
 
   mask = 1u << lock_bit;
 
-#ifdef USE_ASM_GOTO
-  if (G_LIKELY (!out_ptr))
-    {
-      while (TRUE)
-        {
-          __asm__ volatile goto ("lock bts %1, (%0)\n"
-                                 "jc %l[contended]"
-                                 : /* no output */
-                                 : "r"(address), "r"((gsize) lock_bit)
-                                 : "cc", "memory"
-                                 : contended);
-          return;
-
-        contended:
-          v = (guintptr) g_atomic_pointer_get ((gpointer *) address);
-          if (v & mask)
-            {
-              g_atomic_int_add (&g_bit_lock_contended[class], +1);
-              g_futex_wait (g_futex_int_address (address), v);
-              g_atomic_int_add (&g_bit_lock_contended[class], -1);
-            }
-        }
-    }
-#endif
-
 retry:
   v = g_atomic_pointer_or ((gpointer *) address, mask);
-  if (v & mask)
+  if ((guintptr) v & mask)
     /* already locked */
     {
       g_atomic_int_add (&g_bit_lock_contended[class], +1);
@@ -489,7 +466,7 @@ retry:
     }
 
   if (out_ptr)
-    *out_ptr = (v | mask);
+      *out_ptr = (gpointer) ((guintptr) v | mask);
 }
 
 /**
@@ -540,29 +517,16 @@ gboolean
   g_return_val_if_fail (lock_bit < 32, FALSE);
 
   {
-#ifdef USE_ASM_GOTO
-    gboolean result;
-
-    __asm__ volatile ("lock bts %2, (%1)\n"
-                      "setnc %%al\n"
-                      "movzx %%al, %0"
-                      : "=r" (result)
-                      : "r" (address), "r" ((gsize) lock_bit)
-                      : "cc", "memory");
-
-    return result;
-#else
     void *address_nonvolatile = (void *) address;
     gpointer *pointer_address = address_nonvolatile;
     gsize mask = 1u << lock_bit;
-    guintptr v;
+    gpointer v;
 
     g_return_val_if_fail (lock_bit < 32, FALSE);
 
     v = g_atomic_pointer_or (pointer_address, mask);
 
     return (~(gsize) v & mask) != 0;
-#endif
   }
 }
 
diff --git a/glib/gbitlock.h b/glib/gbitlock.h
index f44a52c3771f..6257e6358b43 100644
--- a/glib/gbitlock.h
+++ b/glib/gbitlock.h
@@ -48,7 +48,7 @@ void      g_pointer_bit_lock              (volatile void *address,
 GLIB_AVAILABLE_IN_2_80
 void      g_pointer_bit_lock_and_get      (gpointer address,
                                            guint lock_bit,
-                                           guintptr *out_ptr);
+                                           gpointer *out_ptr);
 
 GLIB_AVAILABLE_IN_ALL
 gboolean  g_pointer_bit_trylock           (volatile void *address,
diff --git a/glib/gdataset.c b/glib/gdataset.c
index 992e17368217..07fb48d66b28 100644
--- a/glib/gdataset.c
+++ b/glib/gdataset.c
@@ -140,7 +140,7 @@ static GDataset     *g_dataset_cached = NULL; /* should this be
 G_ALWAYS_INLINE static inline GData *
 g_datalist_lock_and_get (GData **datalist)
 {
-  guintptr ptr;
+  gpointer ptr;
 
   g_pointer_bit_lock_and_get ((void **) datalist, DATALIST_LOCK_BIT, &ptr);
   return G_DATALIST_CLEAN_POINTER (ptr);
diff --git a/glib/gtypes.h b/glib/gtypes.h
index 9d912d52363d..969eb1a4b197 100644
--- a/glib/gtypes.h
+++ b/glib/gtypes.h
@@ -245,7 +245,7 @@ typedef const gchar *   (*GTranslateFunc)       (const gchar   *str,
 
 /* Arch specific stuff for speed
  */
-#if defined (__GNUC__) && (__GNUC__ >= 2) && defined (__OPTIMIZE__)
+#if defined (__GNUC__) && (__GNUC__ >= 2) && defined (__OPTIMIZE__) && !defined(__FILC__)
 
 #  if __GNUC__ >= 4 && defined (__GNUC_MINOR__) && __GNUC_MINOR__ >= 3
 #    define GUINT32_SWAP_LE_BE(val) ((guint32) __builtin_bswap32 ((guint32) (val)))
diff --git a/glib/tests/atomic.c b/glib/tests/atomic.c
index dff493d27e0f..8104452da665 100644
--- a/glib/tests/atomic.c
+++ b/glib/tests/atomic.c
@@ -182,13 +182,13 @@ test_types (void)
   gu2 = (guintptr) g_atomic_pointer_add (&gu, 5);
   g_assert_cmpuint (gu2, ==, 0);
   g_assert_cmpuint (gu, ==, 5);
-  gu2 = g_atomic_pointer_and (&gu, 6);
+  gu2 = (guintptr) g_atomic_pointer_and (&gu, 6);
   g_assert_cmpuint (gu2, ==, 5);
   g_assert_cmpuint (gu, ==, 4);
-  gu2 = g_atomic_pointer_or (&gu, 8);
+  gu2 = (guintptr) g_atomic_pointer_or (&gu, 8);
   g_assert_cmpuint (gu2, ==, 4);
   g_assert_cmpuint (gu, ==, 12);
-  gu2 = g_atomic_pointer_xor (&gu, 4);
+  gu2 = (guintptr) g_atomic_pointer_xor (&gu, 4);
   g_assert_cmpuint (gu2, ==, 12);
   g_assert_cmpuint (gu, ==, 8);
   vp_str2 = g_atomic_pointer_exchange (&vp_str, str);
@@ -362,16 +362,17 @@ G_GNUC_END_IGNORE_DEPRECATIONS
   g_assert_true (res);
   g_assert_cmpuint (gu, ==, 0);
   g_assert_cmpuint ((guintptr) cp, ==, 0);
+#pragma clang diagnostic ignored "-Wbad-function-cast"
   gu2 = (guintptr) g_atomic_pointer_add (&gu, 5);
   g_assert_cmpuint (gu2, ==, 0);
   g_assert_cmpuint (gu, ==, 5);
-  gu2 = g_atomic_pointer_and (&gu, 6);
+  gu2 = (guintptr) g_atomic_pointer_and (&gu, 6);
   g_assert_cmpuint (gu2, ==, 5);
   g_assert_cmpuint (gu, ==, 4);
-  gu2 = g_atomic_pointer_or (&gu, 8);
+  gu2 = (guintptr) g_atomic_pointer_or (&gu, 8);
   g_assert_cmpuint (gu2, ==, 4);
   g_assert_cmpuint (gu, ==, 12);
-  gu2 = g_atomic_pointer_xor (&gu, 4);
+  gu2 = (guintptr) g_atomic_pointer_xor (&gu, 4);
   g_assert_cmpuint (gu2, ==, 12);
   g_assert_cmpuint (gu, ==, 8);
   vp2 = g_atomic_pointer_exchange (&gu, NULL);
diff --git a/glib/valgrind.h b/glib/valgrind.h
index 6f1c452975f9..54765374b409 100644
--- a/glib/valgrind.h
+++ b/glib/valgrind.h
@@ -173,6 +173,9 @@
 #  endif
 #endif
 
+#if !defined(NVALGRIND)
+#  define NVALGRIND 1
+#endif
 
 /* ------------------------------------------------------------------ */
 /* ARCHITECTURE SPECIFICS for SPECIAL INSTRUCTIONS.  There is nothing */
diff --git a/gobject/gclosure.c b/gobject/gclosure.c
index af219c268afc..8ea5fdff97df 100644
--- a/gobject/gclosure.c
+++ b/gobject/gclosure.c
@@ -1206,15 +1206,15 @@ value_to_ffi_type (const GValue *gvalue,
       *tmpval_used = FALSE;
     }
 
-  switch (type)
+  switch ((uintptr_t) type)
     {
-    case G_TYPE_BOOLEAN:
-    case G_TYPE_CHAR:
-    case G_TYPE_INT:
+    case (uintptr_t) G_TYPE_BOOLEAN:
+    case (uintptr_t) G_TYPE_CHAR:
+    case (uintptr_t) G_TYPE_INT:
       rettype = &ffi_type_sint;
       *value = (gpointer)&(gvalue->data[0].v_int);
       break;
-    case G_TYPE_ENUM:
+    case (uintptr_t) G_TYPE_ENUM:
       /* enums are stored in v_long even though they are integers, which makes
        * marshalling through libffi somewhat complicated.  They need to be
        * marshalled as signed ints, but we need to use a temporary int sized
@@ -1227,49 +1227,49 @@ value_to_ffi_type (const GValue *gvalue,
       *value = enum_tmpval;
       *tmpval_used = TRUE;
       break;
-    case G_TYPE_FLAGS:
+    case (uintptr_t) G_TYPE_FLAGS:
       g_assert (enum_tmpval != NULL);
       rettype = &ffi_type_uint;
       *enum_tmpval = g_value_get_flags (gvalue);
       *value = enum_tmpval;
       *tmpval_used = TRUE;
       break;
-    case G_TYPE_UCHAR:
-    case G_TYPE_UINT:
+    case (uintptr_t) G_TYPE_UCHAR:
+    case (uintptr_t) G_TYPE_UINT:
       rettype = &ffi_type_uint;
       *value = (gpointer)&(gvalue->data[0].v_uint);
       break;
-    case G_TYPE_STRING:
-    case G_TYPE_OBJECT:
-    case G_TYPE_BOXED:
-    case G_TYPE_PARAM:
-    case G_TYPE_POINTER:
-    case G_TYPE_INTERFACE:
-    case G_TYPE_VARIANT:
+    case (uintptr_t) G_TYPE_STRING:
+    case (uintptr_t) G_TYPE_OBJECT:
+    case (uintptr_t) G_TYPE_BOXED:
+    case (uintptr_t) G_TYPE_PARAM:
+    case (uintptr_t) G_TYPE_POINTER:
+    case (uintptr_t) G_TYPE_INTERFACE:
+    case (uintptr_t) G_TYPE_VARIANT:
       rettype = &ffi_type_pointer;
       *value = (gpointer)&(gvalue->data[0].v_pointer);
       break;
-    case G_TYPE_FLOAT:
+    case (uintptr_t) G_TYPE_FLOAT:
       rettype = &ffi_type_float;
       *value = (gpointer)&(gvalue->data[0].v_float);
       break;
-    case G_TYPE_DOUBLE:
+    case (uintptr_t) G_TYPE_DOUBLE:
       rettype = &ffi_type_double;
       *value = (gpointer)&(gvalue->data[0].v_double);
       break;
-    case G_TYPE_LONG:
+    case (uintptr_t) G_TYPE_LONG:
       rettype = &ffi_type_slong;
       *value = (gpointer)&(gvalue->data[0].v_long);
       break;
-    case G_TYPE_ULONG:
+    case (uintptr_t) G_TYPE_ULONG:
       rettype = &ffi_type_ulong;
       *value = (gpointer)&(gvalue->data[0].v_ulong);
       break;
-    case G_TYPE_INT64:
+    case (uintptr_t) G_TYPE_INT64:
       rettype = &ffi_type_sint64;
       *value = (gpointer)&(gvalue->data[0].v_int64);
       break;
-    case G_TYPE_UINT64:
+    case (uintptr_t) G_TYPE_UINT64:
       rettype = &ffi_type_uint64;
       *value = (gpointer)&(gvalue->data[0].v_uint64);
       break;
@@ -1291,66 +1291,66 @@ value_from_ffi_type (GValue *gvalue, gpointer *value)
   type = G_VALUE_TYPE (gvalue);
 
 restart:
-  switch (g_type_fundamental (type))
+  switch ((uintptr_t) g_type_fundamental (type))
     {
-    case G_TYPE_INT:
+    case (uintptr_t) G_TYPE_INT:
       g_value_set_int (gvalue, (gint) *int_val);
       break;
-    case G_TYPE_FLOAT:
+    case (uintptr_t) G_TYPE_FLOAT:
       g_value_set_float (gvalue, *(gfloat*)value);
       break;
-    case G_TYPE_DOUBLE:
+    case (uintptr_t) G_TYPE_DOUBLE:
       g_value_set_double (gvalue, *(gdouble*)value);
       break;
-    case G_TYPE_BOOLEAN:
+    case (uintptr_t) G_TYPE_BOOLEAN:
       g_value_set_boolean (gvalue, (gboolean) *int_val);
       break;
-    case G_TYPE_STRING:
+    case (uintptr_t) G_TYPE_STRING:
       g_value_take_string (gvalue, *(gchar**)value);
       break;
-    case G_TYPE_CHAR:
+    case (uintptr_t) G_TYPE_CHAR:
       g_value_set_schar (gvalue, (gint8) *int_val);
       break;
-    case G_TYPE_UCHAR:
+    case (uintptr_t) G_TYPE_UCHAR:
       g_value_set_uchar (gvalue, (guchar) *int_val);
       break;
-    case G_TYPE_UINT:
+    case (uintptr_t) G_TYPE_UINT:
       g_value_set_uint (gvalue, (guint) *int_val);
       break;
-    case G_TYPE_POINTER:
+    case (uintptr_t) G_TYPE_POINTER:
       g_value_set_pointer (gvalue, *(gpointer*)value);
       break;
-    case G_TYPE_LONG:
+    case (uintptr_t) G_TYPE_LONG:
       g_value_set_long (gvalue, (glong) *int_val);
       break;
-    case G_TYPE_ULONG:
+    case (uintptr_t) G_TYPE_ULONG:
       g_value_set_ulong (gvalue, (gulong) *int_val);
       break;
-    case G_TYPE_INT64:
+    case (uintptr_t) G_TYPE_INT64:
       g_value_set_int64 (gvalue, (gint64) *int_val);
       break;
-    case G_TYPE_UINT64:
+    case (uintptr_t) G_TYPE_UINT64:
       g_value_set_uint64 (gvalue, (guint64) *int_val);
       break;
-    case G_TYPE_BOXED:
+    case (uintptr_t) G_TYPE_BOXED:
       g_value_take_boxed (gvalue, *(gpointer*)value);
       break;
-    case G_TYPE_ENUM:
+    case (uintptr_t) G_TYPE_ENUM:
       g_value_set_enum (gvalue, (gint) *int_val);
       break;
-    case G_TYPE_FLAGS:
+    case (uintptr_t) G_TYPE_FLAGS:
       g_value_set_flags (gvalue, (guint) *int_val);
       break;
-    case G_TYPE_PARAM:
+    case (uintptr_t) G_TYPE_PARAM:
       g_value_take_param (gvalue, *(gpointer*)value);
       break;
-    case G_TYPE_OBJECT:
+    case (uintptr_t) G_TYPE_OBJECT:
       g_value_take_object (gvalue, *(gpointer*)value);
       break;
-    case G_TYPE_VARIANT:
+    case (uintptr_t) G_TYPE_VARIANT:
       g_value_take_variant (gvalue, *(gpointer*)value);
       break;
-    case G_TYPE_INTERFACE:
+    case (uintptr_t) G_TYPE_INTERFACE:
       type = g_type_interface_instantiatable_prerequisite (type);
       if (type)
         goto restart;
@@ -1383,53 +1383,53 @@ va_to_ffi_type (GType gtype,
   GType type = g_type_fundamental (gtype);
   g_assert (type != G_TYPE_INVALID);
 
-  switch (type)
+  switch ((uintptr_t) type)
     {
-    case G_TYPE_BOOLEAN:
-    case G_TYPE_CHAR:
-    case G_TYPE_INT:
-    case G_TYPE_ENUM:
+    case (uintptr_t) G_TYPE_BOOLEAN:
+    case (uintptr_t) G_TYPE_CHAR:
+    case (uintptr_t) G_TYPE_INT:
+    case (uintptr_t) G_TYPE_ENUM:
       rettype = &ffi_type_sint;
       storage->_gint = va_arg (*va, gint);
       break;
-    case G_TYPE_UCHAR:
-    case G_TYPE_UINT:
-    case G_TYPE_FLAGS:
+    case (uintptr_t) G_TYPE_UCHAR:
+    case (uintptr_t) G_TYPE_UINT:
+    case (uintptr_t) G_TYPE_FLAGS:
       rettype = &ffi_type_uint;
       storage->_guint = va_arg (*va, guint);
       break;
-    case G_TYPE_STRING:
-    case G_TYPE_OBJECT:
-    case G_TYPE_BOXED:
-    case G_TYPE_PARAM:
-    case G_TYPE_POINTER:
-    case G_TYPE_INTERFACE:
-    case G_TYPE_VARIANT:
+    case (uintptr_t) G_TYPE_STRING:
+    case (uintptr_t) G_TYPE_OBJECT:
+    case (uintptr_t) G_TYPE_BOXED:
+    case (uintptr_t) G_TYPE_PARAM:
+    case (uintptr_t) G_TYPE_POINTER:
+    case (uintptr_t) G_TYPE_INTERFACE:
+    case (uintptr_t) G_TYPE_VARIANT:
       rettype = &ffi_type_pointer;
       storage->_gpointer = va_arg (*va, gpointer);
       break;
-    case G_TYPE_FLOAT:
+    case (uintptr_t) G_TYPE_FLOAT:
       /* Float args are passed as doubles in varargs */
       rettype = &ffi_type_float;
       storage->_float = (float)va_arg (*va, double);
       break;
-    case G_TYPE_DOUBLE:
+    case (uintptr_t) G_TYPE_DOUBLE:
       rettype = &ffi_type_double;
       storage->_double = va_arg (*va, double);
       break;
-    case G_TYPE_LONG:
+    case (uintptr_t) G_TYPE_LONG:
       rettype = &ffi_type_slong;
       storage->_glong = va_arg (*va, glong);
       break;
-    case G_TYPE_ULONG:
+    case (uintptr_t) G_TYPE_ULONG:
       rettype = &ffi_type_ulong;
       storage->_gulong = va_arg (*va, gulong);
       break;
-    case G_TYPE_INT64:
+    case (uintptr_t) G_TYPE_INT64:
       rettype = &ffi_type_sint64;
       storage->_gint64 = va_arg (*va, gint64);
       break;
-    case G_TYPE_UINT64:
+    case (uintptr_t) G_TYPE_UINT64:
       rettype = &ffi_type_uint64;
       storage->_guint64 = va_arg (*va, guint64);
       break;
@@ -1621,7 +1621,7 @@ g_cclosure_marshal_generic_va (GClosure *closure,
   /* Box non-primitive arguments */
   for (i = 0; i < n_params; i++)
     {
-      GType type = param_types[i]  & ~G_SIGNAL_TYPE_STATIC_SCOPE;
+      GType type = (GType) ((uintptr_t) param_types[i]  & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE);
       GType fundamental = G_TYPE_FUNDAMENTAL (type);
 
       atypes[i+1] = va_to_ffi_type (type,
@@ -1629,7 +1629,7 @@ g_cclosure_marshal_generic_va (GClosure *closure,
 				    &storage[i]);
       args[i+1] = &storage[i];
 
-      if ((param_types[i]  & G_SIGNAL_TYPE_STATIC_SCOPE) == 0)
+      if (((uintptr_t) param_types[i]  & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0)
 	{
 	  if (fundamental == G_TYPE_STRING && storage[i]._gpointer != NULL)
 	    storage[i]._gpointer = g_strdup (storage[i]._gpointer);
@@ -1654,10 +1654,10 @@ g_cclosure_marshal_generic_va (GClosure *closure,
   /* Unbox non-primitive arguments */
   for (i = 0; i < n_params; i++)
     {
-      GType type = param_types[i]  & ~G_SIGNAL_TYPE_STATIC_SCOPE;
+      GType type = (GType) ((uintptr_t) param_types[i]  & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE);
       GType fundamental = G_TYPE_FUNDAMENTAL (type);
 
-      if ((param_types[i]  & G_SIGNAL_TYPE_STATIC_SCOPE) == 0)
+      if (((uintptr_t) param_types[i]  & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0)
 	{
 	  if (fundamental == G_TYPE_STRING && storage[i]._gpointer != NULL)
 	    g_free (storage[i]._gpointer);
diff --git a/gobject/glib-genmarshal.in b/gobject/glib-genmarshal.in
index aa5af43bd3ff..445432ab3e9b 100755
--- a/gobject/glib-genmarshal.in
+++ b/gobject/glib-genmarshal.in
@@ -80,13 +80,13 @@ DEPRECATED_MSG_STR = 'The token "{}" is deprecated; use "{}" instead'
 VA_ARG_STR = \
     '  arg{:d} = ({:s}) va_arg (args_copy, {:s});'
 STATIC_CHECK_STR = \
-    '(param_types[{:d}] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && '
+    '((uintptr_t) param_types[{:d}] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && '
 BOX_TYPED_STR = \
-    '    arg{idx:d} = {box_func} (param_types[{idx:d}] & ~G_SIGNAL_TYPE_STATIC_SCOPE, arg{idx:d});'
+    '    arg{idx:d} = {box_func} ((GType) ((uintptr_t) param_types[{idx:d}] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE), arg{idx:d});'
 BOX_UNTYPED_STR = \
     '    arg{idx:d} = {box_func} (arg{idx:d});'
 UNBOX_TYPED_STR = \
-    '    {unbox_func} (param_types[{idx:d}] & ~G_SIGNAL_TYPE_STATIC_SCOPE, arg{idx:d});'
+    '    {unbox_func} ((GType) ((uintptr_t) param_types[{idx:d}] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE), arg{idx:d});'
 UNBOX_UNTYPED_STR = \
     '    {unbox_func} (arg{idx:d});'
 
diff --git a/gobject/gmarshal.c b/gobject/gmarshal.c
index 2ccbe12cd5c3..2b04af87cb8b 100644
--- a/gobject/gmarshal.c
+++ b/gobject/gmarshal.c
@@ -20,6 +20,7 @@
 #include "genums.h"
 #include "gboxed.h"
 #include "gvaluetypes.h"
+#include <inttypes.h>
 
 
 #ifdef G_ENABLE_DEBUG
@@ -1443,7 +1444,7 @@ g_cclosure_marshal_VOID__STRINGv (GClosure     *closure,
 
   va_copy (args_copy, args);
   arg0 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     arg0 = g_strdup (arg0);
   va_end (args_copy);
 
@@ -1462,7 +1463,7 @@ g_cclosure_marshal_VOID__STRINGv (GClosure     *closure,
   callback (data1,
             arg0,
             data2);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     g_free (arg0);
 }
 
@@ -1555,7 +1556,7 @@ g_cclosure_marshal_VOID__PARAMv (GClosure     *closure,
 
   va_copy (args_copy, args);
   arg0 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     arg0 = g_param_spec_ref (arg0);
   va_end (args_copy);
 
@@ -1574,7 +1575,7 @@ g_cclosure_marshal_VOID__PARAMv (GClosure     *closure,
   callback (data1,
             arg0,
             data2);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     g_param_spec_unref (arg0);
 }
 
@@ -1667,8 +1668,8 @@ g_cclosure_marshal_VOID__BOXEDv (GClosure     *closure,
 
   va_copy (args_copy, args);
   arg0 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
-    arg0 = g_boxed_copy (param_types[0] & ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+    arg0 = g_boxed_copy ((GType) ((uintptr_t) param_types[0] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE), arg0);
   va_end (args_copy);
 
   if (G_CCLOSURE_SWAP_DATA (closure))
@@ -1686,8 +1687,8 @@ g_cclosure_marshal_VOID__BOXEDv (GClosure     *closure,
   callback (data1,
             arg0,
             data2);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
-    g_boxed_free (param_types[0] & ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+    g_boxed_free ((GType) ((uintptr_t) param_types[0] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE), arg0);
 }
 
 /**
@@ -2003,7 +2004,7 @@ g_cclosure_marshal_VOID__VARIANTv (GClosure     *closure,
 
   va_copy (args_copy, args);
   arg0 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     arg0 = g_variant_ref_sink (arg0);
   va_end (args_copy);
 
@@ -2022,7 +2023,7 @@ g_cclosure_marshal_VOID__VARIANTv (GClosure     *closure,
   callback (data1,
             arg0,
             data2);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
     g_variant_unref (arg0);
 }
 
@@ -2489,11 +2490,11 @@ g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv (GClosure     *closure,
 
   va_copy (args_copy, args);
   arg0 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
-    arg0 = g_boxed_copy (param_types[0] & ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+    arg0 = g_boxed_copy ((GType) ((uintptr_t) param_types[0] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE), arg0);
   arg1 = (gpointer) va_arg (args_copy, gpointer);
-  if ((param_types[1] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
-    arg1 = g_boxed_copy (param_types[1] & ~G_SIGNAL_TYPE_STATIC_SCOPE, arg1);
+  if (((uintptr_t) param_types[1] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
+    arg1 = g_boxed_copy ((GType) ((uintptr_t) param_types[1] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE), arg1);
   va_end (args_copy);
 
   if (G_CCLOSURE_SWAP_DATA (closure))
@@ -2512,10 +2513,10 @@ g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv (GClosure     *closure,
                        arg0,
                        arg1,
                        data2);
-  if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
-    g_boxed_free (param_types[0] & ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
-  if ((param_types[1] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
-    g_boxed_free (param_types[1] & ~G_SIGNAL_TYPE_STATIC_SCOPE, arg1);
+  if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+    g_boxed_free ((GType) ((uintptr_t) param_types[0] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE), arg0);
+  if (((uintptr_t) param_types[1] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg1 != NULL)
+    g_boxed_free ((GType) ((uintptr_t) param_types[1] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE), arg1);
 
   g_value_set_boolean (return_value, v_return);
 }
diff --git a/gobject/gobject-query.c b/gobject/gobject-query.c
index 76670320f3a0..a4460a8d5eb7 100644
--- a/gobject/gobject-query.c
+++ b/gobject/gobject-query.c
@@ -200,17 +200,17 @@ main (gint   argc,
     show_nodes (root, 0, iindent);
   if (gen_froots)
     {
-      root = ~0;
-      for (i = 0; i <= G_TYPE_FUNDAMENTAL_MAX; i += G_TYPE_MAKE_FUNDAMENTAL (1))
+        root = (GType) ~0;
+        for (i = 0; i <= G_TYPE_FUNDAMENTAL_MAX; i += (gint) G_TYPE_MAKE_FUNDAMENTAL (1))
 	{
-	  const gchar *name = g_type_name (i);
-          GType sibling = i + G_TYPE_MAKE_FUNDAMENTAL (1);
+          const gchar *name = g_type_name ((GType) i);
+          GType sibling = (GType) (i + (gint) G_TYPE_MAKE_FUNDAMENTAL (1));
 
-          if (sibling > G_TYPE_FUNDAMENTAL_MAX || g_type_name (sibling) == NULL)
+          if (sibling > (GType) G_TYPE_FUNDAMENTAL_MAX || g_type_name (sibling) == NULL)
             sibling = 0;
 	  
 	  if (name)
-	    show_nodes (i, sibling, iindent);
+	    show_nodes ((GType) i, sibling, iindent);
 	}
     }
   
diff --git a/gobject/gobject.c b/gobject/gobject.c
index 9ebe362ce884..0fe6fe54e9f0 100644
--- a/gobject/gobject.c
+++ b/gobject/gobject.c
@@ -5447,10 +5447,10 @@ _weak_ref_lock (GWeakRef *weak_ref, GObject **out_object)
 
   if (out_object)
     {
-      guintptr ptr;
+      gpointer ptr;
 
       g_pointer_bit_lock_and_get (&weak_ref->priv.p, WEAK_REF_LOCK_BIT, &ptr);
-      *out_object = _weak_ref_clean_pointer ((gpointer) ptr);
+      *out_object = _weak_ref_clean_pointer (ptr);
     }
   else
     g_pointer_bit_lock (&weak_ref->priv.p, WEAK_REF_LOCK_BIT);
diff --git a/gobject/gparam.c b/gobject/gparam.c
index 1571b34e50b0..a398a1635d97 100644
--- a/gobject/gparam.c
+++ b/gobject/gparam.c
@@ -255,11 +255,11 @@ g_param_spec_unref (GParamSpec *pspec)
 void
 g_param_spec_sink (GParamSpec *pspec)
 {
-  guintptr oldvalue;
+  gpointer oldvalue;
   g_return_if_fail (G_IS_PARAM_SPEC (pspec));
 
   oldvalue = g_atomic_pointer_and (&pspec->qdata, ~(gsize)PARAM_FLOATING_FLAG);
-  if (oldvalue & PARAM_FLOATING_FLAG)
+  if ((gsize) oldvalue & PARAM_FLOATING_FLAG)
     g_param_spec_unref (pspec);
 }
 
@@ -275,11 +275,11 @@ g_param_spec_sink (GParamSpec *pspec)
 GParamSpec*
 g_param_spec_ref_sink (GParamSpec *pspec)
 {
-  guintptr oldvalue;
+  gpointer oldvalue;
   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), NULL);
 
   oldvalue = g_atomic_pointer_and (&pspec->qdata, ~(gsize)PARAM_FLOATING_FLAG);
-  if (!(oldvalue & PARAM_FLOATING_FLAG))
+  if (!((gsize) oldvalue & PARAM_FLOATING_FLAG))
     g_param_spec_ref (pspec);
 
   return pspec;
diff --git a/gobject/gparamspecs.c b/gobject/gparamspecs.c
index 12a81245ac28..7aea4f430bb5 100644
--- a/gobject/gparamspecs.c
+++ b/gobject/gparamspecs.c
@@ -1735,7 +1735,7 @@ _g_param_spec_types_init (void)
       sizeof (GParamSpecValueArray),	/* instance_size */
       0,				/* n_preallocs */
       param_value_array_init,		/* instance_init */
-      0xdeadbeef,			/* value_type, assigned further down */
+      (GType) 0xdeadbeef,		/* value_type, assigned further down */
       param_value_array_finalize,	/* finalize */
       param_value_array_set_default,	/* value_set_default */
       param_value_array_validate,	/* value_validate */
@@ -1792,7 +1792,7 @@ _g_param_spec_types_init (void)
       sizeof (GParamSpecGType),	/* instance_size */
       0,			/* n_preallocs */
       param_gtype_init,		/* instance_init */
-      0xdeadbeef,		/* value_type, assigned further down */
+      (GType) 0xdeadbeef,	/* value_type, assigned further down */
       NULL,			/* finalize */
       param_gtype_set_default,	/* value_set_default */
       param_gtype_validate,	/* value_validate */
diff --git a/gobject/gsignal.c b/gobject/gsignal.c
index a5b471cb3c5f..9a0c6556a9d2 100644
--- a/gobject/gsignal.c
+++ b/gobject/gsignal.c
@@ -37,6 +37,7 @@
 #include "gobject.h"
 #include "genums.h"
 #include "gobject_trace.h"
+#include <inttypes.h>
 
 
 #define REPORT_BUG      "please report occurrence circumstances to https://gitlab.gnome.org/GNOME/glib/issues/new"
@@ -1618,8 +1619,8 @@ g_signal_newv (const gchar       *signal_name,
   g_return_val_if_fail (G_TYPE_IS_INSTANTIATABLE (itype) || G_TYPE_IS_INTERFACE (itype), 0);
   if (n_params)
     g_return_val_if_fail (param_types != NULL, 0);
-  g_return_val_if_fail ((return_type & G_SIGNAL_TYPE_STATIC_SCOPE) == 0, 0);
-  if (return_type == (G_TYPE_NONE & ~G_SIGNAL_TYPE_STATIC_SCOPE))
+  g_return_val_if_fail (((uintptr_t) return_type & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0, 0);
+  if (return_type == (GType) ((uintptr_t) G_TYPE_NONE & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE))
     g_return_val_if_fail (accumulator == NULL, 0);
   if (!accumulator)
     g_return_val_if_fail (accu_data == NULL, 0);
@@ -1661,7 +1662,7 @@ g_signal_newv (const gchar       *signal_name,
       return 0;
     }
   for (i = 0; i < n_params; i++)
-    if (!G_TYPE_IS_VALUE (param_types[i] & ~G_SIGNAL_TYPE_STATIC_SCOPE))
+    if (!G_TYPE_IS_VALUE ((GType) ((uintptr_t) param_types[i] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE)))
       {
 	g_critical (G_STRLOC ": parameter %d of type '%s' for signal \"%s::%s\" is not a value type",
 		    i + 1, type_debug_name (param_types[i]), type_debug_name (itype), name);
@@ -1669,7 +1670,7 @@ g_signal_newv (const gchar       *signal_name,
 	SIGNAL_UNLOCK ();
 	return 0;
       }
-  if (return_type != G_TYPE_NONE && !G_TYPE_IS_VALUE (return_type & ~G_SIGNAL_TYPE_STATIC_SCOPE))
+  if (return_type != G_TYPE_NONE && !G_TYPE_IS_VALUE ((GType) ((uintptr_t) return_type & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE)))
     {
       g_critical (G_STRLOC ": return value of type '%s' for signal \"%s::%s\" is not a value type",
 		  type_debug_name (return_type), type_debug_name (itype), name);
@@ -1728,7 +1729,7 @@ g_signal_newv (const gchar       *signal_name,
   else if (n_params == 1 && return_type == G_TYPE_NONE)
     {
 #define ADD_CHECK(__type__) \
-      else if (g_type_is_a (param_types[0] & ~G_SIGNAL_TYPE_STATIC_SCOPE, G_TYPE_ ##__type__))         \
+      else if (g_type_is_a ((GType) ((uintptr_t) param_types[0] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE), G_TYPE_ ##__type__)) \
 	{                                                                \
 	  builtin_c_marshaller = g_cclosure_marshal_VOID__ ## __type__;  \
 	  builtin_va_marshaller = g_cclosure_marshal_VOID__ ## __type__ ##v;     \
@@ -2178,8 +2179,8 @@ g_signal_chain_from_overridden_handler (gpointer instance,
       for (i = 0; i < node->n_params; i++)
         {
           gchar *error;
-          GType ptype = node->param_types[i] & ~G_SIGNAL_TYPE_STATIC_SCOPE;
-          gboolean static_scope = node->param_types[i] & G_SIGNAL_TYPE_STATIC_SCOPE;
+          GType ptype = (GType) ((uintptr_t) node->param_types[i] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE);
+          gboolean static_scope = (uintptr_t) node->param_types[i] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE;
 
           SIGNAL_UNLOCK ();
           G_VALUE_COLLECT_INIT (param_values + i, ptype,
@@ -2222,8 +2223,8 @@ g_signal_chain_from_overridden_handler (gpointer instance,
         {
           GValue return_value = G_VALUE_INIT;
           gchar *error = NULL;
-          GType rtype = signal_return_type & ~G_SIGNAL_TYPE_STATIC_SCOPE;
-          gboolean static_scope = signal_return_type & G_SIGNAL_TYPE_STATIC_SCOPE;
+          GType rtype = (GType) ((uintptr_t) signal_return_type & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE);
+          gboolean static_scope = (uintptr_t) signal_return_type & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE;
 
           g_value_init (&return_value, rtype);
 
@@ -3378,8 +3379,8 @@ signal_emit_valist_unlocked (gpointer instance,
 	  GValue *return_accu, accu = G_VALUE_INIT;
 	  GType instance_type = G_TYPE_FROM_INSTANCE (instance);
 	  GValue emission_return = G_VALUE_INIT;
-          GType rtype = node_copy.return_type & ~G_SIGNAL_TYPE_STATIC_SCOPE;
-	  gboolean static_scope = node_copy.return_type & G_SIGNAL_TYPE_STATIC_SCOPE;
+          GType rtype = (GType) ((uintptr_t) node_copy.return_type & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE);
+	  gboolean static_scope = (uintptr_t) node_copy.return_type & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE;
 
 	  if (rtype == G_TYPE_NONE)
 	    return_accu = NULL;
@@ -3448,7 +3449,7 @@ signal_emit_valist_unlocked (gpointer instance,
 	      gchar *error = NULL;
               for (i = 0; i < node_copy.n_params; i++)
 		{
-                  GType ptype = node_copy.param_types[i] & ~G_SIGNAL_TYPE_STATIC_SCOPE;
+                  GType ptype = (GType) ((uintptr_t) node_copy.param_types[i] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE);
 		  G_VALUE_COLLECT_SKIP (ptype, var_args);
 		}
 
@@ -3491,8 +3492,8 @@ signal_emit_valist_unlocked (gpointer instance,
   for (i = 0; i < node_copy.n_params; i++)
     {
       gchar *error;
-      GType ptype = node_copy.param_types[i] & ~G_SIGNAL_TYPE_STATIC_SCOPE;
-      gboolean static_scope = node_copy.param_types[i] & G_SIGNAL_TYPE_STATIC_SCOPE;
+      GType ptype = (GType) ((uintptr_t) node_copy.param_types[i] & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE);
+      gboolean static_scope = (uintptr_t) node_copy.param_types[i] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE;
 
       G_VALUE_COLLECT_INIT (param_values + i, ptype,
 			    var_args,
@@ -3524,8 +3525,8 @@ signal_emit_valist_unlocked (gpointer instance,
     {
       GValue return_value = G_VALUE_INIT;
       gchar *error = NULL;
-      GType rtype = node_copy.return_type & ~G_SIGNAL_TYPE_STATIC_SCOPE;
-      gboolean static_scope = node_copy.return_type & G_SIGNAL_TYPE_STATIC_SCOPE;
+      GType rtype = (GType) ((uintptr_t) node_copy.return_type & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE);
+      gboolean static_scope = (uintptr_t) node_copy.return_type & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE;
       
       g_value_init (&return_value, rtype);
 
@@ -3645,7 +3646,7 @@ maybe_init_accumulator_unlocked (SignalNode *node,
         return accumulator_value;
 
       g_value_init (accumulator_value,
-                    node->return_type & ~G_SIGNAL_TYPE_STATIC_SCOPE);
+                    (GType) ((uintptr_t) node->return_type & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE));
       return accumulator_value;
     }
 
@@ -4002,7 +4003,7 @@ signal_emit_unlocked_R (SignalNode   *node,
       SIGNAL_UNLOCK ();
       if (node->return_type != G_TYPE_NONE && !accumulator)
 	{
-	  g_value_init (&accu, node->return_type & ~G_SIGNAL_TYPE_STATIC_SCOPE);
+	  g_value_init (&accu, (GType) ((uintptr_t) node->return_type & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE));
 	  need_unset = TRUE;
 	}
       g_closure_invoke (class_closure,
@@ -4082,7 +4083,7 @@ type_debug_name (GType type)
 {
   if (type)
     {
-      const char *name = g_type_name (type & ~G_SIGNAL_TYPE_STATIC_SCOPE);
+      const char *name = g_type_name ((GType) ((uintptr_t) type & ~(uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE));
       return name ? name : "<unknown>";
     }
   else
diff --git a/gobject/gtype.c b/gobject/gtype.c
index 8222fc493663..2f578a6ecedd 100644
--- a/gobject/gtype.c
+++ b/gobject/gtype.c
@@ -362,15 +362,15 @@ G_GNUC_END_IGNORE_DEPRECATIONS
 /* --- type nodes --- */
 static GHashTable       *static_type_nodes_ht = NULL;
 static TypeNode		*static_fundamental_type_nodes[(G_TYPE_FUNDAMENTAL_MAX >> G_TYPE_FUNDAMENTAL_SHIFT) + 1] = { NULL, };
-static GType		 static_fundamental_next = G_TYPE_RESERVED_USER_FIRST;
+static GType		 static_fundamental_next = (GType) G_TYPE_RESERVED_USER_FIRST;
 
 static inline TypeNode*
 lookup_type_node_I (GType utype)
 {
-  if (utype > G_TYPE_FUNDAMENTAL_MAX)
-    return (TypeNode*) (utype & ~TYPE_ID_MASK);
+  if (utype > (GType) G_TYPE_FUNDAMENTAL_MAX)
+    return (TypeNode*) ((uintptr_t) utype & ~(uintptr_t) TYPE_ID_MASK);
   else
-    return static_fundamental_type_nodes[utype >> G_TYPE_FUNDAMENTAL_SHIFT];
+    return static_fundamental_type_nodes[(uintptr_t) utype >> G_TYPE_FUNDAMENTAL_SHIFT];
 }
 
 /**
@@ -414,7 +414,7 @@ type_node_any_new_W (TypeNode             *pnode,
   if (!pnode)					      /* offset fundamental types */
     {
       node = G_STRUCT_MEMBER_P (node, SIZEOF_FUNDAMENTAL_INFO);
-      static_fundamental_type_nodes[ftype >> G_TYPE_FUNDAMENTAL_SHIFT] = node;
+      static_fundamental_type_nodes[(uintptr_t) ftype >> G_TYPE_FUNDAMENTAL_SHIFT] = node;
       type = ftype;
 
 #if ENABLE_VALGRIND
@@ -424,7 +424,7 @@ type_node_any_new_W (TypeNode             *pnode,
   else
     type = GPOINTER_TO_TYPE (node);
   
-  g_assert ((type & TYPE_ID_MASK) == 0);
+  g_assert (((uintptr_t) type & (uintptr_t) TYPE_ID_MASK) == 0);
   
   node->n_supers = n_supers;
   if (!pnode)
@@ -523,11 +523,11 @@ type_node_fundamental_new_W (GType                 ftype,
   GTypeFundamentalInfo *finfo;
   TypeNode *node;
 
-  g_assert ((ftype & TYPE_ID_MASK) == 0);
-  g_assert (ftype <= G_TYPE_FUNDAMENTAL_MAX);
+  g_assert (((uintptr_t) ftype & (uintptr_t) TYPE_ID_MASK) == 0);
+  g_assert (ftype <= (GType) G_TYPE_FUNDAMENTAL_MAX);
 
-  if (ftype >> G_TYPE_FUNDAMENTAL_SHIFT == static_fundamental_next)
-    static_fundamental_next++;
+  if ((uintptr_t) ftype >> G_TYPE_FUNDAMENTAL_SHIFT == (uintptr_t) static_fundamental_next)
+    static_fundamental_next = (GType) ((uintptr_t) static_fundamental_next + 1);
 
   node = type_node_any_new_W (NULL, ftype, name, NULL, type_flags);
 
@@ -878,7 +878,7 @@ check_type_info_I (TypeNode        *pnode,
   GTypeFundamentalInfo *finfo = type_node_fundamental_info_I (lookup_type_node_I (ftype));
   gboolean is_interface = ftype == G_TYPE_INTERFACE;
   
-  g_assert (ftype <= G_TYPE_FUNDAMENTAL_MAX && !(ftype & TYPE_ID_MASK));
+  g_assert (ftype <= (GType) G_TYPE_FUNDAMENTAL_MAX && !((uintptr_t) ftype & (uintptr_t) TYPE_ID_MASK));
   
   /* check instance members */
   if (!(finfo->type_flags & G_TYPE_FLAG_INSTANTIATABLE) &&
@@ -1518,17 +1518,17 @@ type_iface_add_prerequisite_W (TypeNode *iface,
   if (NODE_IS_IFACE (prerequisite_node))
     {
       dependants = iface_node_get_dependants_array_L (prerequisite_node);
-      n_dependants = dependants ? dependants[0] : 0;
+      n_dependants = dependants ? (guint) dependants[0] : 0;
       n_dependants += 1;
       dependants = g_renew (GType, dependants, n_dependants + 1);
       dependants[n_dependants] = NODE_TYPE (iface);
-      dependants[0] = n_dependants;
+      dependants[0] = (GType) n_dependants;
       iface_node_set_dependants_array_W (prerequisite_node, dependants);
     }
   
   /* we need to notify all dependants */
   dependants = iface_node_get_dependants_array_L (iface);
-  n_dependants = dependants ? dependants[0] : 0;
+  n_dependants = dependants ? (guint) dependants[0] : 0;
   for (i = 1; i <= n_dependants; i++)
     type_iface_add_prerequisite_W (lookup_type_node_I (dependants[i]), prerequisite_node);
 }
@@ -2718,8 +2718,8 @@ g_type_register_fundamental (GType                       type_id,
   
   if (!check_type_name_I (type_name))
     return 0;
-  if ((type_id & TYPE_ID_MASK) ||
-      type_id > G_TYPE_FUNDAMENTAL_MAX)
+  if (((uintptr_t) type_id & (uintptr_t) TYPE_ID_MASK) ||
+      type_id > (GType) G_TYPE_FUNDAMENTAL_MAX)
     {
       g_critical ("attempt to register fundamental type '%s' with invalid type id (%" G_GUINTPTR_FORMAT ")",
 		  type_name,
@@ -4102,8 +4102,8 @@ g_type_fundamental_next (void)
   G_READ_LOCK (&type_rw_lock);
   type = static_fundamental_next;
   G_READ_UNLOCK (&type_rw_lock);
-  type = G_TYPE_MAKE_FUNDAMENTAL (type);
-  return type <= G_TYPE_FUNDAMENTAL_MAX ? type : 0;
+  type = G_TYPE_MAKE_FUNDAMENTAL ((uintptr_t) type);
+  return type <= (GType) G_TYPE_FUNDAMENTAL_MAX ? type : 0;
 }
 
 /**
diff --git a/gobject/gtype.h b/gobject/gtype.h
index a16da4593255..40f180f61cc3 100644
--- a/gobject/gtype.h
+++ b/gobject/gtype.h
@@ -25,6 +25,7 @@
 
 #include  <glib.h>
 #include <gobject/gobject-visibility.h>
+#include <inttypes.h>
 
 G_BEGIN_DECLS
 
@@ -270,7 +271,7 @@ G_BEGIN_DECLS
  *
  * Returns: %TRUE is @type is fundamental
  */
-#define G_TYPE_IS_FUNDAMENTAL(type)             ((type) <= G_TYPE_FUNDAMENTAL_MAX)
+#define G_TYPE_IS_FUNDAMENTAL(type)             ((type) <= (GType) G_TYPE_FUNDAMENTAL_MAX)
 /**
  * G_TYPE_IS_DERIVED:
  * @type: A #GType value
@@ -281,7 +282,7 @@ G_BEGIN_DECLS
  *
  * Returns: %TRUE if @type is derived
  */
-#define G_TYPE_IS_DERIVED(type)                 ((type) > G_TYPE_FUNDAMENTAL_MAX)
+#define G_TYPE_IS_DERIVED(type)                 ((type) > (GType) G_TYPE_FUNDAMENTAL_MAX)
 /**
  * G_TYPE_IS_INTERFACE:
  * @type: A #GType value
@@ -421,13 +422,7 @@ G_BEGIN_DECLS
  * A numerical value which represents the unique identifier of a registered
  * type.
  */
-#if     GLIB_SIZEOF_VOID_P > GLIB_SIZEOF_SIZE_T
-typedef guintptr                        GType;
-#elif     GLIB_SIZEOF_SIZE_T != GLIB_SIZEOF_LONG || !defined (G_CXX_STD_VERSION)
-typedef gsize                           GType;
-#else   /* for historic reasons, C++ on non-Morello/CHERI systems links against gulong GTypes */
-typedef gulong                          GType;
-#endif
+typedef struct _GTypeOpaque             *GType;
 typedef struct _GValue                  GValue;
 typedef union  _GTypeCValue             GTypeCValue;
 typedef struct _GTypePlugin             GTypePlugin;
diff --git a/gobject/tests/basics-gobject.c b/gobject/tests/basics-gobject.c
index 60ab0031984e..ff0904177254 100644
--- a/gobject/tests/basics-gobject.c
+++ b/gobject/tests/basics-gobject.c
@@ -100,7 +100,7 @@ test_object_test_iface_init (gpointer giface,
   TestIfaceClass *iface = giface;
 
   g_assert (iface_data == GUINT_TO_POINTER (42));
-  g_assert_cmpint (G_TYPE_FROM_INTERFACE (iface), ==, TEST_TYPE_IFACE);
+  g_assert_cmpint ((uintptr_t) G_TYPE_FROM_INTERFACE (iface), ==, (uintptr_t) TEST_TYPE_IFACE);
 
   /* assert iface_base_init() was already called */
   g_assert_cmpuint (iface_base_init_count, >, 0);
diff --git a/gobject/tests/dynamictype.c b/gobject/tests/dynamictype.c
index 21421181649d..7c1eb92a5953 100644
--- a/gobject/tests/dynamictype.c
+++ b/gobject/tests/dynamictype.c
@@ -176,7 +176,7 @@ test_dynamic_type_query (void)
 
   g_type_query (DYNAMIC_OBJECT_TYPE, &query_result);
 
-  g_assert_cmpuint (query_result.type, !=, 0);
+  g_assert_cmpuint ((uintptr_t) query_result.type, !=, 0);
   g_assert_cmpstr (query_result.type_name, ==, "DynamicObject");
   g_assert_cmpuint (query_result.class_size, >=, sizeof (DynamicObjectClass));
   g_assert_cmpuint (query_result.instance_size, >=, sizeof (DynamicObject));
diff --git a/gobject/tests/genmarshal.py b/gobject/tests/genmarshal.py
index e2ecf7424b2c..3b2a5cb18625 100644
--- a/gobject/tests/genmarshal.py
+++ b/gobject/tests/genmarshal.py
@@ -500,7 +500,7 @@ class TestGenmarshal(unittest.TestCase):
 
               va_copy (args_copy, args);
               arg0 = (gpointer) va_arg (args_copy, gpointer);
-              if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+              if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
                 arg0 = g_variant_ref_sink (arg0);
               va_end (args_copy);
 
@@ -520,7 +520,7 @@ class TestGenmarshal(unittest.TestCase):
               callback (data1,
                         arg0,
                         data2);
-              if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+              if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
                 g_variant_unref (arg0);
             }}
             """
@@ -642,7 +642,7 @@ class TestGenmarshal(unittest.TestCase):
 
               va_copy (args_copy, args);
               arg0 = (gpointer) va_arg (args_copy, gpointer);
-              if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+              if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
                 arg0 = g_strdup (arg0);
               va_end (args_copy);
 
@@ -662,7 +662,7 @@ class TestGenmarshal(unittest.TestCase):
               callback (data1,
                         arg0,
                         data2);
-              if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+              if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
                 g_free (arg0);
             }}
             """
@@ -785,7 +785,7 @@ class TestGenmarshal(unittest.TestCase):
 
               va_copy (args_copy, args);
               arg0 = (gpointer) va_arg (args_copy, gpointer);
-              if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+              if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
                 arg0 = g_param_spec_ref (arg0);
               va_end (args_copy);
 
@@ -805,7 +805,7 @@ class TestGenmarshal(unittest.TestCase):
               callback (data1,
                         arg0,
                         data2);
-              if ((param_types[0] & G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
+              if (((uintptr_t) param_types[0] & (uintptr_t) G_SIGNAL_TYPE_STATIC_SCOPE) == 0 && arg0 != NULL)
                 g_param_spec_unref (arg0);
             }}
             """
diff --git a/gobject/tests/param.c b/gobject/tests/param.c
index 9d22135ccc2a..5f4b473911a9 100644
--- a/gobject/tests/param.c
+++ b/gobject/tests/param.c
@@ -508,12 +508,12 @@ test_param_spec_gtype (void)
   g_value_set_gtype (&value, G_TYPE_INT);
   g_assert_false (g_param_value_is_valid (pspec, &value));
   g_assert_true (g_param_value_validate (pspec, &value));
-  g_assert_cmpint (g_value_get_gtype (&value), ==, G_TYPE_PARAM);
+  g_assert_cmpint ((uintptr_t) g_value_get_gtype (&value), ==, (uintptr_t) G_TYPE_PARAM);
 
   g_value_set_gtype (&value, G_TYPE_PARAM_INT);
   g_assert_true (g_param_value_is_valid (pspec, &value));
   g_assert_false (g_param_value_validate (pspec, &value));
-  g_assert_cmpint (g_value_get_gtype (&value), ==, G_TYPE_PARAM_INT);
+  g_assert_cmpint ((uintptr_t) g_value_get_gtype (&value), ==, (uintptr_t) G_TYPE_PARAM_INT);
 
   g_param_spec_unref (pspec);
 }
diff --git a/gobject/tests/reference.c b/gobject/tests/reference.c
index 0fe655ea03a7..d035f979ca41 100644
--- a/gobject/tests/reference.c
+++ b/gobject/tests/reference.c
@@ -46,7 +46,7 @@ test_type_query (void)
   GTypeQuery query;
 
   g_type_query (G_TYPE_ENUM, &query);
-  g_assert_cmpint (query.type, ==, G_TYPE_ENUM);
+  g_assert_cmpint ((uintptr_t) query.type, ==, (uintptr_t) G_TYPE_ENUM);
   g_assert_cmpstr (query.type_name, ==, "GEnum");
   g_assert_cmpint (query.class_size, ==, sizeof (GEnumClass));
   g_assert_cmpint (query.instance_size, ==, 0);
diff --git a/gobject/tests/signalgroup.c b/gobject/tests/signalgroup.c
index 198c16ca4e03..df56c9f8a5c3 100644
--- a/gobject/tests/signalgroup.c
+++ b/gobject/tests/signalgroup.c
@@ -590,7 +590,7 @@ test_signal_group_properties (void)
                 "target", &target,
                 "target-type", &gtype,
                 NULL);
-  g_assert_cmpint (gtype, ==, signal_target_get_type ());
+  g_assert_cmpint ((uintptr_t) gtype, ==, (uintptr_t) signal_target_get_type ());
   g_assert_null (target);
 
   target = g_object_new (signal_target_get_type (), NULL);
diff --git a/gobject/tests/signals.c b/gobject/tests/signals.c
index 834fdd68e41a..31f4c4ddce0c 100644
--- a/gobject/tests/signals.c
+++ b/gobject/tests/signals.c
@@ -1509,7 +1509,7 @@ test_introspection (void)
   g_assert_cmpstr (query.signal_name, ==, "simple");
   g_assert_true (query.itype == test_get_type ());
   g_assert_cmpint (query.signal_flags, ==, G_SIGNAL_RUN_LAST);
-  g_assert_cmpint (query.return_type, ==, G_TYPE_NONE);
+  g_assert_cmpint ((uintptr_t) query.return_type, ==, (uintptr_t) G_TYPE_NONE);
   g_assert_cmpuint (query.n_params, ==, 0);
 
   g_free (ids);
diff --git a/gobject/tests/threadtests.c b/gobject/tests/threadtests.c
index 9b923f3fd095..e3c0047e50c3 100644
--- a/gobject/tests/threadtests.c
+++ b/gobject/tests/threadtests.c
@@ -516,7 +516,7 @@ test_threaded_g_pointer_bit_unlock_and_set (void)
   GObject *obj;
   gpointer plock;
   gpointer ptr;
-  guintptr ptr2;
+  gpointer ptr2;
   gpointer mangled_obj;
 
 #if defined(__GNUC__)
@@ -551,7 +551,7 @@ test_threaded_g_pointer_bit_unlock_and_set (void)
 
   plock = obj;
   g_pointer_bit_lock_and_get (&plock, 0, &ptr2);
-  g_assert_true ((gpointer) ptr2 == plock);
+  g_assert_true (ptr2 == plock);
   g_assert_true (plock != obj);
   g_atomic_pointer_set (&plock, mangled_obj);
   g_pointer_bit_unlock_and_set (&plock, 0, obj, 0);
diff --git a/gobject/tests/type.c b/gobject/tests/type.c
index ea0dd46f33f3..3680244bb9a3 100644
--- a/gobject/tests/type.c
+++ b/gobject/tests/type.c
@@ -118,10 +118,10 @@ test_interface_prerequisite (void)
 
   g_free (prereqs);
 
-  g_assert_cmpint (g_type_interface_instantiatable_prerequisite (baa_get_type ()), ==, G_TYPE_INVALID);
-  g_assert_cmpint (g_type_interface_instantiatable_prerequisite (boo_get_type ()), ==, G_TYPE_INVALID);
+  g_assert_cmpint ((uintptr_t) g_type_interface_instantiatable_prerequisite (baa_get_type ()), ==, (uintptr_t) G_TYPE_INVALID);
+  g_assert_cmpint ((uintptr_t) g_type_interface_instantiatable_prerequisite (boo_get_type ()), ==, (uintptr_t) G_TYPE_INVALID);
 
-  g_assert_cmpint (g_type_interface_instantiatable_prerequisite (bozo_get_type ()), ==, G_TYPE_INITIALLY_UNOWNED);
+  g_assert_cmpint ((uintptr_t) g_type_interface_instantiatable_prerequisite (bozo_get_type ()), ==, (uintptr_t) G_TYPE_INITIALLY_UNOWNED);
 }
 
 typedef struct {
@@ -222,11 +222,11 @@ test_query (void)
 
   g_test_message ("Invalid types can’t be queried.");
   g_type_query (G_TYPE_INVALID, &results);
-  g_assert_cmpuint (results.type, ==, 0);
+  g_assert_cmpuint ((uintptr_t) results.type, ==, 0);
 
   g_test_message ("Unclassed types can’t be queried.");
   g_type_query (G_TYPE_INT64, &results);
-  g_assert_cmpuint (results.type, ==, 0);
+  g_assert_cmpuint ((uintptr_t) results.type, ==, 0);
 }
 
 int
