diff --git a/src/liblzma/Makefile.am b/src/liblzma/Makefile.am
index 85b3a52b4865..c605c914fec7 100644
--- a/src/liblzma/Makefile.am
+++ b/src/liblzma/Makefile.am
@@ -25,11 +25,11 @@ liblzma_la_LDFLAGS = -no-undefined -version-info 11:2:6
 EXTRA_DIST += liblzma_generic.map liblzma_linux.map validate_map.sh
 if COND_SYMVERS_GENERIC
 liblzma_la_LDFLAGS += \
-	-Wl,--version-script=$(top_srcdir)/src/liblzma/liblzma_generic.map
+	-XCClinker --version-script=$(top_srcdir)/src/liblzma/liblzma_generic.map
 endif
 if COND_SYMVERS_LINUX
 liblzma_la_LDFLAGS += \
-	-Wl,--version-script=$(top_srcdir)/src/liblzma/liblzma_linux.map
+	-XCClinker --version-script=$(top_srcdir)/src/liblzma/liblzma_linux.map
 endif
 
 liblzma_la_SOURCES += ../common/tuklib_physmem.c
diff --git a/src/liblzma/check/crc32_fast.c b/src/liblzma/check/crc32_fast.c
index 16dbb7467513..8b00f4c7fa45 100644
--- a/src/liblzma/check/crc32_fast.c
+++ b/src/liblzma/check/crc32_fast.c
@@ -21,6 +21,7 @@
 #	include "crc32_arm64.h"
 #endif
 
+#include <stdfil.h>
 
 #ifdef CRC32_GENERIC
 
@@ -185,6 +186,10 @@ lzma_crc32(const uint8_t *buf, size_t size, uint32_t crc)
 		return crc32_generic(buf, size, crc);
 #endif
 
+        if (!zinbounds(zmkptr(buf, (uintptr_t)buf & -16)) ||
+            !zinbounds(zmkptr(buf, (((uintptr_t)buf + size + 15) & -16) - 1)))
+                return crc32_generic(buf, size, crc);
+
 /*
 #ifndef HAVE_FUNC_ATTRIBUTE_CONSTRUCTOR
 	// See crc32_dispatch(). This would be the alternative which uses
diff --git a/src/liblzma/check/crc64_fast.c b/src/liblzma/check/crc64_fast.c
index 0ce83fe4ad36..dddb6ac44767 100644
--- a/src/liblzma/check/crc64_fast.c
+++ b/src/liblzma/check/crc64_fast.c
@@ -18,6 +18,7 @@
 #	include "crc_x86_clmul.h"
 #endif
 
+#include <stdfil.h>
 
 #ifdef CRC64_GENERIC
 
@@ -139,7 +140,12 @@ lzma_crc64(const uint8_t *buf, size_t size, uint64_t crc)
 	if (size <= 16)
 		return crc64_generic(buf, size, crc);
 #endif
-	return crc64_func(buf, size, crc);
+
+        if (!zinbounds(zmkptr(buf, (uintptr_t)buf & -16)) ||
+            !zinbounds(zmkptr(buf, (((uintptr_t)buf + size + 15) & -16) - 1)))
+                return crc64_generic(buf, size, crc);
+
+        return crc64_func(buf, size, crc);
 
 #elif defined(CRC64_ARCH_OPTIMIZED)
 	// If arch-optimized version is used unconditionally without runtime
diff --git a/src/liblzma/check/crc_x86_clmul.h b/src/liblzma/check/crc_x86_clmul.h
index f1254ece18ed..8a6800a13a72 100644
--- a/src/liblzma/check/crc_x86_clmul.h
+++ b/src/liblzma/check/crc_x86_clmul.h
@@ -38,6 +38,7 @@
 #define LZMA_CRC_X86_CLMUL_H
 
 #include <immintrin.h>
+#include <stdfil.h>
 
 #if defined(_MSC_VER)
 #	include <intrin.h>
@@ -100,8 +101,8 @@ crc_simd_body(const uint8_t *buf, const size_t size, __m128i *v0, __m128i *v1,
 	// D = buf + size + skip_end == aligned_buf + size2 + skip_end
 	const size_t skip_start = (size_t)((uintptr_t)buf & 15);
 	const size_t skip_end = (size_t)((0U - (uintptr_t)(buf + size)) & 15);
-	const __m128i *aligned_buf = (const __m128i *)(
-			(uintptr_t)buf & ~(uintptr_t)15);
+	const __m128i *aligned_buf = (const __m128i *)zmkptr(
+			buf, (uintptr_t)buf & ~(uintptr_t)15);
 
 	// If size2 <= 16 then the whole input fits into a single 16-byte
 	// vector. If size2 > 16 then at least two 16-byte vectors must
diff --git a/src/liblzma/rangecoder/range_decoder.h b/src/liblzma/rangecoder/range_decoder.h
index 31a58d1ffbed..4e5e96bf6839 100644
--- a/src/liblzma/rangecoder/range_decoder.h
+++ b/src/liblzma/rangecoder/range_decoder.h
@@ -46,7 +46,8 @@
 #ifndef LZMA_RANGE_DECODER_CONFIG
 #	if defined(__x86_64__) && !defined(__ILP32__) \
 			&& !defined(__NVCOMPILER) \
-			&& (defined(__GNUC__) || defined(__clang__))
+			&& (defined(__GNUC__) || defined(__clang__)) \
+                        && !defined(__PIZLONATOR_WAS_HERE__)
 #		define LZMA_RANGE_DECODER_CONFIG 0x1F0
 #	else
 #		define LZMA_RANGE_DECODER_CONFIG 0
diff --git a/src/xz/file_io.h b/src/xz/file_io.h
index ae7e2f38f520..3cf02b6a63a2 100644
--- a/src/xz/file_io.h
+++ b/src/xz/file_io.h
@@ -33,7 +33,7 @@
 /// to avoid strict aliasing violations. Taking a pointer of u8
 /// should be fine as long as uint8_t maps to unsigned char which
 /// can alias anything.
-typedef union {
+typedef union __attribute__((aligned(16))) {
 	uint8_t u8[IO_BUFFER_SIZE];
 	uint32_t u32[IO_BUFFER_SIZE / sizeof(uint32_t)];
 	uint64_t u64[IO_BUFFER_SIZE / sizeof(uint64_t)];
