diff --git a/m4/visibility.m4 b/m4/visibility.m4
deleted file mode 100644
index 4a741c5eab3b..000000000000
--- a/m4/visibility.m4
+++ /dev/null
@@ -1,85 +0,0 @@
-dnl SPDX-License-Identifier: FSFULLR
-
-# visibility.m4
-# serial 9
-dnl Copyright (C) 2005, 2008, 2010-2024 Free Software Foundation, Inc.
-dnl This file is free software; the Free Software Foundation
-dnl gives unlimited permission to copy and/or distribute it,
-dnl with or without modifications, as long as this notice is preserved.
-
-dnl From Bruno Haible.
-
-dnl Tests whether the compiler supports the command-line option
-dnl -fvisibility=hidden and the function and variable attributes
-dnl __attribute__((__visibility__("hidden"))) and
-dnl __attribute__((__visibility__("default"))).
-dnl Does *not* test for __visibility__("protected") - which has tricky
-dnl semantics (see the 'vismain' test in glibc) and does not exist e.g. on
-dnl Mac OS X.
-dnl Does *not* test for __visibility__("internal") - which has processor
-dnl dependent semantics.
-dnl Does *not* test for #pragma GCC visibility push(hidden) - which is
-dnl "really only recommended for legacy code".
-dnl Set the variable CFLAG_VISIBILITY.
-dnl Defines and sets the variable HAVE_VISIBILITY.
-
-AC_DEFUN([gl_VISIBILITY],
-[
-  AC_REQUIRE([AC_PROG_CC])
-  CFLAG_VISIBILITY=
-  HAVE_VISIBILITY=0
-  if test -n "$GCC"; then
-    dnl First, check whether -Werror can be added to the command line, or
-    dnl whether it leads to an error because of some other option that the
-    dnl user has put into $CC $CFLAGS $CPPFLAGS.
-    AC_CACHE_CHECK([whether the -Werror option is usable],
-      [gl_cv_cc_vis_werror],
-      [gl_saved_CFLAGS="$CFLAGS"
-       CFLAGS="$CFLAGS -Werror"
-       AC_COMPILE_IFELSE(
-         [AC_LANG_PROGRAM([[]], [[]])],
-         [gl_cv_cc_vis_werror=yes],
-         [gl_cv_cc_vis_werror=no])
-       CFLAGS="$gl_saved_CFLAGS"
-      ])
-    dnl Now check whether visibility declarations are supported.
-    AC_CACHE_CHECK([for simple visibility declarations],
-      [gl_cv_cc_visibility],
-      [gl_saved_CFLAGS="$CFLAGS"
-       CFLAGS="$CFLAGS -fvisibility=hidden"
-       dnl We use the option -Werror and a function dummyfunc, because on some
-       dnl platforms (Cygwin 1.7) the use of -fvisibility triggers a warning
-       dnl "visibility attribute not supported in this configuration; ignored"
-       dnl at the first function definition in every compilation unit, and we
-       dnl don't want to use the option in this case.
-       if test $gl_cv_cc_vis_werror = yes; then
-         CFLAGS="$CFLAGS -Werror"
-       fi
-       AC_COMPILE_IFELSE(
-         [AC_LANG_PROGRAM(
-            [[extern __attribute__((__visibility__("hidden"))) int hiddenvar;
-              extern __attribute__((__visibility__("default"))) int exportedvar;
-              extern __attribute__((__visibility__("hidden"))) int hiddenfunc (void);
-              extern __attribute__((__visibility__("default"))) int exportedfunc (void);
-              void dummyfunc (void);
-              int hiddenvar;
-              int exportedvar;
-              int hiddenfunc (void) { return 51; }
-              int exportedfunc (void) { return 1225736919; }
-              void dummyfunc (void) {}
-            ]],
-            [[]])],
-         [gl_cv_cc_visibility=yes],
-         [gl_cv_cc_visibility=no])
-       CFLAGS="$gl_saved_CFLAGS"
-      ])
-    if test $gl_cv_cc_visibility = yes; then
-      CFLAG_VISIBILITY="-fvisibility=hidden"
-      HAVE_VISIBILITY=1
-    fi
-  fi
-  AC_SUBST([CFLAG_VISIBILITY])
-  AC_SUBST([HAVE_VISIBILITY])
-  AC_DEFINE_UNQUOTED([HAVE_VISIBILITY], [$HAVE_VISIBILITY],
-    [Define to 1 or 0, depending whether the compiler supports simple visibility declarations.])
-])
diff --git a/src/liblzma/Makefile.am b/src/liblzma/Makefile.am
index 85b3a52b4865..c605c914fec7 100644
--- a/src/liblzma/Makefile.am
+++ b/src/liblzma/Makefile.am
@@ -25,11 +25,11 @@ liblzma_la_LDFLAGS = -no-undefined -version-info 11:2:6
 EXTRA_DIST += liblzma_generic.map liblzma_linux.map validate_map.sh
 if COND_SYMVERS_GENERIC
 liblzma_la_LDFLAGS += \
-	-Wl,--version-script=$(top_srcdir)/src/liblzma/liblzma_generic.map
+	-XCClinker --version-script=$(top_srcdir)/src/liblzma/liblzma_generic.map
 endif
 if COND_SYMVERS_LINUX
 liblzma_la_LDFLAGS += \
-	-Wl,--version-script=$(top_srcdir)/src/liblzma/liblzma_linux.map
+	-XCClinker --version-script=$(top_srcdir)/src/liblzma/liblzma_linux.map
 endif
 
 liblzma_la_SOURCES += ../common/tuklib_physmem.c
diff --git a/src/liblzma/check/crc_x86_clmul.h b/src/liblzma/check/crc_x86_clmul.h
index f1254ece18ed..8a6800a13a72 100644
--- a/src/liblzma/check/crc_x86_clmul.h
+++ b/src/liblzma/check/crc_x86_clmul.h
@@ -38,6 +38,7 @@
 #define LZMA_CRC_X86_CLMUL_H
 
 #include <immintrin.h>
+#include <stdfil.h>
 
 #if defined(_MSC_VER)
 #	include <intrin.h>
@@ -100,8 +101,8 @@ crc_simd_body(const uint8_t *buf, const size_t size, __m128i *v0, __m128i *v1,
 	// D = buf + size + skip_end == aligned_buf + size2 + skip_end
 	const size_t skip_start = (size_t)((uintptr_t)buf & 15);
 	const size_t skip_end = (size_t)((0U - (uintptr_t)(buf + size)) & 15);
-	const __m128i *aligned_buf = (const __m128i *)(
-			(uintptr_t)buf & ~(uintptr_t)15);
+	const __m128i *aligned_buf = (const __m128i *)zmkptr(
+			buf, (uintptr_t)buf & ~(uintptr_t)15);
 
 	// If size2 <= 16 then the whole input fits into a single 16-byte
 	// vector. If size2 > 16 then at least two 16-byte vectors must
diff --git a/src/liblzma/common/common.h b/src/liblzma/common/common.h
index 20af32f6d6cd..677901132819 100644
--- a/src/liblzma/common/common.h
+++ b/src/liblzma/common/common.h
@@ -90,6 +90,10 @@
 #		define LZMA_SYMVER_API(extnamever, type, intname) \
 			extern __attribute__((__symver__(extnamever))) \
 					LZMA_API(type) intname
+#	elif __PIZLONATOR_WAS_HERE__
+#		define LZMA_SYMVER_API(extnamever, type, intname) \
+			__asm__(".filc_symver " #intname "," extnamever); \
+			extern LZMA_API(type) intname
 #	else
 #		define LZMA_SYMVER_API(extnamever, type, intname) \
 			__asm__(".symver " #intname "," extnamever); \
diff --git a/src/liblzma/rangecoder/range_decoder.h b/src/liblzma/rangecoder/range_decoder.h
index 31a58d1ffbed..4e5e96bf6839 100644
--- a/src/liblzma/rangecoder/range_decoder.h
+++ b/src/liblzma/rangecoder/range_decoder.h
@@ -46,7 +46,8 @@
 #ifndef LZMA_RANGE_DECODER_CONFIG
 #	if defined(__x86_64__) && !defined(__ILP32__) \
 			&& !defined(__NVCOMPILER) \
-			&& (defined(__GNUC__) || defined(__clang__))
+			&& (defined(__GNUC__) || defined(__clang__)) \
+                        && !defined(__PIZLONATOR_WAS_HERE__)
 #		define LZMA_RANGE_DECODER_CONFIG 0x1F0
 #	else
 #		define LZMA_RANGE_DECODER_CONFIG 0
diff --git a/src/xz/file_io.h b/src/xz/file_io.h
index ae7e2f38f520..3cf02b6a63a2 100644
--- a/src/xz/file_io.h
+++ b/src/xz/file_io.h
@@ -33,7 +33,7 @@
 /// to avoid strict aliasing violations. Taking a pointer of u8
 /// should be fine as long as uint8_t maps to unsigned char which
 /// can alias anything.
-typedef union {
+typedef union __attribute__((aligned(16))) {
 	uint8_t u8[IO_BUFFER_SIZE];
 	uint32_t u32[IO_BUFFER_SIZE / sizeof(uint32_t)];
 	uint64_t u64[IO_BUFFER_SIZE / sizeof(uint64_t)];
