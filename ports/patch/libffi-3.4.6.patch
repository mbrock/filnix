diff --git a/Makefile.am b/Makefile.am
index 3de0bea4737d..77b83b30709e 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -119,7 +119,7 @@ endif
 
 if LIBFFI_BUILD_VERSIONED_SHLIB
 if LIBFFI_BUILD_VERSIONED_SHLIB_GNU
-libffi_version_script = -Wl,--version-script,libffi.map
+libffi_version_script = --version-script,libffi.map
 libffi_version_dep = libffi.map
 endif
 if LIBFFI_BUILD_VERSIONED_SHLIB_SUN
diff --git a/configure.host b/configure.host
index 4cc69be4fe29..6da272b8f338 100644
--- a/configure.host
+++ b/configure.host
@@ -331,6 +331,8 @@ case "${TARGET}" in
 	;;
 esac
 
+SOURCES=ffi64.c
+
 # If we failed to configure SOURCES, we can't do anything.
 if test -z "${SOURCES}"; then
   UNSUPPORTED=1
diff --git a/fficonfig.h.in b/fficonfig.h.in
index 2e4aac6623ba..36c12ad20275 100644
--- a/fficonfig.h.in
+++ b/fficonfig.h.in
@@ -65,10 +65,10 @@
 /* Define if you support more than one size of the long double type */
 #undef HAVE_LONG_DOUBLE_VARIANT
 
-/* Define to 1 if you have the `memcpy' function. */
+/* Define to 1 if you have the 'memcpy' function. */
 #undef HAVE_MEMCPY
 
-/* Define to 1 if you have the `memfd_create' function. */
+/* Define to 1 if you have the 'memfd_create' function. */
 #undef HAVE_MEMFD_CREATE
 
 /* Define if your compiler supports pointer authentication. */
@@ -131,16 +131,16 @@
 /* Define to the version of this package. */
 #undef PACKAGE_VERSION
 
-/* The size of `double', as computed by sizeof. */
+/* The size of 'double', as computed by sizeof. */
 #undef SIZEOF_DOUBLE
 
-/* The size of `long double', as computed by sizeof. */
+/* The size of 'long double', as computed by sizeof. */
 #undef SIZEOF_LONG_DOUBLE
 
-/* The size of `size_t', as computed by sizeof. */
+/* The size of 'size_t', as computed by sizeof. */
 #undef SIZEOF_SIZE_T
 
-/* Define to 1 if all of the C90 standard headers exist (not just the ones
+/* Define to 1 if all of the C89 standard headers exist (not just the ones
    required in a freestanding environment). This macro is provided for
    backward compatibility; new code need not use it. */
 #undef STDC_HEADERS
diff --git a/ffitest.c b/ffitest.c
new file mode 100644
index 000000000000..504884c3630f
--- /dev/null
+++ b/ffitest.c
@@ -0,0 +1,34 @@
+#include <stdio.h>
+#include <ffi.h>
+
+int main()
+{
+    ffi_cif cif;
+    ffi_type *args[1];
+    void *values[1];
+    char *s;
+    ffi_arg rc;
+
+    /* Initialize the argument info vectors */
+    args[0] = &ffi_type_pointer;
+    values[0] = &s;
+
+    /* Initialize the cif */
+    if (ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+                     &ffi_type_sint, args) == FFI_OK) 
+    {
+        s = "Hello World!";
+        ffi_call(&cif, puts, &rc, values);
+        /* rc now holds the result of the call to puts */
+
+        /* values holds a pointer to the function's arg, so to
+           call puts() again all we need to do is change the
+           value of s */
+        s = "This is cool!";
+        ffi_call(&cif, puts, &rc, values);
+    }
+
+    return 0;
+}
+
+
diff --git a/ffitest.expected b/ffitest.expected
new file mode 100644
index 000000000000..2648dbba26db
--- /dev/null
+++ b/ffitest.expected
@@ -0,0 +1,2 @@
+Hello World!
+This is cool!
diff --git a/src/closures.c b/src/closures.c
index 67a94a822ca0..3090c4abc42a 100644
--- a/src/closures.c
+++ b/src/closures.c
@@ -38,6 +38,30 @@
 #include <ffi_common.h>
 #include <tramp.h>
 
+#ifdef __FILC__
+
+#include <stdfil.h>
+
+extern void ffi_closure_callback (void);
+
+void *
+ffi_closure_alloc (size_t size, void **code)
+{
+  *code = zclosure_new(ffi_closure_callback, NULL);
+  return *code;
+}
+
+void
+ffi_closure_free (__attribute__((unused)) void *ptr)
+{
+}
+
+int ffi_tramp_is_present(__attribute__((unused)) void *ptr)
+{
+  return 0;
+}
+
+#else /* __FILC__ -> so !__FILC__ */
 #ifdef __NetBSD__
 #include <sys/param.h>
 #endif
@@ -1104,4 +1128,6 @@ ffi_tramp_is_present (__attribute__((unused)) void *ptr)
 #endif /* FFI_CLOSURES */
 
 #endif /* NetBSD with PROT_MPROTECT */
+#endif /* !__FILC__ */
 #endif /* __EMSCRIPTEN__ */
+
diff --git a/src/x86/ffi64.c b/src/x86/ffi64.c
index 6a8e37fc5679..8da593d1bb91 100644
--- a/src/x86/ffi64.c
+++ b/src/x86/ffi64.c
@@ -33,9 +33,14 @@
 #include <stdlib.h>
 #include <stdarg.h>
 #include <stdint.h>
+#include <stdbool.h>
 #include <tramp.h>
 #include "internal64.h"
 
+#ifdef __FILC__
+#include <stdfil.h>
+#endif
+
 #ifdef __x86_64__
 
 #define MAX_GPR_REGS 6
@@ -69,8 +74,16 @@ struct register_args
   UINT64 r10;	/* static chain */
 };
 
+#ifdef __FILC__
+static bool is_filc = true;
+#else
+static bool is_filc = false;
+#endif
+
+#ifndef __FILC__
 extern void ffi_call_unix64 (void *args, unsigned long bytes, unsigned flags,
 			     void *raddr, void (*fnaddr)(void)) FFI_HIDDEN;
+#endif
 
 /* All reference to register classes here is identical to the code in
    gcc/config/i386/i386.c. Do *not* change one without the other.  */
@@ -392,7 +405,7 @@ examine_argument (ffi_type *type, enum x86_64_reg_class classes[MAX_CLASSES],
 
 /* Perform machine dependent cif processing.  */
 
-#ifndef __ILP32__
+#if !defined(__ILP32__) && !defined(__FILC__)
 extern ffi_status
 ffi_prep_cif_machdep_efi64(ffi_cif *cif);
 #endif
@@ -406,12 +419,17 @@ ffi_prep_cif_machdep (ffi_cif *cif)
   size_t bytes, n, rtype_size;
   ffi_type *rtype;
 
-#ifndef __ILP32__
+#ifdef __FILC__
+  if (cif->abi != FFI_FILC)
+    return FFI_BAD_ABI;
+#else
+# ifndef __ILP32__
   if (cif->abi == FFI_EFI64 || cif->abi == FFI_GNUW64)
     return ffi_prep_cif_machdep_efi64(cif);
-#endif
+# endif
   if (cif->abi != FFI_UNIX64)
     return FFI_BAD_ABI;
+#endif
 
   gprcount = ssecount = 0;
 
@@ -530,7 +548,8 @@ ffi_prep_cif_machdep (ffi_cif *cif)
      not, add it's size to the stack byte count.  */
   for (bytes = 0, i = 0, avn = cif->nargs; i < avn; i++)
     {
-      if (examine_argument (cif->arg_types[i], classes, 0, &ngpr, &nsse) == 0
+      if (is_filc
+          || examine_argument (cif->arg_types[i], classes, 0, &ngpr, &nsse) == 0
 	  || gprcount + ngpr > MAX_GPR_REGS
 	  || ssecount + nsse > MAX_SSE_REGS)
 	{
@@ -561,6 +580,57 @@ static void
 ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue,
 	      void **avalue, void *closure)
 {
+#ifdef __FILC__
+  char *stack, *argp;
+  ffi_type **arg_types;
+  int i, avn, flags;
+  size_t bytes;
+  void *rets;
+
+  FFI_ASSERT (cif->abi == FFI_FILC);
+  FFI_ASSERT (closure == NULL);
+
+  flags = cif->flags;
+  bytes = cif->bytes;
+  if (flags & UNIX64_FLAG_RET_IN_MEM)
+    bytes += sizeof (void*);
+
+  stack = alloca (bytes);
+  argp = stack;
+
+  if (flags & UNIX64_FLAG_RET_IN_MEM)
+    {
+      if (rvalue == NULL)
+        rvalue = alloca (cif->rtype->size);
+
+      *(void **) argp = rvalue;
+      argp += sizeof (void*);
+    }
+
+  arg_types = cif->arg_types;
+  avn = cif->nargs;
+
+  for (i = 0; i < avn; ++i)
+    {
+      size_t size = size = arg_types[i]->size;
+      long align = arg_types[i]->alignment;
+
+      if (align < 8)
+        align = 8;
+
+      argp = (void *) FFI_ALIGN (argp, align);
+      memcpy (argp, avalue[i], size);
+
+      argp += size;
+    }
+
+  FFI_ASSERT (argp == stack + cif->bytes);
+
+  rets = zcall (fn, stack);
+
+  if (rvalue != NULL && !(flags & UNIX64_FLAG_RET_IN_MEM))
+    memcpy (rvalue, rets, cif->rtype->size);
+#else
   enum x86_64_reg_class classes[MAX_CLASSES];
   char *stack, *argp;
   ffi_type **arg_types;
@@ -672,9 +742,10 @@ ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue,
 
   ffi_call_unix64 (stack, cif->bytes + sizeof (struct register_args),
 		   flags, rvalue, fn);
+#endif
 }
 
-#ifndef __ILP32__
+#if !defined(__ILP32__) && !defined(__FILC__)
 extern void
 ffi_call_efi64(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue);
 #endif
@@ -682,8 +753,10 @@ ffi_call_efi64(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue);
 void
 ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
 {
+#ifndef __FILC__
   ffi_type **arg_types = cif->arg_types;
   int i, nargs = cif->nargs;
+
   const int max_reg_struct_size = cif->abi == FFI_GNUW64 ? 8 : 16;
 
   /* If we have any large structure arguments, make a copy so we are passing
@@ -706,6 +779,7 @@ ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
       ffi_call_efi64(cif, fn, rvalue, avalue);
       return;
     }
+#endif
 #endif
   ffi_call_int (cif, fn, rvalue, avalue, NULL);
 }
@@ -741,7 +815,7 @@ extern void ffi_closure_unix64_alt(void) FFI_HIDDEN;
 extern void ffi_closure_unix64_sse_alt(void) FFI_HIDDEN;
 #endif
 
-#ifndef __ILP32__
+#if !defined(__ILP32__) && !defined(__FILC__)
 extern ffi_status
 ffi_prep_closure_loc_efi64(ffi_closure* closure,
 			   ffi_cif* cif,
@@ -757,6 +831,9 @@ ffi_prep_closure_loc (ffi_closure* closure,
 		      void *user_data,
 		      void *codeloc)
 {
+#ifdef __FILC__
+  zclosure_set_data (codeloc, closure);
+#else
   static const unsigned char trampoline[24] = {
     /* endbr64 */
     0xf3, 0x0f, 0x1e, 0xfa,
@@ -801,6 +878,7 @@ ffi_prep_closure_loc (ffi_closure* closure,
 
 #if defined(FFI_EXEC_STATIC_TRAMP)
 out:
+#endif
 #endif
   closure->cif = cif;
   closure->fun = fun;
@@ -809,6 +887,57 @@ out:
   return FFI_OK;
 }
 
+#ifdef __FILC__
+void FFI_HIDDEN
+ffi_closure_callback (void)
+{
+  ffi_closure *closure;
+  ffi_cif *cif;
+  void (*fun)(ffi_cif*, void*, void**, void*);
+  char *argp;
+  void *user_data, **avalue, *rvalue;
+  int i, avn, flags;
+  ffi_type **arg_types;
+
+  closure = zcallee_closure_data ();
+  cif = closure->cif;
+  fun = closure->fun;
+  user_data = closure->user_data;
+
+  avn = cif->nargs;
+  flags = cif->flags;
+  arg_types = cif->arg_types;
+
+  argp = zargs ();
+
+  avalue = alloca (avn * sizeof (void *));
+
+  if (flags & UNIX64_FLAG_RET_IN_MEM)
+    {
+      rvalue = *(void **) argp;
+      argp += sizeof (void*);
+    }
+  else
+    rvalue = alloca (cif->rtype->size);
+
+  for (i = 0; i < avn; ++i)
+    {
+      long align = arg_types[i]->alignment;
+
+      if (align < 8)
+        align = 8;
+
+      argp = (void *) FFI_ALIGN (argp, align);
+      avalue[i] = argp;
+      argp += arg_types[i]->size;
+    }
+
+  fun (cif, rvalue, avalue, user_data);
+
+  if (!(flags & UNIX64_FLAG_RET_IN_MEM))
+    zreturn (rvalue);
+}
+#else
 int FFI_HIDDEN
 ffi_closure_unix64_inner(ffi_cif *cif,
 			 void (*fun)(ffi_cif*, void*, void**, void*),
@@ -901,6 +1030,7 @@ ffi_closure_unix64_inner(ffi_cif *cif,
   /* Tell assembly how to perform return type promotions.  */
   return flags;
 }
+#endif
 
 #ifdef FFI_GO_CLOSURES
 
diff --git a/src/x86/ffitarget.h b/src/x86/ffitarget.h
index 5a3399d80982..ac676917b4b6 100644
--- a/src/x86/ffitarget.h
+++ b/src/x86/ffitarget.h
@@ -81,7 +81,13 @@ typedef signed long            ffi_sarg;
 #endif
 
 typedef enum ffi_abi {
-#if defined(X86_WIN64)
+#if defined(__FILC__)
+  FFI_FIRST_ABI = 0,
+  FFI_FILC,
+  FFI_UNIX64 = FFI_FILC,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_FILC
+#elif defined(X86_WIN64)
   FFI_FIRST_ABI = 0,
   FFI_WIN64,            /* sizeof(long double) == 8  - microsoft compilers */
   FFI_GNUW64,           /* sizeof(long double) == 16 - GNU compilers */
@@ -130,7 +136,9 @@ typedef enum ffi_abi {
 /* ---- Definitions for closures ----------------------------------------- */
 
 #define FFI_CLOSURES 1
+#ifndef __FILC__
 #define FFI_GO_CLOSURES 1
+#endif
 
 #define FFI_TYPE_SMALL_STRUCT_1B (FFI_TYPE_LAST + 1)
 #define FFI_TYPE_SMALL_STRUCT_2B (FFI_TYPE_LAST + 2)
