diff --git a/gnulib-tests/test-explicit_bzero.c b/gnulib-tests/test-explicit_bzero.c
index 42d9d3cb6084..108bf3e44d5b 100644
--- a/gnulib-tests/test-explicit_bzero.c
+++ b/gnulib-tests/test-explicit_bzero.c
@@ -111,6 +111,7 @@ test_heap (void)
   explicit_bzero (heapbuf, SECRET_SIZE);
   free (heapbuf);
   heapbuf = (char *) addr;
+#ifndef __FILC__
   if (is_range_mapped (addr, addr + SECRET_SIZE))
     {
       /* some implementation could override freed memory by canaries so
@@ -119,6 +120,7 @@ test_heap (void)
       printf ("test_heap: address range is still mapped after free().\n");
     }
   else
+#endif
     printf ("test_heap: address range is unmapped after free().\n");
 }
 
diff --git a/gnulib-tests/test-free.c b/gnulib-tests/test-free.c
index 9248712b1b36..3643e6de1d84 100644
--- a/gnulib-tests/test-free.c
+++ b/gnulib-tests/test-free.c
@@ -111,7 +111,7 @@ main ()
      But do not test it with glibc < 2.15, since that triggers a glibc internal
      abort: "malloc.c:3551: munmap_chunk: Assertion `ret == 0' failed."
    */
-  #if defined __linux__ && !(__GLIBC__ == 2 && __GLIBC_MINOR__ < 15)
+  #if defined __linux__ && !(__GLIBC__ == 2 && __GLIBC_MINOR__ < 15) && !defined __FILC__
   if (open ("/proc/sys/vm/max_map_count", O_RDONLY) >= 0)
     {
       /* Preparations.  */
diff --git a/gnulib-tests/test-malloc-gnu.c b/gnulib-tests/test-malloc-gnu.c
index 8873eb893fe2..69b3ec8dd3e3 100644
--- a/gnulib-tests/test-malloc-gnu.c
+++ b/gnulib-tests/test-malloc-gnu.c
@@ -32,6 +32,7 @@ main (int argc, char **argv)
   ASSERT (p != NULL);
   free (p);
 
+#ifndef __FILC__
   /* Check that malloc (n) fails when n exceeds PTRDIFF_MAX.  */
   if (PTRDIFF_MAX < SIZE_MAX)
     {
@@ -40,6 +41,7 @@ main (int argc, char **argv)
       ASSERT (p == NULL);
       ASSERT (errno == ENOMEM);
     }
+#endif
 
   return 0;
 }
diff --git a/gnulib-tests/test-realloc-gnu.c b/gnulib-tests/test-realloc-gnu.c
index c3bca67a2692..d3ceb851196d 100644
--- a/gnulib-tests/test-realloc-gnu.c
+++ b/gnulib-tests/test-realloc-gnu.c
@@ -31,6 +31,7 @@ main (int argc, char **argv)
   void *volatile p = realloc (NULL, 0);
   ASSERT (p != NULL);
 
+#ifndef __FILC__
   /* Check that realloc (p, n) fails when p is non-null and n exceeds
      PTRDIFF_MAX.  */
   if (PTRDIFF_MAX < SIZE_MAX)
@@ -43,6 +44,7 @@ main (int argc, char **argv)
       if (!getenv ("MALLOC_CHECK_"))
         ASSERT (errno == ENOMEM);
     }
+#endif
 
   free (p);
   return 0;
diff --git a/gnulib-tests/test-reallocarray.c b/gnulib-tests/test-reallocarray.c
index b830361d645f..b5ba55f84be9 100644
--- a/gnulib-tests/test-reallocarray.c
+++ b/gnulib-tests/test-reallocarray.c
@@ -30,6 +30,7 @@ SIGNATURE_CHECK (reallocarray, void *, (void *, size_t, size_t));
 int
 main ()
 {
+#ifndef __FILC__
   /* Check that reallocarray fails when requested to allocate a block
      of memory larger than PTRDIFF_MAX or SIZE_MAX bytes.  */
   for (size_t n = 2; n != 0; n <<= 1)
@@ -53,6 +54,7 @@ main ()
       p = reallocarray (p, n, 0);
       free (p);
     }
+#endif
 
   return 0;
 }
diff --git a/lib/obstack.h b/lib/obstack.h
index de16ac9247f2..184ca478711f 100644
--- a/lib/obstack.h
+++ b/lib/obstack.h
@@ -109,6 +109,8 @@
 
 #include <stddef.h>             /* For size_t and ptrdiff_t.  */
 #include <string.h>             /* For __GNU_LIBRARY__, and memcpy.  */
+#include <stdfil.h>
+#include <inttypes.h>
 
 #if __STDC_VERSION__ < 199901L || defined __HP_cc
 # define __FLEXIBLE_ARRAY_MEMBER 1
@@ -133,7 +135,10 @@
    aligning P to the next multiple of A + 1.  B and P must be of type
    char *.  A + 1 must be a power of 2.  */
 
-#define __BPTR_ALIGN(B, P, A) ((B) + (((P) - (B) + (A)) & ~(A)))
+#define __BPTR_ALIGN(B, P, A)                                            \
+  __extension__                                                          \
+    ({ char *__P = (char *) (P);                                         \
+       zmkptr(__P, (uintptr_t)((B) + ((__P - (B) + (A)) & ~(A)))); })
 
 /* Similar to __BPTR_ALIGN (B, P, A), except optimize the common case
    where pointers can be converted to integers, aligned as integers,
