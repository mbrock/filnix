--- trealla-clean/src/bif_ffi.c	2025-11-05 07:20:11.000000000 +0200
+++ trealla-patched/src/bif_ffi.c	2025-11-05 14:56:34.290889044 +0200
@@ -6,12 +6,23 @@
 #if USE_FFI
 #include <dlfcn.h>
 #include <ffi.h>
+#include <stdfil.h>
 #endif
 
 #include "module.h"
 #include "prolog.h"
 #include "query.h"
 
+#if USE_FFI
+// Global pointer table for FFI handles (dlopen/dlsym results)
+static zptrtable *g_ffi_handles = NULL;
+
+static void ensure_ffi_handles(void) {
+	if (!g_ffi_handles)
+		g_ffi_handles = zptrtable_new();
+}
+#endif
+
 // These are pseudo tags just used here...
 
 enum {
@@ -114,8 +125,10 @@
 	GET_NEXT_ARG(p3,var);
 	void *handle = do_dlopen(C_STR(q, p1), get_smallint(p2));
 	if (!handle) return false;
+	ensure_ffi_handles();
+	uintptr_t encoded = zptrtable_encode(g_ffi_handles, handle);
 	cell tmp;
-	make_uint(&tmp, (pl_int)(size_t)handle);
+	make_uint(&tmp, encoded);
 	tmp.flags |= FLAG_INT_HANDLE | FLAG_HANDLE_DLL;
 	return unify(q, p3, p3_ctx, &tmp, q->st.cur_ctx);
 }
@@ -125,16 +138,19 @@
 	GET_FIRST_ARG(p1,integer);
 	GET_NEXT_ARG(p2,atom);
 	GET_NEXT_ARG(p3,var);
-	size_t handle = get_smalluint(p1);
+	uintptr_t encoded_handle = get_smalluint(p1);
 	const char *symbol = C_STR(q, p2);
 
 	if (!(p1->flags & FLAG_INT_HANDLE) && !(p1->flags & FLAG_HANDLE_DLL))
 		return throw_error(q, p1, p1_ctx, "existence_error", "handle");
 
-	void *ptr = dlsym((void*)handle, symbol);
+	ensure_ffi_handles();
+	void *handle = zptrtable_decode(g_ffi_handles, encoded_handle);
+	void *ptr = dlsym(handle, symbol);
 	if (!ptr) return false;
+	uintptr_t encoded_fn = zptrtable_encode(g_ffi_handles, ptr);
 	cell tmp;
-	make_uint(&tmp, (pl_int)(size_t)ptr);
+	make_uint(&tmp, encoded_fn);
 	tmp.flags |= FLAG_INT_HANDLE;
 	return unify(q, p3, p3_ctx, &tmp, q->st.cur_ctx);
 }
@@ -147,12 +163,14 @@
 static bool bif_sys_dlclose_1(query *q)
 {
 	GET_FIRST_ARG(p1,integer);
-	size_t handle = get_smalluint(p1);
+	uintptr_t encoded_handle = get_smalluint(p1);
 
 	if (!(p1->flags & FLAG_INT_HANDLE) && !(p1->flags & FLAG_HANDLE_DLL))
 		return throw_error(q, p1, p1_ctx, "existence_error", "handle");
 
-	return do_dlclose((void*)handle) ? false : true;
+	ensure_ffi_handles();
+	void *handle = zptrtable_decode(g_ffi_handles, encoded_handle);
+	return do_dlclose(handle) ? false : true;
 }
 
 static int max_struct_idx = 0, max_ffi_idx = 8;
@@ -205,9 +223,11 @@
 	if (!(p1->flags & FLAG_INT_HANDLE) && !(p1->flags & FLAG_HANDLE_DLL))
 		return throw_error(q, p1, p1_ctx, "existence_error", "handle");
 
-	size_t handle = get_smalluint(p1);
+	uintptr_t encoded_handle = get_smalluint(p1);
+	ensure_ffi_handles();
+	void *handle = zptrtable_decode(g_ffi_handles, encoded_handle);
 	const char *symbol = C_STR(q, p2);
-	void *func = dlsym((void*)handle, symbol);
+	void *func = dlsym(handle, symbol);
 	if (!func) return false;
 
 	uint8_t arg_types[MAX_FFI_ARGS], ret_type = 0;
