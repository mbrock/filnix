#+TITLE: Porting Nix to Fil-C
#+AUTHOR: Generated Analysis
#+DATE: 2025-11-05

* Overview

This document outlines the strategy for porting Nix (the package manager and evaluator) to build and run with Fil-C, achieving complete memory safety for the Nix toolchain.

** Why Port Nix to Fil-C?

- Memory-safe package manager and build daemon
- Secure expression evaluation (no buffer overflows, use-after-free)
- Hardened infrastructure for critical supply chain component
- Dogfooding: Use fil-c Nix to build fil-c Nix

** Scope

Two main components with different complexity levels:

1. *libstore + CLI tools* (nix-build, nix-env, nix-store) - Lower complexity
2. *libexpr evaluator* (Nix language runtime) - Higher complexity

** Key Constraint

Fil-C and non-fil-c code cannot link together. All components must be compiled with fil-c:
- Core Nix libraries
- Plugins (if enabled)
- Dependencies (boost, nlohmann-json, etc.)

* Feasibility Assessment

** Compatibility Matrix

| Component | Risk Level | Reason | Mitigation |
|-----------+------------+--------+------------|
| Store GC | ðŸŸ¢ Low | File-based, string scanning | None needed |
| Daemon Protocol | ðŸŸ¢ Low | Value serialization, no pointers | None needed |
| CLI Tools | ðŸŸ¢ Low | Mostly libstore usage | None needed |
| Expression Evaluator | ðŸŸ¡ Medium | Pointer tagging, Boehm GC | Disable Boehm, rewrite tagging |
| Boehm GC | ðŸ”´ High | Conflicts with FUGC | Disable with build flag |
| Pointer Tagging | ðŸŸ¡ Medium | 3-bit discriminators in Value* | Use z*ptr intrinsics |
| Plugin System | ðŸŸ¢ Low | Rarely used, unstable API | Disable or require fil-c plugins |

** Estimated Effort

- *Option A (Boehm disabled):* 2-3 weeks
  - FFI boundary fixes
  - Testing store operations
  
- *Option B (Full port):* 2-3 months
  - All of Option A
  - Pointer tagging conversion (hundreds of sites)
  - Value layout refactoring
  - Comprehensive evaluator testing

* Critical Issues

** Issue #1: Boehm GC Conflict

*** Problem

Nix's expression evaluator uses Boehm GC for automatic memory management:
- Conservative stack/heap scanning
- Tagged pointer support via ~GC_register_displacement~
- Batch allocation caches (~GC_malloc_many~)

Fil-C has its own FUGC (Fil's Unified Garbage Collector). Two GCs cannot coexist:
- Both scan stacks for roots
- Conflicting allocation strategies
- Undefined behavior with dual collection

*** Solution

Nix already supports building without Boehm GC:

#+begin_src bash
meson setup build -Dgc=disabled
#+end_src

When disabled:
- Expression evaluator uses standard malloc/free
- FUGC intercepts malloc and provides memory safety
- Higher memory usage (no automatic collection of intermediate values)
- Acceptable trade-off for memory safety

*** Precedent

Similar to Emacs port in pizlonator/fil-c - custom GC replaced with fil-c's runtime.

** Issue #2: Pointer Tagging in Value Type

*** Problem

Nix uses sophisticated pointer tagging to compress ~Value~ from 24 bytes to 16 bytes.

*Source:* ~src/libexpr/include/nix/expr/value.hh:381-648~

#+begin_src cpp
// 3-bit discriminator stored in lower bits of pointers
template<std::size_t ptrSize>
class alignas(16) ValueStorage<...> {
    static constexpr uintptr_t discriminatorMask = 0x7;
    
    template<typename T>
    static T untagPointer(PackedPointer val) noexcept {
        return std::bit_cast<T>(val & ~discriminatorMask);
    }
};
#+end_src

Direct bitwise operations destroy fil-c capabilities:
- ~val & ~discriminatorMask~ strips capability metadata
- Reconstructed pointer has no bounds information

*** Solution: Use Fil-C Tagged Pointer Intrinsics

Replace bitwise operations with capability-preserving intrinsics:

#+begin_src diff
-template<typename T>
-static T untagPointer(PackedPointer val) noexcept {
-    return std::bit_cast<T>(val & ~discriminatorMask);
-}
+#include <stdfil.h>
+
+template<typename T>
+static T untagPointer(PackedPointer val) noexcept {
+    return std::bit_cast<T>(zandptr(val, ~discriminatorMask));
+}
#+end_src

*Required changes:*
- Replace ~&~ with ~zandptr~ for masking tag bits
- Replace ~|~ with ~zorptr~ for setting tag bits  
- Replace ~^~ with ~zxorptr~ for toggling bits
- Use ~zretagptr(new_ptr, old_ptr, mask)~ when replacing pointer while preserving tags

*Scope:* ~100-200 call sites in libexpr

*** Alternative: Disable Pointer Tagging

Accept 24-byte ~Value~ size instead of 16-byte:
- Remove ~alignas(16)~ and ~useBitPackedValueStorage~ specialization
- Use explicit tag field in struct
- ~50% more memory for Values (24 vs 16 bytes)
- Simpler porting effort (no z*ptr conversions needed)

Trade-off: Memory usage vs porting complexity

** Issue #3: Plugin System

*** Current Status

Plugin ecosystem is minimal:
- Only ~2 known third-party plugins exist
- Zero usage in nixpkgs  
- Explicitly unstable API
- Optional feature (added 2018)

*** Options

*Option A: Disable Plugins*

#+begin_src nix
# In Nix build configuration
mesonFlags = [
  "-Dplugins=disabled"  # If such flag exists
];
#+end_src

Impact: None for 99.9% of users

*Option B: Require Fil-C Plugins*

Since fil-c and non-fil-c code can't link:
- Plugins must be compiled with fil-c
- Document requirement in release notes
- Acceptable given instability and rare usage

*** Recommendation

Start with plugins disabled. Add support later if needed.

* Porting Strategy

** Phase 1: Minimal Port (Store + CLI Tools)

*Goal:* Memory-safe nix-store, nix-build, nix-env without evaluator changes

*** Steps

1. Configure build with Boehm GC disabled:
   #+begin_src bash
   meson setup build \
     -Dgc=disabled \
     -Dplugins=disabled \
     CC=filcc CXX=filc++
   #+end_src

2. Build libutil, libstore, and CLI tools

3. Test store operations:
   #+begin_src bash
   # Basic store tests
   nix-store --add /etc/hosts
   nix-store --verify --check-contents
   nix-store --gc
   
   # Build tests (requires evaluator)
   nix-build '<nixpkgs>' -A hello  # Will fail - evaluator needed
   #+end_src

*** Expected Issues

- Boehm GC references in libutil/libstore (should be minimal)
- Atomic operations on pointers (use ~void*_Atomic~ instead of ~atomic_uintptr_t~)
- Any pointer-to-integer conversions in store path handling

*** Success Criteria

- ~nix-store~ operations work correctly
- Store GC runs without errors
- No capability-related crashes

** Phase 2: Evaluator Without Pointer Tagging

*Goal:* Working expression evaluator with 24-byte Values

*** Steps

1. Disable pointer tagging:
   #+begin_src diff
   --- a/src/libexpr/include/nix/expr/value.hh
   +++ b/src/libexpr/include/nix/expr/value.hh
   @@ -379,7 +379,10 @@ namespace nix {
    
   -template<std::size_t ptrSize>
   -class alignas(16) ValueStorage<...>
   +// Fil-C: Disable pointer tagging - accept 24-byte Values
   +#define NIX_DISABLE_PACKED_VALUES 1
   +
   +template<std::size_t ptrSize>
   +class ValueStorage<...>  // Remove alignas(16)
   #+end_src

2. Build libexpr with fil-c:
   #+begin_src bash
   ninja src/libexpr/libnixexpr.so
   #+end_src

3. Fix any atomic pointer issues:
   #+begin_src diff
   --- a/src/libexpr/eval.hh
   +++ b/src/libexpr/eval.hh
   -atomic_uintptr_t somePointer;
   +void* _Atomic somePointer;
   #+end_src

*** Testing

#+begin_src bash
# Expression evaluation tests
nix-instantiate --eval -E '1 + 1'
nix-instantiate --eval -E 'builtins.toString 42'
nix-instantiate --eval -E 'with import <nixpkgs> {}; hello.name'

# Build tests
nix-build '<nixpkgs>' -A hello
nix-build '<nixpkgs>' -A python3

# Run full test suite
meson test
#+end_src

*** Success Criteria

- All basic evaluation tests pass
- Can build simple derivations
- No memory safety violations detected
- Store GC still works

** Phase 3: Optimized Port (Pointer Tagging)

*Goal:* Restore 16-byte Value size using fil-c tagged pointer intrinsics

*** Steps

1. Audit all pointer tagging operations:
   #+begin_src bash
   rg 'discriminatorMask|PackedPointer' src/libexpr/
   #+end_src

2. Replace bitwise operations systematically:

   *Pattern 1: Extract tag bits (reading)*
   #+begin_src diff
   -auto flags = (uintptr_t)ptr & discriminatorMask;
   +auto flags = (uintptr_t)ptr & discriminatorMask;  // âœ“ OK - casting to int for reading
   #+end_src
   
   *Pattern 2: Remove tag bits (untagging)*
   #+begin_src diff
   -void* untagged = (void*)(val & ~discriminatorMask);
   +void* untagged = (void*)zandptr(val, ~discriminatorMask);
   #+end_src
   
   *Pattern 3: Set tag bits (tagging)*
   #+begin_src diff
   -PackedPointer tagged = (uintptr_t)ptr | TAG_VALUE;
   +PackedPointer tagged = (PackedPointer)zorptr(ptr, TAG_VALUE);
   #+end_src
   
   *Pattern 4: Replace pointer, preserve tag*
   #+begin_src diff
   -new_val = (uintptr_t)new_ptr | (old_val & discriminatorMask);
   +new_val = (PackedPointer)zretagptr(new_ptr, old_val, ~discriminatorMask);
   #+end_src

3. Add stdfil.h includes:
   #+begin_src diff
   --- a/src/libexpr/include/nix/expr/value.hh
   +++ b/src/libexpr/include/nix/expr/value.hh
   @@ -1,6 +1,10 @@
    #pragma once
    
   +#ifdef __PIZLONATOR_WAS_HERE__
   +#include <stdfil.h>
   +#endif
   +
    #include "symbol-table.hh"
   #+end_src

*** Testing

Same as Phase 2, plus:

#+begin_src bash
# Memory usage regression test
nix-instantiate --eval -E 'builtins.seq (builtins.genList (x: x) 1000000) null'

# Ensure 16-byte Values
cat > check-value-size.cc << 'EOF'
#include "nix/expr/value.hh"
static_assert(sizeof(nix::Value) == 16, "Value should be 16 bytes");
EOF
filc++ -c check-value-size.cc -I src/libexpr/include/
#+end_src

*** Success Criteria

- All Phase 2 tests still pass
- Value size is 16 bytes
- No performance regressions
- Memory usage comparable to non-fil-c build

* Build Configuration

** Meson Options for Fil-C

#+begin_src bash
meson setup build-filc \
  --buildtype=debug \
  -Dgc=disabled \
  -Dplugins=disabled \
  CC=filcc \
  CXX=filc++ \
  AR=filc-ar \
  LD=filc-ld
#+end_src

** Environment Variables

#+begin_src bash
export CC=filcc
export CXX=filc++
export CFLAGS="-O0 -g"
export CXXFLAGS="-O0 -g"
#+end_src

** Nix Flake Expression

#+begin_src nix
{
  description = "Nix built with Fil-C for complete memory safety";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    filnix.url = "github:mbrock/filnix";
  };

  outputs = { self, nixpkgs, filnix }: {
    packages.x86_64-linux.nix-filc = 
      let
        pkgs = nixpkgs.legacyPackages.x86_64-linux;
        filc = filnix.packages.x86_64-linux.filc;
      in
      pkgs.nix.overrideAttrs (old: {
        pname = "nix-filc";
        
        nativeBuildInputs = old.nativeBuildInputs ++ [ filc ];
        
        mesonFlags = (old.mesonFlags or []) ++ [
          "-Dgc=disabled"
          "-Dplugins=disabled"
        ];
        
        preConfigure = ''
          export CC=filcc
          export CXX=filc++
        '';
        
        # Disable tests initially during porting
        doCheck = false;
        doInstallCheck = false;
      });
  };
}
#+end_src

* Testing Strategy

** Unit Tests

Run Nix's existing test suite:

#+begin_src bash
# Meson tests
meson test -C build-filc

# Functional tests
make -C tests functional-tests
#+end_src

** Integration Tests

#+begin_src bash
# Store operations
./build-filc/src/nix/nix store verify --all
./build-filc/src/nix/nix store gc

# Evaluation
./build-filc/src/nix/nix eval --expr '1 + 1'
./build-filc/src/nix/nix eval nixpkgs#hello.name

# Building
./build-filc/src/nix/nix build nixpkgs#hello
./build-filc/src/nix/nix build nixpkgs#python3
#+end_src

** Stress Tests

#+begin_src bash
# Large evaluations
nix-instantiate '<nixpkgs>' -A stdenv.drvPath

# Many simultaneous builds
nix-build '<nixpkgs>' -A {bash,coreutils,findutils,diffutils,gnugrep}

# GC during builds
nix-store --gc &
nix-build '<nixpkgs>' -A hello
#+end_src

** Memory Safety Validation

#+begin_src bash
# Fil-C should catch these at runtime:
# - Buffer overflows in string handling
# - Use-after-free in evaluation
# - Out-of-bounds array access

# Known vulnerable patterns (if any exist):
# TODO: Identify from CVE history
#+end_src

* Comparison to Other Ports

** Simpler Than

- *Python* (1500 LOC) - extensive GC rewrite, atomics, frame management
- *Perl* (892 LOC) - 20+ pointer tables for XS interface
- *Emacs* (588 LOC) - complete allocator replacement

** Similar To

- *Git* (524 LOC) - mostly type changes, intptr_t â†’ void*
- *Systemd* (455 LOC) - linker flags, version script changes

** Harder Than

- *Trealla* (30 LOC) - already capability-friendly design
- *Vim* (13 LOC) - single bugfix
- *Dash* (13 LOC) - vfork â†’ fork change

** Estimated Scope

- *Phase 1 (Store):* 50-100 LOC changes
- *Phase 2 (Evaluator):* 200-400 LOC changes  
- *Phase 3 (Optimized):* 400-800 LOC changes

* Known Issues and Workarounds

** Issue: Flexible Array Members

Nix uses FAMs for variable-sized structures:

#+begin_src cpp
struct Bindings {
    size_t numAttrs;
    Attr attrs[0];  // Flexible array member
};
#+end_src

*Fil-C behavior:* FAMs work fine - bounds tracked via allocation size.

*No changes needed.*

** Issue: std::bit_cast

Nix uses ~std::bit_cast~ for pointer â†” integer conversions.

*Fil-C behavior:* ~bit_cast~ preserves capability metadata (unlike C-style cast).

*No changes needed* if only used for type punning, not bit manipulation.

** Issue: Monotonic Buffer Resources

Nix uses ~std::pmr::monotonic_buffer_resource~ for arena allocation.

*Fil-C behavior:* Standard C++ allocators work fine with FUGC.

*No changes needed.*

** Issue: ChunkedVector

Custom vector implementation with stable references.

*Fil-C behavior:* No special pointer tricks - just array indexing.

*No changes needed.*

* Migration Path for Ecosystem

** Nix Itself

1. Port core Nix (this document)
2. Test with existing package set
3. Release as opt-in ~nix-filc~ package

** Nixpkgs Packages

Most packages don't need changes:
- Nix evaluator memory safety â‰  package memory safety
- Fil-C Nix can build non-fil-c packages normally

Eventually:
- Packages could opt into fil-c compilation
- Start with leaf packages (no dependents)
- Gradually build fil-c package ecosystem

** Plugin Authors

If plugins re-enabled:
- Document fil-c requirement
- Provide filc++ build instructions
- Most plugins are simple - recompilation should suffice

* Success Metrics

** Phase 1 Success

- [ ] ~nix-store --verify~ works
- [ ] ~nix-store --gc~ completes
- [ ] Store database operations succeed
- [ ] No capability violations in store tests

** Phase 2 Success  

- [ ] ~nix-instantiate --eval~ works for basic expressions
- [ ] Can build simple derivations (~hello~, ~coreutils~)
- [ ] Full test suite passes (or failures documented)
- [ ] Can evaluate ~<nixpkgs>~ without crashes

** Phase 3 Success

- [ ] 16-byte Value size restored
- [ ] Memory usage comparable to baseline
- [ ] Performance within 2x of non-fil-c build
- [ ] Can build complex derivations (Python, GCC, etc.)

** Production Readiness

- [ ] All nixpkgs tests pass
- [ ] Can build NixOS system closure
- [ ] Multi-hour builds stable
- [ ] Daemon mode works correctly
- [ ] Binary cache operations succeed

* References

** Fil-C Documentation

- Main repository: https://github.com/pizlonator/fil-c
- Tagged pointer intrinsics: ~zorptr~, ~zandptr~, ~zxorptr~, ~zretagptr~
- Pointer tables: ~zptrtable~, ~zexact_ptrtable~
- Alignment: ~zmkptr~
- Syscall wrappers: ~zsys_*~

** Nix Source Code

- Expression evaluator: ~src/libexpr/~
- Store implementation: ~src/libstore/~
- Value representation: ~src/libexpr/include/nix/expr/value.hh~
- GC integration: ~src/libexpr/eval-gc.cc~
- Plugin system: ~src/libmain/plugin.cc~

** Related Ports

See ~ports/analysis.md~ in this repository for:
- Python port (GC replacement)
- Perl port (extensive pointer tables)
- Git port (type changes)
- Quickjs port (pointer tagging patterns)

* Next Steps

1. *Set up build environment* with filc++
2. *Attempt Phase 1* (store-only build)
3. *Document issues* encountered  
4. *Create patches* for minimal working port
5. *Test* with real-world Nix usage
6. *Upstream discussion* with Nix team

* Open Questions

- [ ] Does Nix have flexibility to accept 24-byte Values? (memory usage impact)
- [ ] Are there performance benchmarks to track regression?
- [ ] What's the process for upstreaming fil-c support?
- [ ] Should this be a configure option (~--enable-filc~) or separate fork?
- [ ] Which dependencies need fil-c ports? (boost, nlohmann-json, etc.)

* Conclusion

Porting Nix to fil-c is *feasible* with moderate effort:

- Store + CLI tools: *Low complexity* (2-3 weeks)
- Full evaluator: *Medium complexity* (2-3 months)

The key challenges are:
1. Disabling/replacing Boehm GC (straightforward)
2. Converting pointer tagging (tedious but mechanical)
3. Testing comprehensive evaluator functionality

The minimal viable port (Phase 1-2) provides significant value:
- Memory-safe package manager
- Secure build daemon  
- Foundation for further hardening

Optimizations (Phase 3) can follow once basic functionality is proven.
