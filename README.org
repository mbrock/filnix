#+TITLE: filnix: Nix Packaging for Fil-C
#+AUTHOR: mbrock
#+OPTIONS: toc:2

* Overview

filnix packages the [[https://github.com/pizlonator/fil-c][Fil-C]] memory-safe C/C++ compiler for Nix.

Fil-C by [[https://twitter.com/filpizlo][Filip Pizlo]] implements memory-safe C/C++ using runtime capabilities and garbage collection. All pointers carry bounds metadata tracked via LLVM instrumentation, shadow memory, and a concurrent GC. Compatible with existing C/C++ code without unsafe escape hatches.

** Technology

- *FilPizlonator LLVM Pass*: Instruments IR to track capability metadata with pointers
- *InvisiCap Runtime*: Stores capabilities in registers or shadow memory; bounds-checks all accesses
- *FUGC Collector*: Concurrent GC built on libpas; prevents use-after-free by keeping freed objects alive until unreferenced

Prevents: use-after-free, out-of-bounds access, type confusion. Performance: 1.5x-4x overhead on Linux/X86_64.

Successfully runs 100+ programs: OpenSSH, CPython, curl, SQLite, Emacs. See [[https://fil-c.org/pizlix][Pizlix]] for complete memory-safe userland.

** Why Nix

Nix builds are pure functions: explicitly declare all inputs, build in isolation, same inputs produce same outputs. The hash in =/nix/store/abc123-package= is derived from build inputs, not outputs. Different versions coexist as separate store paths.

For Fil-C, this enables:
- Reproducible compiler toolchain builds
- Trivial package porting via nixpkgs overrides
- Automatic dependency management
- No directory layout hacks for mixed safe/unsafe binaries on NixOS

Binary caches (like =filc.cachix.org=) are trusted vendors that sign pre-built artifacts. Nix verifies signatures but doesn't cryptographically verify binary contents. Trust cache operators or build locally.

** NixOS: Selective Memory Safety

NixOS stores all packages in =/nix/store/hash-package= instead of =/usr=, making it trivial to run memory-safe and regular binaries side-by-side without conflicts or special filesystem layouts.

This flake enables selective hardening - replace security-critical components with Fil-C versions while keeping others unchanged:

#+BEGIN_SRC nix
# configuration.nix
{ pkgs, ... }:
let
  filc = (builtins.getFlake "github:mbrock/filnix").packages.${pkgs.system};
in {
  environment.systemPackages = [
    filc.bash          # Memory-safe shell
    filc.coreutils     # Memory-safe core utilities
    filc.openssh       # Memory-safe SSH
    pkgs.vim           # Regular editor
    pkgs.firefox       # Regular browser
  ];

  programs.bash.package = filc.bash;  # System shell
}
#+END_SRC

Each package has explicit store path dependencies, so =filc.bash= uses Fil-C's libc while =pkgs.vim= uses the regular glibc. No chroot, no container, no directory tricks - they coexist naturally.

Practical: harden network-facing and privileged components (openssh, curl, bash, coreutils) while deferring non-critical software. Incremental migration path to memory-safe userland.

** Repository Structure

Upstream fil-c is a development repository with shell-script builds. This repository packages the compiler and runtime as Nix derivations with:
- Modular separation of compiler from applications
- Reproducible, cacheable builds
- Integration with nixpkgs ecosystem

* Quick Start

#+BEGIN_SRC bash
# Development shell with Fil-C compiler
nix develop github:mbrock/filnix

# Build specific package
nix build github:mbrock/filnix#wasm3

# Try CVE testing environment
nix develop github:mbrock/filnix#wasm3-cve-test

# Enable binary cache (optional, saves ~1-2 hours building LLVM)
cachix use filc
#+END_SRC

** Hello World

#+BEGIN_SRC bash
# In dev shell
echo '#include <stdio.h>
int main() { printf("Hello from Fil-C!\n"); return 0; }' > hello.c

clang -o hello hello.c -g -O
./hello
#+END_SRC

** Memory Safety Demo

#+BEGIN_SRC bash
echo '#include <stdlib.h>
#include <stdio.h>
int main() {
    int* ptr = malloc(sizeof(int));
    printf("oob memory = %d\n", ptr[10]);  // Out of bounds
    return 0;
}' > bad.c

clang -o bad bad.c -g -O
./bad
#+END_SRC

Expected output shows trapped bounds violation with source location.

* Architecture

** Build Pipeline

1. *filc0* - Bootstrap LLVM/Clang with FilPizlonator pass
2. *filc1* - Add OS headers
3. *filc2* - Add yolo runtime (minimally-modified glibc)
4. *libpizlo* - Fil-C runtime and FUGC
5. *libmojo* - Memory-safe user glibc (heavily modified)
6. *filc-libcxx* - C++ standard library
7. *filcc* - Complete toolchain

** Two-Libc Architecture

#+BEGIN_EXAMPLE
Application Code
├─ libmojo (user glibc)     ← Applications link here
├─ libpizlo (Fil-C runtime) ← Memory safety + FUGC
├─ libyolo (yolo glibc)     ← Runtime uses this
└─ Linux kernel
#+END_EXAMPLE

Both libcs are required for a working system.

** Driver Flags

Patches add explicit flags for Nix integration:

- =--filc-resource-dir=PATH=
- =--filc-dynamic-linker=PATH=
- =--filc-crt-path=PATH=
- =--filc-stdfil-include=PATH=
- =--filc-os-include=PATH=
- =--filc-include=PATH=

Eliminates directory layout requirements. See =DRIVER-FLAGS.md=.

* Packages

** Core

- =filcc= - Wrapped toolchain (use this)
- =filc0-7= - Individual build stages
- =libpizlo= - Runtime library
- =libmojo= - Memory-safe glibc
- =filc-libcxx= - C++ stdlib

** Applications

Built via =packages.nix=: bash, lua, tmux, sqlite, wasm3, nethack, nano.

#+BEGIN_SRC bash
nix build .#wasm3
./result/bin/wasm3 --version
#+END_SRC

** Ports

=ports/= contains patches from upstream fil-c. =ports/patches.nix= maps packages to versions and patches. =ports.nix= applies patches to nixpkgs packages.

* Development

** Default Shell

#+BEGIN_SRC bash
nix develop
#+END_SRC

Provides: filcc toolchain, cmake, ninja, gdb, valgrind, ripgrep, fd, jq.

** Package Introspection

#+BEGIN_SRC bash
./query-package.sh bash | jq .
#+END_SRC

Returns function args, build inputs, configure flags, derivation structure, metadata.

** Porting Packages

#+BEGIN_SRC nix
mypackage = fix base.mypackage {
  deps = { inherit zlib openssl; };
  attrs = old: { doCheck = false; };
};
#+END_SRC

The =fix= function switches to Fil-C stdenv and applies overrides.

** Debugging

Environment variables:
- =FUGC_STW=1= - Force stop-the-world GC
- =FUGC_SCRIBBLE=1 FUGC_VERIFY=1= - Memory debugging
- =FUGC_MIN_THRESHOLD=0= - GC stress testing
- =FILC_DUMP_SETUP=1= - Verify environment

** Common Issues

ABI incompatibility: Fil-C code cannot link with regular C. Port entire dependency chains.

Compilation: Always use =-g= for error messages, must use =-O= with =-g=.

* Examples

** CVE Mitigation: wasm3

The wasm3 shell demonstrates real CVE prevention:

#+BEGIN_SRC bash
nix develop .#wasm3-cve-test
wasm3 cve-2022-39974.wasm  # Out-of-bounds read - caught
wasm3 cve-2022-34529.wasm  # Integer overflow - caught
#+END_SRC

Both exploits work in normal wasm3 but are trapped by Fil-C. See =wasm3-cves.md=.

* Building

** Prerequisites

- Nix with flakes
- Linux/X86_64
- ~20GB disk space

** Build

#+BEGIN_SRC bash
git clone https://github.com/mbrock/filnix
cd filnix

nix build .#filcc      # Toolchain
nix build .#bash       # Sample packages
nix build .#ports      # All ported packages
#+END_SRC

* Resources

** Upstream

- Repository: https://github.com/pizlonator/fil-c
- Website: https://fil-c.org/
- Author: Filip Pizlo (pizlo@mac.com)

** Documentation

- [[https://github.com/pizlonator/fil-c/blob/deluge/Manifesto.md][Manifesto]] - Technical design
- [[https://github.com/pizlonator/fil-c/blob/deluge/invisicaps_by_example.md][InvisiCaps by Example]] - Pointer implementation
- [[https://github.com/pizlonator/fil-c/blob/deluge/gimso_semantics.md][GIMSO Semantics]] - Formal semantics
- [[https://github.com/WebKit/WebKit/blob/main/Source/bmalloc/libpas/Documentation.md][libpas]] - Allocator infrastructure

** Related

- [[https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/][CHERI]] - Hardware capabilities
- [[https://github.com/google/sanitizers/wiki/addresssanitizer][AddressSanitizer]] - Dynamic analysis
- [[https://developer.arm.com/documentation/108035/0100/Introduction-to-the-Memory-Tagging-Extension][MTE]] - ARM Memory Tagging

* License

Same as upstream Fil-C:
- Compiler: Apache 2.0
- Runtime (libpas): BSD
- C++ libraries: Apache 2.0
- Glibc: LGPL

Source: https://github.com/pizlonator/fil-c

* Contributing

File issues:
- Fil-C itself: https://github.com/pizlonator/fil-c/issues
- Nix packaging: https://github.com/mbrock/filnix/issues

* Roadmap

** Current: Standalone Flake

This repository packages Fil-C as a standalone flake. Users reference it explicitly:

#+BEGIN_SRC nix
filc = (builtins.getFlake "github:mbrock/filnix").packages.${pkgs.system};
#+END_SRC

Works now. Requires manual flake reference for each package.

** Goal: nixpkgs Cross-Platform Integration

Nixpkgs supports cross-compilation targets via =pkgsCross= - alternative toolchains for building packages. Examples: =pkgsCross.musl.bash= (musl libc), =pkgsCross.mingwW64.curl= (Windows).

Integration plan:

1. *Add Fil-C as cross-compilation target to nixpkgs*
   - Similar to how musl, uclibc, mingw are integrated
   - Defines stdenv using Fil-C compiler and runtime

2. *Enable via =pkgsCross.filc=*
   #+BEGIN_SRC nix
   pkgs.pkgsCross.filc.bash       # Memory-safe bash
   pkgs.pkgsCross.filc.coreutils  # Memory-safe coreutils
   pkgs.pkgsCross.filc.openssh    # Memory-safe openssh
   #+END_SRC

3. *Automatic access to 80,000+ packages*
   - Any nixpkgs package becomes =pkgsCross.filc.package=
   - No manual porting needed for packages that compile
   - Patches live in nixpkgs tree

** Benefits of Integration

- *Official builds*: Hydra CI automatically builds and tests
- *Binary cache*: Pre-built binaries from cache.nixos.org
- *Community maintenance*: Package updates tracked with nixpkgs
- *Simple usage*: No flake references, just =pkgsCross.filc.anything=
- *Overlay compatibility*: Works with existing nixpkgs infrastructure

Example system configuration after integration:

#+BEGIN_SRC nix
{ pkgs, ... }: {
  environment.systemPackages = with pkgs.pkgsCross.filc; [
    bash coreutils openssh curl
  ];
}
#+END_SRC

** Current Status

Experimental standalone flake. Working: toolchain builds, many packages run, CVE mitigation demonstrated.

Active work:
- Port more packages to validate cross-compilation approach
- Document integration requirements for nixpkgs maintainers
- Establish CI and binary caching infrastructure
- Verify ABI stability across nixpkgs updates
