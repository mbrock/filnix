diff --git a/Makefile b/Makefile
index e8cc443675ef..35969157e069 100644
--- a/Makefile
+++ b/Makefile
@@ -29,7 +29,8 @@ REPLACED_OBJS = $(sort $(subst /$(ARCH)/,/,$(ARCH_OBJS)))
 ALL_OBJS = $(addprefix obj/, $(filter-out $(REPLACED_OBJS), $(sort $(BASE_OBJS) $(ARCH_OBJS))))
 
 LIBC_OBJS = $(filter obj/src/%,$(ALL_OBJS)) $(filter obj/compat/%,$(ALL_OBJS))
-LDSO_OBJS = $(filter obj/ldso/%,$(ALL_OBJS:%.o=%.lo))
+#LDSO_OBJS = $(filter obj/ldso/%,$(ALL_OBJS:%.o=%.lo))
+LDSO_OBJS =
 CRT_OBJS = $(filter obj/crt/%,$(ALL_OBJS))
 
 AOBJS = $(LIBC_OBJS)
@@ -44,7 +45,7 @@ LIBCC = -lgcc
 CPPFLAGS =
 CFLAGS =
 CFLAGS_AUTO = -Os -pipe
-CFLAGS_C99FSE = -std=c99 -ffreestanding -nostdinc 
+CFLAGS_C99FSE = -std=c99 -ffreestanding -nostdinc
 
 CFLAGS_ALL = $(CFLAGS_C99FSE)
 CFLAGS_ALL += -D_XOPEN_SOURCE=700 -I$(srcdir)/arch/$(ARCH) -I$(srcdir)/arch/generic -Iobj/src/internal -I$(srcdir)/src/include -I$(srcdir)/src/internal -Iobj/include -I$(srcdir)/include
@@ -67,13 +68,13 @@ CRT_LIBS = $(addprefix lib/,$(notdir $(CRT_OBJS)))
 STATIC_LIBS = lib/libc.a
 SHARED_LIBS = lib/libc.so
 TOOL_LIBS = lib/musl-gcc.specs
-ALL_LIBS = $(CRT_LIBS) $(STATIC_LIBS) $(SHARED_LIBS) $(EMPTY_LIBS) $(TOOL_LIBS)
+ALL_LIBS = $(STATIC_LIBS) $(SHARED_LIBS) $(EMPTY_LIBS) $(TOOL_LIBS)
 ALL_TOOLS = obj/musl-gcc
 
 WRAPCC_GCC = gcc
 WRAPCC_CLANG = clang
 
-LDSO_PATHNAME = $(syslibdir)/ld-musl-$(ARCH)$(SUBARCH).so.1
+#LDSO_PATHNAME = $(syslibdir)/ld-musl-$(ARCH)$(SUBARCH).so.1
 
 -include config.mak
 -include $(srcdir)/arch/$(ARCH)/arch.mak
@@ -159,8 +160,8 @@ obj/%.lo: $(srcdir)/%.c $(GENH) $(IMPH)
 	$(CC_CMD)
 
 lib/libc.so: $(LOBJS) $(LDSO_OBJS)
-	$(CC) $(CFLAGS_ALL) $(LDFLAGS_ALL) -nostdlib -shared \
-	-Wl,-e,_dlstart -o $@ $(LOBJS) $(LDSO_OBJS) $(LIBCC)
+	$(CC) $(CFLAGS_ALL) $(LDFLAGS_ALL) -shared \
+	-o $@ $(LOBJS) $(LDSO_OBJS) $(LIBCC) -nodefaultlibs
 
 lib/libc.a: $(AOBJS)
 	rm -f $@
@@ -209,10 +210,7 @@ $(DESTDIR)$(includedir)/bits/%: obj/include/bits/%
 $(DESTDIR)$(includedir)/%: $(srcdir)/include/%
 	$(INSTALL) -D -m 644 $< $@
 
-$(DESTDIR)$(LDSO_PATHNAME): $(DESTDIR)$(libdir)/libc.so
-	$(INSTALL) -D -l $(libdir)/libc.so $@ || true
-
-install-libs: $(ALL_LIBS:lib/%=$(DESTDIR)$(libdir)/%) $(if $(SHARED_LIBS),$(DESTDIR)$(LDSO_PATHNAME),)
+install-libs: $(ALL_LIBS:lib/%=$(DESTDIR)$(libdir)/%)
 
 install-headers: $(ALL_INCLUDES:include/%=$(DESTDIR)$(includedir)/%)
 
diff --git a/arch/aarch64/atomic_arch.h b/arch/aarch64/atomic_arch.h
index 40fefc25bb17..e69de29bb2d1 100644
--- a/arch/aarch64/atomic_arch.h
+++ b/arch/aarch64/atomic_arch.h
@@ -1,82 +0,0 @@
-#define a_ll a_ll
-static inline int a_ll(volatile int *p)
-{
-	int v;
-	__asm__ __volatile__ ("ldaxr %w0,%1" : "=r"(v) : "Q"(*p));
-	return v;
-}
-
-#define a_sc a_sc
-static inline int a_sc(volatile int *p, int v)
-{
-	int r;
-	__asm__ __volatile__ ("stlxr %w0,%w2,%1" : "=&r"(r), "=Q"(*p) : "r"(v) : "memory");
-	return !r;
-}
-
-#define a_barrier a_barrier
-static inline void a_barrier()
-{
-	__asm__ __volatile__ ("dmb ish" : : : "memory");
-}
-
-#define a_cas a_cas
-static inline int a_cas(volatile int *p, int t, int s)
-{
-	int old;
-	do {
-		old = a_ll(p);
-		if (old != t) {
-			a_barrier();
-			break;
-		}
-	} while (!a_sc(p, s));
-	return old;
-}
-
-#define a_ll_p a_ll_p
-static inline void *a_ll_p(volatile void *p)
-{
-	void *v;
-	__asm__ __volatile__ ("ldaxr %0, %1" : "=r"(v) : "Q"(*(void *volatile *)p));
-	return v;
-}
-
-#define a_sc_p a_sc_p
-static inline int a_sc_p(volatile int *p, void *v)
-{
-	int r;
-	__asm__ __volatile__ ("stlxr %w0,%2,%1" : "=&r"(r), "=Q"(*(void *volatile *)p) : "r"(v) : "memory");
-	return !r;
-}
-
-#define a_cas_p a_cas_p
-static inline void *a_cas_p(volatile void *p, void *t, void *s)
-{
-	void *old;
-	do {
-		old = a_ll_p(p);
-		if (old != t) {
-			a_barrier();
-			break;
-		}
-	} while (!a_sc_p(p, s));
-	return old;
-}
-
-#define a_ctz_64 a_ctz_64
-static inline int a_ctz_64(uint64_t x)
-{
-	__asm__(
-		"	rbit %0, %1\n"
-		"	clz %0, %0\n"
-		: "=r"(x) : "r"(x));
-	return x;
-}
-
-#define a_clz_64 a_clz_64
-static inline int a_clz_64(uint64_t x)
-{
-	__asm__("clz %0, %1" : "=r"(x) : "r"(x));
-	return x;
-}
diff --git a/arch/aarch64/bits/alltypes.h.in b/arch/aarch64/bits/alltypes.h.in
index c547ca0b72a3..d34b9e9ade4b 100644
--- a/arch/aarch64/bits/alltypes.h.in
+++ b/arch/aarch64/bits/alltypes.h.in
@@ -21,4 +21,4 @@ TYPEDEF unsigned int nlink_t;
 TYPEDEF float float_t;
 TYPEDEF double double_t;
 
-TYPEDEF struct { long long __ll; long double __ld; } max_align_t;
+TYPEDEF struct { void *__p; } max_align_t;
diff --git a/arch/x86_64/atomic_arch.h b/arch/x86_64/atomic_arch.h
index da4e20375480..e69de29bb2d1 100644
--- a/arch/x86_64/atomic_arch.h
+++ b/arch/x86_64/atomic_arch.h
@@ -1,123 +0,0 @@
-#define a_cas a_cas
-static inline int a_cas(volatile int *p, int t, int s)
-{
-	__asm__ __volatile__ (
-		"lock ; cmpxchg %3, %1"
-		: "=a"(t), "=m"(*p) : "a"(t), "r"(s) : "memory" );
-	return t;
-}
-
-#define a_cas_p a_cas_p
-static inline void *a_cas_p(volatile void *p, void *t, void *s)
-{
-	__asm__( "lock ; cmpxchg %3, %1"
-		: "=a"(t), "=m"(*(void *volatile *)p)
-		: "a"(t), "r"(s) : "memory" );
-	return t;
-}
-
-#define a_swap a_swap
-static inline int a_swap(volatile int *p, int v)
-{
-	__asm__ __volatile__(
-		"xchg %0, %1"
-		: "=r"(v), "=m"(*p) : "0"(v) : "memory" );
-	return v;
-}
-
-#define a_fetch_add a_fetch_add
-static inline int a_fetch_add(volatile int *p, int v)
-{
-	__asm__ __volatile__(
-		"lock ; xadd %0, %1"
-		: "=r"(v), "=m"(*p) : "0"(v) : "memory" );
-	return v;
-}
-
-#define a_and a_and
-static inline void a_and(volatile int *p, int v)
-{
-	__asm__ __volatile__(
-		"lock ; and %1, %0"
-		: "=m"(*p) : "r"(v) : "memory" );
-}
-
-#define a_or a_or
-static inline void a_or(volatile int *p, int v)
-{
-	__asm__ __volatile__(
-		"lock ; or %1, %0"
-		: "=m"(*p) : "r"(v) : "memory" );
-}
-
-#define a_and_64 a_and_64
-static inline void a_and_64(volatile uint64_t *p, uint64_t v)
-{
-	__asm__ __volatile(
-		"lock ; and %1, %0"
-		 : "=m"(*p) : "r"(v) : "memory" );
-}
-
-#define a_or_64 a_or_64
-static inline void a_or_64(volatile uint64_t *p, uint64_t v)
-{
-	__asm__ __volatile__(
-		"lock ; or %1, %0"
-		 : "=m"(*p) : "r"(v) : "memory" );
-}
-
-#define a_inc a_inc
-static inline void a_inc(volatile int *p)
-{
-	__asm__ __volatile__(
-		"lock ; incl %0"
-		: "=m"(*p) : "m"(*p) : "memory" );
-}
-
-#define a_dec a_dec
-static inline void a_dec(volatile int *p)
-{
-	__asm__ __volatile__(
-		"lock ; decl %0"
-		: "=m"(*p) : "m"(*p) : "memory" );
-}
-
-#define a_store a_store
-static inline void a_store(volatile int *p, int x)
-{
-	__asm__ __volatile__(
-		"mov %1, %0 ; lock ; orl $0,(%%rsp)"
-		: "=m"(*p) : "r"(x) : "memory" );
-}
-
-#define a_barrier a_barrier
-static inline void a_barrier()
-{
-	__asm__ __volatile__( "" : : : "memory" );
-}
-
-#define a_spin a_spin
-static inline void a_spin()
-{
-	__asm__ __volatile__( "pause" : : : "memory" );
-}
-
-#define a_crash a_crash
-static inline void a_crash()
-{
-	__asm__ __volatile__( "hlt" : : : "memory" );
-}
-
-#define a_ctz_64 a_ctz_64
-static inline int a_ctz_64(uint64_t x)
-{
-	__asm__( "bsf %1,%0" : "=r"(x) : "r"(x) );
-	return x;
-}
-
-#define a_clz_64 a_clz_64
-static inline int a_clz_64(uint64_t x)
-{
-	__asm__( "bsr %1,%0 ; xor $63,%0" : "=r"(x) : "r"(x) );
-	return x;
-}
diff --git a/arch/x86_64/bits/alltypes.h.in b/arch/x86_64/bits/alltypes.h.in
index 5cd8a2997f62..20a128dd2fba 100644
--- a/arch/x86_64/bits/alltypes.h.in
+++ b/arch/x86_64/bits/alltypes.h.in
@@ -17,4 +17,4 @@ TYPEDEF float float_t;
 TYPEDEF double double_t;
 #endif
 
-TYPEDEF struct { long long __ll; long double __ld; } max_align_t;
+TYPEDEF struct { void *__p; } max_align_t;
diff --git a/include/aio.h b/include/aio.h
index a938fcad5d6b..8f24995bf420 100644
--- a/include/aio.h
+++ b/include/aio.h
@@ -25,7 +25,6 @@ struct aiocb {
 	ssize_t __ret;
 	off_t aio_offset;
 	void *__next, *__prev;
-	char __dummy4[32-2*sizeof(void *)];
 };
 
 #define AIO_CANCELED 0
diff --git a/include/alltypes.h.in b/include/alltypes.h.in
index d47aeea9aa8b..b3ff40328c1d 100644
--- a/include/alltypes.h.in
+++ b/include/alltypes.h.in
@@ -50,11 +50,7 @@ TYPEDEF unsigned gid_t;
 TYPEDEF int key_t;
 TYPEDEF unsigned useconds_t;
 
-#ifdef __cplusplus
-TYPEDEF unsigned long pthread_t;
-#else
 TYPEDEF struct __pthread * pthread_t;
-#endif
 TYPEDEF int pthread_once_t;
 TYPEDEF unsigned pthread_key_t;
 TYPEDEF int pthread_spinlock_t;
@@ -83,12 +79,12 @@ TYPEDEF unsigned socklen_t;
 TYPEDEF unsigned short sa_family_t;
 
 TYPEDEF struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t;
-TYPEDEF struct { union { int __i[sizeof(long)==8?10:6]; volatile int __vi[sizeof(long)==8?10:6]; volatile void *volatile __p[sizeof(long)==8?5:6]; } __u; } pthread_mutex_t;
-TYPEDEF struct { union { int __i[sizeof(long)==8?10:6]; volatile int __vi[sizeof(long)==8?10:6]; volatile void *volatile __p[sizeof(long)==8?5:6]; } __u; } mtx_t;
-TYPEDEF struct { union { int __i[12]; volatile int __vi[12]; void *__p[12*sizeof(int)/sizeof(void*)]; } __u; } pthread_cond_t;
-TYPEDEF struct { union { int __i[12]; volatile int __vi[12]; void *__p[12*sizeof(int)/sizeof(void*)]; } __u; } cnd_t;
+TYPEDEF struct { union { int __i[4]; volatile int __vi[4]; } __u; volatile void *volatile __p[2]; } pthread_mutex_t;
+TYPEDEF struct { union { int __i[4]; volatile int __vi[4]; } __u; volatile void *volatile __p[2]; } mtx_t;
+TYPEDEF struct { union { int __i[5]; volatile int __vi[5];  } __u; void *__p[3]; } pthread_cond_t;
+TYPEDEF struct { union { int __i[5]; volatile int __vi[5];  } __u; void *__p[3]; } cnd_t;
 TYPEDEF struct { union { int __i[sizeof(long)==8?14:8]; volatile int __vi[sizeof(long)==8?14:8]; void *__p[sizeof(long)==8?7:8]; } __u; } pthread_rwlock_t;
-TYPEDEF struct { union { int __i[sizeof(long)==8?8:5]; volatile int __vi[sizeof(long)==8?8:5]; void *__p[sizeof(long)==8?4:5]; } __u; } pthread_barrier_t;
+TYPEDEF struct { union { int __i[5]; volatile int __vi[5]; } __u; void *__p[1]; } pthread_barrier_t;
 
 #undef _Addr
 #undef _Int64
diff --git a/include/ctype.h b/include/ctype.h
index 32bcef4dabcc..39179f4eb3dd 100644
--- a/include/ctype.h
+++ b/include/ctype.h
@@ -38,10 +38,6 @@ static __inline int __isspace(int _c)
 #endif
 
 
-#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
- || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
- || defined(_BSD_SOURCE)
-
 #define __NEED_locale_t
 #include <bits/alltypes.h>
 
@@ -68,8 +64,6 @@ int   toascii(int);
 #define isascii(a) (0 ? isascii(a) : (unsigned)(a) < 128)
 #endif
 
-#endif
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/locale.h b/include/locale.h
index 11106fea878a..60eee18fb55c 100644
--- a/include/locale.h
+++ b/include/locale.h
@@ -55,10 +55,6 @@ struct lconv {
 char *setlocale (int, const char *);
 struct lconv *localeconv(void);
 
-
-#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
- || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
-
 #define __NEED_locale_t
 
 #include <bits/alltypes.h>
@@ -78,9 +74,6 @@ void freelocale(locale_t);
 locale_t newlocale(int, const char *, locale_t);
 locale_t uselocale(locale_t);
 
-#endif
-
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/pthread.h b/include/pthread.h
index 89fd9ff7c12f..e1f25f3a8364 100644
--- a/include/pthread.h
+++ b/include/pthread.h
@@ -55,9 +55,9 @@ extern "C" {
 #define PTHREAD_PROCESS_SHARED 1
 
 
-#define PTHREAD_MUTEX_INITIALIZER {{{0}}}
+#define PTHREAD_MUTEX_INITIALIZER {{{0}}, {0}}
 #define PTHREAD_RWLOCK_INITIALIZER {{{0}}}
-#define PTHREAD_COND_INITIALIZER {{{0}}}
+#define PTHREAD_COND_INITIALIZER {{{0}}, {0}}
 #define PTHREAD_ONCE_INIT 0
 
 
diff --git a/include/setjmp.h b/include/setjmp.h
index 1976af231b8c..b11326b9cf60 100644
--- a/include/setjmp.h
+++ b/include/setjmp.h
@@ -10,12 +10,10 @@ extern "C" {
 #include <bits/setjmp.h>
 
 typedef struct __jmp_buf_tag {
-	__jmp_buf __jb;
-	unsigned long __fl;
-	unsigned long __ss[128/sizeof(long)];
+    void* __p;
 } jmp_buf[1];
 
-#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1)
+#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || defined(__PIZLONATOR_WAS_HERE__)
 #define __setjmp_attr __attribute__((__returns_twice__))
 #else
 #define __setjmp_attr
diff --git a/include/stdio.h b/include/stdio.h
index cb858618512d..749246aa3292 100644
--- a/include/stdio.h
+++ b/include/stdio.h
@@ -15,13 +15,9 @@ extern "C" {
 #define __NEED_struct__IO_FILE
 #endif
 
-#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
- || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
- || defined(_BSD_SOURCE)
 #define __NEED_ssize_t
 #define __NEED_off_t
 #define __NEED_va_list
-#endif
 
 #include <bits/alltypes.h>
 
@@ -131,9 +127,6 @@ void setbuf(FILE *__restrict, char *__restrict);
 char *tmpnam(char *);
 FILE *tmpfile(void);
 
-#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
- || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
- || defined(_BSD_SOURCE)
 FILE *fmemopen(void *__restrict, size_t, const char *__restrict);
 FILE *open_memstream(char **, size_t *);
 FILE *fdopen(int, const char *);
@@ -156,16 +149,11 @@ ssize_t getline(char **__restrict, size_t *__restrict, FILE *__restrict);
 int renameat(int, const char *, int, const char *);
 char *ctermid(char *);
 #define L_ctermid 20
-#endif
 
 
-#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
- || defined(_BSD_SOURCE)
 #define P_tmpdir "/tmp"
 char *tempnam(const char *, const char *);
-#endif
 
-#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
 #define L_cuserid 20
 char *cuserid(char *);
 void setlinebuf(FILE *);
@@ -184,7 +172,6 @@ int putw(int, FILE *);
 char *fgetln(FILE *, size_t *);
 int asprintf(char **, const char *, ...);
 int vasprintf(char **, const char *, __isoc_va_list);
-#endif
 
 #ifdef _GNU_SOURCE
 char *fgets_unlocked(char *, int, FILE *);
diff --git a/include/stdlib.h b/include/stdlib.h
index 475190bfa2c9..cba1b4c34135 100644
--- a/include/stdlib.h
+++ b/include/stdlib.h
@@ -84,10 +84,6 @@ size_t __ctype_get_mb_cur_max(void);
 #define RAND_MAX (0x7fffffff)
 
 
-#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
- || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
- || defined(_BSD_SOURCE)
-
 #define WNOHANG    1
 #define WUNTRACED  2
 
@@ -107,11 +103,7 @@ char *mkdtemp (char *);
 int getsubopt (char **, char *const *, char **);
 int rand_r (unsigned *);
 
-#endif
-
 
-#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
- || defined(_BSD_SOURCE)
 char *realpath (const char *__restrict, char *__restrict);
 long int random (void);
 void srandom (unsigned int);
@@ -134,7 +126,6 @@ long jrand48 (unsigned short [3]);
 void srand48 (long);
 unsigned short *seed48 (unsigned short [3]);
 void lcong48 (unsigned short [7]);
-#endif
 
 #if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
 #include <alloca.h>
@@ -151,7 +142,6 @@ void *reallocarray (void *, size_t, size_t);
 void qsort_r (void *, size_t, size_t, int (*)(const void *, const void *, void *), void *);
 #endif
 
-#ifdef _GNU_SOURCE
 int ptsname_r(int, char *, size_t);
 char *ecvt(double, int, int *, int *);
 char *fcvt(double, int, int *, int *);
@@ -161,7 +151,6 @@ struct __locale_struct;
 float strtof_l(const char *__restrict, char **__restrict, struct __locale_struct *);
 double strtod_l(const char *__restrict, char **__restrict, struct __locale_struct *);
 long double strtold_l(const char *__restrict, char **__restrict, struct __locale_struct *);
-#endif
 
 #if defined(_LARGEFILE64_SOURCE)
 #define mkstemp64 mkstemp
diff --git a/include/string.h b/include/string.h
index 83e2b946486f..97b1723b9d74 100644
--- a/include/string.h
+++ b/include/string.h
@@ -16,11 +16,7 @@ extern "C" {
 #endif
 
 #define __NEED_size_t
-#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
- || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
- || defined(_BSD_SOURCE)
 #define __NEED_locale_t
-#endif
 
 #include <bits/alltypes.h>
 
@@ -59,9 +55,6 @@ char *strerror (int);
 #include <strings.h>
 #endif
 
-#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
- || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
- || defined(_BSD_SOURCE)
 char *strtok_r (char *__restrict, const char *__restrict, char **__restrict);
 int strerror_r (int, char *, size_t);
 char *stpcpy(char *__restrict, const char *__restrict);
@@ -74,7 +67,6 @@ char *strerror_l (int, locale_t);
 int strcoll_l (const char *, const char *, locale_t);
 size_t strxfrm_l (char *__restrict, const char *__restrict, size_t, locale_t);
 void *memmem(const void *, size_t, const void *, size_t);
-#endif
 
 #if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
  || defined(_BSD_SOURCE)
diff --git a/include/sys/epoll.h b/include/sys/epoll.h
index ac81a8418a0c..52b695ab2d99 100644
--- a/include/sys/epoll.h
+++ b/include/sys/epoll.h
@@ -48,11 +48,7 @@ typedef union epoll_data {
 struct epoll_event {
 	uint32_t events;
 	epoll_data_t data;
-}
-#ifdef __x86_64__
-__attribute__ ((__packed__))
-#endif
-;
+};
 
 
 int epoll_create(int);
diff --git a/include/sys/queue.h b/include/sys/queue.h
new file mode 100644
index 000000000000..daf4553d33e9
--- /dev/null
+++ b/include/sys/queue.h
@@ -0,0 +1,574 @@
+/*
+ * Copyright (c) 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)queue.h	8.5 (Berkeley) 8/20/94
+ */
+
+#ifndef	_SYS_QUEUE_H_
+#define	_SYS_QUEUE_H_
+
+/*
+ * This file defines five types of data structures: singly-linked lists,
+ * lists, simple queues, tail queues, and circular queues.
+ *
+ * A singly-linked list is headed by a single forward pointer. The
+ * elements are singly linked for minimum space and pointer manipulation
+ * overhead at the expense of O(n) removal for arbitrary elements. New
+ * elements can be added to the list after an existing element or at the
+ * head of the list.  Elements being removed from the head of the list
+ * should use the explicit macro for this purpose for optimum
+ * efficiency. A singly-linked list may only be traversed in the forward
+ * direction.  Singly-linked lists are ideal for applications with large
+ * datasets and few or no removals or for implementing a LIFO queue.
+ *
+ * A list is headed by a single forward pointer (or an array of forward
+ * pointers for a hash table header). The elements are doubly linked
+ * so that an arbitrary element can be removed without a need to
+ * traverse the list. New elements can be added to the list before
+ * or after an existing element or at the head of the list. A list
+ * may only be traversed in the forward direction.
+ *
+ * A simple queue is headed by a pair of pointers, one the head of the
+ * list and the other to the tail of the list. The elements are singly
+ * linked to save space, so elements can only be removed from the
+ * head of the list. New elements can be added to the list after
+ * an existing element, at the head of the list, or at the end of the
+ * list. A simple queue may only be traversed in the forward direction.
+ *
+ * A tail queue is headed by a pair of pointers, one to the head of the
+ * list and the other to the tail of the list. The elements are doubly
+ * linked so that an arbitrary element can be removed without a need to
+ * traverse the list. New elements can be added to the list before or
+ * after an existing element, at the head of the list, or at the end of
+ * the list. A tail queue may be traversed in either direction.
+ *
+ * A circle queue is headed by a pair of pointers, one to the head of the
+ * list and the other to the tail of the list. The elements are doubly
+ * linked so that an arbitrary element can be removed without a need to
+ * traverse the list. New elements can be added to the list before or after
+ * an existing element, at the head of the list, or at the end of the list.
+ * A circle queue may be traversed in either direction, but has a more
+ * complex end of list detection.
+ *
+ * For details on the use of these macros, see the queue(3) manual page.
+ */
+
+/*
+ * List definitions.
+ */
+#define	LIST_HEAD(name, type)						\
+struct name {								\
+	struct type *lh_first;	/* first element */			\
+}
+
+#define	LIST_HEAD_INITIALIZER(head)					\
+	{ NULL }
+
+#define	LIST_ENTRY(type)						\
+struct {								\
+	struct type *le_next;	/* next element */			\
+	struct type **le_prev;	/* address of previous next element */	\
+}
+
+/*
+ * List functions.
+ */
+#define	LIST_INIT(head) do {						\
+	(head)->lh_first = NULL;					\
+} while (/*CONSTCOND*/0)
+
+#define	LIST_INSERT_AFTER(listelm, elm, field) do {			\
+	if (((elm)->field.le_next = (listelm)->field.le_next) != NULL)	\
+		(listelm)->field.le_next->field.le_prev =		\
+		    &(elm)->field.le_next;				\
+	(listelm)->field.le_next = (elm);				\
+	(elm)->field.le_prev = &(listelm)->field.le_next;		\
+} while (/*CONSTCOND*/0)
+
+#define	LIST_INSERT_BEFORE(listelm, elm, field) do {			\
+	(elm)->field.le_prev = (listelm)->field.le_prev;		\
+	(elm)->field.le_next = (listelm);				\
+	*(listelm)->field.le_prev = (elm);				\
+	(listelm)->field.le_prev = &(elm)->field.le_next;		\
+} while (/*CONSTCOND*/0)
+
+#define	LIST_INSERT_HEAD(head, elm, field) do {				\
+	if (((elm)->field.le_next = (head)->lh_first) != NULL)		\
+		(head)->lh_first->field.le_prev = &(elm)->field.le_next;\
+	(head)->lh_first = (elm);					\
+	(elm)->field.le_prev = &(head)->lh_first;			\
+} while (/*CONSTCOND*/0)
+
+#define	LIST_REMOVE(elm, field) do {					\
+	if ((elm)->field.le_next != NULL)				\
+		(elm)->field.le_next->field.le_prev = 			\
+		    (elm)->field.le_prev;				\
+	*(elm)->field.le_prev = (elm)->field.le_next;			\
+} while (/*CONSTCOND*/0)
+
+#define	LIST_FOREACH(var, head, field)					\
+	for ((var) = ((head)->lh_first);				\
+		(var);							\
+		(var) = ((var)->field.le_next))
+
+/*
+ * List access methods.
+ */
+#define	LIST_EMPTY(head)		((head)->lh_first == NULL)
+#define	LIST_FIRST(head)		((head)->lh_first)
+#define	LIST_NEXT(elm, field)		((elm)->field.le_next)
+
+
+/*
+ * Singly-linked List definitions.
+ */
+#define	SLIST_HEAD(name, type)						\
+struct name {								\
+	struct type *slh_first;	/* first element */			\
+}
+
+#define	SLIST_HEAD_INITIALIZER(head)					\
+	{ NULL }
+
+#define	SLIST_ENTRY(type)						\
+struct {								\
+	struct type *sle_next;	/* next element */			\
+}
+
+/*
+ * Singly-linked List functions.
+ */
+#define	SLIST_INIT(head) do {						\
+	(head)->slh_first = NULL;					\
+} while (/*CONSTCOND*/0)
+
+#define	SLIST_INSERT_AFTER(slistelm, elm, field) do {			\
+	(elm)->field.sle_next = (slistelm)->field.sle_next;		\
+	(slistelm)->field.sle_next = (elm);				\
+} while (/*CONSTCOND*/0)
+
+#define	SLIST_INSERT_HEAD(head, elm, field) do {			\
+	(elm)->field.sle_next = (head)->slh_first;			\
+	(head)->slh_first = (elm);					\
+} while (/*CONSTCOND*/0)
+
+#define	SLIST_REMOVE_HEAD(head, field) do {				\
+	(head)->slh_first = (head)->slh_first->field.sle_next;		\
+} while (/*CONSTCOND*/0)
+
+#define	SLIST_REMOVE(head, elm, type, field) do {			\
+	if ((head)->slh_first == (elm)) {				\
+		SLIST_REMOVE_HEAD((head), field);			\
+	}								\
+	else {								\
+		struct type *curelm = (head)->slh_first;		\
+		while(curelm->field.sle_next != (elm))			\
+			curelm = curelm->field.sle_next;		\
+		curelm->field.sle_next =				\
+		    curelm->field.sle_next->field.sle_next;		\
+	}								\
+} while (/*CONSTCOND*/0)
+
+#define	SLIST_FOREACH(var, head, field)					\
+	for((var) = (head)->slh_first; (var); (var) = (var)->field.sle_next)
+
+/*
+ * Singly-linked List access methods.
+ */
+#define	SLIST_EMPTY(head)	((head)->slh_first == NULL)
+#define	SLIST_FIRST(head)	((head)->slh_first)
+#define	SLIST_NEXT(elm, field)	((elm)->field.sle_next)
+
+
+/*
+ * Singly-linked Tail queue declarations.
+ */
+#define	STAILQ_HEAD(name, type)					\
+struct name {								\
+	struct type *stqh_first;	/* first element */			\
+	struct type **stqh_last;	/* addr of last next element */		\
+}
+
+#define	STAILQ_HEAD_INITIALIZER(head)					\
+	{ NULL, &(head).stqh_first }
+
+#define	STAILQ_ENTRY(type)						\
+struct {								\
+	struct type *stqe_next;	/* next element */			\
+}
+
+/*
+ * Singly-linked Tail queue functions.
+ */
+#define	STAILQ_INIT(head) do {						\
+	(head)->stqh_first = NULL;					\
+	(head)->stqh_last = &(head)->stqh_first;				\
+} while (/*CONSTCOND*/0)
+
+#define	STAILQ_INSERT_HEAD(head, elm, field) do {			\
+	if (((elm)->field.stqe_next = (head)->stqh_first) == NULL)	\
+		(head)->stqh_last = &(elm)->field.stqe_next;		\
+	(head)->stqh_first = (elm);					\
+} while (/*CONSTCOND*/0)
+
+#define	STAILQ_INSERT_TAIL(head, elm, field) do {			\
+	(elm)->field.stqe_next = NULL;					\
+	*(head)->stqh_last = (elm);					\
+	(head)->stqh_last = &(elm)->field.stqe_next;			\
+} while (/*CONSTCOND*/0)
+
+#define	STAILQ_INSERT_AFTER(head, listelm, elm, field) do {		\
+	if (((elm)->field.stqe_next = (listelm)->field.stqe_next) == NULL)\
+		(head)->stqh_last = &(elm)->field.stqe_next;		\
+	(listelm)->field.stqe_next = (elm);				\
+} while (/*CONSTCOND*/0)
+
+#define	STAILQ_REMOVE_HEAD(head, field) do {				\
+	if (((head)->stqh_first = (head)->stqh_first->field.stqe_next) == NULL) \
+		(head)->stqh_last = &(head)->stqh_first;			\
+} while (/*CONSTCOND*/0)
+
+#define	STAILQ_REMOVE(head, elm, type, field) do {			\
+	if ((head)->stqh_first == (elm)) {				\
+		STAILQ_REMOVE_HEAD((head), field);			\
+	} else {							\
+		struct type *curelm = (head)->stqh_first;		\
+		while (curelm->field.stqe_next != (elm))			\
+			curelm = curelm->field.stqe_next;		\
+		if ((curelm->field.stqe_next =				\
+			curelm->field.stqe_next->field.stqe_next) == NULL) \
+			    (head)->stqh_last = &(curelm)->field.stqe_next; \
+	}								\
+} while (/*CONSTCOND*/0)
+
+#define	STAILQ_FOREACH(var, head, field)				\
+	for ((var) = ((head)->stqh_first);				\
+		(var);							\
+		(var) = ((var)->field.stqe_next))
+
+#define	STAILQ_CONCAT(head1, head2) do {				\
+	if (!STAILQ_EMPTY((head2))) {					\
+		*(head1)->stqh_last = (head2)->stqh_first;		\
+		(head1)->stqh_last = (head2)->stqh_last;		\
+		STAILQ_INIT((head2));					\
+	}								\
+} while (/*CONSTCOND*/0)
+
+/*
+ * Singly-linked Tail queue access methods.
+ */
+#define	STAILQ_EMPTY(head)	((head)->stqh_first == NULL)
+#define	STAILQ_FIRST(head)	((head)->stqh_first)
+#define	STAILQ_NEXT(elm, field)	((elm)->field.stqe_next)
+
+
+/*
+ * Simple queue definitions.
+ */
+#define	SIMPLEQ_HEAD(name, type)					\
+struct name {								\
+	struct type *sqh_first;	/* first element */			\
+	struct type **sqh_last;	/* addr of last next element */		\
+}
+
+#define	SIMPLEQ_HEAD_INITIALIZER(head)					\
+	{ NULL, &(head).sqh_first }
+
+#define	SIMPLEQ_ENTRY(type)						\
+struct {								\
+	struct type *sqe_next;	/* next element */			\
+}
+
+/*
+ * Simple queue functions.
+ */
+#define	SIMPLEQ_INIT(head) do {						\
+	(head)->sqh_first = NULL;					\
+	(head)->sqh_last = &(head)->sqh_first;				\
+} while (/*CONSTCOND*/0)
+
+#define	SIMPLEQ_INSERT_HEAD(head, elm, field) do {			\
+	if (((elm)->field.sqe_next = (head)->sqh_first) == NULL)	\
+		(head)->sqh_last = &(elm)->field.sqe_next;		\
+	(head)->sqh_first = (elm);					\
+} while (/*CONSTCOND*/0)
+
+#define	SIMPLEQ_INSERT_TAIL(head, elm, field) do {			\
+	(elm)->field.sqe_next = NULL;					\
+	*(head)->sqh_last = (elm);					\
+	(head)->sqh_last = &(elm)->field.sqe_next;			\
+} while (/*CONSTCOND*/0)
+
+#define	SIMPLEQ_INSERT_AFTER(head, listelm, elm, field) do {		\
+	if (((elm)->field.sqe_next = (listelm)->field.sqe_next) == NULL)\
+		(head)->sqh_last = &(elm)->field.sqe_next;		\
+	(listelm)->field.sqe_next = (elm);				\
+} while (/*CONSTCOND*/0)
+
+#define	SIMPLEQ_REMOVE_HEAD(head, field) do {				\
+	if (((head)->sqh_first = (head)->sqh_first->field.sqe_next) == NULL) \
+		(head)->sqh_last = &(head)->sqh_first;			\
+} while (/*CONSTCOND*/0)
+
+#define	SIMPLEQ_REMOVE(head, elm, type, field) do {			\
+	if ((head)->sqh_first == (elm)) {				\
+		SIMPLEQ_REMOVE_HEAD((head), field);			\
+	} else {							\
+		struct type *curelm = (head)->sqh_first;		\
+		while (curelm->field.sqe_next != (elm))			\
+			curelm = curelm->field.sqe_next;		\
+		if ((curelm->field.sqe_next =				\
+			curelm->field.sqe_next->field.sqe_next) == NULL) \
+			    (head)->sqh_last = &(curelm)->field.sqe_next; \
+	}								\
+} while (/*CONSTCOND*/0)
+
+#define	SIMPLEQ_FOREACH(var, head, field)				\
+	for ((var) = ((head)->sqh_first);				\
+		(var);							\
+		(var) = ((var)->field.sqe_next))
+
+/*
+ * Simple queue access methods.
+ */
+#define	SIMPLEQ_EMPTY(head)		((head)->sqh_first == NULL)
+#define	SIMPLEQ_FIRST(head)		((head)->sqh_first)
+#define	SIMPLEQ_NEXT(elm, field)	((elm)->field.sqe_next)
+
+
+/*
+ * Tail queue definitions.
+ */
+#define	_TAILQ_HEAD(name, type, qual)					\
+struct name {								\
+	qual type *tqh_first;		/* first element */		\
+	qual type *qual *tqh_last;	/* addr of last next element */	\
+}
+#define TAILQ_HEAD(name, type)	_TAILQ_HEAD(name, struct type,)
+
+#define	TAILQ_HEAD_INITIALIZER(head)					\
+	{ NULL, &(head).tqh_first }
+
+#define	_TAILQ_ENTRY(type, qual)					\
+struct {								\
+	qual type *tqe_next;		/* next element */		\
+	qual type *qual *tqe_prev;	/* address of previous next element */\
+}
+#define TAILQ_ENTRY(type)	_TAILQ_ENTRY(struct type,)
+
+/*
+ * Tail queue functions.
+ */
+#define	TAILQ_INIT(head) do {						\
+	(head)->tqh_first = NULL;					\
+	(head)->tqh_last = &(head)->tqh_first;				\
+} while (/*CONSTCOND*/0)
+
+#define	TAILQ_INSERT_HEAD(head, elm, field) do {			\
+	if (((elm)->field.tqe_next = (head)->tqh_first) != NULL)	\
+		(head)->tqh_first->field.tqe_prev =			\
+		    &(elm)->field.tqe_next;				\
+	else								\
+		(head)->tqh_last = &(elm)->field.tqe_next;		\
+	(head)->tqh_first = (elm);					\
+	(elm)->field.tqe_prev = &(head)->tqh_first;			\
+} while (/*CONSTCOND*/0)
+
+#define	TAILQ_INSERT_TAIL(head, elm, field) do {			\
+	(elm)->field.tqe_next = NULL;					\
+	(elm)->field.tqe_prev = (head)->tqh_last;			\
+	*(head)->tqh_last = (elm);					\
+	(head)->tqh_last = &(elm)->field.tqe_next;			\
+} while (/*CONSTCOND*/0)
+
+#define	TAILQ_INSERT_AFTER(head, listelm, elm, field) do {		\
+	if (((elm)->field.tqe_next = (listelm)->field.tqe_next) != NULL)\
+		(elm)->field.tqe_next->field.tqe_prev = 		\
+		    &(elm)->field.tqe_next;				\
+	else								\
+		(head)->tqh_last = &(elm)->field.tqe_next;		\
+	(listelm)->field.tqe_next = (elm);				\
+	(elm)->field.tqe_prev = &(listelm)->field.tqe_next;		\
+} while (/*CONSTCOND*/0)
+
+#define	TAILQ_INSERT_BEFORE(listelm, elm, field) do {			\
+	(elm)->field.tqe_prev = (listelm)->field.tqe_prev;		\
+	(elm)->field.tqe_next = (listelm);				\
+	*(listelm)->field.tqe_prev = (elm);				\
+	(listelm)->field.tqe_prev = &(elm)->field.tqe_next;		\
+} while (/*CONSTCOND*/0)
+
+#define	TAILQ_REMOVE(head, elm, field) do {				\
+	if (((elm)->field.tqe_next) != NULL)				\
+		(elm)->field.tqe_next->field.tqe_prev = 		\
+		    (elm)->field.tqe_prev;				\
+	else								\
+		(head)->tqh_last = (elm)->field.tqe_prev;		\
+	*(elm)->field.tqe_prev = (elm)->field.tqe_next;			\
+} while (/*CONSTCOND*/0)
+
+#define	TAILQ_FOREACH(var, head, field)					\
+	for ((var) = ((head)->tqh_first);				\
+		(var);							\
+		(var) = ((var)->field.tqe_next))
+
+#define	TAILQ_FOREACH_REVERSE(var, head, headname, field)		\
+	for ((var) = (*(((struct headname *)((head)->tqh_last))->tqh_last));	\
+		(var);							\
+		(var) = (*(((struct headname *)((var)->field.tqe_prev))->tqh_last)))
+
+#define	TAILQ_CONCAT(head1, head2, field) do {				\
+	if (!TAILQ_EMPTY(head2)) {					\
+		*(head1)->tqh_last = (head2)->tqh_first;		\
+		(head2)->tqh_first->field.tqe_prev = (head1)->tqh_last;	\
+		(head1)->tqh_last = (head2)->tqh_last;			\
+		TAILQ_INIT((head2));					\
+	}								\
+} while (/*CONSTCOND*/0)
+
+/*
+ * Tail queue access methods.
+ */
+#define	TAILQ_EMPTY(head)		((head)->tqh_first == NULL)
+#define	TAILQ_FIRST(head)		((head)->tqh_first)
+#define	TAILQ_NEXT(elm, field)		((elm)->field.tqe_next)
+
+#define	TAILQ_LAST(head, headname) \
+	(*(((struct headname *)((head)->tqh_last))->tqh_last))
+#define	TAILQ_PREV(elm, headname, field) \
+	(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))
+
+
+/*
+ * Circular queue definitions.
+ */
+#define	CIRCLEQ_HEAD(name, type)					\
+struct name {								\
+	struct type *cqh_first;		/* first element */		\
+	struct type *cqh_last;		/* last element */		\
+}
+
+#define	CIRCLEQ_HEAD_INITIALIZER(head)					\
+	{ (void *)&head, (void *)&head }
+
+#define	CIRCLEQ_ENTRY(type)						\
+struct {								\
+	struct type *cqe_next;		/* next element */		\
+	struct type *cqe_prev;		/* previous element */		\
+}
+
+/*
+ * Circular queue functions.
+ */
+#define	CIRCLEQ_INIT(head) do {						\
+	(head)->cqh_first = (void *)(head);				\
+	(head)->cqh_last = (void *)(head);				\
+} while (/*CONSTCOND*/0)
+
+#define	CIRCLEQ_INSERT_AFTER(head, listelm, elm, field) do {		\
+	(elm)->field.cqe_next = (listelm)->field.cqe_next;		\
+	(elm)->field.cqe_prev = (listelm);				\
+	if ((listelm)->field.cqe_next == (void *)(head))		\
+		(head)->cqh_last = (elm);				\
+	else								\
+		(listelm)->field.cqe_next->field.cqe_prev = (elm);	\
+	(listelm)->field.cqe_next = (elm);				\
+} while (/*CONSTCOND*/0)
+
+#define	CIRCLEQ_INSERT_BEFORE(head, listelm, elm, field) do {		\
+	(elm)->field.cqe_next = (listelm);				\
+	(elm)->field.cqe_prev = (listelm)->field.cqe_prev;		\
+	if ((listelm)->field.cqe_prev == (void *)(head))		\
+		(head)->cqh_first = (elm);				\
+	else								\
+		(listelm)->field.cqe_prev->field.cqe_next = (elm);	\
+	(listelm)->field.cqe_prev = (elm);				\
+} while (/*CONSTCOND*/0)
+
+#define	CIRCLEQ_INSERT_HEAD(head, elm, field) do {			\
+	(elm)->field.cqe_next = (head)->cqh_first;			\
+	(elm)->field.cqe_prev = (void *)(head);				\
+	if ((head)->cqh_last == (void *)(head))				\
+		(head)->cqh_last = (elm);				\
+	else								\
+		(head)->cqh_first->field.cqe_prev = (elm);		\
+	(head)->cqh_first = (elm);					\
+} while (/*CONSTCOND*/0)
+
+#define	CIRCLEQ_INSERT_TAIL(head, elm, field) do {			\
+	(elm)->field.cqe_next = (void *)(head);				\
+	(elm)->field.cqe_prev = (head)->cqh_last;			\
+	if ((head)->cqh_first == (void *)(head))			\
+		(head)->cqh_first = (elm);				\
+	else								\
+		(head)->cqh_last->field.cqe_next = (elm);		\
+	(head)->cqh_last = (elm);					\
+} while (/*CONSTCOND*/0)
+
+#define	CIRCLEQ_REMOVE(head, elm, field) do {				\
+	if ((elm)->field.cqe_next == (void *)(head))			\
+		(head)->cqh_last = (elm)->field.cqe_prev;		\
+	else								\
+		(elm)->field.cqe_next->field.cqe_prev =			\
+		    (elm)->field.cqe_prev;				\
+	if ((elm)->field.cqe_prev == (void *)(head))			\
+		(head)->cqh_first = (elm)->field.cqe_next;		\
+	else								\
+		(elm)->field.cqe_prev->field.cqe_next =			\
+		    (elm)->field.cqe_next;				\
+} while (/*CONSTCOND*/0)
+
+#define	CIRCLEQ_FOREACH(var, head, field)				\
+	for ((var) = ((head)->cqh_first);				\
+		(var) != (const void *)(head);				\
+		(var) = ((var)->field.cqe_next))
+
+#define	CIRCLEQ_FOREACH_REVERSE(var, head, field)			\
+	for ((var) = ((head)->cqh_last);				\
+		(var) != (const void *)(head);				\
+		(var) = ((var)->field.cqe_prev))
+
+/*
+ * Circular queue access methods.
+ */
+#define	CIRCLEQ_EMPTY(head)		((head)->cqh_first == (void *)(head))
+#define	CIRCLEQ_FIRST(head)		((head)->cqh_first)
+#define	CIRCLEQ_LAST(head)		((head)->cqh_last)
+#define	CIRCLEQ_NEXT(elm, field)	((elm)->field.cqe_next)
+#define	CIRCLEQ_PREV(elm, field)	((elm)->field.cqe_prev)
+
+#define CIRCLEQ_LOOP_NEXT(head, elm, field)				\
+	(((elm)->field.cqe_next == (void *)(head))			\
+	    ? ((head)->cqh_first)					\
+	    : (elm->field.cqe_next))
+#define CIRCLEQ_LOOP_PREV(head, elm, field)				\
+	(((elm)->field.cqe_prev == (void *)(head))			\
+	    ? ((head)->cqh_last)					\
+	    : (elm->field.cqe_prev))
+
+#endif	/* sys/queue.h */
diff --git a/include/time.h b/include/time.h
index 3d94837205ad..7bc6695ed20e 100644
--- a/include/time.h
+++ b/include/time.h
@@ -21,14 +21,10 @@ extern "C" {
 #define __NEED_clock_t
 #define __NEED_struct_timespec
 
-#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
- || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
- || defined(_BSD_SOURCE)
 #define __NEED_clockid_t
 #define __NEED_timer_t
 #define __NEED_pid_t
 #define __NEED_locale_t
-#endif
 
 #include <bits/alltypes.h>
 
@@ -66,9 +62,7 @@ int timespec_get(struct timespec *, int);
 
 #define TIME_UTC 1
 
-#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
- || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) \
- || defined(_BSD_SOURCE)
+int nanosleep (const struct timespec *, struct timespec *);
 
 size_t strftime_l (char *  __restrict, size_t, const char *  __restrict, const struct tm *  __restrict, locale_t);
 
@@ -99,7 +93,6 @@ struct itimerspec {
 
 #define TIMER_ABSTIME 1
 
-int nanosleep (const struct timespec *, struct timespec *);
 int clock_getres (clockid_t, struct timespec *);
 int clock_gettime (clockid_t, struct timespec *);
 int clock_settime (clockid_t, const struct timespec *);
@@ -115,8 +108,6 @@ int timer_getoverrun (timer_t);
 
 extern char *tzname[2];
 
-#endif
-
 
 #if defined(_XOPEN_SOURCE) || defined(_BSD_SOURCE) || defined(_GNU_SOURCE)
 char *strptime (const char *__restrict, const char *__restrict, struct tm *__restrict);
diff --git a/include/unistd.h b/include/unistd.h
index 5bc7f7982f5e..d0956131feaa 100644
--- a/include/unistd.h
+++ b/include/unistd.h
@@ -162,7 +162,6 @@ unsigned ualarm(unsigned, unsigned);
 #define L_XTND 2
 int brk(void *);
 void *sbrk(intptr_t);
-pid_t vfork(void);
 int vhangup(void);
 int chroot(const char *);
 int getpagesize(void);
@@ -184,12 +183,13 @@ int getentropy(void *, size_t);
 extern int optreset;
 #endif
 
-#ifdef _GNU_SOURCE
-extern char **environ;
 int setresuid(uid_t, uid_t, uid_t);
 int setresgid(gid_t, gid_t, gid_t);
 int getresuid(uid_t *, uid_t *, uid_t *);
 int getresgid(gid_t *, gid_t *, gid_t *);
+
+#ifdef _GNU_SOURCE
+extern char **environ;
 char *get_current_dir_name(void);
 int syncfs(int);
 int euidaccess(const char *, int);
diff --git a/include/wchar.h b/include/wchar.h
index ed5d774dfa96..8818ac81d877 100644
--- a/include/wchar.h
+++ b/include/wchar.h
@@ -18,15 +18,10 @@ extern "C" {
 #define __NEED_struct__IO_FILE
 #endif
 
-#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
- || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
 #define __NEED_locale_t
 #define __NEED_va_list
-#endif
 
-#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
 #define __NEED_wctype_t
-#endif
 
 #include <bits/alltypes.h>
 
@@ -157,8 +152,6 @@ int fputws_unlocked (const wchar_t *__restrict, FILE *__restrict);
 size_t wcsftime_l (wchar_t *__restrict, size_t, const wchar_t *__restrict, const struct tm *__restrict, locale_t);
 #endif
 
-#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
- || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE)  || defined(_BSD_SOURCE)
 FILE *open_wmemstream(wchar_t **, size_t *);
 size_t mbsnrtowcs(wchar_t *__restrict, const char **__restrict, size_t, size_t, mbstate_t *__restrict);
 size_t wcsnrtombs(char *__restrict, const wchar_t **__restrict, size_t, size_t, mbstate_t *__restrict);
@@ -172,9 +165,7 @@ int wcsncasecmp(const wchar_t *, const wchar_t *, size_t);
 int wcsncasecmp_l(const wchar_t *, const wchar_t *, size_t, locale_t);
 int wcscoll_l(const wchar_t *, const wchar_t *, locale_t);
 size_t wcsxfrm_l(wchar_t *__restrict, const wchar_t *__restrict, size_t, locale_t);
-#endif
 
-#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
 int wcwidth (wchar_t);
 int wcswidth (const wchar_t *, size_t);
 int       iswalnum(wint_t);
@@ -198,7 +189,6 @@ wctype_t  wctype(const char *);
 #undef iswdigit
 #define iswdigit(a) (0 ? iswdigit(a) : ((unsigned)(a)-'0') < 10)
 #endif
-#endif
 
 #ifdef __cplusplus
 }
diff --git a/include/wctype.h b/include/wctype.h
index bc2420d3fd84..681aa79738d6 100644
--- a/include/wctype.h
+++ b/include/wctype.h
@@ -10,10 +10,7 @@ extern "C" {
 #define __NEED_wint_t
 #define __NEED_wctype_t
 
-#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
- || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
 #define __NEED_locale_t
-#endif
 
 #include <bits/alltypes.h>
 
@@ -48,9 +45,6 @@ wctype_t  wctype(const char *);
 #define iswdigit(a) (0 ? iswdigit(a) : ((unsigned)(a)-'0') < 10)
 #endif
 
-#if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
- || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
-
 int iswalnum_l(wint_t, locale_t);
 int iswalpha_l(wint_t, locale_t);
 int iswblank_l(wint_t, locale_t);
@@ -70,8 +64,6 @@ wint_t towctrans_l(wint_t, wctrans_t, locale_t);
 wctrans_t wctrans_l(const char *, locale_t);
 wctype_t  wctype_l(const char *, locale_t);
 
-#endif
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/conf/sysconf.c b/src/conf/sysconf.c
index 60d3e745350d..ec733b8d162e 100644
--- a/src/conf/sysconf.c
+++ b/src/conf/sysconf.c
@@ -203,7 +203,7 @@ long sysconf(int name)
 	case JT_NPROCESSORS_ONLN & 255: ;
 		unsigned char set[128] = {1};
 		int i, cnt;
-		__syscall(SYS_sched_getaffinity, 0, sizeof set, set);
+		zsys_sched_getaffinity(0, sizeof set, set);
 		for (i=cnt=0; i<sizeof set; i++)
 			for (; set[i]; set[i]&=set[i]-1, cnt++);
 		return cnt;
diff --git a/src/crypt/crypt_r.c b/src/crypt/crypt_r.c
index db6015e236f6..511e3a43951a 100644
--- a/src/crypt/crypt_r.c
+++ b/src/crypt/crypt_r.c
@@ -1,4 +1,5 @@
 #include <crypt.h>
+#include "yescrypt.h"
 
 char *__crypt_r(const char *key, const char *salt, struct crypt_data *data)
 {
@@ -16,6 +17,10 @@ char *__crypt_r(const char *key, const char *salt, struct crypt_data *data)
 			return __crypt_sha256(key, salt, output);
 		if (salt[1] == '6' && salt[2] == '$')
 			return __crypt_sha512(key, salt, output);
+		if ((salt[1] == '7' || salt[1] == 'y') && salt[2] == '$') {
+			/* our yescrypt() is thread-safe already. */
+			return yescrypt(key, salt);
+		}
 	}
 	return __crypt_des(key, salt, output);
 }
diff --git a/src/dirent/readdir.c b/src/dirent/readdir.c
index 5a03b36352f9..4f7ef3094517 100644
--- a/src/dirent/readdir.c
+++ b/src/dirent/readdir.c
@@ -12,9 +12,10 @@ struct dirent *readdir(DIR *dir)
 	struct dirent *de;
 	
 	if (dir->buf_pos >= dir->buf_end) {
-		int len = __syscall(SYS_getdents, dir->fd, dir->buf, sizeof dir->buf);
+		int len = zsys_getdents(dir->fd, dir->buf, sizeof dir->buf);
 		if (len <= 0) {
-			if (len < 0 && len != -ENOENT) errno = -len;
+			if (len < 0 && errno == ENOENT)
+				errno = 0;
 			return 0;
 		}
 		dir->buf_end = len;
diff --git a/src/env/__init_tls.c b/src/env/__init_tls.c
index a93141ed36a8..68e086b933eb 100644
--- a/src/env/__init_tls.c
+++ b/src/env/__init_tls.c
@@ -15,11 +15,12 @@ int __init_tp(void *p)
 {
 	pthread_t td = p;
 	td->self = td;
-	int r = __set_thread_area(TP_ADJ(p));
-	if (r < 0) return -1;
-	if (!r) libc.can_do_threads = 1;
+        zthread_set_self_cookie(p);
+	libc.can_do_threads = 1;
 	td->detach_state = DT_JOINABLE;
-	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
+	td->tid = zthread_self_id();
+        td->zthread = zthread_self();
+	ZASSERT(td->tid);
 	td->locale = &libc.global_locale;
 	td->robust_list.head = &td->robust_list.head;
 	td->sysinfo = __sysinfo;
@@ -27,49 +28,7 @@ int __init_tp(void *p)
 	return 0;
 }
 
-static struct builtin_tls {
-	char c;
-	struct pthread pt;
-	void *space[16];
-} builtin_tls[1];
-#define MIN_TLS_ALIGN offsetof(struct builtin_tls, pt)
-
-static struct tls_module main_tls;
-
-void *__copy_tls(unsigned char *mem)
-{
-	pthread_t td;
-	struct tls_module *p;
-	size_t i;
-	uintptr_t *dtv;
-
-#ifdef TLS_ABOVE_TP
-	dtv = (uintptr_t*)(mem + libc.tls_size) - (libc.tls_cnt + 1);
-
-	mem += -((uintptr_t)mem + sizeof(struct pthread)) & (libc.tls_align-1);
-	td = (pthread_t)mem;
-	mem += sizeof(struct pthread);
-
-	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
-		dtv[i] = (uintptr_t)(mem + p->offset) + DTP_OFFSET;
-		memcpy(mem + p->offset, p->image, p->len);
-	}
-#else
-	dtv = (uintptr_t *)mem;
-
-	mem += libc.tls_size - sizeof(struct pthread);
-	mem -= (uintptr_t)mem & (libc.tls_align-1);
-	td = (pthread_t)mem;
-
-	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
-		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
-		memcpy(mem - p->offset, p->image, p->len);
-	}
-#endif
-	dtv[0] = libc.tls_cnt;
-	td->dtv = dtv;
-	return td;
-}
+struct pthread builtin_pt;
 
 #if ULONG_MAX == 0xffffffff
 typedef Elf32_Phdr Phdr;
@@ -87,66 +46,7 @@ static void static_init_tls(size_t *aux)
 	size_t base = 0;
 	void *mem;
 
-	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
-		phdr = (void *)p;
-		if (phdr->p_type == PT_PHDR)
-			base = aux[AT_PHDR] - phdr->p_vaddr;
-		if (phdr->p_type == PT_DYNAMIC && _DYNAMIC)
-			base = (size_t)_DYNAMIC - phdr->p_vaddr;
-		if (phdr->p_type == PT_TLS)
-			tls_phdr = phdr;
-		if (phdr->p_type == PT_GNU_STACK &&
-		    phdr->p_memsz > __default_stacksize)
-			__default_stacksize =
-				phdr->p_memsz < DEFAULT_STACK_MAX ?
-				phdr->p_memsz : DEFAULT_STACK_MAX;
-	}
-
-	if (tls_phdr) {
-		main_tls.image = (void *)(base + tls_phdr->p_vaddr);
-		main_tls.len = tls_phdr->p_filesz;
-		main_tls.size = tls_phdr->p_memsz;
-		main_tls.align = tls_phdr->p_align;
-		libc.tls_cnt = 1;
-		libc.tls_head = &main_tls;
-	}
-
-	main_tls.size += (-main_tls.size - (uintptr_t)main_tls.image)
-		& (main_tls.align-1);
-#ifdef TLS_ABOVE_TP
-	main_tls.offset = GAP_ABOVE_TP;
-	main_tls.offset += (-GAP_ABOVE_TP + (uintptr_t)main_tls.image)
-		& (main_tls.align-1);
-#else
-	main_tls.offset = main_tls.size;
-#endif
-	if (main_tls.align < MIN_TLS_ALIGN) main_tls.align = MIN_TLS_ALIGN;
-
-	libc.tls_align = main_tls.align;
-	libc.tls_size = 2*sizeof(void *) + sizeof(struct pthread)
-#ifdef TLS_ABOVE_TP
-		+ main_tls.offset
-#endif
-		+ main_tls.size + main_tls.align
-		+ MIN_TLS_ALIGN-1 & -MIN_TLS_ALIGN;
-
-	if (libc.tls_size > sizeof builtin_tls) {
-#ifndef SYS_mmap2
-#define SYS_mmap2 SYS_mmap
-#endif
-		mem = (void *)__syscall(
-			SYS_mmap2,
-			0, libc.tls_size, PROT_READ|PROT_WRITE,
-			MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
-		/* -4095...-1 cast to void * will crash on dereference anyway,
-		 * so don't bloat the init code checking for error codes and
-		 * explicitly calling a_crash(). */
-	} else {
-		mem = builtin_tls;
-	}
-
-	/* Failure to initialize thread pointer is always fatal. */
-	if (__init_tp(__copy_tls(mem)) < 0)
+	if (__init_tp(&builtin_pt) < 0)
 		a_crash();
 }
 
diff --git a/src/env/__libc_start_main.c b/src/env/__libc_start_main.c
index c5b277bdcf2e..2e42c6f98e5d 100644
--- a/src/env/__libc_start_main.c
+++ b/src/env/__libc_start_main.c
@@ -1,31 +1,41 @@
 #include <elf.h>
+#include <errno.h>
+#include <pizlonated_runtime.h>
 #include <poll.h>
 #include <fcntl.h>
 #include <signal.h>
 #include <unistd.h>
 #include "syscall.h"
 #include "atomic.h"
+#include "dynlink.h"
 #include "libc.h"
 
 static void dummy(void) {}
 weak_alias(dummy, _init);
 
-extern weak hidden void (*const __init_array_start)(void), (*const __init_array_end)(void);
-
 static void dummy1(void *p) {}
 weak_alias(dummy1, __init_ssp);
 
 #define AUX_CNT 38
 
+static void errno_handler(int errno_value)
+{
+	errno = errno_value;
+}
+
+static void dlerror_handler(const char* str)
+{
+	__dl_seterr("%s", str);
+}
+
 #ifdef __GNUC__
 __attribute__((__noinline__))
 #endif
-void __init_libc(char **envp, char *pn)
+void __init_libc(char **envp, char *pn, size_t *auxv)
 {
-	size_t i, *auxv, aux[AUX_CNT] = { 0 };
+	size_t i, aux[AUX_CNT] = { 0 };
 	__environ = envp;
-	for (i=0; envp[i]; i++);
-	libc.auxv = auxv = (void *)(envp+i+1);
+	libc.auxv = auxv;
 	for (i=0; auxv[i]; i+=2) if (auxv[i]<AUX_CNT) aux[auxv[i]] = auxv[i+1];
 	__hwcap = aux[AT_HWCAP];
 	if (aux[AT_SYSINFO]) __sysinfo = aux[AT_SYSINFO];
@@ -37,61 +47,35 @@ void __init_libc(char **envp, char *pn)
 	for (i=0; pn[i]; i++) if (pn[i]=='/') __progname = pn+i+1;
 
 	__init_tls(aux);
+
+	zregister_sys_errno_handler(errno_handler);
+	zregister_sys_dlerror_handler(dlerror_handler);
+	
 	__init_ssp((void *)aux[AT_RANDOM]);
 
 	if (aux[AT_UID]==aux[AT_EUID] && aux[AT_GID]==aux[AT_EGID]
 		&& !aux[AT_SECURE]) return;
 
 	struct pollfd pfd[3] = { {.fd=0}, {.fd=1}, {.fd=2} };
-	int r =
-#ifdef SYS_poll
-	__syscall(SYS_poll, pfd, 3, 0);
-#else
-	__syscall(SYS_ppoll, pfd, 3, &(struct timespec){0}, 0, _NSIG/8);
-#endif
+	int r = zsys_poll(pfd, 3, 0);
 	if (r<0) a_crash();
 	for (i=0; i<3; i++) if (pfd[i].revents&POLLNVAL)
-		if (__sys_open("/dev/null", O_RDWR)<0)
+		if (zsys_open("/dev/null", O_RDWR)<0)
 			a_crash();
 	libc.secure = 1;
 }
 
-static void libc_start_init(void)
+void __libc_start_main(int (*main)(int,char **,char **), int argc, char **argv,
+                       char **envp, size_t *auxv)
 {
-	_init();
-	uintptr_t a = (uintptr_t)&__init_array_start;
-	for (; a<(uintptr_t)&__init_array_end; a+=sizeof(void(*)()))
-		(*(void (**)(void))a)();
-}
-
-weak_alias(libc_start_init, __libc_start_init);
-
-typedef int lsm2_fn(int (*)(int,char **,char **), int, char **);
-static lsm2_fn libc_start_main_stage2;
-
-int __libc_start_main(int (*main)(int,char **,char **), int argc, char **argv,
-	void (*init_dummy)(), void(*fini_dummy)(), void(*ldso_dummy)())
-{
-	char **envp = argv+argc+1;
-
 	/* External linkage, and explicit noinline attribute if available,
 	 * are used to prevent the stack frame used during init from
 	 * persisting for the entire process lifetime. */
-	__init_libc(envp, argv[0]);
+	__init_libc(envp, argv[0], auxv);
 
-	/* Barrier against hoisting application code or anything using ssp
-	 * or thread pointer prior to its initialization above. */
-	lsm2_fn *stage2 = libc_start_main_stage2;
-	__asm__ ( "" : "+r"(stage2) : : "memory" );
-	return stage2(main, argc, argv);
-}
-
-static int libc_start_main_stage2(int (*main)(int,char **,char **), int argc, char **argv)
-{
-	char **envp = argv+argc+1;
-	__libc_start_init();
+	zrun_deferred_global_ctors();
 
 	/* Pass control to the application */
 	exit(main(argc, argv, envp));
-	return 0;
 }
+
diff --git a/src/env/__reset_tls.c b/src/env/__reset_tls.c
index 15685bc66698..83d2d3eb87be 100644
--- a/src/env/__reset_tls.c
+++ b/src/env/__reset_tls.c
@@ -4,12 +4,5 @@
 
 void __reset_tls()
 {
-	pthread_t self = __pthread_self();
-	struct tls_module *p;
-	size_t i, n = self->dtv[0];
-	if (n) for (p=libc.tls_head, i=1; i<=n; i++, p=p->next) {
-		char *mem = (char *)(self->dtv[i] - DTP_OFFSET);
-		memcpy(mem, p->image, p->len);
-		memset(mem+p->len, 0, p->size - p->len);
-	}
+    /* FIXME: Probably we should do something here? */
 }
diff --git a/src/env/__stack_chk_fail.c b/src/env/__stack_chk_fail.c
deleted file mode 100644
index e53526020f75..000000000000
--- a/src/env/__stack_chk_fail.c
+++ /dev/null
@@ -1,31 +0,0 @@
-#include <string.h>
-#include <stdint.h>
-#include "pthread_impl.h"
-
-uintptr_t __stack_chk_guard;
-
-void __init_ssp(void *entropy)
-{
-	if (entropy) memcpy(&__stack_chk_guard, entropy, sizeof(uintptr_t));
-	else __stack_chk_guard = (uintptr_t)&__stack_chk_guard * 1103515245;
-
-#if UINTPTR_MAX >= 0xffffffffffffffff
-	/* Sacrifice 8 bits of entropy on 64bit to prevent leaking/
-	 * overwriting the canary via string-manipulation functions.
-	 * The NULL byte is on the second byte so that off-by-ones can
-	 * still be detected. Endianness is taken care of
-	 * automatically. */
-	((char *)&__stack_chk_guard)[1] = 0;
-#endif
-
-	__pthread_self()->canary = __stack_chk_guard;
-}
-
-void __stack_chk_fail(void)
-{
-	a_crash();
-}
-
-hidden void __stack_chk_fail_local(void);
-
-weak_alias(__stack_chk_fail, __stack_chk_fail_local);
diff --git a/src/exit/_Exit.c b/src/exit/_Exit.c
index 7a6115c7bbc7..b646b8ba14d7 100644
--- a/src/exit/_Exit.c
+++ b/src/exit/_Exit.c
@@ -1,8 +1,8 @@
 #include <stdlib.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 _Noreturn void _Exit(int ec)
 {
-	__syscall(SYS_exit_group, ec);
-	for (;;) __syscall(SYS_exit, ec);
+	zsys_exit_hard(ec);
 }
diff --git a/src/exit/abort.c b/src/exit/abort.c
index f21f458eca14..e3780093a6dd 100644
--- a/src/exit/abort.c
+++ b/src/exit/abort.c
@@ -8,7 +8,9 @@
 
 _Noreturn void abort(void)
 {
-	raise(SIGABRT);
+    //raise(SIGABRT);
+        
+        zerror("abort() called");
 
 	/* If there was a SIGABRT handler installed and it returned, or if
 	 * SIGABRT was blocked or ignored, take an AS-safe lock to prevent
diff --git a/src/exit/atexit.c b/src/exit/atexit.c
index 854e9fddbe55..49a57c01802e 100644
--- a/src/exit/atexit.c
+++ b/src/exit/atexit.c
@@ -70,10 +70,10 @@ int __cxa_atexit(void (*func)(void *), void *arg, void *dso)
 
 static void call(void *p)
 {
-	((void (*)(void))(uintptr_t)p)();
+	((void (*)(void))p)();
 }
 
 int atexit(void (*func)(void))
 {
-	return __cxa_atexit(call, (void *)(uintptr_t)func, 0);
+	return __cxa_atexit(call, (void *)func, 0);
 }
diff --git a/src/exit/exit.c b/src/exit/exit.c
index a6869b37594e..74dee6b4129d 100644
--- a/src/exit/exit.c
+++ b/src/exit/exit.c
@@ -12,13 +12,8 @@ weak_alias(dummy, __funcs_on_exit);
 weak_alias(dummy, __stdio_exit);
 weak_alias(dummy, _fini);
 
-extern weak hidden void (*const __fini_array_start)(void), (*const __fini_array_end)(void);
-
 static void libc_exit_fini(void)
 {
-	uintptr_t a = (uintptr_t)&__fini_array_end;
-	for (; a>(uintptr_t)&__fini_array_start; a-=sizeof(void(*)()))
-		(*(void (**)())(a-sizeof(void(*)())))();
 	_fini();
 }
 
@@ -29,5 +24,5 @@ _Noreturn void exit(int code)
 	__funcs_on_exit();
 	__libc_exit_fini();
 	__stdio_exit();
-	_Exit(code);
+	zsys_exit_soft(code);
 }
diff --git a/src/fcntl/fcntl.c b/src/fcntl/fcntl.c
index d3bff5c48680..4816c2ee29b3 100644
--- a/src/fcntl/fcntl.c
+++ b/src/fcntl/fcntl.c
@@ -4,45 +4,7 @@
 #include <errno.h>
 #include "syscall.h"
 
-int fcntl(int fd, int cmd, ...)
+__attribute__((__noinline__)) int fcntl(int fd, int cmd, ...)
 {
-	unsigned long arg;
-	va_list ap;
-	va_start(ap, cmd);
-	arg = va_arg(ap, unsigned long);
-	va_end(ap);
-	if (cmd == F_SETFL) arg |= O_LARGEFILE;
-	if (cmd == F_SETLKW) return syscall_cp(SYS_fcntl, fd, cmd, (void *)arg);
-	if (cmd == F_GETOWN) {
-		struct f_owner_ex ex;
-		int ret = __syscall(SYS_fcntl, fd, F_GETOWN_EX, &ex);
-		if (ret == -EINVAL) return __syscall(SYS_fcntl, fd, cmd, (void *)arg);
-		if (ret) return __syscall_ret(ret);
-		return ex.type == F_OWNER_PGRP ? -ex.pid : ex.pid;
-	}
-	if (cmd == F_DUPFD_CLOEXEC) {
-		int ret = __syscall(SYS_fcntl, fd, F_DUPFD_CLOEXEC, arg);
-		if (ret != -EINVAL) {
-			if (ret >= 0)
-				__syscall(SYS_fcntl, ret, F_SETFD, FD_CLOEXEC);
-			return __syscall_ret(ret);
-		}
-		ret = __syscall(SYS_fcntl, fd, F_DUPFD_CLOEXEC, 0);
-		if (ret != -EINVAL) {
-			if (ret >= 0) __syscall(SYS_close, ret);
-			return __syscall_ret(-EINVAL);
-		}
-		ret = __syscall(SYS_fcntl, fd, F_DUPFD, arg);
-		if (ret >= 0) __syscall(SYS_fcntl, ret, F_SETFD, FD_CLOEXEC);
-		return __syscall_ret(ret);
-	}
-	switch (cmd) {
-	case F_SETLK:
-	case F_GETLK:
-	case F_GETOWN_EX:
-	case F_SETOWN_EX:
-		return syscall(SYS_fcntl, fd, cmd, (void *)arg);
-	default:
-		return syscall(SYS_fcntl, fd, cmd, arg);
-	}
+	return *(int*)zcall(zsys_fcntl, zargs());
 }
diff --git a/src/fcntl/open.c b/src/fcntl/open.c
index 4c3c82759c1b..33a76560e942 100644
--- a/src/fcntl/open.c
+++ b/src/fcntl/open.c
@@ -1,6 +1,7 @@
 #include <fcntl.h>
 #include <stdarg.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int open(const char *filename, int flags, ...)
 {
@@ -13,9 +14,9 @@ int open(const char *filename, int flags, ...)
 		va_end(ap);
 	}
 
-	int fd = __sys_open_cp(filename, flags, mode);
+	int fd = zsys_open(filename, flags, mode);
 	if (fd>=0 && (flags & O_CLOEXEC))
-		__syscall(SYS_fcntl, fd, F_SETFD, FD_CLOEXEC);
+		zsys_fcntl(fd, F_SETFD, FD_CLOEXEC);
 
-	return __syscall_ret(fd);
+	return fd;
 }
diff --git a/src/fcntl/openat.c b/src/fcntl/openat.c
index 83a9e0d008c4..f0a5cc7cc8b5 100644
--- a/src/fcntl/openat.c
+++ b/src/fcntl/openat.c
@@ -12,6 +12,6 @@ int openat(int fd, const char *filename, int flags, ...)
 		mode = va_arg(ap, mode_t);
 		va_end(ap);
 	}
-
-	return syscall_cp(SYS_openat, fd, filename, flags|O_LARGEFILE, mode);
+	
+	return zsys_openat(fd, filename, flags, mode);
 }
diff --git a/src/fcntl/posix_fadvise.c b/src/fcntl/posix_fadvise.c
index 07346d21ae2f..6c8f5b705d9a 100644
--- a/src/fcntl/posix_fadvise.c
+++ b/src/fcntl/posix_fadvise.c
@@ -3,14 +3,5 @@
 
 int posix_fadvise(int fd, off_t base, off_t len, int advice)
 {
-#if defined(SYSCALL_FADVISE_6_ARG)
-	/* Some archs, at least arm and powerpc, have the syscall
-	 * arguments reordered to avoid needing 7 argument registers
-	 * due to 64-bit argument alignment. */
-	return -__syscall(SYS_fadvise, fd, advice,
-		__SYSCALL_LL_E(base), __SYSCALL_LL_E(len));
-#else
-	return -__syscall(SYS_fadvise, fd, __SYSCALL_LL_O(base),
-		__SYSCALL_LL_E(len), advice);
-#endif
+	return zsys_posix_fadvise(fd, base, len, advice);
 }
diff --git a/src/fcntl/posix_fallocate.c b/src/fcntl/posix_fallocate.c
index 80a65cbfd62e..10913ccdc5f6 100644
--- a/src/fcntl/posix_fallocate.c
+++ b/src/fcntl/posix_fallocate.c
@@ -3,6 +3,5 @@
 
 int posix_fallocate(int fd, off_t base, off_t len)
 {
-	return -__syscall(SYS_fallocate, fd, 0, __SYSCALL_LL_E(base),
-		__SYSCALL_LL_E(len));
+	return zsys_posix_fallocate(fd, base, len);
 }
diff --git a/src/fenv/aarch64/fenv.s b/src/fenv/aarch64/fenv.s
deleted file mode 100644
index 8f3ec9653caa..000000000000
--- a/src/fenv/aarch64/fenv.s
+++ /dev/null
@@ -1,68 +0,0 @@
-.global fegetround
-.type fegetround,%function
-fegetround:
-	mrs x0, fpcr
-	and w0, w0, #0xc00000
-	ret
-
-.global __fesetround
-.hidden __fesetround
-.type __fesetround,%function
-__fesetround:
-	mrs x1, fpcr
-	bic w1, w1, #0xc00000
-	orr w1, w1, w0
-	msr fpcr, x1
-	mov w0, #0
-	ret
-
-.global fetestexcept
-.type fetestexcept,%function
-fetestexcept:
-	and w0, w0, #0x1f
-	mrs x1, fpsr
-	and w0, w0, w1
-	ret
-
-.global feclearexcept
-.type feclearexcept,%function
-feclearexcept:
-	and w0, w0, #0x1f
-	mrs x1, fpsr
-	bic w1, w1, w0
-	msr fpsr, x1
-	mov w0, #0
-	ret
-
-.global feraiseexcept
-.type feraiseexcept,%function
-feraiseexcept:
-	and w0, w0, #0x1f
-	mrs x1, fpsr
-	orr w1, w1, w0
-	msr fpsr, x1
-	mov w0, #0
-	ret
-
-.global fegetenv
-.type fegetenv,%function
-fegetenv:
-	mrs x1, fpcr
-	mrs x2, fpsr
-	stp w1, w2, [x0]
-	mov w0, #0
-	ret
-
-// TODO preserve some bits
-.global fesetenv
-.type fesetenv,%function
-fesetenv:
-	mov x1, #0
-	mov x2, #0
-	cmn x0, #1
-	b.eq 1f
-	ldp w1, w2, [x0]
-1:	msr fpcr, x1
-	msr fpsr, x2
-	mov w0, #0
-	ret
diff --git a/src/fenv/arm/fenv-hf.S b/src/fenv/arm/fenv-hf.S
deleted file mode 100644
index 2a1de0d1682a..000000000000
--- a/src/fenv/arm/fenv-hf.S
+++ /dev/null
@@ -1,70 +0,0 @@
-#if __ARM_PCS_VFP
-
-.syntax unified
-.fpu vfp
-
-.global fegetround
-.type fegetround,%function
-fegetround:
-	fmrx r0, fpscr
-	and r0, r0, #0xc00000
-	bx lr
-
-.global __fesetround
-.hidden __fesetround
-.type __fesetround,%function
-__fesetround:
-	fmrx r3, fpscr
-	bic r3, r3, #0xc00000
-	orr r3, r3, r0
-	fmxr fpscr, r3
-	mov r0, #0
-	bx lr
-
-.global fetestexcept
-.type fetestexcept,%function
-fetestexcept:
-	and r0, r0, #0x1f
-	fmrx r3, fpscr
-	and r0, r0, r3
-	bx lr
-
-.global feclearexcept
-.type feclearexcept,%function
-feclearexcept:
-	and r0, r0, #0x1f
-	fmrx r3, fpscr
-	bic r3, r3, r0
-	fmxr fpscr, r3
-	mov r0, #0
-	bx lr
-
-.global feraiseexcept
-.type feraiseexcept,%function
-feraiseexcept:
-	and r0, r0, #0x1f
-	fmrx r3, fpscr
-	orr r3, r3, r0
-	fmxr fpscr, r3
-	mov r0, #0
-	bx lr
-
-.global fegetenv
-.type fegetenv,%function
-fegetenv:
-	fmrx r3, fpscr
-	str r3, [r0]
-	mov r0, #0
-	bx lr
-
-.global fesetenv
-.type fesetenv,%function
-fesetenv:
-	cmn r0, #1
-	moveq r3, #0
-	ldrne r3, [r0]
-	fmxr fpscr, r3
-	mov r0, #0
-	bx lr
-
-#endif
diff --git a/src/fenv/arm/fenv.c b/src/fenv/arm/fenv.c
deleted file mode 100644
index ad295f58cc52..000000000000
--- a/src/fenv/arm/fenv.c
+++ /dev/null
@@ -1,3 +0,0 @@
-#if !__ARM_PCS_VFP
-#include "../fenv.c"
-#endif
diff --git a/src/fenv/i386/fenv.s b/src/fenv/i386/fenv.s
deleted file mode 100644
index e7f7932a1cd5..000000000000
--- a/src/fenv/i386/fenv.s
+++ /dev/null
@@ -1,164 +0,0 @@
-.hidden __hwcap
-
-.global feclearexcept
-.type feclearexcept,@function
-feclearexcept:	
-	mov 4(%esp),%ecx
-	and $0x3f,%ecx
-	fnstsw %ax
-		# consider sse fenv as well if the cpu has XMM capability
-	call 1f
-1:	addl $__hwcap-1b,(%esp)
-	pop %edx
-	testl $0x02000000,(%edx)
-	jz 2f
-		# maintain exceptions in the sse mxcsr, clear x87 exceptions
-	test %eax,%ecx
-	jz 1f
-	fnclex
-1:	push %edx
-	stmxcsr (%esp)
-	pop %edx
-	and $0x3f,%eax
-	or %eax,%edx
-	test %edx,%ecx
-	jz 1f
-	not %ecx
-	and %ecx,%edx
-	push %edx
-	ldmxcsr (%esp)
-	pop %edx
-1:	xor %eax,%eax
-	ret
-		# only do the expensive x87 fenv load/store when needed
-2:	test %eax,%ecx
-	jz 1b
-	not %ecx
-	and %ecx,%eax
-	test $0x3f,%eax
-	jz 1f
-	fnclex
-	jmp 1b
-1:	sub $32,%esp
-	fnstenv (%esp)
-	mov %al,4(%esp)
-	fldenv (%esp)
-	add $32,%esp
-	xor %eax,%eax
-	ret
-
-.global feraiseexcept
-.type feraiseexcept,@function
-feraiseexcept:	
-	mov 4(%esp),%eax
-	and $0x3f,%eax
-	sub $32,%esp
-	fnstenv (%esp)
-	or %al,4(%esp)
-	fldenv (%esp)
-	add $32,%esp
-	xor %eax,%eax
-	ret
-
-.global __fesetround
-.hidden __fesetround
-.type __fesetround,@function
-__fesetround:
-	mov 4(%esp),%ecx
-	push %eax
-	xor %eax,%eax
-	fnstcw (%esp)
-	andb $0xf3,1(%esp)
-	or %ch,1(%esp)
-	fldcw (%esp)
-		# consider sse fenv as well if the cpu has XMM capability
-	call 1f
-1:	addl $__hwcap-1b,(%esp)
-	pop %edx
-	testl $0x02000000,(%edx)
-	jz 1f
-	stmxcsr (%esp)
-	shl $3,%ch
-	andb $0x9f,1(%esp)
-	or %ch,1(%esp)
-	ldmxcsr (%esp)
-1:	pop %ecx
-	ret
-
-.global fegetround
-.type fegetround,@function
-fegetround:
-	push %eax
-	fnstcw (%esp)
-	pop %eax
-	and $0xc00,%eax
-	ret
-
-.global fegetenv
-.type fegetenv,@function
-fegetenv:
-	mov 4(%esp),%ecx
-	xor %eax,%eax
-	fnstenv (%ecx)
-		# consider sse fenv as well if the cpu has XMM capability
-	call 1f
-1:	addl $__hwcap-1b,(%esp)
-	pop %edx
-	testl $0x02000000,(%edx)
-	jz 1f
-	push %eax
-	stmxcsr (%esp)
-	pop %edx
-	and $0x3f,%edx
-	or %edx,4(%ecx)
-1:	ret
-
-.global fesetenv
-.type fesetenv,@function
-fesetenv:
-	mov 4(%esp),%ecx
-	xor %eax,%eax
-	inc %ecx
-	jz 1f
-	fldenv -1(%ecx)
-	movl -1(%ecx),%ecx
-	jmp 2f
-1:	push %eax
-	push %eax
-	push %eax
-	push %eax
-	pushl $0xffff
-	push %eax
-	pushl $0x37f
-	fldenv (%esp)
-	add $28,%esp
-		# consider sse fenv as well if the cpu has XMM capability
-2:	call 1f
-1:	addl $__hwcap-1b,(%esp)
-	pop %edx
-	testl $0x02000000,(%edx)
-	jz 1f
-		# mxcsr := same rounding mode, cleared exceptions, default mask
-	and $0xc00,%ecx
-	shl $3,%ecx
-	or $0x1f80,%ecx
-	mov %ecx,4(%esp)
-	ldmxcsr 4(%esp)
-1:	ret
-
-.global fetestexcept
-.type fetestexcept,@function
-fetestexcept:
-	mov 4(%esp),%ecx
-	and $0x3f,%ecx
-	fnstsw %ax
-		# consider sse fenv as well if the cpu has XMM capability
-	call 1f
-1:	addl $__hwcap-1b,(%esp)
-	pop %edx
-	testl $0x02000000,(%edx)
-	jz 1f
-	stmxcsr 4(%esp)
-	or 4(%esp),%eax
-1:	and %ecx,%eax
-	ret
diff --git a/src/fenv/m68k/fenv.c b/src/fenv/m68k/fenv.c
deleted file mode 100644
index d0658e678477..000000000000
--- a/src/fenv/m68k/fenv.c
+++ /dev/null
@@ -1,85 +0,0 @@
-#include <fenv.h>
-#include <features.h>
-
-#if __HAVE_68881__ || __mcffpu__
-
-static unsigned getsr()
-{
-	unsigned v;
-	__asm__ __volatile__ ("fmove.l %%fpsr,%0" : "=dm"(v));
-	return v;
-}
-
-static void setsr(unsigned v)
-{
-	__asm__ __volatile__ ("fmove.l %0,%%fpsr" : : "dm"(v));
-}
-
-static unsigned getcr()
-{
-	unsigned v;
-	__asm__ __volatile__ ("fmove.l %%fpcr,%0" : "=dm"(v));
-	return v;
-}
-
-static void setcr(unsigned v)
-{
-	__asm__ __volatile__ ("fmove.l %0,%%fpcr" : : "dm"(v));
-}
-
-int feclearexcept(int mask)
-{
-	if (mask & ~FE_ALL_EXCEPT) return -1;
-	setsr(getsr() & ~mask);
-	return 0;
-}
-
-int feraiseexcept(int mask)
-{
-	if (mask & ~FE_ALL_EXCEPT) return -1;
-	setsr(getsr() | mask);
-	return 0;
-}
-
-int fetestexcept(int mask)
-{
-	return getsr() & mask;
-}
-
-int fegetround(void)
-{
-	return getcr() & FE_UPWARD;
-}
-
-hidden int __fesetround(int r)
-{
-	setcr((getcr() & ~FE_UPWARD) | r);
-	return 0;
-}
-
-int fegetenv(fenv_t *envp)
-{
-	envp->__control_register = getcr();
-	envp->__status_register = getsr();
-	__asm__ __volatile__ ("fmove.l %%fpiar,%0"
-		: "=dm"(envp->__instruction_address));
-	return 0;
-}
-
-int fesetenv(const fenv_t *envp)
-{
-	static const fenv_t default_env = { 0 };
-	if (envp == FE_DFL_ENV)
-		envp = &default_env;
-	setcr(envp->__control_register);
-	setsr(envp->__status_register);
-	__asm__ __volatile__ ("fmove.l %0,%%fpiar"
-		: : "dm"(envp->__instruction_address));
-	return 0;
-}
-
-#else
-
-#include "../fenv.c"
-
-#endif
diff --git a/src/fenv/mips/fenv-sf.c b/src/fenv/mips/fenv-sf.c
deleted file mode 100644
index 4aa3dbf12729..000000000000
--- a/src/fenv/mips/fenv-sf.c
+++ /dev/null
@@ -1,3 +0,0 @@
-#ifdef __mips_soft_float
-#include "../fenv.c"
-#endif
diff --git a/src/fenv/mips/fenv.S b/src/fenv/mips/fenv.S
deleted file mode 100644
index ffa92971c047..000000000000
--- a/src/fenv/mips/fenv.S
+++ /dev/null
@@ -1,72 +0,0 @@
-#ifndef __mips_soft_float
-
-.set noreorder
-
-.global feclearexcept
-.type  feclearexcept,@function
-feclearexcept:
-	and     $4, $4, 0x7c
-	cfc1    $5, $31
-	or      $5, $5, $4
-	xor     $5, $5, $4
-	ctc1    $5, $31
-	jr      $ra
-	li      $2, 0
-
-.global feraiseexcept
-.type  feraiseexcept,@function
-feraiseexcept:
-	and     $4, $4, 0x7c
-	cfc1    $5, $31
-	or      $5, $5, $4
-	ctc1    $5, $31
-	jr      $ra
-	li      $2, 0
-
-.global fetestexcept
-.type  fetestexcept,@function
-fetestexcept:
-	and     $4, $4, 0x7c
-	cfc1    $2, $31
-	jr      $ra
-	and     $2, $2, $4
-
-.global fegetround
-.type  fegetround,@function
-fegetround:
-	cfc1    $2, $31
-	jr      $ra
-	andi    $2, $2, 3
-
-.global __fesetround
-.hidden __fesetround
-.type __fesetround,@function
-__fesetround:
-	cfc1    $5, $31
-	li      $6, -4
-	and     $5, $5, $6
-	or      $5, $5, $4
-	ctc1    $5, $31
-	jr      $ra
-	li      $2, 0
-
-.global fegetenv
-.type  fegetenv,@function
-fegetenv:
-	cfc1    $5, $31
-	sw      $5, 0($4)
-	jr      $ra
-	li      $2, 0
-
-.global fesetenv
-.type  fesetenv,@function
-fesetenv:
-	addiu   $5, $4, 1
-	beq     $5, $0, 1f
-	 nop
-	lw      $5, 0($4)
-1:	ctc1    $5, $31
-	jr      $ra
-	li      $2, 0
-
-#endif
diff --git a/src/fenv/mips64/fenv-sf.c b/src/fenv/mips64/fenv-sf.c
deleted file mode 100644
index 4aa3dbf12729..000000000000
--- a/src/fenv/mips64/fenv-sf.c
+++ /dev/null
@@ -1,3 +0,0 @@
-#ifdef __mips_soft_float
-#include "../fenv.c"
-#endif
diff --git a/src/fenv/mips64/fenv.S b/src/fenv/mips64/fenv.S
deleted file mode 100644
index d5e0a6201c25..000000000000
--- a/src/fenv/mips64/fenv.S
+++ /dev/null
@@ -1,72 +0,0 @@
-#ifndef __mips_soft_float
-
-.set	noreorder
-
-.global	feclearexcept
-.type	feclearexcept,@function
-feclearexcept:
-	and	$4, $4, 0x7c
-	cfc1	$5, $31
-	or	$5, $5, $4
-	xor	$5, $5, $4
-	ctc1	$5, $31
-	jr	$ra
-	li	$2, 0
-
-.global	feraiseexcept
-.type	feraiseexcept,@function
-feraiseexcept:
-	and	$4, $4, 0x7c
-	cfc1	$5, $31
-	or	$5, $5, $4
-	ctc1	$5, $31
-	jr	$ra
-	li	$2, 0
-
-.global	fetestexcept
-.type	fetestexcept,@function
-fetestexcept:
-	and	$4, $4, 0x7c
-	cfc1	$2, $31
-	jr	$ra
-	and	$2, $2, $4
-
-.global	fegetround
-.type	fegetround,@function
-fegetround:
-	cfc1	$2, $31
-	jr	$ra
-	andi	$2, $2, 3
-
-.global	__fesetround
-.hidden __fesetround
-.type	__fesetround,@function
-__fesetround:
-	cfc1	$5, $31
-	li	$6, -4
-	and	$5, $5, $6
-	or	$5, $5, $4
-	ctc1	$5, $31
-	jr	$ra
-	li	$2, 0
-
-.global	fegetenv
-.type	fegetenv,@function
-fegetenv:
-	cfc1	$5, $31
-	sw	$5, 0($4)
-	jr	$ra
-	li	$2, 0
-
-.global	fesetenv
-.type	fesetenv,@function
-fesetenv:
-	daddiu	$5, $4, 1
-	beq	$5, $0, 1f
-	nop
-	lw	$5, 0($4)
-1:	ctc1	$5, $31
-	jr	$ra
-	li	$2, 0
-
-#endif
diff --git a/src/fenv/mipsn32/fenv-sf.c b/src/fenv/mipsn32/fenv-sf.c
deleted file mode 100644
index 4aa3dbf12729..000000000000
--- a/src/fenv/mipsn32/fenv-sf.c
+++ /dev/null
@@ -1,3 +0,0 @@
-#ifdef __mips_soft_float
-#include "../fenv.c"
-#endif
diff --git a/src/fenv/mipsn32/fenv.S b/src/fenv/mipsn32/fenv.S
deleted file mode 100644
index 563d32207362..000000000000
--- a/src/fenv/mipsn32/fenv.S
+++ /dev/null
@@ -1,71 +0,0 @@
-#ifndef __mips_soft_float
-
-.set	noreorder
-.global	feclearexcept
-.type	feclearexcept,@function
-feclearexcept:
-	and	$4, $4, 0x7c
-	cfc1	$5, $31
-	or	$5, $5, $4
-	xor	$5, $5, $4
-	ctc1	$5, $31
-	jr	$ra
-	li	$2, 0
-
-.global feraiseexcept
-.type  feraiseexcept,@function
-feraiseexcept:
-	and	$4, $4, 0x7c
-	cfc1	$5, $31
-	or	$5, $5, $4
-	ctc1	$5, $31
-	jr	$ra
-	li	$2, 0
-
-.global fetestexcept
-.type  fetestexcept,@function
-fetestexcept:
-	and	$4, $4, 0x7c
-	cfc1	$2, $31
-	jr	$ra
-	and	$2, $2, $4
-
-.global fegetround
-.type  fegetround,@function
-fegetround:
-	cfc1	$2, $31
-	jr	$ra
-	andi	$2, $2, 3
-
-.global __fesetround
-.hidden __fesetround
-.type __fesetround,@function
-__fesetround:
-	cfc1	$5, $31
-	li	$6, -4
-	and	$5, $5, $6
-	or	$5, $5, $4
-	ctc1	$5, $31
-	jr	$ra
-	li	$2, 0
-
-.global fegetenv
-.type  fegetenv,@function
-fegetenv:
-	cfc1	$5, $31
-	sw	$5, 0($4)
-	jr	$ra
-	li	$2, 0
-
-.global fesetenv
-.type  fesetenv,@function
-fesetenv:
-	addiu   $5, $4, 1
-	beq	$5, $0, 1f
-	nop
-	lw	$5, 0($4)
-1:	ctc1	$5, $31
-	jr	$ra
-	li	$2, 0
-
-#endif
diff --git a/src/fenv/powerpc/fenv-sf.c b/src/fenv/powerpc/fenv-sf.c
deleted file mode 100644
index d4248f26f718..000000000000
--- a/src/fenv/powerpc/fenv-sf.c
+++ /dev/null
@@ -1,3 +0,0 @@
-#if defined(_SOFT_FLOAT) || defined(__NO_FPRS__)
-#include "../fenv.c"
-#endif
diff --git a/src/fenv/powerpc/fenv.S b/src/fenv/powerpc/fenv.S
deleted file mode 100644
index 55055d0b3a87..000000000000
--- a/src/fenv/powerpc/fenv.S
+++ /dev/null
@@ -1,130 +0,0 @@
-#if !defined(_SOFT_FLOAT) && !defined(__NO_FPRS__)
-.global feclearexcept
-.type feclearexcept,@function
-feclearexcept:
-	andis. 3,3,0x3e00
-	/* if (r3 & FE_INVALID) r3 |= all_invalid_flags */
-	andis. 0,3,0x2000
-	stwu 1,-16(1)
-	beq- 0,1f
-	oris 3,3,0x01f8
-	ori  3,3,0x0700
-1:
-	/*
-	 * note: fpscr contains various fpu status and control
-	 * flags and we dont check if r3 may alter other flags
-	 * than the exception related ones
-	 * ufpscr &= ~r3
-	 */
-	mffs 0
-	stfd 0,8(1)
-	lwz 9,12(1)
-	andc 9,9,3
-	stw 9,12(1)
-	lfd 0,8(1)
-	mtfsf 255,0
-
-	/* return 0 */
-	li 3,0
-	addi 1,1,16
-	blr
-
-.global feraiseexcept
-.type feraiseexcept,@function
-feraiseexcept:
-	andis. 3,3,0x3e00
-	/* if (r3 & FE_INVALID) r3 |= software_invalid_flag */
-	andis. 0,3,0x2000
-	stwu 1,-16(1)
-	beq- 0,1f
-	ori 3,3,0x0400
-1:
-	/* fpscr |= r3 */
-	mffs 0
-	stfd 0,8(1)
-	lwz 9,12(1)
-	or 9,9,3
-	stw 9,12(1)
-	lfd 0,8(1)
-	mtfsf 255,0
-
-	/* return 0 */
-	li 3,0
-	addi 1,1,16
-	blr
-
-.global fetestexcept
-.type fetestexcept,@function
-fetestexcept:
-	andis. 3,3,0x3e00
-	/* return r3 & fpscr */
-	stwu 1,-16(1)
-	mffs 0
-	stfd 0,8(1)
-	lwz 9,12(1)
-	addi 1,1,16
-	and 3,3,9
-	blr
-
-.global fegetround
-.type fegetround,@function
-fegetround:
-	/* return fpscr & 3 */
-	stwu 1,-16(1)
-	mffs 0
-	stfd 0,8(1)
-	lwz 3,12(1)
-	addi 1,1,16
-	clrlwi 3,3,30
-	blr
-
-.global __fesetround
-.hidden __fesetround
-.type __fesetround,@function
-__fesetround:
-	/*
-	 * note: invalid input is not checked, r3 < 4 must hold
-	 * fpscr = (fpscr & -4U) | r3
-	 */
-	stwu 1,-16(1)
-	mffs 0
-	stfd 0,8(1)
-	lwz 9,12(1)
-	clrrwi 9,9,2
-	or 9,9,3
-	stw 9,12(1)
-	lfd 0,8(1)
-	mtfsf 255,0
-
-	/* return 0 */
-	li 3,0
-	addi 1,1,16
-	blr
-
-.global fegetenv
-.type fegetenv,@function
-fegetenv:
-	/* *r3 = fpscr */
-	mffs 0
-	stfd 0,0(3)
-	/* return 0 */
-	li 3,0
-	blr
-
-.global fesetenv
-.type fesetenv,@function
-fesetenv:
-	cmpwi 3, -1
-	bne 1f
-	mflr 4
-	bl 2f
-	.zero 8
-2:	mflr 3
-	mtlr 4
-1:	/* fpscr = *r3 */
-	lfd 0,0(3)
-	mtfsf 255,0
-	/* return 0 */
-	li 3,0
-	blr
-#endif
diff --git a/src/fenv/powerpc64/fenv.c b/src/fenv/powerpc64/fenv.c
deleted file mode 100644
index 90dabdc8c9ba..000000000000
--- a/src/fenv/powerpc64/fenv.c
+++ /dev/null
@@ -1,69 +0,0 @@
-#define _GNU_SOURCE
-#include <fenv.h>
-#include <features.h>
-
-static inline double get_fpscr_f(void)
-{
-	double d;
-	__asm__ __volatile__("mffs %0" : "=d"(d));
-	return d;
-}
-
-static inline long get_fpscr(void)
-{
-	return (union {double f; long i;}) {get_fpscr_f()}.i;
-}
-
-static inline void set_fpscr_f(double fpscr)
-{
-	__asm__ __volatile__("mtfsf 255, %0" : : "d"(fpscr));
-}
-
-static void set_fpscr(long fpscr)
-{
-	set_fpscr_f((union {long i; double f;}) {fpscr}.f);
-}
-
-int feclearexcept(int mask)
-{
-	mask &= FE_ALL_EXCEPT;
-	if (mask & FE_INVALID) mask |= FE_ALL_INVALID;
-	set_fpscr(get_fpscr() & ~mask);
-	return 0;
-}
-
-int feraiseexcept(int mask)
-{
-	mask &= FE_ALL_EXCEPT;
-	if (mask & FE_INVALID) mask |= FE_INVALID_SOFTWARE;
-	set_fpscr(get_fpscr() | mask);
-	return 0;
-}
-
-int fetestexcept(int mask)
-{
-	return get_fpscr() & mask & FE_ALL_EXCEPT;
-}
-
-int fegetround(void)
-{
-	return get_fpscr() & 3;
-}
-
-hidden int __fesetround(int r)
-{
-	set_fpscr(get_fpscr() & ~3L | r);
-	return 0;
-}
-
-int fegetenv(fenv_t *envp)
-{
-	*envp = get_fpscr_f();
-	return 0;
-}
-
-int fesetenv(const fenv_t *envp)
-{
-	set_fpscr_f(envp != FE_DFL_ENV ? *envp : 0);
-	return 0;
-}
diff --git a/src/fenv/riscv64/fenv-sf.c b/src/fenv/riscv64/fenv-sf.c
deleted file mode 100644
index ecd3cb5cad59..000000000000
--- a/src/fenv/riscv64/fenv-sf.c
+++ /dev/null
@@ -1,3 +0,0 @@
-#ifndef __riscv_flen
-#include "../fenv.c"
-#endif
diff --git a/src/fenv/riscv64/fenv.S b/src/fenv/riscv64/fenv.S
deleted file mode 100644
index 0ea78bf9ac8d..000000000000
--- a/src/fenv/riscv64/fenv.S
+++ /dev/null
@@ -1,56 +0,0 @@
-#ifdef __riscv_flen
-
-.global feclearexcept
-.type feclearexcept, %function
-feclearexcept:
-	csrc fflags, a0
-	li a0, 0
-	ret
-
-.global feraiseexcept
-.type feraiseexcept, %function
-feraiseexcept:
-	csrs fflags, a0
-	li a0, 0
-	ret
-
-.global fetestexcept
-.type fetestexcept, %function
-fetestexcept:
-	frflags t0
-	and a0, t0, a0
-	ret
-
-.global fegetround
-.type fegetround, %function
-fegetround:
-	frrm a0
-	ret
-
-.global __fesetround
-.type __fesetround, %function
-__fesetround:
-	fsrm t0, a0
-	li a0, 0
-	ret
-
-.global fegetenv
-.type fegetenv, %function
-fegetenv:
-	frcsr t0
-	sw t0, 0(a0)
-	li a0, 0
-	ret
-
-.global fesetenv
-.type fesetenv, %function
-fesetenv:
-	li t2, -1
-	li t1, 0
-	beq a0, t2, 1f
-	lw t1, 0(a0)
-1:	fscsr t1
-	li a0, 0
-	ret
-
-#endif
diff --git a/src/fenv/s390x/fenv.c b/src/fenv/s390x/fenv.c
deleted file mode 100644
index fd4e60c5eb31..000000000000
--- a/src/fenv/s390x/fenv.c
+++ /dev/null
@@ -1,56 +0,0 @@
-#include <fenv.h>
-#include <features.h>
-
-static inline unsigned get_fpc(void)
-{
-	unsigned fpc;
-	__asm__ __volatile__("efpc %0" : "=r"(fpc));
-	return fpc;
-}
-
-static inline void set_fpc(unsigned fpc)
-{
-	__asm__ __volatile__("sfpc %0" :: "r"(fpc));
-}
-
-int feclearexcept(int mask)
-{
-	mask &= FE_ALL_EXCEPT;
-	set_fpc(get_fpc() & ~mask);
-	return 0;
-}
-
-int feraiseexcept(int mask)
-{
-	mask &= FE_ALL_EXCEPT;
-	set_fpc(get_fpc() | mask);
-	return 0;
-}
-
-int fetestexcept(int mask)
-{
-	return get_fpc() & mask & FE_ALL_EXCEPT;
-}
-
-int fegetround(void)
-{
-	return get_fpc() & 3;
-}
-
-hidden int __fesetround(int r)
-{
-	set_fpc(get_fpc() & ~3L | r);
-	return 0;
-}
-
-int fegetenv(fenv_t *envp)
-{
-	*envp = get_fpc();
-	return 0;
-}
-
-int fesetenv(const fenv_t *envp)
-{
-	set_fpc(envp != FE_DFL_ENV ? *envp : 0);
-	return 0;
-}
diff --git a/src/fenv/sh/fenv-nofpu.c b/src/fenv/sh/fenv-nofpu.c
deleted file mode 100644
index b2495a658346..000000000000
--- a/src/fenv/sh/fenv-nofpu.c
+++ /dev/null
@@ -1,3 +0,0 @@
-#if !__SH_FPU_ANY__ && !__SH4__
-#include "../fenv.c"
-#endif
diff --git a/src/fenv/sh/fenv.S b/src/fenv/sh/fenv.S
deleted file mode 100644
index b3b7d66adacd..000000000000
--- a/src/fenv/sh/fenv.S
+++ /dev/null
@@ -1,81 +0,0 @@
-#if __SH_FPU_ANY__ || __SH4__
-
-.global fegetround
-.type   fegetround, @function
-fegetround:
-	sts fpscr, r0
-	rts
-	 and #3, r0
-
-.global __fesetround
-.hidden __fesetround
-.type   __fesetround, @function
-__fesetround:
-	sts fpscr, r0
-	mov #-4, r1
-	and r1, r0
-	or  r4, r0
-	lds r0, fpscr
-	rts
-	 mov #0, r0
-
-.global fetestexcept
-.type   fetestexcept, @function
-fetestexcept:
-	sts fpscr, r0
-	and r4, r0
-	rts
-	 and #0x7c, r0
-
-.global feclearexcept
-.type   feclearexcept, @function
-feclearexcept:
-	mov r4, r0
-	and #0x7c, r0
-	not r0, r4
-	sts fpscr, r0
-	and r4, r0
-	lds r0, fpscr
-	rts
-	 mov #0, r0
-
-.global feraiseexcept
-.type   feraiseexcept, @function
-feraiseexcept:
-	mov r4, r0
-	and #0x7c, r0
-	sts fpscr, r4
-	or  r4, r0
-	lds r0, fpscr
-	rts
-	 mov #0, r0
-
-.global fegetenv
-.type   fegetenv, @function
-fegetenv:
-	sts fpscr, r0
-	mov.l r0, @r4
-	rts
-	 mov #0, r0
-
-.global fesetenv
-.type   fesetenv, @function
-fesetenv:
-	mov r4, r0
-	cmp/eq #-1, r0
-	bf 1f
-
-	! the default environment is complicated by the fact that we need to
-	! preserve the current precision bit, which we do not know a priori
-	sts fpscr, r0
-	mov #8, r1
-	swap.w r1, r1
-	bra 2f
-	 and r1, r0
-
-1:	mov.l @r4, r0      ! non-default environment
-2:	lds r0, fpscr
-	rts
-	 mov #0, r0
-
-#endif
diff --git a/src/fenv/x32/fenv.s b/src/fenv/x32/fenv.s
deleted file mode 100644
index 835f23b61583..000000000000
--- a/src/fenv/x32/fenv.s
+++ /dev/null
@@ -1,98 +0,0 @@
-.global feclearexcept
-.type feclearexcept,@function
-feclearexcept:
-		# maintain exceptions in the sse mxcsr, clear x87 exceptions
-	mov %edi,%ecx
-	and $0x3f,%ecx
-	fnstsw %ax
-	test %eax,%ecx
-	jz 1f
-	fnclex
-1:	stmxcsr -8(%esp)
-	and $0x3f,%eax
-	or %eax,-8(%esp)
-	test %ecx,-8(%esp)
-	jz 1f
-	not %ecx
-	and %ecx,-8(%esp)
-	ldmxcsr -8(%esp)
-1:	xor %eax,%eax
-	ret
-
-.global feraiseexcept
-.type feraiseexcept,@function
-feraiseexcept:
-	and $0x3f,%edi
-	stmxcsr -8(%esp)
-	or %edi,-8(%esp)
-	ldmxcsr -8(%esp)
-	xor %eax,%eax
-	ret
-
-.global __fesetround
-.hidden __fesetround
-.type __fesetround,@function
-__fesetround:
-	push %rax
-	xor %eax,%eax
-	mov %edi,%ecx
-	fnstcw (%esp)
-	andb $0xf3,1(%esp)
-	or %ch,1(%esp)
-	fldcw (%esp)
-	stmxcsr (%esp)
-	shl $3,%ch
-	andb $0x9f,1(%esp)
-	or %ch,1(%esp)
-	ldmxcsr (%esp)
-	pop %rcx
-	ret
-
-.global fegetround
-.type fegetround,@function
-fegetround:
-	push %rax
-	stmxcsr (%esp)
-	pop %rax
-	shr $3,%eax
-	and $0xc00,%eax
-	ret
-
-.global fegetenv
-.type fegetenv,@function
-fegetenv:
-	xor %eax,%eax
-	fnstenv (%edi)
-	stmxcsr 28(%edi)
-	ret
-
-.global fesetenv
-.type fesetenv,@function
-fesetenv:
-	xor %eax,%eax
-	inc %edi
-	jz 1f
-	fldenv -1(%edi)
-	ldmxcsr 27(%edi)
-	ret
-1:	push %rax
-	push %rax
-	pushq $0xffff
-	pushq $0x37f
-	fldenv (%esp)
-	pushq $0x1f80
-	ldmxcsr (%esp)
-	add $40,%esp
-	ret
-
-.global fetestexcept
-.type fetestexcept,@function
-fetestexcept:
-	and $0x3f,%edi
-	push %rax
-	stmxcsr (%esp)
-	pop %rsi
-	fnstsw %ax
-	or %esi,%eax
-	and %edi,%eax
-	ret
diff --git a/src/fenv/x86_64/fenv.s b/src/fenv/x86_64/fenv.s
deleted file mode 100644
index 98d876da26e9..000000000000
--- a/src/fenv/x86_64/fenv.s
+++ /dev/null
@@ -1,98 +0,0 @@
-.global feclearexcept
-.type feclearexcept,@function
-feclearexcept:
-		# maintain exceptions in the sse mxcsr, clear x87 exceptions
-	mov %edi,%ecx
-	and $0x3f,%ecx
-	fnstsw %ax
-	test %eax,%ecx
-	jz 1f
-	fnclex
-1:	stmxcsr -8(%rsp)
-	and $0x3f,%eax
-	or %eax,-8(%rsp)
-	test %ecx,-8(%rsp)
-	jz 1f
-	not %ecx
-	and %ecx,-8(%rsp)
-	ldmxcsr -8(%rsp)
-1:	xor %eax,%eax
-	ret
-
-.global feraiseexcept
-.type feraiseexcept,@function
-feraiseexcept:
-	and $0x3f,%edi
-	stmxcsr -8(%rsp)
-	or %edi,-8(%rsp)
-	ldmxcsr -8(%rsp)
-	xor %eax,%eax
-	ret
-
-.global __fesetround
-.hidden __fesetround
-.type __fesetround,@function
-__fesetround:
-	push %rax
-	xor %eax,%eax
-	mov %edi,%ecx
-	fnstcw (%rsp)
-	andb $0xf3,1(%rsp)
-	or %ch,1(%rsp)
-	fldcw (%rsp)
-	stmxcsr (%rsp)
-	shl $3,%ch
-	andb $0x9f,1(%rsp)
-	or %ch,1(%rsp)
-	ldmxcsr (%rsp)
-	pop %rcx
-	ret
-
-.global fegetround
-.type fegetround,@function
-fegetround:
-	push %rax
-	stmxcsr (%rsp)
-	pop %rax
-	shr $3,%eax
-	and $0xc00,%eax
-	ret
-
-.global fegetenv
-.type fegetenv,@function
-fegetenv:
-	xor %eax,%eax
-	fnstenv (%rdi)
-	stmxcsr 28(%rdi)
-	ret
-
-.global fesetenv
-.type fesetenv,@function
-fesetenv:
-	xor %eax,%eax
-	inc %rdi
-	jz 1f
-	fldenv -1(%rdi)
-	ldmxcsr 27(%rdi)
-	ret
-1:	push %rax
-	push %rax
-	pushq $0xffff
-	pushq $0x37f
-	fldenv (%rsp)
-	pushq $0x1f80
-	ldmxcsr (%rsp)
-	add $40,%rsp
-	ret
-
-.global fetestexcept
-.type fetestexcept,@function
-fetestexcept:
-	and $0x3f,%edi
-	push %rax
-	stmxcsr (%rsp)
-	pop %rsi
-	fnstsw %ax
-	or %esi,%eax
-	and %edi,%eax
-	ret
diff --git a/src/internal/atomic.h b/src/internal/atomic.h
index 96c1552d6eda..b2e4355c2814 100644
--- a/src/internal/atomic.h
+++ b/src/internal/atomic.h
@@ -3,28 +3,20 @@
 
 #include <stdint.h>
 
+#include <stdfil.h>
 #include "atomic_arch.h"
 
-#ifdef a_ll
-
-#ifndef a_pre_llsc
-#define a_pre_llsc()
-#endif
-
-#ifndef a_post_llsc
-#define a_post_llsc()
+#ifndef a_barrier
+#define a_barrier a_barrier
+static inline void a_barrier(void) { zfence(); }
 #endif
 
 #ifndef a_cas
 #define a_cas a_cas
 static inline int a_cas(volatile int *p, int t, int s)
 {
-	int old;
-	a_pre_llsc();
-	do old = a_ll(p);
-	while (old==t && !a_sc(p, s));
-	a_post_llsc();
-	return old;
+    __c11_atomic_compare_exchange_strong((_Atomic int*)p, &t, s, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST);
+    return t;
 }
 #endif
 
@@ -32,12 +24,7 @@ static inline int a_cas(volatile int *p, int t, int s)
 #define a_swap a_swap
 static inline int a_swap(volatile int *p, int v)
 {
-	int old;
-	a_pre_llsc();
-	do old = a_ll(p);
-	while (!a_sc(p, v));
-	a_post_llsc();
-	return old;
+    return __c11_atomic_exchange((_Atomic int*)p, v, __ATOMIC_SEQ_CST);
 }
 #endif
 
@@ -45,12 +32,7 @@ static inline int a_swap(volatile int *p, int v)
 #define a_fetch_add a_fetch_add
 static inline int a_fetch_add(volatile int *p, int v)
 {
-	int old;
-	a_pre_llsc();
-	do old = a_ll(p);
-	while (!a_sc(p, (unsigned)old + v));
-	a_post_llsc();
-	return old;
+    return __c11_atomic_fetch_add((_Atomic int*)p, v, __ATOMIC_SEQ_CST);
 }
 #endif
 
@@ -58,12 +40,7 @@ static inline int a_fetch_add(volatile int *p, int v)
 #define a_fetch_and a_fetch_and
 static inline int a_fetch_and(volatile int *p, int v)
 {
-	int old;
-	a_pre_llsc();
-	do old = a_ll(p);
-	while (!a_sc(p, old & v));
-	a_post_llsc();
-	return old;
+    return __c11_atomic_fetch_and((_Atomic int*)p, v, __ATOMIC_SEQ_CST);
 }
 #endif
 
@@ -71,34 +48,10 @@ static inline int a_fetch_and(volatile int *p, int v)
 #define a_fetch_or a_fetch_or
 static inline int a_fetch_or(volatile int *p, int v)
 {
-	int old;
-	a_pre_llsc();
-	do old = a_ll(p);
-	while (!a_sc(p, old | v));
-	a_post_llsc();
-	return old;
-}
-#endif
-
-#endif
-
-#ifdef a_ll_p
-
-#ifndef a_cas_p
-#define a_cas_p a_cas_p
-static inline void *a_cas_p(volatile void *p, void *t, void *s)
-{
-	void *old;
-	a_pre_llsc();
-	do old = a_ll_p(p);
-	while (old==t && !a_sc_p(p, s));
-	a_post_llsc();
-	return old;
+    return __c11_atomic_fetch_or((_Atomic int*)p, v, __ATOMIC_SEQ_CST);
 }
 #endif
 
-#endif
-
 #ifndef a_cas
 #error missing definition of a_cas
 #endif
@@ -226,11 +179,10 @@ static inline void a_or_64(volatile uint64_t *p, uint64_t v)
 #endif
 
 #ifndef a_cas_p
-typedef char a_cas_p_undefined_but_pointer_not_32bit[-sizeof(char) == 0xffffffff ? 1 : -1];
 #define a_cas_p a_cas_p
 static inline void *a_cas_p(volatile void *p, void *t, void *s)
 {
-	return (void *)a_cas((volatile int *)p, (int)t, (int)s);
+    return zstrong_cas_ptr((void**)p, t, s);
 }
 #endif
 
@@ -255,15 +207,7 @@ static inline void a_crash()
 #define a_ctz_32 a_ctz_32
 static inline int a_ctz_32(uint32_t x)
 {
-#ifdef a_clz_32
-	return 31-a_clz_32(x&-x);
-#else
-	static const char debruijn32[32] = {
-		0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13,
-		31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14
-	};
-	return debruijn32[(x&-x)*0x076be629 >> 27];
-#endif
+    return __builtin_ctz(x);
 }
 #endif
 
@@ -271,21 +215,7 @@ static inline int a_ctz_32(uint32_t x)
 #define a_ctz_64 a_ctz_64
 static inline int a_ctz_64(uint64_t x)
 {
-	static const char debruijn64[64] = {
-		0, 1, 2, 53, 3, 7, 54, 27, 4, 38, 41, 8, 34, 55, 48, 28,
-		62, 5, 39, 46, 44, 42, 22, 9, 24, 35, 59, 56, 49, 18, 29, 11,
-		63, 52, 6, 26, 37, 40, 33, 47, 61, 45, 43, 21, 23, 58, 17, 10,
-		51, 25, 36, 32, 60, 20, 57, 16, 50, 31, 19, 15, 30, 14, 13, 12
-	};
-	if (sizeof(long) < 8) {
-		uint32_t y = x;
-		if (!y) {
-			y = x>>32;
-			return 32 + a_ctz_32(y);
-		}
-		return a_ctz_32(y);
-	}
-	return debruijn64[(x&-x)*0x022fdd63cc95386dull >> 58];
+    return __builtin_ctzll(x);
 }
 #endif
 
@@ -298,20 +228,7 @@ static inline int a_ctz_l(unsigned long x)
 #define a_clz_64 a_clz_64
 static inline int a_clz_64(uint64_t x)
 {
-#ifdef a_clz_32
-	if (x>>32)
-		return a_clz_32(x>>32);
-	return a_clz_32(x) + 32;
-#else
-	uint32_t y;
-	int r;
-	if (x>>32) y=x>>32, r=0; else y=x, r=32;
-	if (y>>16) y>>=16; else r |= 16;
-	if (y>>8) y>>=8; else r |= 8;
-	if (y>>4) y>>=4; else r |= 4;
-	if (y>>2) y>>=2; else r |= 2;
-	return r | !(y>>1);
-#endif
+    return __builtin_clzll(x);
 }
 #endif
 
@@ -319,14 +236,7 @@ static inline int a_clz_64(uint64_t x)
 #define a_clz_32 a_clz_32
 static inline int a_clz_32(uint32_t x)
 {
-	x >>= 1;
-	x |= x >> 1;
-	x |= x >> 2;
-	x |= x >> 4;
-	x |= x >> 8;
-	x |= x >> 16;
-	x++;
-	return 31-a_ctz_32(x);
+    return __builtin_clz(x);
 }
 #endif
 
diff --git a/src/internal/libc.h b/src/internal/libc.h
index 619bba8613e8..27031beab69f 100644
--- a/src/internal/libc.h
+++ b/src/internal/libc.h
@@ -4,6 +4,8 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <limits.h>
+#include <stdfil.h>
+#include <pizlonated_syscalls.h>
 
 struct __locale_map;
 
@@ -37,7 +39,7 @@ struct __libc {
 extern hidden struct __libc __libc;
 #define libc __libc
 
-hidden void __init_libc(char **, char *);
+hidden void __init_libc(char **, char *, size_t *);
 hidden void __init_tls(size_t *);
 hidden void __init_ssp(void *);
 hidden void __libc_start_init(void);
@@ -52,7 +54,7 @@ extern char *__progname, *__progname_full;
 
 extern hidden const char __libc_version[];
 
-hidden void __synccall(void (*)(void *), void *);
+#define __synccall(callback, arg) zerrorf("%s:%d: %s: attempt to __synccall(%s, %s)", __FILE__, __LINE__, __PRETTY_FUNCTION__, #callback, #arg)
 hidden int __setxid(int, int, int, int);
 
 #endif
diff --git a/src/internal/pthread_impl.h b/src/internal/pthread_impl.h
index de2b9d8b477e..888a1a4357fe 100644
--- a/src/internal/pthread_impl.h
+++ b/src/internal/pthread_impl.h
@@ -10,6 +10,8 @@
 #include "syscall.h"
 #include "atomic.h"
 #include "futex.h"
+#include <pizlonated_runtime.h>
+#include <pizlonated_syscalls.h>
 
 #include "pthread_arch.h"
 
@@ -32,6 +34,7 @@ struct pthread {
 #endif
 
 	/* Part 2 -- implementation details, non-ABI. */
+	void* zthread;
 	int tid;
 	int errno_val;
 	volatile int detach_state;
@@ -86,16 +89,16 @@ enum {
 #define _m_type __u.__i[0]
 #define _m_lock __u.__vi[1]
 #define _m_waiters __u.__vi[2]
-#define _m_prev __u.__p[3]
-#define _m_next __u.__p[4]
-#define _m_count __u.__i[5]
-#define _c_shared __u.__p[0]
-#define _c_seq __u.__vi[2]
-#define _c_waiters __u.__vi[3]
-#define _c_clock __u.__i[4]
-#define _c_lock __u.__vi[8]
-#define _c_head __u.__p[1]
-#define _c_tail __u.__p[5]
+#define _m_prev __p[0]
+#define _m_next __p[1]
+#define _m_count __u.__i[3]
+#define _c_shared __u.__i[0]
+#define _c_seq __u.__vi[1]
+#define _c_waiters __u.__vi[2]
+#define _c_clock __u.__i[3]
+#define _c_lock __u.__vi[4]
+#define _c_head __p[1]
+#define _c_tail __p[2]
 #define _rw_lock __u.__vi[0]
 #define _rw_waiters __u.__vi[1]
 #define _rw_shared __u.__i[2]
@@ -104,7 +107,7 @@ enum {
 #define _b_limit __u.__i[2]
 #define _b_count __u.__vi[3]
 #define _b_waiters2 __u.__vi[4]
-#define _b_inst __u.__p[3]
+#define _b_inst __p[0]
 
 #ifndef TP_OFFSET
 #define TP_OFFSET 0
@@ -114,19 +117,13 @@ enum {
 #define DTP_OFFSET 0
 #endif
 
-#ifdef TLS_ABOVE_TP
-#define TP_ADJ(p) ((char *)(p) + sizeof(struct pthread) + TP_OFFSET)
-#define __pthread_self() ((pthread_t)(__get_tp() - sizeof(struct __pthread) - TP_OFFSET))
-#else
-#define TP_ADJ(p) (p)
-#define __pthread_self() ((pthread_t)__get_tp())
-#endif
+#define __pthread_self() ((struct pthread*)zthread_self_cookie())
 
 #ifndef tls_mod_off_t
 #define tls_mod_off_t size_t
 #endif
 
-#define SIGTIMER 32
+#define SIGTIMER 35
 #define SIGCANCEL 33
 #define SIGSYNCCALL 34
 
@@ -134,16 +131,13 @@ enum {
 #define SIGPT_SET \
 	((sigset_t *)(const unsigned long [_NSIG/8/sizeof(long)]){ \
 	[sizeof(long)==4] = 3UL<<(32*(sizeof(long)>4)) })
-#define SIGTIMER_SET \
-	((sigset_t *)(const unsigned long [_NSIG/8/sizeof(long)]){ \
-	 0x80000000 })
+
+int __sigdelsetyolo(sigset_t *, int);
 
 void *__tls_get_addr(tls_mod_off_t *);
 hidden int __init_tp(void *);
-hidden void *__copy_tls(unsigned char *);
 hidden void __reset_tls();
 
-hidden void __membarrier_init(void);
 hidden void __dl_thread_cleanup(void);
 hidden void __testcancel();
 hidden void __do_cleanup_push(struct __ptcb *);
@@ -167,16 +161,11 @@ hidden int __timedwait_cp(volatile int *, int, clockid_t, const struct timespec
 hidden void __wait(volatile int *, volatile int *, int, int);
 static inline void __wake(volatile void *addr, int cnt, int priv)
 {
-	if (priv) priv = FUTEX_PRIVATE;
-	if (cnt<0) cnt = INT_MAX;
-	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
-	__syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
+	zsys_futex_wake(addr, cnt, priv);
 }
 static inline void __futexwait(volatile void *addr, int val, int priv)
 {
-	if (priv) priv = FUTEX_PRIVATE;
-	__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS ||
-	__syscall(SYS_futex, addr, FUTEX_WAIT, val, 0);
+	zsys_futex_wait(addr, val, priv);
 }
 
 hidden void __acquire_ptc(void);
diff --git a/src/internal/syscall.h b/src/internal/syscall.h
index 4a446157063b..eb5ba4967836 100644
--- a/src/internal/syscall.h
+++ b/src/internal/syscall.h
@@ -5,6 +5,8 @@
 #include <errno.h>
 #include <sys/syscall.h>
 #include "syscall_arch.h"
+#include <stdfil.h>
+#include <pizlonated_syscalls.h>
 
 #ifndef SYSCALL_RLIM_INFINITY
 #define SYSCALL_RLIM_INFINITY (~0ULL)
@@ -27,13 +29,13 @@ hidden long __syscall_ret(unsigned long),
 	__syscall_cp(syscall_arg_t, syscall_arg_t, syscall_arg_t, syscall_arg_t,
 	             syscall_arg_t, syscall_arg_t, syscall_arg_t);
 
-#define __syscall1(n,a) __syscall1(n,__scc(a))
-#define __syscall2(n,a,b) __syscall2(n,__scc(a),__scc(b))
-#define __syscall3(n,a,b,c) __syscall3(n,__scc(a),__scc(b),__scc(c))
-#define __syscall4(n,a,b,c,d) __syscall4(n,__scc(a),__scc(b),__scc(c),__scc(d))
-#define __syscall5(n,a,b,c,d,e) __syscall5(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e))
-#define __syscall6(n,a,b,c,d,e,f) __syscall6(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e),__scc(f))
-#define __syscall7(n,a,b,c,d,e,f,g) __syscall7(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e),__scc(f),__scc(g))
+#define __syscall0(n) ({ zerrorf("%s:%d: %s: bad syscall: %s", __FILE__, __LINE__, __PRETTY_FUNCTION__, #n); 0; })
+#define __syscall1(n, a0) ({ zerrorf("%s:%d: %s: bad syscall: %s, %s", __FILE__, __LINE__, __PRETTY_FUNCTION__, #n, #a0); 0; })
+#define __syscall2(n, a0, a1) ({ zerrorf("%s:%d: %s: bad syscall: %s, %s, %s", __FILE__, __LINE__, __PRETTY_FUNCTION__, #n, #a0, #a1); 0; })
+#define __syscall3(n, a0, a1, a2) ({ zerrorf("%s:%d: %s: bad syscall: %s, %s, %s, %s", __FILE__, __LINE__, __PRETTY_FUNCTION__, #n, #a0, #a1, #a2); 0; })
+#define __syscall4(n, a0, a1, a2, a3) ({ zerrorf("%s:%d: %s: bad syscall: %s, %s, %s, %s, %s", __FILE__, __LINE__, __PRETTY_FUNCTION__, #n, #a0, #a1, #a2, #a3); 0; })
+#define __syscall5(n, a0, a1, a2, a3, a4) ({ zerrorf("%s:%d: %s: bad syscall: %s, %s, %s, %s, %s, %s", __FILE__, __LINE__, __PRETTY_FUNCTION__, #n, #a0, #a1, #a2, #a3, #a4); 0; })
+#define __syscall6(n, a0, a1, a2, a3, a4, a5) ({ zerrorf("%s:%d: %s: bad syscall: %s, %s, %s, %s, %s, %s, %s", __FILE__, __LINE__, __PRETTY_FUNCTION__, #n, #a0, #a1, #a2, #a3, #a4, #a5); 0; })
 
 #define __SYSCALL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n
 #define __SYSCALL_NARGS(...) __SYSCALL_NARGS_X(__VA_ARGS__,7,6,5,4,3,2,1,0,)
@@ -47,29 +49,18 @@ hidden long __syscall_ret(unsigned long),
 #define socketcall(nm,a,b,c,d,e,f) __syscall_ret(__socketcall(nm,a,b,c,d,e,f))
 #define socketcall_cp(nm,a,b,c,d,e,f) __syscall_ret(__socketcall_cp(nm,a,b,c,d,e,f))
 
-#define __syscall_cp0(n) (__syscall_cp)(n,0,0,0,0,0,0)
-#define __syscall_cp1(n,a) (__syscall_cp)(n,__scc(a),0,0,0,0,0)
-#define __syscall_cp2(n,a,b) (__syscall_cp)(n,__scc(a),__scc(b),0,0,0,0)
-#define __syscall_cp3(n,a,b,c) (__syscall_cp)(n,__scc(a),__scc(b),__scc(c),0,0,0)
-#define __syscall_cp4(n,a,b,c,d) (__syscall_cp)(n,__scc(a),__scc(b),__scc(c),__scc(d),0,0)
-#define __syscall_cp5(n,a,b,c,d,e) (__syscall_cp)(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e),0)
-#define __syscall_cp6(n,a,b,c,d,e,f) (__syscall_cp)(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e),__scc(f))
+#define __syscall_cp0(n) ({ zerrorf("%s:%d: %s: bad syscall: %s", __FILE__, __LINE__, __PRETTY_FUNCTION__, #n); 0; })
+#define __syscall_cp1(n, a0) ({ zerrorf("%s:%d: %s: bad syscall: %s, %s", __FILE__, __LINE__, __PRETTY_FUNCTION__, #n, #a0); 0; })
+#define __syscall_cp2(n, a0, a1) ({ zerrorf("%s:%d: %s: bad syscall: %s, %s, %s", __FILE__, __LINE__, __PRETTY_FUNCTION__, #n, #a0, #a1); 0; })
+#define __syscall_cp3(n, a0, a1, a2) ({ zerrorf("%s:%d: %s: bad syscall: %s, %s, %s, %s", __FILE__, __LINE__, __PRETTY_FUNCTION__, #n, #a0, #a1, #a2); 0; })
+#define __syscall_cp4(n, a0, a1, a2, a3) ({ zerrorf("%s:%d: %s: bad syscall: %s, %s, %s, %s, %s", __FILE__, __LINE__, __PRETTY_FUNCTION__, #n, #a0, #a1, #a2, #a3); 0; })
+#define __syscall_cp5(n, a0, a1, a2, a3, a4) ({ zerrorf("%s:%d: %s: bad syscall: %s, %s, %s, %s, %s, %s", __FILE__, __LINE__, __PRETTY_FUNCTION__, #n, #a0, #a1, #a2, #a3, #a4); 0; })
+#define __syscall_cp6(n, a0, a1, a2, a3, a4, a5) ({ zerrorf("%s:%d: %s: bad syscall: %s, %s, %s, %s, %s, %s, %s", __FILE__, __LINE__, __PRETTY_FUNCTION__, #n, #a0, #a1, #a2, #a3, #a4, #a5); 0; })
 
 #define __syscall_cp(...) __SYSCALL_DISP(__syscall_cp,__VA_ARGS__)
 #define syscall_cp(...) __syscall_ret(__syscall_cp(__VA_ARGS__))
 
-static inline long __alt_socketcall(int sys, int sock, int cp, syscall_arg_t a, syscall_arg_t b, syscall_arg_t c, syscall_arg_t d, syscall_arg_t e, syscall_arg_t f)
-{
-	long r;
-	if (cp) r = __syscall_cp(sys, a, b, c, d, e, f);
-	else r = __syscall(sys, a, b, c, d, e, f);
-	if (r != -ENOSYS) return r;
-#ifdef SYS_socketcall
-	if (cp) r = __syscall_cp(SYS_socketcall, sock, ((long[6]){a, b, c, d, e, f}));
-	else r = __syscall(SYS_socketcall, sock, ((long[6]){a, b, c, d, e, f}));
-#endif
-	return r;
-}
+#define __alt_socketcall(sys, sock, cp, a, b, c, d, e, f) ({ zerrorf("%s:%d: %s: bad socketcall: %s, %s, %s, %s, %s, %s, %s, %s, %s", __FILE__, __LINE__, __PRETTY_FUNCTION__, #sys, #sock, #cp, #a, #b, #c, #d, #e, #f); 0; })
 #define __socketcall(nm, a, b, c, d, e, f) __alt_socketcall(SYS_##nm, __SC_##nm, 0, \
 	__scc(a), __scc(b), __scc(c), __scc(d), __scc(e), __scc(f))
 #define __socketcall_cp(nm, a, b, c, d, e, f) __alt_socketcall(SYS_##nm, __SC_##nm, 1, \
diff --git a/src/internal/yescrypt.h b/src/internal/yescrypt.h
new file mode 100644
index 000000000000..d3c5a21a1cf6
--- /dev/null
+++ b/src/internal/yescrypt.h
@@ -0,0 +1,346 @@
+/*-
+ * Copyright 2009 Colin Percival
+ * Copyright 2013-2018 Alexander Peslyak
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * This file was originally written by Colin Percival as part of the Tarsnap
+ * online backup system.
+ */
+#ifndef _YESCRYPT_H_
+#define _YESCRYPT_H_
+
+#include <stdint.h>
+#include <stdlib.h> /* for size_t */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * crypto_scrypt(passwd, passwdlen, salt, saltlen, N, r, p, buf, buflen):
+ * Compute scrypt(passwd[0 .. passwdlen - 1], salt[0 .. saltlen - 1], N, r,
+ * p, buflen) and write the result into buf.  The parameters r, p, and buflen
+ * must satisfy r * p < 2^30 and buflen <= (2^32 - 1) * 32.  The parameter N
+ * must be a power of 2 greater than 1.
+ *
+ * Return 0 on success; or -1 on error.
+ *
+ * MT-safe as long as buf is local to the thread.
+ */
+hidden extern int crypto_scrypt(const uint8_t *passwd, size_t passwdlen,
+    const uint8_t *salt, size_t saltlen,
+    uint64_t N, uint32_t r, uint32_t p, uint8_t *buf, size_t buflen);
+
+/**
+ * Internal type used by the memory allocator.  Please do not use it directly.
+ * Use yescrypt_shared_t and yescrypt_local_t as appropriate instead, since
+ * they might differ from each other in a future version.
+ */
+typedef struct {
+	void *base, *aligned;
+	size_t base_size, aligned_size;
+} yescrypt_region_t;
+
+/**
+ * Types for shared (ROM) and thread-local (RAM) data structures.
+ */
+typedef yescrypt_region_t yescrypt_shared_t;
+typedef yescrypt_region_t yescrypt_local_t;
+
+/**
+ * Two 64-bit tags placed 48 bytes to the end of a ROM in host byte endianness
+ * (and followed by 32 bytes of the ROM digest).
+ */
+#define YESCRYPT_ROM_TAG1 0x7470797263736579ULL /* "yescrypt" */
+#define YESCRYPT_ROM_TAG2 0x687361684d4f522dULL /* "-ROMhash" */
+
+/**
+ * Type and possible values for the flags argument of yescrypt_kdf(),
+ * yescrypt_encode_params_r(), yescrypt_encode_params().  Most of these may be
+ * OR'ed together, except that YESCRYPT_WORM stands on its own.
+ * Please refer to the description of yescrypt_kdf() below for the meaning of
+ * these flags.
+ */
+typedef uint32_t yescrypt_flags_t;
+/* Public */
+#define YESCRYPT_WORM			1
+#define YESCRYPT_RW			0x002
+#define YESCRYPT_ROUNDS_3		0x000
+#define YESCRYPT_ROUNDS_6		0x004
+#define YESCRYPT_GATHER_1		0x000
+#define YESCRYPT_GATHER_2		0x008
+#define YESCRYPT_GATHER_4		0x010
+#define YESCRYPT_GATHER_8		0x018
+#define YESCRYPT_SIMPLE_1		0x000
+#define YESCRYPT_SIMPLE_2		0x020
+#define YESCRYPT_SIMPLE_4		0x040
+#define YESCRYPT_SIMPLE_8		0x060
+#define YESCRYPT_SBOX_6K		0x000
+#define YESCRYPT_SBOX_12K		0x080
+#define YESCRYPT_SBOX_24K		0x100
+#define YESCRYPT_SBOX_48K		0x180
+#define YESCRYPT_SBOX_96K		0x200
+#define YESCRYPT_SBOX_192K		0x280
+#define YESCRYPT_SBOX_384K		0x300
+#define YESCRYPT_SBOX_768K		0x380
+/* Only valid for yescrypt_init_shared() */
+#define YESCRYPT_SHARED_PREALLOCATED	0x10000
+#ifdef YESCRYPT_INTERNAL
+/* Private */
+#define YESCRYPT_MODE_MASK		0x003
+#define YESCRYPT_RW_FLAVOR_MASK		0x3fc
+#define YESCRYPT_INIT_SHARED		0x01000000
+#define YESCRYPT_ALLOC_ONLY		0x08000000
+#define YESCRYPT_PREHASH		0x10000000
+#endif
+
+#define YESCRYPT_RW_DEFAULTS \
+	(YESCRYPT_RW | \
+	YESCRYPT_ROUNDS_6 | YESCRYPT_GATHER_4 | YESCRYPT_SIMPLE_2 | \
+	YESCRYPT_SBOX_12K)
+
+#define YESCRYPT_DEFAULTS YESCRYPT_RW_DEFAULTS
+
+#ifdef YESCRYPT_INTERNAL
+#define YESCRYPT_KNOWN_FLAGS \
+	(YESCRYPT_MODE_MASK | YESCRYPT_RW_FLAVOR_MASK | \
+	YESCRYPT_SHARED_PREALLOCATED | \
+	YESCRYPT_INIT_SHARED | YESCRYPT_ALLOC_ONLY | YESCRYPT_PREHASH)
+#endif
+
+/**
+ * yescrypt parameters combined into one struct.  N, r, p are the same as in
+ * classic scrypt, except that the meaning of p changes when YESCRYPT_RW is
+ * set.  flags, t, g, NROM are special to yescrypt.
+ */
+typedef struct {
+	yescrypt_flags_t flags;
+	uint64_t N;
+	uint32_t r, p, t, g;
+	uint64_t NROM;
+} yescrypt_params_t;
+
+/**
+ * A 256-bit yescrypt hash, or a hash encryption key (which may itself have
+ * been derived as a yescrypt hash of a human-specified key string).
+ */
+typedef union {
+	unsigned char uc[32];
+	uint64_t u64[4];
+} yescrypt_binary_t;
+
+/**
+ * yescrypt_init_shared(shared, seed, seedlen, params):
+ * Optionally allocate memory for and initialize the shared (ROM) data
+ * structure.  The parameters flags, NROM, r, p, and t specify how the ROM is
+ * to be initialized, and seed and seedlen specify the initial seed affecting
+ * the data with which the ROM is filled.
+ *
+ * Return 0 on success; or -1 on error.
+ *
+ * If bit YESCRYPT_SHARED_PREALLOCATED in flags is set, then memory for the
+ * ROM is assumed to have been preallocated by the caller, with shared->aligned
+ * being the start address of the ROM and shared->aligned_size being its size
+ * (which must be sufficient for NROM, r, p).  This may be used e.g. when the
+ * ROM is to be placed in a SysV shared memory segment allocated by the caller.
+ *
+ * MT-safe as long as shared is local to the thread.
+ */
+hidden extern int yescrypt_init_shared(yescrypt_shared_t *shared,
+    const uint8_t *seed, size_t seedlen, const yescrypt_params_t *params);
+
+/**
+ * yescrypt_digest_shared(shared):
+ * Extract the previously stored message digest of the provided yescrypt ROM.
+ *
+ * Return pointer to the message digest on success; or NULL on error.
+ *
+ * MT-unsafe.
+ */
+hidden extern yescrypt_binary_t *yescrypt_digest_shared(yescrypt_shared_t *shared);
+
+/**
+ * yescrypt_free_shared(shared):
+ * Free memory that had been allocated with yescrypt_init_shared().
+ *
+ * Return 0 on success; or -1 on error.
+ *
+ * MT-safe as long as shared is local to the thread.
+ */
+hidden extern int yescrypt_free_shared(yescrypt_shared_t *shared);
+
+/**
+ * yescrypt_init_local(local):
+ * Initialize the thread-local (RAM) data structure.  Actual memory allocation
+ * is currently fully postponed until a call to yescrypt_kdf() or yescrypt_r().
+ *
+ * Return 0 on success; or -1 on error.
+ *
+ * MT-safe as long as local is local to the thread.
+ */
+hidden extern int yescrypt_init_local(yescrypt_local_t *local);
+
+/**
+ * yescrypt_free_local(local):
+ * Free memory that may have been allocated for an initialized thread-local
+ * (RAM) data structure.
+ *
+ * Return 0 on success; or -1 on error.
+ *
+ * MT-safe as long as local is local to the thread.
+ */
+hidden extern int yescrypt_free_local(yescrypt_local_t *local);
+
+/**
+ * yescrypt_kdf(shared, local, passwd, passwdlen, salt, saltlen, params,
+ *     buf, buflen):
+ * Compute scrypt(passwd[0 .. passwdlen - 1], salt[0 .. saltlen - 1], N, r,
+ * p, buflen), or a revision of scrypt as requested by flags and shared, and
+ * write the result into buf.  The parameters N, r, p, and buflen must satisfy
+ * the same conditions as with crypto_scrypt().  t controls computation time
+ * while not affecting peak memory usage (t = 0 is optimal unless higher N*r
+ * is not affordable while higher t is).  g controls hash upgrades (g = 0 for
+ * no upgrades so far).  shared and flags may request special modes.  local is
+ * the thread-local data structure, allowing to preserve and reuse a memory
+ * allocation across calls, thereby reducing processing overhead.
+ *
+ * Return 0 on success; or -1 on error.
+ *
+ * Classic scrypt is available by setting shared = NULL, flags = 0, and t = 0.
+ *
+ * Setting YESCRYPT_WORM enables only minimal deviations from classic scrypt:
+ * support for the t parameter, and pre- and post-hashing.
+ *
+ * Setting YESCRYPT_RW fully enables yescrypt.  As a side effect of differences
+ * between the algorithms, it also prevents p > 1 from growing the threads'
+ * combined processing time and memory allocation (like it did with classic
+ * scrypt and YESCRYPT_WORM), treating p as a divider rather than a multiplier.
+ *
+ * Passing a shared structure, with ROM contents previously computed by
+ * yescrypt_init_shared(), enables the use of ROM and requires YESCRYPT_RW.
+ *
+ * In order to allow for initialization of the ROM to be split into a separate
+ * program (or separate invocation of the same program), the shared->aligned
+ * and shared->aligned_size fields may optionally be set by the caller directly
+ * (e.g., to a mapped SysV shm segment), without using yescrypt_init_shared().
+ *
+ * local must be initialized with yescrypt_init_local().
+ *
+ * MT-safe as long as local and buf are local to the thread.
+ */
+hidden extern int yescrypt_kdf(const yescrypt_shared_t *shared,
+    yescrypt_local_t *local,
+    const uint8_t *passwd, size_t passwdlen,
+    const uint8_t *salt, size_t saltlen,
+    const yescrypt_params_t *params,
+    uint8_t *buf, size_t buflen);
+
+/**
+ * yescrypt_r(shared, local, passwd, passwdlen, setting, key, buf, buflen):
+ * Compute and encode an scrypt or enhanced scrypt hash of passwd given the
+ * parameters and salt value encoded in setting.  If shared is not NULL, a ROM
+ * is used and YESCRYPT_RW is required.  Otherwise, whether to compute classic
+ * scrypt, YESCRYPT_WORM (a slight deviation from classic scrypt), or
+ * YESCRYPT_RW (time-memory tradeoff discouraging modification) is determined
+ * by the setting string.  shared (if not NULL) and local must be initialized
+ * as described above for yescrypt_kdf().  buf must be large enough (as
+ * indicated by buflen) to hold the encoded hash string.
+ *
+ * Return the encoded hash string on success; or NULL on error.
+ *
+ * MT-safe as long as local and buf are local to the thread.
+ */
+hidden extern uint8_t *yescrypt_r(const yescrypt_shared_t *shared,
+    yescrypt_local_t *local,
+    const uint8_t *passwd, size_t passwdlen,
+    const uint8_t *setting,
+    const yescrypt_binary_t *key,
+    uint8_t *buf, size_t buflen);
+
+/**
+ * yescrypt(passwd, setting):
+ * Compute and encode an scrypt or enhanced scrypt hash of passwd given the
+ * parameters and salt value encoded in setting.  Whether to compute classic
+ * scrypt, YESCRYPT_WORM (a slight deviation from classic scrypt), or
+ * YESCRYPT_RW (time-memory tradeoff discouraging modification) is determined
+ * by the setting string.
+ *
+ * Return the encoded hash string on success; or NULL on error.
+ *
+ * This is a crypt(3)-like interface, which is simpler to use than
+ * yescrypt_r(), but it is not MT-safe, it does not allow for the use of a ROM,
+ * and it is slower than yescrypt_r() for repeated calls because it allocates
+ * and frees memory on each call.
+ *
+ * MT-unsafe.
+ */
+hidden extern uint8_t *yescrypt(const uint8_t *passwd, const uint8_t *setting);
+
+/**
+ * yescrypt_reencrypt(hash, from_key, to_key):
+ * Re-encrypt a yescrypt hash from one key to another.  Either key may be NULL
+ * to indicate unencrypted hash.  The encoded hash string is modified in-place.
+ *
+ * Return the hash pointer on success; or NULL on error (in which case the hash
+ * string is left unmodified).
+ *
+ * MT-safe as long as hash is local to the thread.
+ */
+hidden extern uint8_t *yescrypt_reencrypt(uint8_t *hash,
+    const yescrypt_binary_t *from_key,
+    const yescrypt_binary_t *to_key);
+
+/**
+ * yescrypt_encode_params_r(params, src, srclen, buf, buflen):
+ * Generate a setting string for use with yescrypt_r() and yescrypt() by
+ * encoding into it the parameters flags, N, r, p, t, g, and a salt given by
+ * src (of srclen bytes).  buf must be large enough (as indicated by buflen)
+ * to hold the setting string.
+ *
+ * Return the setting string on success; or NULL on error.
+ *
+ * MT-safe as long as buf is local to the thread.
+ */
+hidden extern uint8_t *yescrypt_encode_params_r(const yescrypt_params_t *params,
+    const uint8_t *src, size_t srclen,
+    uint8_t *buf, size_t buflen);
+
+/**
+ * yescrypt_encode_params(params, src, srclen):
+ * Generate a setting string for use with yescrypt_r() and yescrypt().  This
+ * function is the same as yescrypt_encode_params_r() except that it uses a
+ * static buffer and thus is not MT-safe.
+ *
+ * Return the setting string on success; or NULL on error.
+ *
+ * MT-unsafe.
+ */
+hidden extern uint8_t *yescrypt_encode_params(const yescrypt_params_t *params,
+    const uint8_t *src, size_t srclen);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_YESCRYPT_H_ */
diff --git a/src/ipc/msgctl.c b/src/ipc/msgctl.c
index 9c11440641a9..9cb883c15dce 100644
--- a/src/ipc/msgctl.c
+++ b/src/ipc/msgctl.c
@@ -3,49 +3,7 @@
 #include "syscall.h"
 #include "ipc.h"
 
-#if __BYTE_ORDER != __BIG_ENDIAN
-#undef SYSCALL_IPC_BROKEN_MODE
-#endif
-
 int msgctl(int q, int cmd, struct msqid_ds *buf)
 {
-#if IPC_TIME64
-	struct msqid_ds out, *orig;
-	if (cmd&IPC_TIME64) {
-		out = (struct msqid_ds){0};
-		orig = buf;
-		buf = &out;
-	}
-#endif
-#ifdef SYSCALL_IPC_BROKEN_MODE
-	struct msqid_ds tmp;
-	if (cmd == IPC_SET) {
-		tmp = *buf;
-		tmp.msg_perm.mode *= 0x10000U;
-		buf = &tmp;
-	}
-#endif
-#ifndef SYS_ipc
-	int r = __syscall(SYS_msgctl, q, IPC_CMD(cmd), buf);
-#else
-	int r = __syscall(SYS_ipc, IPCOP_msgctl, q, IPC_CMD(cmd), 0, buf, 0);
-#endif
-#ifdef SYSCALL_IPC_BROKEN_MODE
-	if (r >= 0) switch (cmd | IPC_TIME64) {
-	case IPC_STAT:
-	case MSG_STAT:
-	case MSG_STAT_ANY:
-		buf->msg_perm.mode >>= 16;
-	}
-#endif
-#if IPC_TIME64
-	if (r >= 0 && (cmd&IPC_TIME64)) {
-		buf = orig;
-		*buf = out;
-		IPC_HILO(buf, msg_stime);
-		IPC_HILO(buf, msg_rtime);
-		IPC_HILO(buf, msg_ctime);
-	}
-#endif
-	return __syscall_ret(r);
+	return zsys_msgctl(q, cmd, buf);
 }
diff --git a/src/ipc/msgget.c b/src/ipc/msgget.c
index 30a4b42b854c..222e48d2cd73 100644
--- a/src/ipc/msgget.c
+++ b/src/ipc/msgget.c
@@ -4,9 +4,5 @@
 
 int msgget(key_t k, int flag)
 {
-#ifndef SYS_ipc
-	return syscall(SYS_msgget, k, flag);
-#else
-	return syscall(SYS_ipc, IPCOP_msgget, k, flag);
-#endif
+	return zsys_msgget(k, flag);
 }
diff --git a/src/ipc/msgrcv.c b/src/ipc/msgrcv.c
index 9d1034b14501..8fc1074458a7 100644
--- a/src/ipc/msgrcv.c
+++ b/src/ipc/msgrcv.c
@@ -4,9 +4,5 @@
 
 ssize_t msgrcv(int q, void *m, size_t len, long type, int flag)
 {
-#ifndef SYS_ipc
-	return syscall_cp(SYS_msgrcv, q, m, len, type, flag);
-#else
-	return syscall_cp(SYS_ipc, IPCOP_msgrcv, q, len, flag, ((long[]){ (long)m, type }));
-#endif
+	return zsys_msgrcv(q, m, len, type, flag);
 }
diff --git a/src/ipc/msgsnd.c b/src/ipc/msgsnd.c
index 99bb17e94aca..6dc5cc50ce91 100644
--- a/src/ipc/msgsnd.c
+++ b/src/ipc/msgsnd.c
@@ -4,9 +4,5 @@
 
 int msgsnd(int q, const void *m, size_t len, int flag)
 {
-#ifndef SYS_ipc
-	return syscall_cp(SYS_msgsnd, q, m, len, flag);
-#else
-	return syscall_cp(SYS_ipc, IPCOP_msgsnd, q, len, flag, m);
-#endif
+	return zsys_msgsnd(q, m, len, flag);
 }
diff --git a/src/ipc/semctl.c b/src/ipc/semctl.c
index bbb97d7aed06..5aa06a818a7c 100644
--- a/src/ipc/semctl.c
+++ b/src/ipc/semctl.c
@@ -4,66 +4,7 @@
 #include "syscall.h"
 #include "ipc.h"
 
-#if __BYTE_ORDER != __BIG_ENDIAN
-#undef SYSCALL_IPC_BROKEN_MODE
-#endif
-
-union semun {
-	int val;
-	struct semid_ds *buf;
-	unsigned short *array;
-};
-
 int semctl(int id, int num, int cmd, ...)
 {
-	union semun arg = {0};
-	va_list ap;
-	switch (cmd & ~IPC_TIME64) {
-	case SETVAL: case GETALL: case SETALL: case IPC_SET:
-	case IPC_INFO: case SEM_INFO:
-	case IPC_STAT & ~IPC_TIME64:
-	case SEM_STAT & ~IPC_TIME64:
-	case SEM_STAT_ANY & ~IPC_TIME64:
-		va_start(ap, cmd);
-		arg = va_arg(ap, union semun);
-		va_end(ap);
-	}
-#if IPC_TIME64
-	struct semid_ds out, *orig;
-	if (cmd&IPC_TIME64) {
-		out = (struct semid_ds){0};
-		orig = arg.buf;
-		arg.buf = &out;
-	}
-#endif
-#ifdef SYSCALL_IPC_BROKEN_MODE
-	struct semid_ds tmp;
-	if (cmd == IPC_SET) {
-		tmp = *arg.buf;
-		tmp.sem_perm.mode *= 0x10000U;
-		arg.buf = &tmp;
-	}
-#endif
-#ifndef SYS_ipc
-	int r = __syscall(SYS_semctl, id, num, IPC_CMD(cmd), arg.buf);
-#else
-	int r = __syscall(SYS_ipc, IPCOP_semctl, id, num, IPC_CMD(cmd), &arg.buf);
-#endif
-#ifdef SYSCALL_IPC_BROKEN_MODE
-	if (r >= 0) switch (cmd | IPC_TIME64) {
-	case IPC_STAT:
-	case SEM_STAT:
-	case SEM_STAT_ANY:
-		arg.buf->sem_perm.mode >>= 16;
-	}
-#endif
-#if IPC_TIME64
-	if (r >= 0 && (cmd&IPC_TIME64)) {
-		arg.buf = orig;
-		*arg.buf = out;
-		IPC_HILO(arg.buf, sem_otime);
-		IPC_HILO(arg.buf, sem_ctime);
-	}
-#endif
-	return __syscall_ret(r);
+	return *(int*)zcall(zsys_semctl, zargs());
 }
diff --git a/src/ipc/semget.c b/src/ipc/semget.c
index 2cdf626b5002..c539771bccb1 100644
--- a/src/ipc/semget.c
+++ b/src/ipc/semget.c
@@ -6,14 +6,5 @@
 
 int semget(key_t key, int n, int fl)
 {
-	/* The kernel uses the wrong type for the sem_nsems member
-	 * of struct semid_ds, and thus might not check that the
-	 * n fits in the correct (per POSIX) userspace type, so
-	 * we have to check here. */
-	if (n > USHRT_MAX) return __syscall_ret(-EINVAL);
-#ifndef SYS_ipc
-	return syscall(SYS_semget, key, n, fl);
-#else
-	return syscall(SYS_ipc, IPCOP_semget, key, n, fl);
-#endif
+	return zsys_semget(key, n, fl);
 }
diff --git a/src/ipc/semop.c b/src/ipc/semop.c
index 5f0c7deaf308..be8097993e96 100644
--- a/src/ipc/semop.c
+++ b/src/ipc/semop.c
@@ -4,9 +4,5 @@
 
 int semop(int id, struct sembuf *buf, size_t n)
 {
-#ifndef SYS_ipc
-	return syscall(SYS_semop, id, buf, n);
-#else
-	return syscall(SYS_ipc, IPCOP_semop, id, n, 0, buf);
-#endif
+	return zsys_semop(id, buf, n);
 }
diff --git a/src/ipc/semtimedop.c b/src/ipc/semtimedop.c
index a104af21895e..b07123a88041 100644
--- a/src/ipc/semtimedop.c
+++ b/src/ipc/semtimedop.c
@@ -4,33 +4,7 @@
 #include "syscall.h"
 #include "ipc.h"
 
-#define IS32BIT(x) !((x)+0x80000000ULL>>32)
-#define CLAMP(x) (int)(IS32BIT(x) ? (x) : 0x7fffffffU+((0ULL+(x))>>63))
-
-#if !defined(SYS_semtimedop) && !defined(SYS_ipc) || \
-	SYS_semtimedop == SYS_semtimedop_time64
-#define NO_TIME32 1
-#else
-#define NO_TIME32 0
-#endif
-
 int semtimedop(int id, struct sembuf *buf, size_t n, const struct timespec *ts)
 {
-#ifdef SYS_semtimedop_time64
-	time_t s = ts ? ts->tv_sec : 0;
-	long ns = ts ? ts->tv_nsec : 0;
-	int r = -ENOSYS;
-	if (NO_TIME32 || !IS32BIT(s))
-		r = __syscall(SYS_semtimedop_time64, id, buf, n,
-			ts ? ((long long[]){s, ns}) : 0);
-	if (NO_TIME32 || r!=-ENOSYS) return __syscall_ret(r);
-	ts = ts ? (void *)(long[]){CLAMP(s), ns} : 0;
-#endif
-#if defined(SYS_ipc)
-	return syscall(SYS_ipc, IPCOP_semtimedop, id, n, 0, buf, ts);
-#elif defined(SYS_semtimedop)
-	return syscall(SYS_semtimedop, id, buf, n, ts);
-#else
-	return __syscall_ret(-ENOSYS);
-#endif
+	return zsys_semtimedop(id, buf, n, ts);
 }
diff --git a/src/ipc/shmat.c b/src/ipc/shmat.c
index 8c7407d13f6d..9766d48a6a21 100644
--- a/src/ipc/shmat.c
+++ b/src/ipc/shmat.c
@@ -2,16 +2,7 @@
 #include "syscall.h"
 #include "ipc.h"
 
-#ifndef SYS_ipc
 void *shmat(int id, const void *addr, int flag)
 {
-	return (void *)syscall(SYS_shmat, id, addr, flag);
+	return zsys_shmat(id, addr, flag);
 }
-#else
-void *shmat(int id, const void *addr, int flag)
-{
-	unsigned long ret;
-	ret = syscall(SYS_ipc, IPCOP_shmat, id, flag, &addr, addr);
-	return (ret > -(unsigned long)SHMLBA) ? (void *)ret : (void *)addr;
-}
-#endif
diff --git a/src/ipc/shmctl.c b/src/ipc/shmctl.c
index 1c9f78c2f11f..fd973b84b8c0 100644
--- a/src/ipc/shmctl.c
+++ b/src/ipc/shmctl.c
@@ -3,49 +3,7 @@
 #include "syscall.h"
 #include "ipc.h"
 
-#if __BYTE_ORDER != __BIG_ENDIAN
-#undef SYSCALL_IPC_BROKEN_MODE
-#endif
-
 int shmctl(int id, int cmd, struct shmid_ds *buf)
 {
-#if IPC_TIME64
-	struct shmid_ds out, *orig;
-	if (cmd&IPC_TIME64) {
-		out = (struct shmid_ds){0};
-		orig = buf;
-		buf = &out;
-	}
-#endif
-#ifdef SYSCALL_IPC_BROKEN_MODE
-	struct shmid_ds tmp;
-	if (cmd == IPC_SET) {
-		tmp = *buf;
-		tmp.shm_perm.mode *= 0x10000U;
-		buf = &tmp;
-	}
-#endif
-#ifndef SYS_ipc
-	int r = __syscall(SYS_shmctl, id, IPC_CMD(cmd), buf);
-#else
-	int r = __syscall(SYS_ipc, IPCOP_shmctl, id, IPC_CMD(cmd), 0, buf, 0);
-#endif
-#ifdef SYSCALL_IPC_BROKEN_MODE
-	if (r >= 0) switch (cmd | IPC_TIME64) {
-	case IPC_STAT:
-	case SHM_STAT:
-	case SHM_STAT_ANY:
-		buf->shm_perm.mode >>= 16;
-	}
-#endif
-#if IPC_TIME64
-	if (r >= 0 && (cmd&IPC_TIME64)) {
-		buf = orig;
-		*buf = out;
-		IPC_HILO(buf, shm_atime);
-		IPC_HILO(buf, shm_dtime);
-		IPC_HILO(buf, shm_ctime);
-	}
-#endif
-	return __syscall_ret(r);
+	return zsys_shmctl(id, cmd, buf);
 }
diff --git a/src/ipc/shmdt.c b/src/ipc/shmdt.c
index 572381378e1d..c0380c17be82 100644
--- a/src/ipc/shmdt.c
+++ b/src/ipc/shmdt.c
@@ -4,9 +4,5 @@
 
 int shmdt(const void *addr)
 {
-#ifndef SYS_ipc
-	return syscall(SYS_shmdt, addr);
-#else
-	return syscall(SYS_ipc, IPCOP_shmdt, 0, 0, 0, addr);
-#endif
+	return zsys_shmdt(addr);
 }
diff --git a/src/ipc/shmget.c b/src/ipc/shmget.c
index 7521b5fa3fca..8225a7191440 100644
--- a/src/ipc/shmget.c
+++ b/src/ipc/shmget.c
@@ -5,10 +5,5 @@
 
 int shmget(key_t key, size_t size, int flag)
 {
-	if (size > PTRDIFF_MAX) size = SIZE_MAX;
-#ifndef SYS_ipc
-	return syscall(SYS_shmget, key, size, flag);
-#else
-	return syscall(SYS_ipc, IPCOP_shmget, key, size, flag);
-#endif
+	return zsys_shmget(key, size, flag);
 }
diff --git a/src/ldso/aarch64/dlsym.s b/src/ldso/aarch64/dlsym.s
deleted file mode 100644
index abaae4d519cf..000000000000
--- a/src/ldso/aarch64/dlsym.s
+++ /dev/null
@@ -1,6 +0,0 @@
-.global dlsym
-.hidden __dlsym
-.type dlsym,%function
-dlsym:
-	mov x2,x30
-	b __dlsym
diff --git a/src/ldso/aarch64/tlsdesc.s b/src/ldso/aarch64/tlsdesc.s
deleted file mode 100644
index c6c685b3d7f0..000000000000
--- a/src/ldso/aarch64/tlsdesc.s
+++ /dev/null
@@ -1,31 +0,0 @@
-// size_t __tlsdesc_static(size_t *a)
-// {
-// 	return a[1];
-// }
-.global __tlsdesc_static
-.hidden __tlsdesc_static
-.type __tlsdesc_static,@function
-__tlsdesc_static:
-	ldr x0,[x0,#8]
-	ret
-
-// size_t __tlsdesc_dynamic(size_t *a)
-// {
-// 	struct {size_t modidx,off;} *p = (void*)a[1];
-// 	size_t *dtv = *(size_t**)(tp - 8);
-// 	return dtv[p->modidx] + p->off - tp;
-// }
-.global __tlsdesc_dynamic
-.hidden __tlsdesc_dynamic
-.type __tlsdesc_dynamic,@function
-__tlsdesc_dynamic:
-	stp x1,x2,[sp,#-16]!
-	mrs x1,tpidr_el0      // tp
-	ldr x0,[x0,#8]        // p
-	ldp x0,x2,[x0]        // p->modidx, p->off
-	sub x2,x2,x1          // p->off - tp
-	ldr x1,[x1,#-8]       // dtv
-	ldr x1,[x1,x0,lsl #3] // dtv[p->modidx]
-	add x0,x1,x2          // dtv[p->modidx] + p->off - tp
-	ldp x1,x2,[sp],#16
-	ret
diff --git a/src/ldso/arm/dlsym.s b/src/ldso/arm/dlsym.s
deleted file mode 100644
index 2652c348d795..000000000000
--- a/src/ldso/arm/dlsym.s
+++ /dev/null
@@ -1,8 +0,0 @@
-.syntax unified
-.text
-.global dlsym
-.hidden __dlsym
-.type dlsym,%function
-dlsym:
-	mov r2,lr
-	b __dlsym
diff --git a/src/ldso/arm/dlsym_time64.S b/src/ldso/arm/dlsym_time64.S
deleted file mode 100644
index bb2e70408f0e..000000000000
--- a/src/ldso/arm/dlsym_time64.S
+++ /dev/null
@@ -1,3 +0,0 @@
-#define __dlsym __dlsym_redir_time64
-#define dlsym __dlsym_time64
-#include "dlsym.s"
diff --git a/src/ldso/arm/find_exidx.c b/src/ldso/arm/find_exidx.c
deleted file mode 100644
index 77c4472bf60f..000000000000
--- a/src/ldso/arm/find_exidx.c
+++ /dev/null
@@ -1,42 +0,0 @@
-#define _GNU_SOURCE
-#include <link.h>
-#include <stdint.h>
-
-struct find_exidx_data {
-	uintptr_t pc, exidx_start;
-	int exidx_len;
-};
-
-static int find_exidx(struct dl_phdr_info *info, size_t size, void *ptr)
-{
-	struct find_exidx_data *data = ptr;
-	const ElfW(Phdr) *phdr = info->dlpi_phdr;
-	uintptr_t addr, exidx_start = 0;
-	int i, match = 0, exidx_len = 0;
-
-	for (i = info->dlpi_phnum; i > 0; i--, phdr++) {
-		addr = info->dlpi_addr + phdr->p_vaddr;
-		switch (phdr->p_type) {
-		case PT_LOAD:
-			match |= data->pc >= addr && data->pc < addr + phdr->p_memsz;
-			break;
-		case PT_ARM_EXIDX:
-			exidx_start = addr;
-			exidx_len = phdr->p_memsz;
-			break;
-		}
-	}
-	data->exidx_start = exidx_start;
-	data->exidx_len = exidx_len;
-	return match;
-}
-
-uintptr_t __gnu_Unwind_Find_exidx(uintptr_t pc, int *pcount)
-{
-	struct find_exidx_data data;
-	data.pc = pc;
-	if (dl_iterate_phdr(find_exidx, &data) <= 0)
-		return 0;
-	*pcount = data.exidx_len / 8;
-	return data.exidx_start;
-}
diff --git a/src/ldso/arm/tlsdesc.S b/src/ldso/arm/tlsdesc.S
deleted file mode 100644
index 3ae133c96b82..000000000000
--- a/src/ldso/arm/tlsdesc.S
+++ /dev/null
@@ -1,55 +0,0 @@
-.syntax unified
-
-.text
-.global __tlsdesc_static
-.hidden __tlsdesc_static
-.type __tlsdesc_static,%function
-__tlsdesc_static:
-	ldr r0,[r0]
-	bx lr
-
-.global __tlsdesc_dynamic
-.hidden __tlsdesc_dynamic
-.type __tlsdesc_dynamic,%function
-__tlsdesc_dynamic:
-	push {r2,r3,ip,lr}
-	ldr r1,[r0]
-	ldr r2,[r1,#4]  // r2 = offset
-	ldr r1,[r1]     // r1 = modid
-
-#if ((__ARM_ARCH_6K__ || __ARM_ARCH_6KZ__ || __ARM_ARCH_6ZK__) && !__thumb__) \
- || __ARM_ARCH_7A__ || __ARM_ARCH_7R__ || __ARM_ARCH >= 7
-	mrc p15,0,r0,c13,c0,3
-#else
-	ldr r0,1f
-	add r0,r0,pc
-	ldr r0,[r0]
-2:
-#if __ARM_ARCH >= 5
-	blx r0          // r0 = tp
-#else
-#if __thumb__
-	add lr,pc,#1
-#else
-	mov lr,pc
-#endif
-	bx r0
-#endif
-#endif
-	ldr r3,[r0,#-4] // r3 = dtv
-	ldr ip,[r3,r1,LSL #2]
-	sub r0,ip,r0
-	add r0,r0,r2    // r0 = r3[r1]-r0+r2
-#if __ARM_ARCH >= 5
-	pop {r2,r3,ip,pc}
-#else
-	pop {r2,r3,ip,lr}
-	bx lr
-#endif
-
-#if ((__ARM_ARCH_6K__ || __ARM_ARCH_6KZ__ || __ARM_ARCH_6ZK__) && !__thumb__) \
- || __ARM_ARCH_7A__ || __ARM_ARCH_7R__ || __ARM_ARCH >= 7
-#else
-	.align 2
-1:	.word __a_gettp_ptr - 2b
-#endif
diff --git a/src/ldso/dl_iterate_phdr.c b/src/ldso/dl_iterate_phdr.c
index 9546dd360961..8ceb1adf51ae 100644
--- a/src/ldso/dl_iterate_phdr.c
+++ b/src/ldso/dl_iterate_phdr.c
@@ -2,46 +2,11 @@
 #include <link.h>
 #include "pthread_impl.h"
 #include "libc.h"
-
-#define AUX_CNT 38
-
-extern weak hidden const size_t _DYNAMIC[];
+#include <stdfil.h>
 
 static int static_dl_iterate_phdr(int(*callback)(struct dl_phdr_info *info, size_t size, void *data), void *data)
 {
-	unsigned char *p;
-	ElfW(Phdr) *phdr, *tls_phdr=0;
-	size_t base = 0;
-	size_t n;
-	struct dl_phdr_info info;
-	size_t i, aux[AUX_CNT] = {0};
-
-	for (i=0; libc.auxv[i]; i+=2)
-		if (libc.auxv[i]<AUX_CNT) aux[libc.auxv[i]] = libc.auxv[i+1];
-
-	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
-		phdr = (void *)p;
-		if (phdr->p_type == PT_PHDR)
-			base = aux[AT_PHDR] - phdr->p_vaddr;
-		if (phdr->p_type == PT_DYNAMIC && _DYNAMIC)
-			base = (size_t)_DYNAMIC - phdr->p_vaddr;
-		if (phdr->p_type == PT_TLS)
-			tls_phdr = phdr;
-	}
-	info.dlpi_addr  = base;
-	info.dlpi_name  = "/proc/self/exe";
-	info.dlpi_phdr  = (void *)aux[AT_PHDR];
-	info.dlpi_phnum = aux[AT_PHNUM];
-	info.dlpi_adds  = 0;
-	info.dlpi_subs  = 0;
-	if (tls_phdr) {
-		info.dlpi_tls_modid = 1;
-		info.dlpi_tls_data = __tls_get_addr((tls_mod_off_t[]){1,0});
-	} else {
-		info.dlpi_tls_modid = 0;
-		info.dlpi_tls_data = 0;
-	}
-	return (callback)(&info, sizeof (info), data);
+    zerror("static_dl_iterate_phdr not implemented");
 }
 
 weak_alias(static_dl_iterate_phdr, dl_iterate_phdr);
diff --git a/src/ldso/dlclose.c b/src/ldso/dlclose.c
index e437422a675a..b8d03d63d1f5 100644
--- a/src/ldso/dlclose.c
+++ b/src/ldso/dlclose.c
@@ -3,5 +3,6 @@
 
 int dlclose(void *p)
 {
-	return __dl_invalid_handle(p);
+    /* FIXME: We could, and should, implement dlclosing eventually. */
+    return 0;
 }
diff --git a/src/ldso/dlopen.c b/src/ldso/dlopen.c
index 69372a220bb1..e01ccee315fd 100644
--- a/src/ldso/dlopen.c
+++ b/src/ldso/dlopen.c
@@ -1,10 +1,10 @@
 #include <dlfcn.h>
 #include "dynlink.h"
+#include <pizlonated_syscalls.h>
 
 static void *stub_dlopen(const char *file, int mode)
 {
-	__dl_seterr("Dynamic loading not supported");
-	return 0;
+    return zsys_dlopen(file, mode);
 }
 
 weak_alias(stub_dlopen, dlopen);
diff --git a/src/ldso/dlsym.c b/src/ldso/dlsym.c
index 65eb27659f7b..b9b4d24b1236 100644
--- a/src/ldso/dlsym.c
+++ b/src/ldso/dlsym.c
@@ -1,7 +1,8 @@
 #include <dlfcn.h>
 #include "dynlink.h"
+#include <pizlonated_syscalls.h>
 
 void *dlsym(void *restrict p, const char *restrict s)
 {
-	return __dlsym(p, s, 0);
+    return zsys_dlsym(p, s);
 }
diff --git a/src/ldso/i386/dlsym.s b/src/ldso/i386/dlsym.s
deleted file mode 100644
index 097e30ce9cee..000000000000
--- a/src/ldso/i386/dlsym.s
+++ /dev/null
@@ -1,11 +0,0 @@
-.text
-.global dlsym
-.hidden __dlsym
-.type dlsym,@function
-dlsym:
-	push (%esp)
-	push 12(%esp)
-	push 12(%esp)
-	call __dlsym
-	add $12,%esp
-	ret
diff --git a/src/ldso/i386/dlsym_time64.S b/src/ldso/i386/dlsym_time64.S
deleted file mode 100644
index bb2e70408f0e..000000000000
--- a/src/ldso/i386/dlsym_time64.S
+++ /dev/null
@@ -1,3 +0,0 @@
-#define __dlsym __dlsym_redir_time64
-#define dlsym __dlsym_time64
-#include "dlsym.s"
diff --git a/src/ldso/i386/tlsdesc.s b/src/ldso/i386/tlsdesc.s
deleted file mode 100644
index 32c81766915b..000000000000
--- a/src/ldso/i386/tlsdesc.s
+++ /dev/null
@@ -1,23 +0,0 @@
-.text
-.global __tlsdesc_static
-.hidden __tlsdesc_static
-.type __tlsdesc_static,@function
-__tlsdesc_static:
-	mov 4(%eax),%eax
-	ret
-
-.global __tlsdesc_dynamic
-.hidden __tlsdesc_dynamic
-.type __tlsdesc_dynamic,@function
-__tlsdesc_dynamic:
-	mov 4(%eax),%eax
-	push %edx
-	mov %gs:4,%edx
-	push %ecx
-	mov (%eax),%ecx
-	mov 4(%eax),%eax
-	add (%edx,%ecx,4),%eax
-	pop %ecx
-	sub %gs:0,%eax
-	pop %edx
-	ret
diff --git a/src/ldso/m68k/dlsym.s b/src/ldso/m68k/dlsym.s
deleted file mode 100644
index 5209ae1b593f..000000000000
--- a/src/ldso/m68k/dlsym.s
+++ /dev/null
@@ -1,12 +0,0 @@
-.text
-.global dlsym
-.hidden __dlsym
-.type dlsym,@function
-dlsym:
-	move.l (%sp),-(%sp)
-	move.l 12(%sp),-(%sp)
-	move.l 12(%sp),-(%sp)
-	lea __dlsym-.-8,%a1
-	jsr (%pc,%a1)
-	add.l #12,%sp
-	rts
diff --git a/src/ldso/m68k/dlsym_time64.S b/src/ldso/m68k/dlsym_time64.S
deleted file mode 100644
index bb2e70408f0e..000000000000
--- a/src/ldso/m68k/dlsym_time64.S
+++ /dev/null
@@ -1,3 +0,0 @@
-#define __dlsym __dlsym_redir_time64
-#define dlsym __dlsym_time64
-#include "dlsym.s"
diff --git a/src/ldso/microblaze/dlsym.s b/src/ldso/microblaze/dlsym.s
deleted file mode 100644
index ea9d8be09dab..000000000000
--- a/src/ldso/microblaze/dlsym.s
+++ /dev/null
@@ -1,6 +0,0 @@
-.global dlsym
-.hidden __dlsym
-.type   dlsym,@function
-dlsym:
-	brid    __dlsym
-	add     r7, r15, r0
diff --git a/src/ldso/microblaze/dlsym_time64.S b/src/ldso/microblaze/dlsym_time64.S
deleted file mode 100644
index bb2e70408f0e..000000000000
--- a/src/ldso/microblaze/dlsym_time64.S
+++ /dev/null
@@ -1,3 +0,0 @@
-#define __dlsym __dlsym_redir_time64
-#define dlsym __dlsym_time64
-#include "dlsym.s"
diff --git a/src/ldso/mips/dlsym.s b/src/ldso/mips/dlsym.s
deleted file mode 100644
index 1573e519380e..000000000000
--- a/src/ldso/mips/dlsym.s
+++ /dev/null
@@ -1,17 +0,0 @@
-.set noreorder
-.global dlsym
-.hidden __dlsym
-.type dlsym,@function
-dlsym:
-	lui $gp, %hi(_gp_disp)
-	addiu $gp, %lo(_gp_disp)
-	addu $gp, $gp, $25
-	move $6, $ra
-	lw $25, %call16(__dlsym)($gp)
-	addiu $sp, $sp, -16
-	sw $ra, 12($sp)
-	jalr $25
-	nop
-	lw $ra, 12($sp)
-	jr $ra
-	addiu $sp, $sp, 16
diff --git a/src/ldso/mips/dlsym_time64.S b/src/ldso/mips/dlsym_time64.S
deleted file mode 100644
index bb2e70408f0e..000000000000
--- a/src/ldso/mips/dlsym_time64.S
+++ /dev/null
@@ -1,3 +0,0 @@
-#define __dlsym __dlsym_redir_time64
-#define dlsym __dlsym_time64
-#include "dlsym.s"
diff --git a/src/ldso/mips64/dlsym.s b/src/ldso/mips64/dlsym.s
deleted file mode 100644
index 32e0dddc4036..000000000000
--- a/src/ldso/mips64/dlsym.s
+++ /dev/null
@@ -1,17 +0,0 @@
-.set	noreorder
-.global	dlsym
-.hidden	__dlsym
-.type	dlsym,@function
-dlsym:
-	lui	$3, %hi(%neg(%gp_rel(dlsym)))
-	daddiu	$3, $3, %lo(%neg(%gp_rel(dlsym)))
-	daddu	$3, $3, $25
-	move	$6, $ra
-	ld	$25, %got_disp(__dlsym)($3)
-	daddiu	$sp, $sp, -32
-	sd	$ra, 24($sp)
-	jalr	$25
-	nop
-	ld	$ra, 24($sp)
-	jr	$ra
-	daddiu	$sp, $sp, 32
diff --git a/src/ldso/mipsn32/dlsym.s b/src/ldso/mipsn32/dlsym.s
deleted file mode 100644
index 1c82da300336..000000000000
--- a/src/ldso/mipsn32/dlsym.s
+++ /dev/null
@@ -1,17 +0,0 @@
-.set	noreorder
-.global	dlsym
-.hidden	__dlsym
-.type	dlsym,@function
-dlsym:
-	lui	$3, %hi(%neg(%gp_rel(dlsym)))
-	addiu	$3, $3, %lo(%neg(%gp_rel(dlsym)))
-	addu	$3, $3, $25
-	move	$6, $ra
-	lw	$25, %got_disp(__dlsym)($3)
-	addiu	$sp, $sp, -32
-	sd	$ra, 16($sp)
-	jalr	$25
-	nop
-	ld	$ra, 16($sp)
-	jr	$ra
-	addiu	$sp, $sp, 32
diff --git a/src/ldso/mipsn32/dlsym_time64.S b/src/ldso/mipsn32/dlsym_time64.S
deleted file mode 100644
index bb2e70408f0e..000000000000
--- a/src/ldso/mipsn32/dlsym_time64.S
+++ /dev/null
@@ -1,3 +0,0 @@
-#define __dlsym __dlsym_redir_time64
-#define dlsym __dlsym_time64
-#include "dlsym.s"
diff --git a/src/ldso/or1k/dlsym.s b/src/ldso/or1k/dlsym.s
deleted file mode 100644
index 122475c158b8..000000000000
--- a/src/ldso/or1k/dlsym.s
+++ /dev/null
@@ -1,6 +0,0 @@
-.global dlsym
-.hidden __dlsym
-.type   dlsym,@function
-dlsym:
-	l.j	__dlsym
-	 l.ori	r5, r9, 0
diff --git a/src/ldso/or1k/dlsym_time64.S b/src/ldso/or1k/dlsym_time64.S
deleted file mode 100644
index bb2e70408f0e..000000000000
--- a/src/ldso/or1k/dlsym_time64.S
+++ /dev/null
@@ -1,3 +0,0 @@
-#define __dlsym __dlsym_redir_time64
-#define dlsym __dlsym_time64
-#include "dlsym.s"
diff --git a/src/ldso/powerpc/dlsym.s b/src/ldso/powerpc/dlsym.s
deleted file mode 100644
index cfe308ef57d2..000000000000
--- a/src/ldso/powerpc/dlsym.s
+++ /dev/null
@@ -1,8 +0,0 @@
-	.text
-	.global dlsym
-	.hidden __dlsym
-	.type   dlsym,@function
-dlsym:
-	mflr    5                      # The return address is arg3.
-	b       __dlsym
-	.size   dlsym, .-dlsym
diff --git a/src/ldso/powerpc/dlsym_time64.S b/src/ldso/powerpc/dlsym_time64.S
deleted file mode 100644
index bb2e70408f0e..000000000000
--- a/src/ldso/powerpc/dlsym_time64.S
+++ /dev/null
@@ -1,3 +0,0 @@
-#define __dlsym __dlsym_redir_time64
-#define dlsym __dlsym_time64
-#include "dlsym.s"
diff --git a/src/ldso/powerpc64/dlsym.s b/src/ldso/powerpc64/dlsym.s
deleted file mode 100644
index a14715fd4dc7..000000000000
--- a/src/ldso/powerpc64/dlsym.s
+++ /dev/null
@@ -1,11 +0,0 @@
-	.text
-	.global dlsym
-	.hidden __dlsym
-	.type   dlsym,@function
-dlsym:
-	addis   2, 12, .TOC.-dlsym@ha
-	addi    2,  2, .TOC.-dlsym@l
-	.localentry dlsym,.-dlsym
-	mflr    5                      # The return address is arg3.
-	b       __dlsym
-	.size   dlsym, .-dlsym
diff --git a/src/ldso/riscv64/dlsym.s b/src/ldso/riscv64/dlsym.s
deleted file mode 100644
index 2bafd72d3eda..000000000000
--- a/src/ldso/riscv64/dlsym.s
+++ /dev/null
@@ -1,6 +0,0 @@
-.global dlsym
-.hidden __dlsym
-.type dlsym, %function
-dlsym:
-	mv a2, ra
-	tail __dlsym
diff --git a/src/ldso/s390x/dlsym.s b/src/ldso/s390x/dlsym.s
deleted file mode 100644
index 2e9fa8fb4b54..000000000000
--- a/src/ldso/s390x/dlsym.s
+++ /dev/null
@@ -1,6 +0,0 @@
-	.global dlsym
-	.hidden __dlsym
-	.type   dlsym,@function
-dlsym:
-	lgr %r4, %r14
-	jg __dlsym
diff --git a/src/ldso/sh/dlsym.s b/src/ldso/sh/dlsym.s
deleted file mode 100644
index 11a6fff5ff63..000000000000
--- a/src/ldso/sh/dlsym.s
+++ /dev/null
@@ -1,11 +0,0 @@
-.text
-.global dlsym
-.hidden __dlsym
-.type   dlsym, @function
-dlsym:
-	mov.l L1, r0
-1:	braf  r0
-	 mov.l @r15, r6
-
-.align 2
-L1:	.long __dlsym@PLT-(1b+4-.)
diff --git a/src/ldso/sh/dlsym_time64.S b/src/ldso/sh/dlsym_time64.S
deleted file mode 100644
index bb2e70408f0e..000000000000
--- a/src/ldso/sh/dlsym_time64.S
+++ /dev/null
@@ -1,3 +0,0 @@
-#define __dlsym __dlsym_redir_time64
-#define dlsym __dlsym_time64
-#include "dlsym.s"
diff --git a/src/ldso/x32/dlsym.s b/src/ldso/x32/dlsym.s
deleted file mode 100644
index d840b955c36e..000000000000
--- a/src/ldso/x32/dlsym.s
+++ /dev/null
@@ -1,7 +0,0 @@
-.text
-.global dlsym
-.hidden __dlsym
-.type dlsym,@function
-dlsym:
-	mov (%rsp),%rdx
-	jmp __dlsym
diff --git a/src/ldso/x86_64/dlsym.s b/src/ldso/x86_64/dlsym.s
deleted file mode 100644
index d840b955c36e..000000000000
--- a/src/ldso/x86_64/dlsym.s
+++ /dev/null
@@ -1,7 +0,0 @@
-.text
-.global dlsym
-.hidden __dlsym
-.type dlsym,@function
-dlsym:
-	mov (%rsp),%rdx
-	jmp __dlsym
diff --git a/src/ldso/x86_64/tlsdesc.s b/src/ldso/x86_64/tlsdesc.s
deleted file mode 100644
index e08f1d7df589..000000000000
--- a/src/ldso/x86_64/tlsdesc.s
+++ /dev/null
@@ -1,23 +0,0 @@
-.text
-.global __tlsdesc_static
-.hidden __tlsdesc_static
-.type __tlsdesc_static,@function
-__tlsdesc_static:
-	mov 8(%rax),%rax
-	ret
-
-.global __tlsdesc_dynamic
-.hidden __tlsdesc_dynamic
-.type __tlsdesc_dynamic,@function
-__tlsdesc_dynamic:
-	mov 8(%rax),%rax
-	push %rdx
-	mov %fs:8,%rdx
-	push %rcx
-	mov (%rax),%rcx
-	mov 8(%rax),%rax
-	add (%rdx,%rcx,8),%rax
-	pop %rcx
-	sub %fs:0,%rax
-	pop %rdx
-	ret
diff --git a/src/linux/chroot.c b/src/linux/chroot.c
index 0e69f145dee3..702467d155f0 100644
--- a/src/linux/chroot.c
+++ b/src/linux/chroot.c
@@ -1,8 +1,9 @@
 #define _GNU_SOURCE
 #include <unistd.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int chroot(const char *path)
 {
-	return syscall(SYS_chroot, path);
+	return zsys_chroot(path);
 }
diff --git a/src/linux/copy_file_range.c b/src/linux/copy_file_range.c
index dd4b13333622..fe1f51ab85bf 100644
--- a/src/linux/copy_file_range.c
+++ b/src/linux/copy_file_range.c
@@ -4,5 +4,5 @@
 
 ssize_t copy_file_range(int fd_in, off_t *off_in, int fd_out, off_t *off_out, size_t len, unsigned flags)
 {
-	return syscall(SYS_copy_file_range, fd_in, off_in, fd_out, off_out, len, flags);
+        return zsys_copy_file_range(fd_in, off_in, fd_out, off_out, len, flags);
 }
diff --git a/src/linux/epoll.c b/src/linux/epoll.c
index e56e8f4c8293..90be455753a4 100644
--- a/src/linux/epoll.c
+++ b/src/linux/epoll.c
@@ -11,28 +11,20 @@ int epoll_create(int size)
 
 int epoll_create1(int flags)
 {
-	int r = __syscall(SYS_epoll_create1, flags);
-#ifdef SYS_epoll_create
-	if (r==-ENOSYS && !flags) r = __syscall(SYS_epoll_create, 1);
-#endif
-	return __syscall_ret(r);
+	return zsys_epoll_create1(flags);
 }
 
 int epoll_ctl(int fd, int op, int fd2, struct epoll_event *ev)
 {
-	return syscall(SYS_epoll_ctl, fd, op, fd2, ev);
+	return zsys_epoll_ctl(fd, op, fd2, ev);
 }
 
 int epoll_pwait(int fd, struct epoll_event *ev, int cnt, int to, const sigset_t *sigs)
 {
-	int r = __syscall_cp(SYS_epoll_pwait, fd, ev, cnt, to, sigs, _NSIG/8);
-#ifdef SYS_epoll_wait
-	if (r==-ENOSYS && !sigs) r = __syscall_cp(SYS_epoll_wait, fd, ev, cnt, to);
-#endif
-	return __syscall_ret(r);
+	return zsys_epoll_pwait(fd, ev, cnt, to, sigs);
 }
 
 int epoll_wait(int fd, struct epoll_event *ev, int cnt, int to)
 {
-	return epoll_pwait(fd, ev, cnt, to, 0);
+	return zsys_epoll_wait(fd, ev, cnt, to);
 }
diff --git a/src/linux/eventfd.c b/src/linux/eventfd.c
index 68e489c83647..f21b99b0fdf7 100644
--- a/src/linux/eventfd.c
+++ b/src/linux/eventfd.c
@@ -5,11 +5,7 @@
 
 int eventfd(unsigned int count, int flags)
 {
-	int r = __syscall(SYS_eventfd2, count, flags);
-#ifdef SYS_eventfd
-	if (r==-ENOSYS && !flags) r = __syscall(SYS_eventfd, count);
-#endif
-	return __syscall_ret(r);
+	return zsys_eventfd(count, flags);
 }
 
 int eventfd_read(int fd, eventfd_t *value)
diff --git a/src/linux/flock.c b/src/linux/flock.c
index 87aa5cfed275..8be2428093c7 100644
--- a/src/linux/flock.c
+++ b/src/linux/flock.c
@@ -3,5 +3,5 @@
 
 int flock(int fd, int op)
 {
-	return syscall(SYS_flock, fd, op);
+	return zsys_flock(fd, op);
 }
diff --git a/src/linux/getdents.c b/src/linux/getdents.c
index 97f76e147941..b7f64587e988 100644
--- a/src/linux/getdents.c
+++ b/src/linux/getdents.c
@@ -5,6 +5,5 @@
 
 int getdents(int fd, struct dirent *buf, size_t len)
 {
-	if (len>INT_MAX) len = INT_MAX;
-	return syscall(SYS_getdents, fd, buf, len);
+	return zsys_getdents(fd, buf, len);
 }
diff --git a/src/linux/getrandom.c b/src/linux/getrandom.c
index 6cc6f6b047c1..960911bb9d6a 100644
--- a/src/linux/getrandom.c
+++ b/src/linux/getrandom.c
@@ -3,5 +3,5 @@
 
 ssize_t getrandom(void *buf, size_t buflen, unsigned flags)
 {
-	return syscall_cp(SYS_getrandom, buf, buflen, flags);
+	return zsys_getrandom(buf, buflen, flags);
 }
diff --git a/src/linux/inotify.c b/src/linux/inotify.c
index df5e48b31b7e..dbad94c17d75 100644
--- a/src/linux/inotify.c
+++ b/src/linux/inotify.c
@@ -8,19 +8,15 @@ int inotify_init()
 }
 int inotify_init1(int flags)
 {
-	int r = __syscall(SYS_inotify_init1, flags);
-#ifdef SYS_inotify_init
-	if (r==-ENOSYS && !flags) r = __syscall(SYS_inotify_init);
-#endif
-	return __syscall_ret(r);
+        return zsys_inotify_init1(flags);
 }
 
 int inotify_add_watch(int fd, const char *pathname, uint32_t mask)
 {
-	return syscall(SYS_inotify_add_watch, fd, pathname, mask);
+        return zsys_inotify_add_watch(fd, pathname, mask);
 }
 
 int inotify_rm_watch(int fd, int wd)
 {
-	return syscall(SYS_inotify_rm_watch, fd, wd);
+        return zsys_inotify_rm_watch(fd, wd);
 }
diff --git a/src/linux/membarrier.c b/src/linux/membarrier.c
index f64fe7e189fb..5850af45fd08 100644
--- a/src/linux/membarrier.c
+++ b/src/linux/membarrier.c
@@ -55,18 +55,4 @@ int __membarrier(int cmd, int flags)
 	return __syscall_ret(r);
 }
 
-void __membarrier_init(void)
-{
-	/* If membarrier is linked, attempt to pre-register to be able to use
-	 * the private expedited command before the process becomes multi-
-	 * threaded, since registering later has bad, potentially unbounded
-	 * latency. This syscall should be essentially free, and it's arguably
-	 * a mistake in the API design that registration was even required.
-	 * For other commands, registration may impose some cost, so it's left
-	 * to the application to do so if desired. Unfortunately this means
-	 * library code initialized after the process becomes multi-threaded
-	 * cannot use these features without accepting registration latency. */
-	__syscall(SYS_membarrier, MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED, 0);
-}
-
 weak_alias(__membarrier, membarrier);
diff --git a/src/linux/mount.c b/src/linux/mount.c
index 34e11af12035..52462e84aba6 100644
--- a/src/linux/mount.c
+++ b/src/linux/mount.c
@@ -3,15 +3,15 @@
 
 int mount(const char *special, const char *dir, const char *fstype, unsigned long flags, const void *data)
 {
-	return syscall(SYS_mount, special, dir, fstype, flags, data);
+        return zsys_mount(special, dir, fstype, flags, data);
 }
 
 int umount(const char *special)
 {
-	return syscall(SYS_umount2, special, 0);
+        return zsys_umount2(special, 0);
 }
 
 int umount2(const char *special, int flags)
 {
-	return syscall(SYS_umount2, special, flags);
+        return zsys_umount2(special, flags);
 }
diff --git a/src/linux/ppoll.c b/src/linux/ppoll.c
index e614600ab8b7..e863c47df9d2 100644
--- a/src/linux/ppoll.c
+++ b/src/linux/ppoll.c
@@ -4,23 +4,7 @@
 #include <errno.h>
 #include "syscall.h"
 
-#define IS32BIT(x) !((x)+0x80000000ULL>>32)
-#define CLAMP(x) (int)(IS32BIT(x) ? (x) : 0x7fffffffU+((0ULL+(x))>>63))
-
 int ppoll(struct pollfd *fds, nfds_t n, const struct timespec *to, const sigset_t *mask)
 {
-	time_t s = to ? to->tv_sec : 0;
-	long ns = to ? to->tv_nsec : 0;
-#ifdef SYS_ppoll_time64
-	int r = -ENOSYS;
-	if (SYS_ppoll == SYS_ppoll_time64 || !IS32BIT(s))
-		r = __syscall_cp(SYS_ppoll_time64, fds, n,
-			to ? ((long long[]){s, ns}) : 0,
-			mask, _NSIG/8);
-	if (SYS_ppoll == SYS_ppoll_time64 || r != -ENOSYS)
-		return __syscall_ret(r);
-	s = CLAMP(s);
-#endif
-	return syscall_cp(SYS_ppoll, fds, n,
-		to ? ((long[]){s, ns}) : 0, mask, _NSIG/8);
+	return zsys_ppoll(fds, n, to, mask);
 }
diff --git a/src/linux/prctl.c b/src/linux/prctl.c
index 19f4267cdeda..1824502b21e3 100644
--- a/src/linux/prctl.c
+++ b/src/linux/prctl.c
@@ -2,13 +2,7 @@
 #include <stdarg.h>
 #include "syscall.h"
 
-int prctl(int op, ...)
+__attribute__((__noinline__)) int prctl(int op, ...)
 {
-	unsigned long x[4];
-	int i;
-	va_list ap;
-	va_start(ap, op);
-	for (i=0; i<4; i++) x[i] = va_arg(ap, unsigned long);
-	va_end(ap);
-	return syscall(SYS_prctl, op, x[0], x[1], x[2], x[3]);
+	return *(int*)zcall(zsys_prctl, zargs());
 }
diff --git a/src/linux/reboot.c b/src/linux/reboot.c
index 7f12af79bc1b..951a784a563b 100644
--- a/src/linux/reboot.c
+++ b/src/linux/reboot.c
@@ -3,5 +3,5 @@
 
 int reboot(int type)
 {
-	return syscall(SYS_reboot, 0xfee1dead, 672274793, type);
+	return zsys_reboot(type);
 }
diff --git a/src/linux/sendfile.c b/src/linux/sendfile.c
index fc1577d34330..41c62d201bcd 100644
--- a/src/linux/sendfile.c
+++ b/src/linux/sendfile.c
@@ -3,5 +3,5 @@
 
 ssize_t sendfile(int out_fd, int in_fd, off_t *ofs, size_t count)
 {
-	return syscall(SYS_sendfile, out_fd, in_fd, ofs, count);
+	return zsys_sendfile(out_fd, in_fd, ofs, count);
 }
diff --git a/src/linux/setgroups.c b/src/linux/setgroups.c
index 47142f141ff5..027a5e230ad2 100644
--- a/src/linux/setgroups.c
+++ b/src/linux/setgroups.c
@@ -3,34 +3,9 @@
 #include <signal.h>
 #include "syscall.h"
 #include "libc.h"
-
-struct ctx {
-	size_t count;
-	const gid_t *list;
-	int ret;
-};
-
-static void do_setgroups(void *p)
-{
-	struct ctx *c = p;
-	if (c->ret<0) return;
-	int ret = __syscall(SYS_setgroups, c->count, c->list);
-	if (ret && !c->ret) {
-		/* If one thread fails to set groups after another has already
-		 * succeeded, forcibly killing the process is the only safe
-		 * thing to do. State is inconsistent and dangerous. Use
-		 * SIGKILL because it is uncatchable. */
-		__block_all_sigs(0);
-		__syscall(SYS_kill, __syscall(SYS_getpid), SIGKILL);
-	}
-	c->ret = ret;
-}
+#include <stdfil.h>
 
 int setgroups(size_t count, const gid_t list[])
 {
-	/* ret is initially nonzero so that failure of the first thread does not
-	 * trigger the safety kill above. */
-	struct ctx c = { .count = count, .list = list, .ret = 1 };
-	__synccall(do_setgroups, &c);
-	return __syscall_ret(c.ret);
+    return zsys_setgroups(count, list);
 }
diff --git a/src/linux/signalfd.c b/src/linux/signalfd.c
index 4bf43326fe5a..42a561ac3010 100644
--- a/src/linux/signalfd.c
+++ b/src/linux/signalfd.c
@@ -6,16 +6,5 @@
 
 int signalfd(int fd, const sigset_t *sigs, int flags)
 {
-	int ret = __syscall(SYS_signalfd4, fd, sigs, _NSIG/8, flags);
-#ifdef SYS_signalfd
-	if (ret != -ENOSYS) return __syscall_ret(ret);
-	ret = __syscall(SYS_signalfd, fd, sigs, _NSIG/8);
-	if (ret >= 0) {
-		if (flags & SFD_CLOEXEC)
-			__syscall(SYS_fcntl, ret, F_SETFD, FD_CLOEXEC);
-		if (flags & SFD_NONBLOCK)
-			__syscall(SYS_fcntl, ret, F_SETFL, O_NONBLOCK);
-	}
-#endif
-	return __syscall_ret(ret);
+	return zsys_signalfd(fd, sigs, flags);
 }
diff --git a/src/linux/splice.c b/src/linux/splice.c
index 78b6220d8e61..39f00eda98f9 100644
--- a/src/linux/splice.c
+++ b/src/linux/splice.c
@@ -4,5 +4,5 @@
 
 ssize_t splice(int fd_in, off_t *off_in, int fd_out, off_t *off_out, size_t len, unsigned flags)
 {
-	return syscall(SYS_splice, fd_in, off_in, fd_out, off_out, len, flags);
+	return zsys_splice(fd_in, off_in, fd_out, off_out, len, flags);
 }
diff --git a/src/linux/sysinfo.c b/src/linux/sysinfo.c
index db86476d0f26..458759a0ef3c 100644
--- a/src/linux/sysinfo.c
+++ b/src/linux/sysinfo.c
@@ -3,7 +3,7 @@
 
 int __lsysinfo(struct sysinfo *info)
 {
-	return syscall(SYS_sysinfo, info);
+	return zsys_sysinfo(info);
 }
 
 weak_alias(__lsysinfo, sysinfo);
diff --git a/src/linux/tee.c b/src/linux/tee.c
index a24748cfb01d..0cdc256b41af 100644
--- a/src/linux/tee.c
+++ b/src/linux/tee.c
@@ -4,5 +4,5 @@
 
 ssize_t tee(int src, int dest, size_t len, unsigned flags)
 {
-	return syscall(SYS_tee, src, dest, len, flags);
+	return zsys_tee(src, dest, len, flags);
 }
diff --git a/src/linux/timerfd.c b/src/linux/timerfd.c
index 5bdfaf165691..b3cab128fb7f 100644
--- a/src/linux/timerfd.c
+++ b/src/linux/timerfd.c
@@ -2,58 +2,17 @@
 #include <errno.h>
 #include "syscall.h"
 
-#define IS32BIT(x) !((x)+0x80000000ULL>>32)
-
 int timerfd_create(int clockid, int flags)
 {
-	return syscall(SYS_timerfd_create, clockid, flags);
+	return zsys_timerfd_create(clockid, flags);
 }
 
 int timerfd_settime(int fd, int flags, const struct itimerspec *new, struct itimerspec *old)
 {
-#ifdef SYS_timerfd_settime64
-	time_t is = new->it_interval.tv_sec, vs = new->it_value.tv_sec;
-	long ins = new->it_interval.tv_nsec, vns = new->it_value.tv_nsec;
-	int r = -ENOSYS;
-	if (SYS_timerfd_settime == SYS_timerfd_settime64
-	    || !IS32BIT(is) || !IS32BIT(vs) || (sizeof(time_t)>4 && old))
-		r = __syscall(SYS_timerfd_settime64, fd, flags,
-			((long long[]){is, ins, vs, vns}), old);
-	if (SYS_timerfd_settime == SYS_timerfd_settime64 || r!=-ENOSYS)
-		return __syscall_ret(r);
-	if (!IS32BIT(is) || !IS32BIT(vs))
-		return __syscall_ret(-ENOTSUP);
-	long old32[4];
-	r = __syscall(SYS_timerfd_settime, fd, flags,
-		((long[]){is, ins, vs, vns}), old32);
-	if (!r && old) {
-		old->it_interval.tv_sec = old32[0];
-		old->it_interval.tv_nsec = old32[1];
-		old->it_value.tv_sec = old32[2];
-		old->it_value.tv_nsec = old32[3];
-	}
-	return __syscall_ret(r);
-#endif
-	return syscall(SYS_timerfd_settime, fd, flags, new, old);
+	return zsys_timerfd_settime(fd, flags, new, old);
 }
 
 int timerfd_gettime(int fd, struct itimerspec *cur)
 {
-#ifdef SYS_timerfd_gettime64
-	int r = -ENOSYS;
-	if (sizeof(time_t) > 4)
-		r = __syscall(SYS_timerfd_gettime64, fd, cur);
-	if (SYS_timerfd_gettime == SYS_timerfd_gettime64 || r!=-ENOSYS)
-		return __syscall_ret(r);
-	long cur32[4];
-	r = __syscall(SYS_timerfd_gettime, fd, cur32);
-	if (!r) {
-		cur->it_interval.tv_sec = cur32[0];
-		cur->it_interval.tv_nsec = cur32[1];
-		cur->it_value.tv_sec = cur32[2];
-		cur->it_value.tv_nsec = cur32[3];
-	}
-	return __syscall_ret(r);
-#endif
-	return syscall(SYS_timerfd_gettime, fd, cur);
+	return zsys_timerfd_gettime(fd, cur);
 }
diff --git a/src/linux/wait4.c b/src/linux/wait4.c
index ff2e3e664900..5709c3d2283d 100644
--- a/src/linux/wait4.c
+++ b/src/linux/wait4.c
@@ -7,33 +7,5 @@
 
 pid_t wait4(pid_t pid, int *status, int options, struct rusage *ru)
 {
-	int r;
-#ifdef SYS_wait4_time64
-	if (ru) {
-		long long kru64[18];
-		r = __syscall(SYS_wait4_time64, pid, status, options, kru64);
-		if (r > 0) {
-			ru->ru_utime = (struct timeval)
-				{ .tv_sec = kru64[0], .tv_usec = kru64[1] };
-			ru->ru_stime = (struct timeval)
-				{ .tv_sec = kru64[2], .tv_usec = kru64[3] };
-			char *slots = (char *)&ru->ru_maxrss;
-			for (int i=0; i<14; i++)
-				*(long *)(slots + i*sizeof(long)) = kru64[4+i];
-		}
-		if (SYS_wait4_time64 == SYS_wait4 || r != -ENOSYS)
-			return __syscall_ret(r);
-	}
-#endif
-	char *dest = ru ? (char *)&ru->ru_maxrss - 4*sizeof(long) : 0;
-	r = __syscall(SYS_wait4, pid, status, options, dest);
-	if (r>0 && ru && sizeof(time_t) > sizeof(long)) {
-		long kru[4];
-		memcpy(kru, dest, 4*sizeof(long));
-		ru->ru_utime = (struct timeval)
-			{ .tv_sec = kru[0], .tv_usec = kru[1] };
-		ru->ru_stime = (struct timeval)
-			{ .tv_sec = kru[2], .tv_usec = kru[3] };
-	}
-	return __syscall_ret(r);
+	return zsys_wait4(pid, status, options, ru);
 }
diff --git a/src/linux/xattr.c b/src/linux/xattr.c
index fea0d209ace7..9d917b42829f 100644
--- a/src/linux/xattr.c
+++ b/src/linux/xattr.c
@@ -3,60 +3,60 @@
 
 ssize_t getxattr(const char *path, const char *name, void *value, size_t size)
 {
-	return syscall(SYS_getxattr, path, name, value, size);
+	return zsys_getxattr(path, name, value, size);
 }
 
 ssize_t lgetxattr(const char *path, const char *name, void *value, size_t size)
 {
-	return syscall(SYS_lgetxattr, path, name, value, size);
+	return zsys_lgetxattr(path, name, value, size);
 }
 
 ssize_t fgetxattr(int filedes, const char *name, void *value, size_t size)
 {
-	return syscall(SYS_fgetxattr, filedes, name, value, size);
+	return zsys_fgetxattr(filedes, name, value, size);
 }
 
 ssize_t listxattr(const char *path, char *list, size_t size)
 {
-	return syscall(SYS_listxattr, path, list, size);
+	return zsys_listxattr(path, list, size);
 }
 
 ssize_t llistxattr(const char *path, char *list, size_t size)
 {
-	return syscall(SYS_llistxattr, path, list, size);
+	return zsys_llistxattr(path, list, size);
 }
 
 ssize_t flistxattr(int filedes, char *list, size_t size)
 {
-	return syscall(SYS_flistxattr, filedes, list, size);
+	return zsys_flistxattr(filedes, list, size);
 }
 
 int setxattr(const char *path, const char *name, const void *value, size_t size, int flags)
 {
-	return syscall(SYS_setxattr, path, name, value, size, flags);
+	return zsys_setxattr(path, name, value, size, flags);
 }
 
 int lsetxattr(const char *path, const char *name, const void *value, size_t size, int flags)
 {
-	return syscall(SYS_lsetxattr, path, name, value, size, flags);
+	return zsys_lsetxattr(path, name, value, size, flags);
 }
 
 int fsetxattr(int filedes, const char *name, const void *value, size_t size, int flags)
 {
-	return syscall(SYS_fsetxattr, filedes, name, value, size, flags);
+	return zsys_fsetxattr(filedes, name, value, size, flags);
 }
 
 int removexattr(const char *path, const char *name)
 {
-	return syscall(SYS_removexattr, path, name);
+	return zsys_removexattr(path, name);
 }
 
 int lremovexattr(const char *path, const char *name)
 {
-	return syscall(SYS_lremovexattr, path, name);
+	return zsys_lremovexattr(path, name);
 }
 
 int fremovexattr(int fd, const char *name)
 {
-	return syscall(SYS_fremovexattr, fd, name);
+	return zsys_fremovexattr(fd, name);
 }
diff --git a/src/locale/locale_map.c b/src/locale/locale_map.c
index da61f7fc032c..d31a9447fd4c 100644
--- a/src/locale/locale_map.c
+++ b/src/locale/locale_map.c
@@ -6,6 +6,7 @@
 #include "libc.h"
 #include "lock.h"
 #include "fork_impl.h"
+#include <stdfil.h>
 
 #define malloc __libc_malloc
 #define calloc undef
@@ -77,7 +78,7 @@ const struct __locale_map *__get_locale(int cat, const char *val)
 		size_t map_size;
 		const void *map = __map_file(buf, &map_size);
 		if (map) {
-			new = malloc(sizeof *new);
+                        new = zgc_alloc(sizeof(*new));
 			if (!new) {
 				__munmap((void *)map, map_size);
 				break;
@@ -96,7 +97,7 @@ const struct __locale_map *__get_locale(int cat, const char *val)
 	 * object anyway to store the name, which is kept for the
 	 * sake of being able to do message translations at the
 	 * application level. */
-	if (!new && (new = malloc(sizeof *new))) {
+	if (!new && (new = zgc_alloc(sizeof(*new)))) {
 		new->map = __c_dot_utf8.map;
 		new->map_size = __c_dot_utf8.map_size;
 		memcpy(new->name, val, n);
diff --git a/src/malloc/aligned_alloc.c b/src/malloc/aligned_alloc.c
new file mode 100644
index 000000000000..57305f630f27
--- /dev/null
+++ b/src/malloc/aligned_alloc.c
@@ -0,0 +1,7 @@
+#include <stdlib.h>
+#include <stdfil.h>
+
+void* aligned_alloc(size_t alignment, size_t size)
+{
+    return zgc_aligned_alloc(alignment, size);
+}
diff --git a/src/malloc/calloc.c b/src/malloc/calloc.c
index bf6bddca3fd8..152a0d4b6737 100644
--- a/src/malloc/calloc.c
+++ b/src/malloc/calloc.c
@@ -1,34 +1,6 @@
 #include <stdlib.h>
-#include <stdint.h>
-#include <string.h>
+#include <stdfil.h>
 #include <errno.h>
-#include "dynlink.h"
-
-static size_t mal0_clear(char *p, size_t n)
-{
-	const size_t pagesz = 4096; /* arbitrary */
-	if (n < pagesz) return n;
-#ifdef __GNUC__
-	typedef uint64_t __attribute__((__may_alias__)) T;
-#else
-	typedef unsigned char T;
-#endif
-	char *pp = p + n;
-	size_t i = (uintptr_t)pp & (pagesz - 1);
-	for (;;) {
-		pp = memset(pp - i, 0, i);
-		if (pp - p < pagesz) return pp - p;
-		for (i = pagesz; i; i -= 2*sizeof(T), pp -= 2*sizeof(T))
-		        if (((T *)pp)[-1] | ((T *)pp)[-2])
-				break;
-	}
-}
-
-static int allzerop(void *p)
-{
-	return 0;
-}
-weak_alias(allzerop, __malloc_allzerop);
 
 void *calloc(size_t m, size_t n)
 {
@@ -37,9 +9,5 @@ void *calloc(size_t m, size_t n)
 		return 0;
 	}
 	n *= m;
-	void *p = malloc(n);
-	if (!p || (!__malloc_replaced && __malloc_allzerop(p)))
-		return p;
-	n = mal0_clear(p, n);
-	return memset(p, 0, n);
+	return zgc_alloc(n); /* zgc_alloc zeroes memory alraedy */
 }
diff --git a/src/malloc/free.c b/src/malloc/free.c
index 3944f7b28f3c..d84b8fd18cd4 100644
--- a/src/malloc/free.c
+++ b/src/malloc/free.c
@@ -1,6 +1,12 @@
 #include <stdlib.h>
+#include <stdfil.h>
 
 void free(void *p)
 {
-	__libc_free(p);
+    zgc_free(p);
+}
+
+void __libc_free(void *p)
+{
+    zgc_free(p);
 }
diff --git a/src/malloc/libc_calloc.c b/src/malloc/libc_calloc.c
index d25eabea47f5..d71f85a0f1c8 100644
--- a/src/malloc/libc_calloc.c
+++ b/src/malloc/libc_calloc.c
@@ -1,4 +1,15 @@
-#define calloc __libc_calloc
-#define malloc __libc_malloc
+#include <stdlib.h>
+#include <stdfil.h>
+#include <errno.h>
+
+void* __libc_calloc(size_t size, size_t count)
+{
+    if (__builtin_mul_overflow(size, count, &size)) {
+        errno = ENOMEM;
+        return NULL;
+    }
+
+    return zgc_alloc(size); /* zgc_alloc already zeroes memory */
+}
+
 
-#include "calloc.c"
diff --git a/src/malloc/lite_malloc.c b/src/malloc/lite_malloc.c
index 43a988fbb8ad..8da55c1e597c 100644
--- a/src/malloc/lite_malloc.c
+++ b/src/malloc/lite_malloc.c
@@ -1,118 +1,8 @@
 #include <stdlib.h>
-#include <stdint.h>
-#include <limits.h>
-#include <errno.h>
-#include <sys/mman.h>
-#include "libc.h"
-#include "lock.h"
-#include "syscall.h"
-#include "fork_impl.h"
-
-#define ALIGN 16
-
-/* This function returns true if the interval [old,new]
- * intersects the 'len'-sized interval below &libc.auxv
- * (interpreted as the main-thread stack) or below &b
- * (the current stack). It is used to defend against
- * buggy brk implementations that can cross the stack. */
-
-static int traverses_stack_p(uintptr_t old, uintptr_t new)
-{
-	const uintptr_t len = 8<<20;
-	uintptr_t a, b;
-
-	b = (uintptr_t)libc.auxv;
-	a = b > len ? b-len : 0;
-	if (new>a && old<b) return 1;
-
-	b = (uintptr_t)&b;
-	a = b > len ? b-len : 0;
-	if (new>a && old<b) return 1;
-
-	return 0;
-}
-
-static volatile int lock[1];
-volatile int *const __bump_lockptr = lock;
-
-static void *__simple_malloc(size_t n)
-{
-	static uintptr_t brk, cur, end;
-	static unsigned mmap_step;
-	size_t align=1;
-	void *p;
-
-	if (n > SIZE_MAX/2) {
-		errno = ENOMEM;
-		return 0;
-	}
-
-	if (!n) n++;
-	while (align<n && align<ALIGN)
-		align += align;
-
-	LOCK(lock);
-
-	cur += -cur & align-1;
-
-	if (n > end-cur) {
-		size_t req = n - (end-cur) + PAGE_SIZE-1 & -PAGE_SIZE;
-
-		if (!cur) {
-			brk = __syscall(SYS_brk, 0);
-			brk += -brk & PAGE_SIZE-1;
-			cur = end = brk;
-		}
-
-		if (brk == end && req < SIZE_MAX-brk
-		    && !traverses_stack_p(brk, brk+req)
-		    && __syscall(SYS_brk, brk+req)==brk+req) {
-			brk = end += req;
-		} else {
-			int new_area = 0;
-			req = n + PAGE_SIZE-1 & -PAGE_SIZE;
-			/* Only make a new area rather than individual mmap
-			 * if wasted space would be over 1/8 of the map. */
-			if (req-n > req/8) {
-				/* Geometric area size growth up to 64 pages,
-				 * bounding waste by 1/8 of the area. */
-				size_t min = PAGE_SIZE<<(mmap_step/2);
-				if (min-n > end-cur) {
-					if (req < min) {
-						req = min;
-						if (mmap_step < 12)
-							mmap_step++;
-					}
-					new_area = 1;
-				}
-			}
-			void *mem = __mmap(0, req, PROT_READ|PROT_WRITE,
-				MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
-			if (mem == MAP_FAILED || !new_area) {
-				UNLOCK(lock);
-				return mem==MAP_FAILED ? 0 : mem;
-			}
-			cur = (uintptr_t)mem;
-			end = cur + req;
-		}
-	}
-
-	p = (void *)cur;
-	cur += n;
-	UNLOCK(lock);
-	return p;
-}
-
-weak_alias(__simple_malloc, __libc_malloc_impl);
+#include <stdfil.h>
 
 void *__libc_malloc(size_t n)
 {
-	return __libc_malloc_impl(n);
-}
-
-static void *default_malloc(size_t n)
-{
-	return __libc_malloc_impl(n);
+    return zgc_alloc(n);
 }
 
-weak_alias(default_malloc, malloc);
diff --git a/src/malloc/malloc.c b/src/malloc/malloc.c
new file mode 100644
index 000000000000..f64e15edb0e9
--- /dev/null
+++ b/src/malloc/malloc.c
@@ -0,0 +1,7 @@
+#include <stdlib.h>
+#include <stdfil.h>
+
+void* malloc(size_t size)
+{
+    return zgc_alloc(size);
+}
diff --git a/src/malloc/malloc_usable_size.c b/src/malloc/malloc_usable_size.c
new file mode 100644
index 000000000000..aa7895306b2c
--- /dev/null
+++ b/src/malloc/malloc_usable_size.c
@@ -0,0 +1,9 @@
+#include <stdlib.h>
+#include <stdfil.h>
+
+size_t malloc_usable_size(void *p)
+{
+    if (!zhasvalidcap(p) || !zinbounds(p))
+        return 0;
+    return (char*)zgetupper(p) - (char*)p;
+}
diff --git a/src/malloc/mallocng/aligned_alloc.c b/src/malloc/mallocng/aligned_alloc.c
deleted file mode 100644
index e0862a83ae00..000000000000
--- a/src/malloc/mallocng/aligned_alloc.c
+++ /dev/null
@@ -1,60 +0,0 @@
-#include <stdlib.h>
-#include <errno.h>
-#include "meta.h"
-
-void *aligned_alloc(size_t align, size_t len)
-{
-	if ((align & -align) != align) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	if (len > SIZE_MAX - align || align >= (1ULL<<31)*UNIT) {
-		errno = ENOMEM;
-		return 0;
-	}
-
-	if (DISABLE_ALIGNED_ALLOC) {
-		errno = ENOMEM;
-		return 0;
-	}
-
-	if (align <= UNIT) align = UNIT;
-
-	unsigned char *p = malloc(len + align - UNIT);
-	if (!p)
-		return 0;
-
-	struct meta *g = get_meta(p);
-	int idx = get_slot_index(p);
-	size_t stride = get_stride(g);
-	unsigned char *start = g->mem->storage + stride*idx;
-	unsigned char *end = g->mem->storage + stride*(idx+1) - IB;
-	size_t adj = -(uintptr_t)p & (align-1);
-
-	if (!adj) {
-		set_size(p, end, len);
-		return p;
-	}
-	p += adj;
-	uint32_t offset = (size_t)(p-g->mem->storage)/UNIT;
-	if (offset <= 0xffff) {
-		*(uint16_t *)(p-2) = offset;
-		p[-4] = 0;
-	} else {
-		// use a 32-bit offset if 16-bit doesn't fit. for this,
-		// 16-bit field must be zero, [-4] byte nonzero.
-		*(uint16_t *)(p-2) = 0;
-		*(uint32_t *)(p-8) = offset;
-		p[-4] = 1;
-	}
-	p[-3] = idx;
-	set_size(p, end, len);
-	// store offset to aligned enframing. this facilitates cycling
-	// offset and also iteration of heap for debugging/measurement.
-	// for extreme overalignment it won't fit but these are classless
-	// allocations anyway.
-	*(uint16_t *)(start - 2) = (size_t)(p-start)/UNIT;
-	start[-3] = 7<<5;
-	return p;
-}
diff --git a/src/malloc/mallocng/donate.c b/src/malloc/mallocng/donate.c
deleted file mode 100644
index 41d850f357e3..000000000000
--- a/src/malloc/mallocng/donate.c
+++ /dev/null
@@ -1,39 +0,0 @@
-#include <stdlib.h>
-#include <stdint.h>
-#include <limits.h>
-#include <string.h>
-#include <sys/mman.h>
-#include <errno.h>
-
-#include "meta.h"
-
-static void donate(unsigned char *base, size_t len)
-{
-	uintptr_t a = (uintptr_t)base;
-	uintptr_t b = a + len;
-	a += -a & (UNIT-1);
-	b -= b & (UNIT-1);
-	memset(base, 0, len);
-	for (int sc=47; sc>0 && b>a; sc-=4) {
-		if (b-a < (size_classes[sc]+1)*UNIT) continue;
-		struct meta *m = alloc_meta();
-		m->avail_mask = 0;
-		m->freed_mask = 1;
-		m->mem = (void *)a;
-		m->mem->meta = m;
-		m->last_idx = 0;
-		m->freeable = 0;
-		m->sizeclass = sc;
-		m->maplen = 0;
-		*((unsigned char *)m->mem+UNIT-4) = 0;
-		*((unsigned char *)m->mem+UNIT-3) = 255;
-		m->mem->storage[size_classes[sc]*UNIT-4] = 0;
-		queue(&ctx.active[sc], m);
-		a += (size_classes[sc]+1)*UNIT;
-	}
-}
-
-void __malloc_donate(char *start, char *end)
-{
-	donate((void *)start, end-start);
-}
diff --git a/src/malloc/mallocng/free.c b/src/malloc/mallocng/free.c
deleted file mode 100644
index 43f32aade86b..000000000000
--- a/src/malloc/mallocng/free.c
+++ /dev/null
@@ -1,151 +0,0 @@
-#define _BSD_SOURCE
-#include <stdlib.h>
-#include <sys/mman.h>
-
-#include "meta.h"
-
-struct mapinfo {
-	void *base;
-	size_t len;
-};
-
-static struct mapinfo nontrivial_free(struct meta *, int);
-
-static struct mapinfo free_group(struct meta *g)
-{
-	struct mapinfo mi = { 0 };
-	int sc = g->sizeclass;
-	if (sc < 48) {
-		ctx.usage_by_class[sc] -= g->last_idx+1;
-	}
-	if (g->maplen) {
-		step_seq();
-		record_seq(sc);
-		mi.base = g->mem;
-		mi.len = g->maplen*4096UL;
-	} else {
-		void *p = g->mem;
-		struct meta *m = get_meta(p);
-		int idx = get_slot_index(p);
-		g->mem->meta = 0;
-		// not checking size/reserved here; it's intentionally invalid
-		mi = nontrivial_free(m, idx);
-	}
-	free_meta(g);
-	return mi;
-}
-
-static int okay_to_free(struct meta *g)
-{
-	int sc = g->sizeclass;
-
-	if (!g->freeable) return 0;
-
-	// always free individual mmaps not suitable for reuse
-	if (sc >= 48 || get_stride(g) < UNIT*size_classes[sc])
-		return 1;
-
-	// always free groups allocated inside another group's slot
-	// since recreating them should not be expensive and they
-	// might be blocking freeing of a much larger group.
-	if (!g->maplen) return 1;
-
-	// if there is another non-full group, free this one to
-	// consolidate future allocations, reduce fragmentation.
-	if (g->next != g) return 1;
-
-	// free any group in a size class that's not bouncing
-	if (!is_bouncing(sc)) return 1;
-
-	size_t cnt = g->last_idx+1;
-	size_t usage = ctx.usage_by_class[sc];
-
-	// if usage is high enough that a larger count should be
-	// used, free the low-count group so a new one will be made.
-	if (9*cnt <= usage && cnt < 20)
-		return 1;
-
-	// otherwise, keep the last group in a bouncing class.
-	return 0;
-}
-
-static struct mapinfo nontrivial_free(struct meta *g, int i)
-{
-	uint32_t self = 1u<<i;
-	int sc = g->sizeclass;
-	uint32_t mask = g->freed_mask | g->avail_mask;
-
-	if (mask+self == (2u<<g->last_idx)-1 && okay_to_free(g)) {
-		// any multi-slot group is necessarily on an active list
-		// here, but single-slot groups might or might not be.
-		if (g->next) {
-			assert(sc < 48);
-			int activate_new = (ctx.active[sc]==g);
-			dequeue(&ctx.active[sc], g);
-			if (activate_new && ctx.active[sc])
-				activate_group(ctx.active[sc]);
-		}
-		return free_group(g);
-	} else if (!mask) {
-		assert(sc < 48);
-		// might still be active if there were no allocations
-		// after last available slot was taken.
-		if (ctx.active[sc] != g) {
-			queue(&ctx.active[sc], g);
-		}
-	}
-	a_or(&g->freed_mask, self);
-	return (struct mapinfo){ 0 };
-}
-
-void free(void *p)
-{
-	if (!p) return;
-
-	struct meta *g = get_meta(p);
-	int idx = get_slot_index(p);
-	size_t stride = get_stride(g);
-	unsigned char *start = g->mem->storage + stride*idx;
-	unsigned char *end = start + stride - IB;
-	get_nominal_size(p, end);
-	uint32_t self = 1u<<idx, all = (2u<<g->last_idx)-1;
-	((unsigned char *)p)[-3] = 255;
-	// invalidate offset to group header, and cycle offset of
-	// used region within slot if current offset is zero.
-	*(uint16_t *)((char *)p-2) = 0;
-
-	// release any whole pages contained in the slot to be freed
-	// unless it's a single-slot group that will be unmapped.
-	if (((uintptr_t)(start-1) ^ (uintptr_t)end) >= 2*PGSZ && g->last_idx) {
-		unsigned char *base = start + (-(uintptr_t)start & (PGSZ-1));
-		size_t len = (end-base) & -PGSZ;
-		if (len && USE_MADV_FREE) {
-			int e = errno;
-			madvise(base, len, MADV_FREE);
-			errno = e;
-		}
-	}
-
-	// atomic free without locking if this is neither first or last slot
-	for (;;) {
-		uint32_t freed = g->freed_mask;
-		uint32_t avail = g->avail_mask;
-		uint32_t mask = freed | avail;
-		assert(!(mask&self));
-		if (!freed || mask+self==all) break;
-		if (!MT)
-			g->freed_mask = freed+self;
-		else if (a_cas(&g->freed_mask, freed, freed+self)!=freed)
-			continue;
-		return;
-	}
-
-	wrlock();
-	struct mapinfo mi = nontrivial_free(g, idx);
-	unlock();
-	if (mi.len) {
-		int e = errno;
-		munmap(mi.base, mi.len);
-		errno = e;
-	}
-}
diff --git a/src/malloc/mallocng/glue.h b/src/malloc/mallocng/glue.h
deleted file mode 100644
index 77f4c812b20a..000000000000
--- a/src/malloc/mallocng/glue.h
+++ /dev/null
@@ -1,95 +0,0 @@
-#ifndef MALLOC_GLUE_H
-#define MALLOC_GLUE_H
-
-#include <stdint.h>
-#include <sys/mman.h>
-#include <pthread.h>
-#include <unistd.h>
-#include <elf.h>
-#include <string.h>
-#include "atomic.h"
-#include "syscall.h"
-#include "libc.h"
-#include "lock.h"
-#include "dynlink.h"
-
-// use macros to appropriately namespace these.
-#define size_classes __malloc_size_classes
-#define ctx __malloc_context
-#define alloc_meta __malloc_alloc_meta
-#define is_allzero __malloc_allzerop
-#define dump_heap __dump_heap
-
-#define malloc __libc_malloc_impl
-#define realloc __libc_realloc
-#define free __libc_free
-
-#define USE_MADV_FREE 0
-
-#if USE_REAL_ASSERT
-#include <assert.h>
-#else
-#undef assert
-#define assert(x) do { if (!(x)) a_crash(); } while(0)
-#endif
-
-#define brk(p) ((uintptr_t)__syscall(SYS_brk, p))
-
-#define mmap __mmap
-#define madvise __madvise
-#define mremap __mremap
-
-#define DISABLE_ALIGNED_ALLOC (__malloc_replaced && !__aligned_alloc_replaced)
-
-static inline uint64_t get_random_secret()
-{
-	uint64_t secret = (uintptr_t)&secret * 1103515245;
-	for (size_t i=0; libc.auxv[i]; i+=2)
-		if (libc.auxv[i]==AT_RANDOM)
-			memcpy(&secret, (char *)libc.auxv[i+1]+8, sizeof secret);
-	return secret;
-}
-
-#ifndef PAGESIZE
-#define PAGESIZE PAGE_SIZE
-#endif
-
-#define MT (libc.need_locks)
-
-#define RDLOCK_IS_EXCLUSIVE 1
-
-__attribute__((__visibility__("hidden")))
-extern int __malloc_lock[1];
-
-#define LOCK_OBJ_DEF \
-int __malloc_lock[1]; \
-void __malloc_atfork(int who) { malloc_atfork(who); }
-
-static inline void rdlock()
-{
-	if (MT) LOCK(__malloc_lock);
-}
-static inline void wrlock()
-{
-	if (MT) LOCK(__malloc_lock);
-}
-static inline void unlock()
-{
-	UNLOCK(__malloc_lock);
-}
-static inline void upgradelock()
-{
-}
-static inline void resetlock()
-{
-	__malloc_lock[0] = 0;
-}
-
-static inline void malloc_atfork(int who)
-{
-	if (who<0) rdlock();
-	else if (who>0) resetlock();
-	else unlock();
-}
-
-#endif
diff --git a/src/malloc/mallocng/malloc.c b/src/malloc/mallocng/malloc.c
deleted file mode 100644
index d695ab8ec982..000000000000
--- a/src/malloc/mallocng/malloc.c
+++ /dev/null
@@ -1,387 +0,0 @@
-#include <stdlib.h>
-#include <stdint.h>
-#include <limits.h>
-#include <string.h>
-#include <sys/mman.h>
-#include <errno.h>
-
-#include "meta.h"
-
-LOCK_OBJ_DEF;
-
-const uint16_t size_classes[] = {
-	1, 2, 3, 4, 5, 6, 7, 8,
-	9, 10, 12, 15,
-	18, 20, 25, 31,
-	36, 42, 50, 63,
-	72, 84, 102, 127,
-	146, 170, 204, 255,
-	292, 340, 409, 511,
-	584, 682, 818, 1023,
-	1169, 1364, 1637, 2047,
-	2340, 2730, 3276, 4095,
-	4680, 5460, 6552, 8191,
-};
-
-static const uint8_t small_cnt_tab[][3] = {
-	{ 30, 30, 30 },
-	{ 31, 15, 15 },
-	{ 20, 10, 10 },
-	{ 31, 15, 7 },
-	{ 25, 12, 6 },
-	{ 21, 10, 5 },
-	{ 18, 8, 4 },
-	{ 31, 15, 7 },
-	{ 28, 14, 6 },
-};
-
-static const uint8_t med_cnt_tab[4] = { 28, 24, 20, 32 };
-
-struct malloc_context ctx = { 0 };
-
-struct meta *alloc_meta(void)
-{
-	struct meta *m;
-	unsigned char *p;
-	if (!ctx.init_done) {
-#ifndef PAGESIZE
-		ctx.pagesize = get_page_size();
-#endif
-		ctx.secret = get_random_secret();
-		ctx.init_done = 1;
-	}
-	size_t pagesize = PGSZ;
-	if (pagesize < 4096) pagesize = 4096;
-	if ((m = dequeue_head(&ctx.free_meta_head))) return m;
-	if (!ctx.avail_meta_count) {
-		int need_unprotect = 1;
-		if (!ctx.avail_meta_area_count && ctx.brk!=-1) {
-			uintptr_t new = ctx.brk + pagesize;
-			int need_guard = 0;
-			if (!ctx.brk) {
-				need_guard = 1;
-				ctx.brk = brk(0);
-				// some ancient kernels returned _ebss
-				// instead of next page as initial brk.
-				ctx.brk += -ctx.brk & (pagesize-1);
-				new = ctx.brk + 2*pagesize;
-			}
-			if (brk(new) != new) {
-				ctx.brk = -1;
-			} else {
-				if (need_guard) mmap((void *)ctx.brk, pagesize,
-					PROT_NONE, MAP_ANON|MAP_PRIVATE|MAP_FIXED, -1, 0);
-				ctx.brk = new;
-				ctx.avail_meta_areas = (void *)(new - pagesize);
-				ctx.avail_meta_area_count = pagesize>>12;
-				need_unprotect = 0;
-			}
-		}
-		if (!ctx.avail_meta_area_count) {
-			size_t n = 2UL << ctx.meta_alloc_shift;
-			p = mmap(0, n*pagesize, PROT_NONE,
-				MAP_PRIVATE|MAP_ANON, -1, 0);
-			if (p==MAP_FAILED) return 0;
-			ctx.avail_meta_areas = p + pagesize;
-			ctx.avail_meta_area_count = (n-1)*(pagesize>>12);
-			ctx.meta_alloc_shift++;
-		}
-		p = ctx.avail_meta_areas;
-		if ((uintptr_t)p & (pagesize-1)) need_unprotect = 0;
-		if (need_unprotect)
-			if (mprotect(p, pagesize, PROT_READ|PROT_WRITE)
-			    && errno != ENOSYS)
-				return 0;
-		ctx.avail_meta_area_count--;
-		ctx.avail_meta_areas = p + 4096;
-		if (ctx.meta_area_tail) {
-			ctx.meta_area_tail->next = (void *)p;
-		} else {
-			ctx.meta_area_head = (void *)p;
-		}
-		ctx.meta_area_tail = (void *)p;
-		ctx.meta_area_tail->check = ctx.secret;
-		ctx.avail_meta_count = ctx.meta_area_tail->nslots
-			= (4096-sizeof(struct meta_area))/sizeof *m;
-		ctx.avail_meta = ctx.meta_area_tail->slots;
-	}
-	ctx.avail_meta_count--;
-	m = ctx.avail_meta++;
-	m->prev = m->next = 0;
-	return m;
-}
-
-static uint32_t try_avail(struct meta **pm)
-{
-	struct meta *m = *pm;
-	uint32_t first;
-	if (!m) return 0;
-	uint32_t mask = m->avail_mask;
-	if (!mask) {
-		if (!m) return 0;
-		if (!m->freed_mask) {
-			dequeue(pm, m);
-			m = *pm;
-			if (!m) return 0;
-		} else {
-			m = m->next;
-			*pm = m;
-		}
-
-		mask = m->freed_mask;
-
-		// skip fully-free group unless it's the only one
-		// or it's a permanently non-freeable group
-		if (mask == (2u<<m->last_idx)-1 && m->freeable) {
-			m = m->next;
-			*pm = m;
-			mask = m->freed_mask;
-		}
-
-		// activate more slots in a not-fully-active group
-		// if needed, but only as a last resort. prefer using
-		// any other group with free slots. this avoids
-		// touching & dirtying as-yet-unused pages.
-		if (!(mask & ((2u<<m->mem->active_idx)-1))) {
-			if (m->next != m) {
-				m = m->next;
-				*pm = m;
-			} else {
-				int cnt = m->mem->active_idx + 2;
-				int size = size_classes[m->sizeclass]*UNIT;
-				int span = UNIT + size*cnt;
-				// activate up to next 4k boundary
-				while ((span^(span+size-1)) < 4096) {
-					cnt++;
-					span += size;
-				}
-				if (cnt > m->last_idx+1)
-					cnt = m->last_idx+1;
-				m->mem->active_idx = cnt-1;
-			}
-		}
-		mask = activate_group(m);
-		assert(mask);
-		decay_bounces(m->sizeclass);
-	}
-	first = mask&-mask;
-	m->avail_mask = mask-first;
-	return first;
-}
-
-static int alloc_slot(int, size_t);
-
-static struct meta *alloc_group(int sc, size_t req)
-{
-	size_t size = UNIT*size_classes[sc];
-	int i = 0, cnt;
-	unsigned char *p;
-	struct meta *m = alloc_meta();
-	if (!m) return 0;
-	size_t usage = ctx.usage_by_class[sc];
-	size_t pagesize = PGSZ;
-	int active_idx;
-	if (sc < 9) {
-		while (i<2 && 4*small_cnt_tab[sc][i] > usage)
-			i++;
-		cnt = small_cnt_tab[sc][i];
-	} else {
-		// lookup max number of slots fitting in power-of-two size
-		// from a table, along with number of factors of two we
-		// can divide out without a remainder or reaching 1.
-		cnt = med_cnt_tab[sc&3];
-
-		// reduce cnt to avoid excessive eagar allocation.
-		while (!(cnt&1) && 4*cnt > usage)
-			cnt >>= 1;
-
-		// data structures don't support groups whose slot offsets
-		// in units don't fit in 16 bits.
-		while (size*cnt >= 65536*UNIT)
-			cnt >>= 1;
-	}
-
-	// If we selected a count of 1 above but it's not sufficient to use
-	// mmap, increase to 2. Then it might be; if not it will nest.
-	if (cnt==1 && size*cnt+UNIT <= pagesize/2) cnt = 2;
-
-	// All choices of size*cnt are "just below" a power of two, so anything
-	// larger than half the page size should be allocated as whole pages.
-	if (size*cnt+UNIT > pagesize/2) {
-		// check/update bounce counter to start/increase retention
-		// of freed maps, and inhibit use of low-count, odd-size
-		// small mappings and single-slot groups if activated.
-		int nosmall = is_bouncing(sc);
-		account_bounce(sc);
-		step_seq();
-
-		// since the following count reduction opportunities have
-		// an absolute memory usage cost, don't overdo them. count
-		// coarse usage as part of usage.
-		if (!(sc&1) && sc<32) usage += ctx.usage_by_class[sc+1];
-
-		// try to drop to a lower count if the one found above
-		// increases usage by more than 25%. these reduced counts
-		// roughly fill an integral number of pages, just not a
-		// power of two, limiting amount of unusable space.
-		if (4*cnt > usage && !nosmall) {
-			if (0);
-			else if ((sc&3)==1 && size*cnt>8*pagesize) cnt = 2;
-			else if ((sc&3)==2 && size*cnt>4*pagesize) cnt = 3;
-			else if ((sc&3)==0 && size*cnt>8*pagesize) cnt = 3;
-			else if ((sc&3)==0 && size*cnt>2*pagesize) cnt = 5;
-		}
-		size_t needed = size*cnt + UNIT;
-		needed += -needed & (pagesize-1);
-
-		// produce an individually-mmapped allocation if usage is low,
-		// bounce counter hasn't triggered, and either it saves memory
-		// or it avoids eagar slot allocation without wasting too much.
-		if (!nosmall && cnt<=7) {
-			req += IB + UNIT;
-			req += -req & (pagesize-1);
-			if (req<size+UNIT || (req>=4*pagesize && 2*cnt>usage)) {
-				cnt = 1;
-				needed = req;
-			}
-		}
-
-		p = mmap(0, needed, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0);
-		if (p==MAP_FAILED) {
-			free_meta(m);
-			return 0;
-		}
-		m->maplen = needed>>12;
-		ctx.mmap_counter++;
-		active_idx = (4096-UNIT)/size-1;
-		if (active_idx > cnt-1) active_idx = cnt-1;
-		if (active_idx < 0) active_idx = 0;
-	} else {
-		int j = size_to_class(UNIT+cnt*size-IB);
-		int idx = alloc_slot(j, UNIT+cnt*size-IB);
-		if (idx < 0) {
-			free_meta(m);
-			return 0;
-		}
-		struct meta *g = ctx.active[j];
-		p = enframe(g, idx, UNIT*size_classes[j]-IB, ctx.mmap_counter);
-		m->maplen = 0;
-		p[-3] = (p[-3]&31) | (6<<5);
-		for (int i=0; i<=cnt; i++)
-			p[UNIT+i*size-4] = 0;
-		active_idx = cnt-1;
-	}
-	ctx.usage_by_class[sc] += cnt;
-	m->avail_mask = (2u<<active_idx)-1;
-	m->freed_mask = (2u<<(cnt-1))-1 - m->avail_mask;
-	m->mem = (void *)p;
-	m->mem->meta = m;
-	m->mem->active_idx = active_idx;
-	m->last_idx = cnt-1;
-	m->freeable = 1;
-	m->sizeclass = sc;
-	return m;
-}
-
-static int alloc_slot(int sc, size_t req)
-{
-	uint32_t first = try_avail(&ctx.active[sc]);
-	if (first) return a_ctz_32(first);
-
-	struct meta *g = alloc_group(sc, req);
-	if (!g) return -1;
-
-	g->avail_mask--;
-	queue(&ctx.active[sc], g);
-	return 0;
-}
-
-void *malloc(size_t n)
-{
-	if (size_overflows(n)) return 0;
-	struct meta *g;
-	uint32_t mask, first;
-	int sc;
-	int idx;
-	int ctr;
-
-	if (n >= MMAP_THRESHOLD) {
-		size_t needed = n + IB + UNIT;
-		void *p = mmap(0, needed, PROT_READ|PROT_WRITE,
-			MAP_PRIVATE|MAP_ANON, -1, 0);
-		if (p==MAP_FAILED) return 0;
-		wrlock();
-		step_seq();
-		g = alloc_meta();
-		if (!g) {
-			unlock();
-			munmap(p, needed);
-			return 0;
-		}
-		g->mem = p;
-		g->mem->meta = g;
-		g->last_idx = 0;
-		g->freeable = 1;
-		g->sizeclass = 63;
-		g->maplen = (needed+4095)/4096;
-		g->avail_mask = g->freed_mask = 0;
-		// use a global counter to cycle offset in
-		// individually-mmapped allocations.
-		ctx.mmap_counter++;
-		idx = 0;
-		goto success;
-	}
-
-	sc = size_to_class(n);
-
-	rdlock();
-	g = ctx.active[sc];
-
-	// use coarse size classes initially when there are not yet
-	// any groups of desired size. this allows counts of 2 or 3
-	// to be allocated at first rather than having to start with
-	// 7 or 5, the min counts for even size classes.
-	if (!g && sc>=4 && sc<32 && sc!=6 && !(sc&1) && !ctx.usage_by_class[sc]) {
-		size_t usage = ctx.usage_by_class[sc|1];
-		// if a new group may be allocated, count it toward
-		// usage in deciding if we can use coarse class.
-		if (!ctx.active[sc|1] || (!ctx.active[sc|1]->avail_mask
-		    && !ctx.active[sc|1]->freed_mask))
-			usage += 3;
-		if (usage <= 12)
-			sc |= 1;
-		g = ctx.active[sc];
-	}
-
-	for (;;) {
-		mask = g ? g->avail_mask : 0;
-		first = mask&-mask;
-		if (!first) break;
-		if (RDLOCK_IS_EXCLUSIVE || !MT)
-			g->avail_mask = mask-first;
-		else if (a_cas(&g->avail_mask, mask, mask-first)!=mask)
-			continue;
-		idx = a_ctz_32(first);
-		goto success;
-	}
-	upgradelock();
-
-	idx = alloc_slot(sc, n);
-	if (idx < 0) {
-		unlock();
-		return 0;
-	}
-	g = ctx.active[sc];
-
-success:
-	ctr = ctx.mmap_counter;
-	unlock();
-	return enframe(g, idx, n, ctr);
-}
-
-int is_allzero(void *p)
-{
-	struct meta *g = get_meta(p);
-	return g->sizeclass >= 48 ||
-		get_stride(g) < UNIT*size_classes[g->sizeclass];
-}
diff --git a/src/malloc/mallocng/malloc_usable_size.c b/src/malloc/mallocng/malloc_usable_size.c
deleted file mode 100644
index ce6a960c6f58..000000000000
--- a/src/malloc/mallocng/malloc_usable_size.c
+++ /dev/null
@@ -1,13 +0,0 @@
-#include <stdlib.h>
-#include "meta.h"
-
-size_t malloc_usable_size(void *p)
-{
-	if (!p) return 0;
-	struct meta *g = get_meta(p);
-	int idx = get_slot_index(p);
-	size_t stride = get_stride(g);
-	unsigned char *start = g->mem->storage + stride*idx;
-	unsigned char *end = start + stride - IB;
-	return get_nominal_size(p, end);
-}
diff --git a/src/malloc/mallocng/meta.h b/src/malloc/mallocng/meta.h
deleted file mode 100644
index 61ec53f9a589..000000000000
--- a/src/malloc/mallocng/meta.h
+++ /dev/null
@@ -1,288 +0,0 @@
-#ifndef MALLOC_META_H
-#define MALLOC_META_H
-
-#include <stdint.h>
-#include <errno.h>
-#include <limits.h>
-#include "glue.h"
-
-__attribute__((__visibility__("hidden")))
-extern const uint16_t size_classes[];
-
-#define MMAP_THRESHOLD 131052
-
-#define UNIT 16
-#define IB 4
-
-struct group {
-	struct meta *meta;
-	unsigned char active_idx:5;
-	char pad[UNIT - sizeof(struct meta *) - 1];
-	unsigned char storage[];
-};
-
-struct meta {
-	struct meta *prev, *next;
-	struct group *mem;
-	volatile int avail_mask, freed_mask;
-	uintptr_t last_idx:5;
-	uintptr_t freeable:1;
-	uintptr_t sizeclass:6;
-	uintptr_t maplen:8*sizeof(uintptr_t)-12;
-};
-
-struct meta_area {
-	uint64_t check;
-	struct meta_area *next;
-	int nslots;
-	struct meta slots[];
-};
-
-struct malloc_context {
-	uint64_t secret;
-#ifndef PAGESIZE
-	size_t pagesize;
-#endif
-	int init_done;
-	unsigned mmap_counter;
-	struct meta *free_meta_head;
-	struct meta *avail_meta;
-	size_t avail_meta_count, avail_meta_area_count, meta_alloc_shift;
-	struct meta_area *meta_area_head, *meta_area_tail;
-	unsigned char *avail_meta_areas;
-	struct meta *active[48];
-	size_t usage_by_class[48];
-	uint8_t unmap_seq[32], bounces[32];
-	uint8_t seq;
-	uintptr_t brk;
-};
-
-__attribute__((__visibility__("hidden")))
-extern struct malloc_context ctx;
-
-#ifdef PAGESIZE
-#define PGSZ PAGESIZE
-#else
-#define PGSZ ctx.pagesize
-#endif
-
-__attribute__((__visibility__("hidden")))
-struct meta *alloc_meta(void);
-
-__attribute__((__visibility__("hidden")))
-int is_allzero(void *);
-
-static inline void queue(struct meta **phead, struct meta *m)
-{
-	assert(!m->next);
-	assert(!m->prev);
-	if (*phead) {
-		struct meta *head = *phead;
-		m->next = head;
-		m->prev = head->prev;
-		m->next->prev = m->prev->next = m;
-	} else {
-		m->prev = m->next = m;
-		*phead = m;
-	}
-}
-
-static inline void dequeue(struct meta **phead, struct meta *m)
-{
-	if (m->next != m) {
-		m->prev->next = m->next;
-		m->next->prev = m->prev;
-		if (*phead == m) *phead = m->next;
-	} else {
-		*phead = 0;
-	}
-	m->prev = m->next = 0;
-}
-
-static inline struct meta *dequeue_head(struct meta **phead)
-{
-	struct meta *m = *phead;
-	if (m) dequeue(phead, m);
-	return m;
-}
-
-static inline void free_meta(struct meta *m)
-{
-	*m = (struct meta){0};
-	queue(&ctx.free_meta_head, m);
-}
-
-static inline uint32_t activate_group(struct meta *m)
-{
-	assert(!m->avail_mask);
-	uint32_t mask, act = (2u<<m->mem->active_idx)-1;
-	do mask = m->freed_mask;
-	while (a_cas(&m->freed_mask, mask, mask&~act)!=mask);
-	return m->avail_mask = mask & act;
-}
-
-static inline int get_slot_index(const unsigned char *p)
-{
-	return p[-3] & 31;
-}
-
-static inline struct meta *get_meta(const unsigned char *p)
-{
-	assert(!((uintptr_t)p & 15));
-	int offset = *(const uint16_t *)(p - 2);
-	int index = get_slot_index(p);
-	if (p[-4]) {
-		assert(!offset);
-		offset = *(uint32_t *)(p - 8);
-		assert(offset > 0xffff);
-	}
-	const struct group *base = (const void *)(p - UNIT*offset - UNIT);
-	const struct meta *meta = base->meta;
-	assert(meta->mem == base);
-	assert(index <= meta->last_idx);
-	assert(!(meta->avail_mask & (1u<<index)));
-	assert(!(meta->freed_mask & (1u<<index)));
-	const struct meta_area *area = (void *)((uintptr_t)meta & -4096);
-	assert(area->check == ctx.secret);
-	if (meta->sizeclass < 48) {
-		assert(offset >= size_classes[meta->sizeclass]*index);
-		assert(offset < size_classes[meta->sizeclass]*(index+1));
-	} else {
-		assert(meta->sizeclass == 63);
-	}
-	if (meta->maplen) {
-		assert(offset <= meta->maplen*4096UL/UNIT - 1);
-	}
-	return (struct meta *)meta;
-}
-
-static inline size_t get_nominal_size(const unsigned char *p, const unsigned char *end)
-{
-	size_t reserved = p[-3] >> 5;
-	if (reserved >= 5) {
-		assert(reserved == 5);
-		reserved = *(const uint32_t *)(end-4);
-		assert(reserved >= 5);
-		assert(!end[-5]);
-	}
-	assert(reserved <= end-p);
-	assert(!*(end-reserved));
-	// also check the slot's overflow byte
-	assert(!*end);
-	return end-reserved-p;
-}
-
-static inline size_t get_stride(const struct meta *g)
-{
-	if (!g->last_idx && g->maplen) {
-		return g->maplen*4096UL - UNIT;
-	} else {
-		return UNIT*size_classes[g->sizeclass];
-	}
-}
-
-static inline void set_size(unsigned char *p, unsigned char *end, size_t n)
-{
-	int reserved = end-p-n;
-	if (reserved) end[-reserved] = 0;
-	if (reserved >= 5) {
-		*(uint32_t *)(end-4) = reserved;
-		end[-5] = 0;
-		reserved = 5;
-	}
-	p[-3] = (p[-3]&31) + (reserved<<5);
-}
-
-static inline void *enframe(struct meta *g, int idx, size_t n, int ctr)
-{
-	size_t stride = get_stride(g);
-	size_t slack = (stride-IB-n)/UNIT;
-	unsigned char *p = g->mem->storage + stride*idx;
-	unsigned char *end = p+stride-IB;
-	// cycle offset within slot to increase interval to address
-	// reuse, facilitate trapping double-free.
-	int off = (p[-3] ? *(uint16_t *)(p-2) + 1 : ctr) & 255;
-	assert(!p[-4]);
-	if (off > slack) {
-		size_t m = slack;
-		m |= m>>1; m |= m>>2; m |= m>>4;
-		off &= m;
-		if (off > slack) off -= slack+1;
-		assert(off <= slack);
-	}
-	if (off) {
-		// store offset in unused header at offset zero
-		// if enframing at non-zero offset.
-		*(uint16_t *)(p-2) = off;
-		p[-3] = 7<<5;
-		p += UNIT*off;
-		// for nonzero offset there is no permanent check
-		// byte, so make one.
-		p[-4] = 0;
-	}
-	*(uint16_t *)(p-2) = (size_t)(p-g->mem->storage)/UNIT;
-	p[-3] = idx;
-	set_size(p, end, n);
-	return p;
-}
-
-static inline int size_to_class(size_t n)
-{
-	n = (n+IB-1)>>4;
-	if (n<10) return n;
-	n++;
-	int i = (28-a_clz_32(n))*4 + 8;
-	if (n>size_classes[i+1]) i+=2;
-	if (n>size_classes[i]) i++;
-	return i;
-}
-
-static inline int size_overflows(size_t n)
-{
-	if (n >= SIZE_MAX/2 - 4096) {
-		errno = ENOMEM;
-		return 1;
-	}
-	return 0;
-}
-
-static inline void step_seq(void)
-{
-	if (ctx.seq==255) {
-		for (int i=0; i<32; i++) ctx.unmap_seq[i] = 0;
-		ctx.seq = 1;
-	} else {
-		ctx.seq++;
-	}
-}
-
-static inline void record_seq(int sc)
-{
-	if (sc-7U < 32) ctx.unmap_seq[sc-7] = ctx.seq;
-}
-
-static inline void account_bounce(int sc)
-{
-	if (sc-7U < 32) {
-		int seq = ctx.unmap_seq[sc-7];
-		if (seq && ctx.seq-seq < 10) {
-			if (ctx.bounces[sc-7]+1 < 100)
-				ctx.bounces[sc-7]++;
-			else
-				ctx.bounces[sc-7] = 150;
-		}
-	}
-}
-
-static inline void decay_bounces(int sc)
-{
-	if (sc-7U < 32 && ctx.bounces[sc-7])
-		ctx.bounces[sc-7]--;
-}
-
-static inline int is_bouncing(int sc)
-{
-	return (sc-7U < 32 && ctx.bounces[sc-7] >= 100);
-}
-
-#endif
diff --git a/src/malloc/mallocng/realloc.c b/src/malloc/mallocng/realloc.c
deleted file mode 100644
index 18769f42d83a..000000000000
--- a/src/malloc/mallocng/realloc.c
+++ /dev/null
@@ -1,51 +0,0 @@
-#define _GNU_SOURCE
-#include <stdlib.h>
-#include <sys/mman.h>
-#include <string.h>
-#include "meta.h"
-
-void *realloc(void *p, size_t n)
-{
-	if (!p) return malloc(n);
-	if (size_overflows(n)) return 0;
-
-	struct meta *g = get_meta(p);
-	int idx = get_slot_index(p);
-	size_t stride = get_stride(g);
-	unsigned char *start = g->mem->storage + stride*idx;
-	unsigned char *end = start + stride - IB;
-	size_t old_size = get_nominal_size(p, end);
-	size_t avail_size = end-(unsigned char *)p;
-	void *new;
-
-	// only resize in-place if size class matches
-	if (n <= avail_size && n<MMAP_THRESHOLD
-	    && size_to_class(n)+1 >= g->sizeclass) {
-		set_size(p, end, n);
-		return p;
-	}
-
-	// use mremap if old and new size are both mmap-worthy
-	if (g->sizeclass>=48 && n>=MMAP_THRESHOLD) {
-		assert(g->sizeclass==63);
-		size_t base = (unsigned char *)p-start;
-		size_t needed = (n + base + UNIT + IB + 4095) & -4096;
-		new = g->maplen*4096UL == needed ? g->mem :
-			mremap(g->mem, g->maplen*4096UL, needed, MREMAP_MAYMOVE);
-		if (new!=MAP_FAILED) {
-			g->mem = new;
-			g->maplen = needed/4096;
-			p = g->mem->storage + base;
-			end = g->mem->storage + (needed - UNIT) - IB;
-			*end = 0;
-			set_size(p, end, n);
-			return p;
-		}
-	}
-
-	new = malloc(n);
-	if (!new) return 0;
-	memcpy(new, p, n < old_size ? n : old_size);
-	free(p);
-	return new;
-}
diff --git a/src/malloc/oldmalloc/aligned_alloc.c b/src/malloc/oldmalloc/aligned_alloc.c
deleted file mode 100644
index 4adca3b4f6b7..000000000000
--- a/src/malloc/oldmalloc/aligned_alloc.c
+++ /dev/null
@@ -1,53 +0,0 @@
-#include <stdlib.h>
-#include <stdint.h>
-#include <errno.h>
-#include "malloc_impl.h"
-
-void *aligned_alloc(size_t align, size_t len)
-{
-	unsigned char *mem, *new;
-
-	if ((align & -align) != align) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	if (len > SIZE_MAX - align ||
-	    (__malloc_replaced && !__aligned_alloc_replaced)) {
-		errno = ENOMEM;
-		return 0;
-	}
-
-	if (align <= SIZE_ALIGN)
-		return malloc(len);
-
-	if (!(mem = malloc(len + align-1)))
-		return 0;
-
-	new = (void *)((uintptr_t)mem + align-1 & -align);
-	if (new == mem) return mem;
-
-	struct chunk *c = MEM_TO_CHUNK(mem);
-	struct chunk *n = MEM_TO_CHUNK(new);
-
-	if (IS_MMAPPED(c)) {
-		/* Apply difference between aligned and original
-		 * address to the "extra" field of mmapped chunk. */
-		n->psize = c->psize + (new-mem);
-		n->csize = c->csize - (new-mem);
-		return new;
-	}
-
-	struct chunk *t = NEXT_CHUNK(c);
-
-	/* Split the allocated chunk into two chunks. The aligned part
-	 * that will be used has the size in its footer reduced by the
-	 * difference between the aligned and original addresses, and
-	 * the resulting size copied to its header. A new header and
-	 * footer are written for the split-off part to be freed. */
-	n->psize = c->csize = C_INUSE | (new-mem);
-	n->csize = t->psize -= new-mem;
-
-	__bin_chunk(c);
-	return new;
-}
diff --git a/src/malloc/oldmalloc/malloc.c b/src/malloc/oldmalloc/malloc.c
deleted file mode 100644
index 25d00d44dea7..000000000000
--- a/src/malloc/oldmalloc/malloc.c
+++ /dev/null
@@ -1,556 +0,0 @@
-#define _GNU_SOURCE
-#include <stdlib.h>
-#include <string.h>
-#include <limits.h>
-#include <stdint.h>
-#include <errno.h>
-#include <sys/mman.h>
-#include "libc.h"
-#include "atomic.h"
-#include "pthread_impl.h"
-#include "malloc_impl.h"
-#include "fork_impl.h"
-
-#define malloc __libc_malloc_impl
-#define realloc __libc_realloc
-#define free __libc_free
-
-#if defined(__GNUC__) && defined(__PIC__)
-#define inline inline __attribute__((always_inline))
-#endif
-
-static struct {
-	volatile uint64_t binmap;
-	struct bin bins[64];
-	volatile int split_merge_lock[2];
-} mal;
-
-/* Synchronization tools */
-
-static inline void lock(volatile int *lk)
-{
-	int need_locks = libc.need_locks;
-	if (need_locks) {
-		while(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);
-		if (need_locks < 0) libc.need_locks = 0;
-	}
-}
-
-static inline void unlock(volatile int *lk)
-{
-	if (lk[0]) {
-		a_store(lk, 0);
-		if (lk[1]) __wake(lk, 1, 1);
-	}
-}
-
-static inline void lock_bin(int i)
-{
-	lock(mal.bins[i].lock);
-	if (!mal.bins[i].head)
-		mal.bins[i].head = mal.bins[i].tail = BIN_TO_CHUNK(i);
-}
-
-static inline void unlock_bin(int i)
-{
-	unlock(mal.bins[i].lock);
-}
-
-static int first_set(uint64_t x)
-{
-#if 1
-	return a_ctz_64(x);
-#else
-	static const char debruijn64[64] = {
-		0, 1, 2, 53, 3, 7, 54, 27, 4, 38, 41, 8, 34, 55, 48, 28,
-		62, 5, 39, 46, 44, 42, 22, 9, 24, 35, 59, 56, 49, 18, 29, 11,
-		63, 52, 6, 26, 37, 40, 33, 47, 61, 45, 43, 21, 23, 58, 17, 10,
-		51, 25, 36, 32, 60, 20, 57, 16, 50, 31, 19, 15, 30, 14, 13, 12
-	};
-	static const char debruijn32[32] = {
-		0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13,
-		31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14
-	};
-	if (sizeof(long) < 8) {
-		uint32_t y = x;
-		if (!y) {
-			y = x>>32;
-			return 32 + debruijn32[(y&-y)*0x076be629 >> 27];
-		}
-		return debruijn32[(y&-y)*0x076be629 >> 27];
-	}
-	return debruijn64[(x&-x)*0x022fdd63cc95386dull >> 58];
-#endif
-}
-
-static const unsigned char bin_tab[60] = {
-	            32,33,34,35,36,36,37,37,38,38,39,39,
-	40,40,40,40,41,41,41,41,42,42,42,42,43,43,43,43,
-	44,44,44,44,44,44,44,44,45,45,45,45,45,45,45,45,
-	46,46,46,46,46,46,46,46,47,47,47,47,47,47,47,47,
-};
-
-static int bin_index(size_t x)
-{
-	x = x / SIZE_ALIGN - 1;
-	if (x <= 32) return x;
-	if (x < 512) return bin_tab[x/8-4];
-	if (x > 0x1c00) return 63;
-	return bin_tab[x/128-4] + 16;
-}
-
-static int bin_index_up(size_t x)
-{
-	x = x / SIZE_ALIGN - 1;
-	if (x <= 32) return x;
-	x--;
-	if (x < 512) return bin_tab[x/8-4] + 1;
-	return bin_tab[x/128-4] + 17;
-}
-
-#if 0
-void __dump_heap(int x)
-{
-	struct chunk *c;
-	int i;
-	for (c = (void *)mal.heap; CHUNK_SIZE(c); c = NEXT_CHUNK(c))
-		fprintf(stderr, "base %p size %zu (%d) flags %d/%d\n",
-			c, CHUNK_SIZE(c), bin_index(CHUNK_SIZE(c)),
-			c->csize & 15,
-			NEXT_CHUNK(c)->psize & 15);
-	for (i=0; i<64; i++) {
-		if (mal.bins[i].head != BIN_TO_CHUNK(i) && mal.bins[i].head) {
-			fprintf(stderr, "bin %d: %p\n", i, mal.bins[i].head);
-			if (!(mal.binmap & 1ULL<<i))
-				fprintf(stderr, "missing from binmap!\n");
-		} else if (mal.binmap & 1ULL<<i)
-			fprintf(stderr, "binmap wrongly contains %d!\n", i);
-	}
-}
-#endif
-
-/* This function returns true if the interval [old,new]
- * intersects the 'len'-sized interval below &libc.auxv
- * (interpreted as the main-thread stack) or below &b
- * (the current stack). It is used to defend against
- * buggy brk implementations that can cross the stack. */
-
-static int traverses_stack_p(uintptr_t old, uintptr_t new)
-{
-	const uintptr_t len = 8<<20;
-	uintptr_t a, b;
-
-	b = (uintptr_t)libc.auxv;
-	a = b > len ? b-len : 0;
-	if (new>a && old<b) return 1;
-
-	b = (uintptr_t)&b;
-	a = b > len ? b-len : 0;
-	if (new>a && old<b) return 1;
-
-	return 0;
-}
-
-/* Expand the heap in-place if brk can be used, or otherwise via mmap,
- * using an exponential lower bound on growth by mmap to make
- * fragmentation asymptotically irrelevant. The size argument is both
- * an input and an output, since the caller needs to know the size
- * allocated, which will be larger than requested due to page alignment
- * and mmap minimum size rules. The caller is responsible for locking
- * to prevent concurrent calls. */
-
-static void *__expand_heap(size_t *pn)
-{
-	static uintptr_t brk;
-	static unsigned mmap_step;
-	size_t n = *pn;
-
-	if (n > SIZE_MAX/2 - PAGE_SIZE) {
-		errno = ENOMEM;
-		return 0;
-	}
-	n += -n & PAGE_SIZE-1;
-
-	if (!brk) {
-		brk = __syscall(SYS_brk, 0);
-		brk += -brk & PAGE_SIZE-1;
-	}
-
-	if (n < SIZE_MAX-brk && !traverses_stack_p(brk, brk+n)
-	    && __syscall(SYS_brk, brk+n)==brk+n) {
-		*pn = n;
-		brk += n;
-		return (void *)(brk-n);
-	}
-
-	size_t min = (size_t)PAGE_SIZE << mmap_step/2;
-	if (n < min) n = min;
-	void *area = __mmap(0, n, PROT_READ|PROT_WRITE,
-		MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
-	if (area == MAP_FAILED) return 0;
-	*pn = n;
-	mmap_step++;
-	return area;
-}
-
-static struct chunk *expand_heap(size_t n)
-{
-	static void *end;
-	void *p;
-	struct chunk *w;
-
-	/* The argument n already accounts for the caller's chunk
-	 * overhead needs, but if the heap can't be extended in-place,
-	 * we need room for an extra zero-sized sentinel chunk. */
-	n += SIZE_ALIGN;
-
-	p = __expand_heap(&n);
-	if (!p) return 0;
-
-	/* If not just expanding existing space, we need to make a
-	 * new sentinel chunk below the allocated space. */
-	if (p != end) {
-		/* Valid/safe because of the prologue increment. */
-		n -= SIZE_ALIGN;
-		p = (char *)p + SIZE_ALIGN;
-		w = MEM_TO_CHUNK(p);
-		w->psize = 0 | C_INUSE;
-	}
-
-	/* Record new heap end and fill in footer. */
-	end = (char *)p + n;
-	w = MEM_TO_CHUNK(end);
-	w->psize = n | C_INUSE;
-	w->csize = 0 | C_INUSE;
-
-	/* Fill in header, which may be new or may be replacing a
-	 * zero-size sentinel header at the old end-of-heap. */
-	w = MEM_TO_CHUNK(p);
-	w->csize = n | C_INUSE;
-
-	return w;
-}
-
-static int adjust_size(size_t *n)
-{
-	/* Result of pointer difference must fit in ptrdiff_t. */
-	if (*n-1 > PTRDIFF_MAX - SIZE_ALIGN - PAGE_SIZE) {
-		if (*n) {
-			errno = ENOMEM;
-			return -1;
-		} else {
-			*n = SIZE_ALIGN;
-			return 0;
-		}
-	}
-	*n = (*n + OVERHEAD + SIZE_ALIGN - 1) & SIZE_MASK;
-	return 0;
-}
-
-static void unbin(struct chunk *c, int i)
-{
-	if (c->prev == c->next)
-		a_and_64(&mal.binmap, ~(1ULL<<i));
-	c->prev->next = c->next;
-	c->next->prev = c->prev;
-	c->csize |= C_INUSE;
-	NEXT_CHUNK(c)->psize |= C_INUSE;
-}
-
-static void bin_chunk(struct chunk *self, int i)
-{
-	self->next = BIN_TO_CHUNK(i);
-	self->prev = mal.bins[i].tail;
-	self->next->prev = self;
-	self->prev->next = self;
-	if (self->prev == BIN_TO_CHUNK(i))
-		a_or_64(&mal.binmap, 1ULL<<i);
-}
-
-static void trim(struct chunk *self, size_t n)
-{
-	size_t n1 = CHUNK_SIZE(self);
-	struct chunk *next, *split;
-
-	if (n >= n1 - DONTCARE) return;
-
-	next = NEXT_CHUNK(self);
-	split = (void *)((char *)self + n);
-
-	split->psize = n | C_INUSE;
-	split->csize = n1-n;
-	next->psize = n1-n;
-	self->csize = n | C_INUSE;
-
-	int i = bin_index(n1-n);
-	lock_bin(i);
-
-	bin_chunk(split, i);
-
-	unlock_bin(i);
-}
-
-void *malloc(size_t n)
-{
-	struct chunk *c;
-	int i, j;
-	uint64_t mask;
-
-	if (adjust_size(&n) < 0) return 0;
-
-	if (n > MMAP_THRESHOLD) {
-		size_t len = n + OVERHEAD + PAGE_SIZE - 1 & -PAGE_SIZE;
-		char *base = __mmap(0, len, PROT_READ|PROT_WRITE,
-			MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
-		if (base == (void *)-1) return 0;
-		c = (void *)(base + SIZE_ALIGN - OVERHEAD);
-		c->csize = len - (SIZE_ALIGN - OVERHEAD);
-		c->psize = SIZE_ALIGN - OVERHEAD;
-		return CHUNK_TO_MEM(c);
-	}
-
-	i = bin_index_up(n);
-	if (i<63 && (mal.binmap & (1ULL<<i))) {
-		lock_bin(i);
-		c = mal.bins[i].head;
-		if (c != BIN_TO_CHUNK(i) && CHUNK_SIZE(c)-n <= DONTCARE) {
-			unbin(c, i);
-			unlock_bin(i);
-			return CHUNK_TO_MEM(c);
-		}
-		unlock_bin(i);
-	}
-	lock(mal.split_merge_lock);
-	for (mask = mal.binmap & -(1ULL<<i); mask; mask -= (mask&-mask)) {
-		j = first_set(mask);
-		lock_bin(j);
-		c = mal.bins[j].head;
-		if (c != BIN_TO_CHUNK(j)) {
-			unbin(c, j);
-			unlock_bin(j);
-			break;
-		}
-		unlock_bin(j);
-	}
-	if (!mask) {
-		c = expand_heap(n);
-		if (!c) {
-			unlock(mal.split_merge_lock);
-			return 0;
-		}
-	}
-	trim(c, n);
-	unlock(mal.split_merge_lock);
-	return CHUNK_TO_MEM(c);
-}
-
-int __malloc_allzerop(void *p)
-{
-	return IS_MMAPPED(MEM_TO_CHUNK(p));
-}
-
-void *realloc(void *p, size_t n)
-{
-	struct chunk *self, *next;
-	size_t n0, n1;
-	void *new;
-
-	if (!p) return malloc(n);
-
-	if (adjust_size(&n) < 0) return 0;
-
-	self = MEM_TO_CHUNK(p);
-	n1 = n0 = CHUNK_SIZE(self);
-
-	if (n<=n0 && n0-n<=DONTCARE) return p;
-
-	if (IS_MMAPPED(self)) {
-		size_t extra = self->psize;
-		char *base = (char *)self - extra;
-		size_t oldlen = n0 + extra;
-		size_t newlen = n + extra;
-		/* Crash on realloc of freed chunk */
-		if (extra & 1) a_crash();
-		if (newlen < PAGE_SIZE && (new = malloc(n-OVERHEAD))) {
-			n0 = n;
-			goto copy_free_ret;
-		}
-		newlen = (newlen + PAGE_SIZE-1) & -PAGE_SIZE;
-		if (oldlen == newlen) return p;
-		base = __mremap(base, oldlen, newlen, MREMAP_MAYMOVE);
-		if (base == (void *)-1)
-			goto copy_realloc;
-		self = (void *)(base + extra);
-		self->csize = newlen - extra;
-		return CHUNK_TO_MEM(self);
-	}
-
-	next = NEXT_CHUNK(self);
-
-	/* Crash on corrupted footer (likely from buffer overflow) */
-	if (next->psize != self->csize) a_crash();
-
-	if (n < n0) {
-		int i = bin_index_up(n);
-		int j = bin_index(n0);
-		if (i<j && (mal.binmap & (1ULL << i)))
-			goto copy_realloc;
-		struct chunk *split = (void *)((char *)self + n);
-		self->csize = split->psize = n | C_INUSE;
-		split->csize = next->psize = n0-n | C_INUSE;
-		__bin_chunk(split);
-		return CHUNK_TO_MEM(self);
-	}
-
-	lock(mal.split_merge_lock);
-
-	size_t nsize = next->csize & C_INUSE ? 0 : CHUNK_SIZE(next);
-	if (n0+nsize >= n) {
-		int i = bin_index(nsize);
-		lock_bin(i);
-		if (!(next->csize & C_INUSE)) {
-			unbin(next, i);
-			unlock_bin(i);
-			next = NEXT_CHUNK(next);
-			self->csize = next->psize = n0+nsize | C_INUSE;
-			trim(self, n);
-			unlock(mal.split_merge_lock);
-			return CHUNK_TO_MEM(self);
-		}
-		unlock_bin(i);
-	}
-	unlock(mal.split_merge_lock);
-
-copy_realloc:
-	/* As a last resort, allocate a new chunk and copy to it. */
-	new = malloc(n-OVERHEAD);
-	if (!new) return 0;
-copy_free_ret:
-	memcpy(new, p, (n<n0 ? n : n0) - OVERHEAD);
-	free(CHUNK_TO_MEM(self));
-	return new;
-}
-
-void __bin_chunk(struct chunk *self)
-{
-	struct chunk *next = NEXT_CHUNK(self);
-
-	/* Crash on corrupted footer (likely from buffer overflow) */
-	if (next->psize != self->csize) a_crash();
-
-	lock(mal.split_merge_lock);
-
-	size_t osize = CHUNK_SIZE(self), size = osize;
-
-	/* Since we hold split_merge_lock, only transition from free to
-	 * in-use can race; in-use to free is impossible */
-	size_t psize = self->psize & C_INUSE ? 0 : CHUNK_PSIZE(self);
-	size_t nsize = next->csize & C_INUSE ? 0 : CHUNK_SIZE(next);
-
-	if (psize) {
-		int i = bin_index(psize);
-		lock_bin(i);
-		if (!(self->psize & C_INUSE)) {
-			struct chunk *prev = PREV_CHUNK(self);
-			unbin(prev, i);
-			self = prev;
-			size += psize;
-		}
-		unlock_bin(i);
-	}
-	if (nsize) {
-		int i = bin_index(nsize);
-		lock_bin(i);
-		if (!(next->csize & C_INUSE)) {
-			unbin(next, i);
-			next = NEXT_CHUNK(next);
-			size += nsize;
-		}
-		unlock_bin(i);
-	}
-
-	int i = bin_index(size);
-	lock_bin(i);
-
-	self->csize = size;
-	next->psize = size;
-	bin_chunk(self, i);
-	unlock(mal.split_merge_lock);
-
-	/* Replace middle of large chunks with fresh zero pages */
-	if (size > RECLAIM && (size^(size-osize)) > size-osize) {
-		uintptr_t a = (uintptr_t)self + SIZE_ALIGN+PAGE_SIZE-1 & -PAGE_SIZE;
-		uintptr_t b = (uintptr_t)next - SIZE_ALIGN & -PAGE_SIZE;
-		int e = errno;
-#if 1
-		__madvise((void *)a, b-a, MADV_DONTNEED);
-#else
-		__mmap((void *)a, b-a, PROT_READ|PROT_WRITE,
-			MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
-#endif
-		errno = e;
-	}
-
-	unlock_bin(i);
-}
-
-static void unmap_chunk(struct chunk *self)
-{
-	size_t extra = self->psize;
-	char *base = (char *)self - extra;
-	size_t len = CHUNK_SIZE(self) + extra;
-	/* Crash on double free */
-	if (extra & 1) a_crash();
-	int e = errno;
-	__munmap(base, len);
-	errno = e;
-}
-
-void free(void *p)
-{
-	if (!p) return;
-
-	struct chunk *self = MEM_TO_CHUNK(p);
-
-	if (IS_MMAPPED(self))
-		unmap_chunk(self);
-	else
-		__bin_chunk(self);
-}
-
-void __malloc_donate(char *start, char *end)
-{
-	size_t align_start_up = (SIZE_ALIGN-1) & (-(uintptr_t)start - OVERHEAD);
-	size_t align_end_down = (SIZE_ALIGN-1) & (uintptr_t)end;
-
-	/* Getting past this condition ensures that the padding for alignment
-	 * and header overhead will not overflow and will leave a nonzero
-	 * multiple of SIZE_ALIGN bytes between start and end. */
-	if (end - start <= OVERHEAD + align_start_up + align_end_down)
-		return;
-	start += align_start_up + OVERHEAD;
-	end   -= align_end_down;
-
-	struct chunk *c = MEM_TO_CHUNK(start), *n = MEM_TO_CHUNK(end);
-	c->psize = n->csize = C_INUSE;
-	c->csize = n->psize = C_INUSE | (end-start);
-	__bin_chunk(c);
-}
-
-void __malloc_atfork(int who)
-{
-	if (who<0) {
-		lock(mal.split_merge_lock);
-		for (int i=0; i<64; i++)
-			lock(mal.bins[i].lock);
-	} else if (!who) {
-		for (int i=0; i<64; i++)
-			unlock(mal.bins[i].lock);
-		unlock(mal.split_merge_lock);
-	} else {
-		for (int i=0; i<64; i++)
-			mal.bins[i].lock[0] = mal.bins[i].lock[1] = 0;
-		mal.split_merge_lock[1] = 0;
-		mal.split_merge_lock[0] = 0;
-	}
-}
diff --git a/src/malloc/oldmalloc/malloc_impl.h b/src/malloc/oldmalloc/malloc_impl.h
deleted file mode 100644
index e1cf4774c1e4..000000000000
--- a/src/malloc/oldmalloc/malloc_impl.h
+++ /dev/null
@@ -1,39 +0,0 @@
-#ifndef MALLOC_IMPL_H
-#define MALLOC_IMPL_H
-
-#include <sys/mman.h>
-#include "dynlink.h"
-
-struct chunk {
-	size_t psize, csize;
-	struct chunk *next, *prev;
-};
-
-struct bin {
-	volatile int lock[2];
-	struct chunk *head;
-	struct chunk *tail;
-};
-
-#define SIZE_ALIGN (4*sizeof(size_t))
-#define SIZE_MASK (-SIZE_ALIGN)
-#define OVERHEAD (2*sizeof(size_t))
-#define MMAP_THRESHOLD (0x1c00*SIZE_ALIGN)
-#define DONTCARE 16
-#define RECLAIM 163840
-
-#define CHUNK_SIZE(c) ((c)->csize & -2)
-#define CHUNK_PSIZE(c) ((c)->psize & -2)
-#define PREV_CHUNK(c) ((struct chunk *)((char *)(c) - CHUNK_PSIZE(c)))
-#define NEXT_CHUNK(c) ((struct chunk *)((char *)(c) + CHUNK_SIZE(c)))
-#define MEM_TO_CHUNK(p) (struct chunk *)((char *)(p) - OVERHEAD)
-#define CHUNK_TO_MEM(c) (void *)((char *)(c) + OVERHEAD)
-#define BIN_TO_CHUNK(i) (MEM_TO_CHUNK(&mal.bins[i].head))
-
-#define C_INUSE  ((size_t)1)
-
-#define IS_MMAPPED(c) !((c)->csize & (C_INUSE))
-
-hidden void __bin_chunk(struct chunk *);
-
-#endif
diff --git a/src/malloc/oldmalloc/malloc_usable_size.c b/src/malloc/oldmalloc/malloc_usable_size.c
deleted file mode 100644
index 672b518ad0ef..000000000000
--- a/src/malloc/oldmalloc/malloc_usable_size.c
+++ /dev/null
@@ -1,9 +0,0 @@
-#include <malloc.h>
-#include "malloc_impl.h"
- 
-hidden void *(*const __realloc_dep)(void *, size_t) = realloc;
-
-size_t malloc_usable_size(void *p)
-{
-	return p ? CHUNK_SIZE(MEM_TO_CHUNK(p)) - OVERHEAD : 0;
-}
diff --git a/src/malloc/realloc.c b/src/malloc/realloc.c
index fb0e8b7c4786..59d16abe986f 100644
--- a/src/malloc/realloc.c
+++ b/src/malloc/realloc.c
@@ -1,6 +1,7 @@
 #include <stdlib.h>
+#include <stdfil.h>
 
 void *realloc(void *p, size_t n)
 {
-	return __libc_realloc(p, n);
+    return zgc_realloc(p, n);
 }
diff --git a/src/malloc/replaced.c b/src/malloc/replaced.c
deleted file mode 100644
index 07fce61ec08d..000000000000
--- a/src/malloc/replaced.c
+++ /dev/null
@@ -1,4 +0,0 @@
-#include "dynlink.h"
-
-int __malloc_replaced;
-int __aligned_alloc_replaced;
diff --git a/src/math/aarch64/ceil.c b/src/math/aarch64/ceil.c
deleted file mode 100644
index ac80c1dce5e4..000000000000
--- a/src/math/aarch64/ceil.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-double ceil(double x)
-{
-	__asm__ ("frintp %d0, %d1" : "=w"(x) : "w"(x));
-	return x;
-}
diff --git a/src/math/aarch64/ceilf.c b/src/math/aarch64/ceilf.c
deleted file mode 100644
index 1ef1e9c83940..000000000000
--- a/src/math/aarch64/ceilf.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-float ceilf(float x)
-{
-	__asm__ ("frintp %s0, %s1" : "=w"(x) : "w"(x));
-	return x;
-}
diff --git a/src/math/aarch64/fabs.c b/src/math/aarch64/fabs.c
deleted file mode 100644
index 5c3ecaf44b1d..000000000000
--- a/src/math/aarch64/fabs.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-double fabs(double x)
-{
-	__asm__ ("fabs %d0, %d1" : "=w"(x) : "w"(x));
-	return x;
-}
diff --git a/src/math/aarch64/fabsf.c b/src/math/aarch64/fabsf.c
deleted file mode 100644
index 7fde9817931c..000000000000
--- a/src/math/aarch64/fabsf.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-float fabsf(float x)
-{
-	__asm__ ("fabs %s0, %s1" : "=w"(x) : "w"(x));
-	return x;
-}
diff --git a/src/math/aarch64/floor.c b/src/math/aarch64/floor.c
deleted file mode 100644
index 50ffdb281b61..000000000000
--- a/src/math/aarch64/floor.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-double floor(double x)
-{
-	__asm__ ("frintm %d0, %d1" : "=w"(x) : "w"(x));
-	return x;
-}
diff --git a/src/math/aarch64/floorf.c b/src/math/aarch64/floorf.c
deleted file mode 100644
index 8d007e9f84ac..000000000000
--- a/src/math/aarch64/floorf.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-float floorf(float x)
-{
-	__asm__ ("frintm %s0, %s1" : "=w"(x) : "w"(x));
-	return x;
-}
diff --git a/src/math/aarch64/fma.c b/src/math/aarch64/fma.c
deleted file mode 100644
index 2450ea7e196f..000000000000
--- a/src/math/aarch64/fma.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-double fma(double x, double y, double z)
-{
-	__asm__ ("fmadd %d0, %d1, %d2, %d3" : "=w"(x) : "w"(x), "w"(y), "w"(z));
-	return x;
-}
diff --git a/src/math/aarch64/fmaf.c b/src/math/aarch64/fmaf.c
deleted file mode 100644
index 9a147213a02b..000000000000
--- a/src/math/aarch64/fmaf.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-float fmaf(float x, float y, float z)
-{
-	__asm__ ("fmadd %s0, %s1, %s2, %s3" : "=w"(x) : "w"(x), "w"(y), "w"(z));
-	return x;
-}
diff --git a/src/math/aarch64/fmax.c b/src/math/aarch64/fmax.c
deleted file mode 100644
index 86dcb3b4591c..000000000000
--- a/src/math/aarch64/fmax.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-double fmax(double x, double y)
-{
-	__asm__ ("fmaxnm %d0, %d1, %d2" : "=w"(x) : "w"(x), "w"(y));
-	return x;
-}
diff --git a/src/math/aarch64/fmaxf.c b/src/math/aarch64/fmaxf.c
deleted file mode 100644
index ee5eac2d7384..000000000000
--- a/src/math/aarch64/fmaxf.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-float fmaxf(float x, float y)
-{
-	__asm__ ("fmaxnm %s0, %s1, %s2" : "=w"(x) : "w"(x), "w"(y));
-	return x;
-}
diff --git a/src/math/aarch64/fmin.c b/src/math/aarch64/fmin.c
deleted file mode 100644
index f1e99808e087..000000000000
--- a/src/math/aarch64/fmin.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-double fmin(double x, double y)
-{
-	__asm__ ("fminnm %d0, %d1, %d2" : "=w"(x) : "w"(x), "w"(y));
-	return x;
-}
diff --git a/src/math/aarch64/fminf.c b/src/math/aarch64/fminf.c
deleted file mode 100644
index 80468f676a7a..000000000000
--- a/src/math/aarch64/fminf.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-float fminf(float x, float y)
-{
-	__asm__ ("fminnm %s0, %s1, %s2" : "=w"(x) : "w"(x), "w"(y));
-	return x;
-}
diff --git a/src/math/aarch64/llrint.c b/src/math/aarch64/llrint.c
deleted file mode 100644
index a9e07a93f18f..000000000000
--- a/src/math/aarch64/llrint.c
+++ /dev/null
@@ -1,10 +0,0 @@
-#include <math.h>
-
-long long llrint(double x)
-{
-	long long n;
-	__asm__ (
-		"frintx %d1, %d1\n"
-		"fcvtzs %x0, %d1\n" : "=r"(n), "+w"(x));
-	return n;
-}
diff --git a/src/math/aarch64/llrintf.c b/src/math/aarch64/llrintf.c
deleted file mode 100644
index 12b6804f7f9d..000000000000
--- a/src/math/aarch64/llrintf.c
+++ /dev/null
@@ -1,10 +0,0 @@
-#include <math.h>
-
-long long llrintf(float x)
-{
-	long long n;
-	__asm__ (
-		"frintx %s1, %s1\n"
-		"fcvtzs %x0, %s1\n" : "=r"(n), "+w"(x));
-	return n;
-}
diff --git a/src/math/aarch64/llround.c b/src/math/aarch64/llround.c
deleted file mode 100644
index e09ddd482a59..000000000000
--- a/src/math/aarch64/llround.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <math.h>
-
-long long llround(double x)
-{
-	long long n;
-	__asm__ ("fcvtas %x0, %d1" : "=r"(n) : "w"(x));
-	return n;
-}
diff --git a/src/math/aarch64/llroundf.c b/src/math/aarch64/llroundf.c
deleted file mode 100644
index 16699598ac65..000000000000
--- a/src/math/aarch64/llroundf.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <math.h>
-
-long long llroundf(float x)
-{
-	long long n;
-	__asm__ ("fcvtas %x0, %s1" : "=r"(n) : "w"(x));
-	return n;
-}
diff --git a/src/math/aarch64/lrint.c b/src/math/aarch64/lrint.c
deleted file mode 100644
index cb7785ad1e41..000000000000
--- a/src/math/aarch64/lrint.c
+++ /dev/null
@@ -1,10 +0,0 @@
-#include <math.h>
-
-long lrint(double x)
-{
-	long n;
-	__asm__ (
-		"frintx %d1, %d1\n"
-		"fcvtzs %x0, %d1\n" : "=r"(n), "+w"(x));
-	return n;
-}
diff --git a/src/math/aarch64/lrintf.c b/src/math/aarch64/lrintf.c
deleted file mode 100644
index 4d750d699d50..000000000000
--- a/src/math/aarch64/lrintf.c
+++ /dev/null
@@ -1,10 +0,0 @@
-#include <math.h>
-
-long lrintf(float x)
-{
-	long n;
-	__asm__ (
-		"frintx %s1, %s1\n"
-		"fcvtzs %x0, %s1\n" : "=r"(n), "+w"(x));
-	return n;
-}
diff --git a/src/math/aarch64/lround.c b/src/math/aarch64/lround.c
deleted file mode 100644
index 85656c78d1c3..000000000000
--- a/src/math/aarch64/lround.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <math.h>
-
-long lround(double x)
-{
-	long n;
-	__asm__ ("fcvtas %x0, %d1" : "=r"(n) : "w"(x));
-	return n;
-}
diff --git a/src/math/aarch64/lroundf.c b/src/math/aarch64/lroundf.c
deleted file mode 100644
index 32e51f3cc3c7..000000000000
--- a/src/math/aarch64/lroundf.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <math.h>
-
-long lroundf(float x)
-{
-	long n;
-	__asm__ ("fcvtas %x0, %s1" : "=r"(n) : "w"(x));
-	return n;
-}
diff --git a/src/math/aarch64/nearbyint.c b/src/math/aarch64/nearbyint.c
deleted file mode 100644
index 9c3fdb4450e9..000000000000
--- a/src/math/aarch64/nearbyint.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-double nearbyint(double x)
-{
-	__asm__ ("frinti %d0, %d1" : "=w"(x) : "w"(x));
-	return x;
-}
diff --git a/src/math/aarch64/nearbyintf.c b/src/math/aarch64/nearbyintf.c
deleted file mode 100644
index 8e7f61df8c40..000000000000
--- a/src/math/aarch64/nearbyintf.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-float nearbyintf(float x)
-{
-	__asm__ ("frinti %s0, %s1" : "=w"(x) : "w"(x));
-	return x;
-}
diff --git a/src/math/aarch64/rint.c b/src/math/aarch64/rint.c
deleted file mode 100644
index 45b194b5e495..000000000000
--- a/src/math/aarch64/rint.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-double rint(double x)
-{
-	__asm__ ("frintx %d0, %d1" : "=w"(x) : "w"(x));
-	return x;
-}
diff --git a/src/math/aarch64/rintf.c b/src/math/aarch64/rintf.c
deleted file mode 100644
index 1ae7dd254003..000000000000
--- a/src/math/aarch64/rintf.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-float rintf(float x)
-{
-	__asm__ ("frintx %s0, %s1" : "=w"(x) : "w"(x));
-	return x;
-}
diff --git a/src/math/aarch64/round.c b/src/math/aarch64/round.c
deleted file mode 100644
index 897a84cc2a04..000000000000
--- a/src/math/aarch64/round.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-double round(double x)
-{
-	__asm__ ("frinta %d0, %d1" : "=w"(x) : "w"(x));
-	return x;
-}
diff --git a/src/math/aarch64/roundf.c b/src/math/aarch64/roundf.c
deleted file mode 100644
index 91637eaa1204..000000000000
--- a/src/math/aarch64/roundf.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-float roundf(float x)
-{
-	__asm__ ("frinta %s0, %s1" : "=w"(x) : "w"(x));
-	return x;
-}
diff --git a/src/math/aarch64/sqrt.c b/src/math/aarch64/sqrt.c
deleted file mode 100644
index fe93c3e6ad55..000000000000
--- a/src/math/aarch64/sqrt.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-double sqrt(double x)
-{
-	__asm__ ("fsqrt %d0, %d1" : "=w"(x) : "w"(x));
-	return x;
-}
diff --git a/src/math/aarch64/sqrtf.c b/src/math/aarch64/sqrtf.c
deleted file mode 100644
index 275c7f399c10..000000000000
--- a/src/math/aarch64/sqrtf.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-float sqrtf(float x)
-{
-	__asm__ ("fsqrt %s0, %s1" : "=w"(x) : "w"(x));
-	return x;
-}
diff --git a/src/math/aarch64/trunc.c b/src/math/aarch64/trunc.c
deleted file mode 100644
index e592147a0ca9..000000000000
--- a/src/math/aarch64/trunc.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-double trunc(double x)
-{
-	__asm__ ("frintz %d0, %d1" : "=w"(x) : "w"(x));
-	return x;
-}
diff --git a/src/math/aarch64/truncf.c b/src/math/aarch64/truncf.c
deleted file mode 100644
index 20ef30f12847..000000000000
--- a/src/math/aarch64/truncf.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-float truncf(float x)
-{
-	__asm__ ("frintz %s0, %s1" : "=w"(x) : "w"(x));
-	return x;
-}
diff --git a/src/math/x86_64/__invtrigl.s b/src/math/x86_64/__invtrigl.s
deleted file mode 100644
index e69de29bb2d1..000000000000
diff --git a/src/math/x86_64/acosl.s b/src/math/x86_64/acosl.s
deleted file mode 100644
index 88e01b49a2bb..000000000000
--- a/src/math/x86_64/acosl.s
+++ /dev/null
@@ -1,16 +0,0 @@
-# see ../i386/acos.s
-
-.global acosl
-.type acosl,@function
-acosl:
-	fldt 8(%rsp)
-1:	fld %st(0)
-	fld1
-	fsub %st(0),%st(1)
-	fadd %st(2)
-	fmulp
-	fsqrt
-	fabs
-	fxch %st(1)
-	fpatan
-	ret
diff --git a/src/math/x86_64/asinl.s b/src/math/x86_64/asinl.s
deleted file mode 100644
index ed212d9a6c17..000000000000
--- a/src/math/x86_64/asinl.s
+++ /dev/null
@@ -1,12 +0,0 @@
-.global asinl
-.type asinl,@function
-asinl:
-	fldt 8(%rsp)
-1:	fld %st(0)
-	fld1
-	fsub %st(0),%st(1)
-	fadd %st(2)
-	fmulp
-	fsqrt
-	fpatan
-	ret
diff --git a/src/math/x86_64/atan2l.s b/src/math/x86_64/atan2l.s
deleted file mode 100644
index e5f0a3deb36e..000000000000
--- a/src/math/x86_64/atan2l.s
+++ /dev/null
@@ -1,7 +0,0 @@
-.global atan2l
-.type atan2l,@function
-atan2l:
-	fldt 8(%rsp)
-	fldt 24(%rsp)
-	fpatan
-	ret
diff --git a/src/math/x86_64/atanl.s b/src/math/x86_64/atanl.s
deleted file mode 100644
index df76de5de4f1..000000000000
--- a/src/math/x86_64/atanl.s
+++ /dev/null
@@ -1,7 +0,0 @@
-.global atanl
-.type atanl,@function
-atanl:
-	fldt 8(%rsp)
-	fld1
-	fpatan
-	ret
diff --git a/src/math/x86_64/ceill.s b/src/math/x86_64/ceill.s
deleted file mode 100644
index f5cfa3b307b4..000000000000
--- a/src/math/x86_64/ceill.s
+++ /dev/null
@@ -1 +0,0 @@
-# see floorl.s
diff --git a/src/math/x86_64/exp2l.s b/src/math/x86_64/exp2l.s
deleted file mode 100644
index effab2bd4eb2..000000000000
--- a/src/math/x86_64/exp2l.s
+++ /dev/null
@@ -1,83 +0,0 @@
-.global expm1l
-.type expm1l,@function
-expm1l:
-	fldt 8(%rsp)
-	fldl2e
-	fmulp
-	movl $0xc2820000,-4(%rsp)
-	flds -4(%rsp)
-	fucomip %st(1),%st
-	fld1
-	jb 1f
-		# x*log2e <= -65, return -1 without underflow
-	fstp %st(1)
-	fchs
-	ret
-1:	fld %st(1)
-	fabs
-	fucomip %st(1),%st
-	fstp %st(0)
-	ja 1f
-	f2xm1
-	ret
-1:	push %rax
-	call 1f
-	pop %rax
-	fld1
-	fsubrp
-	ret
-
-.global exp2l
-.type exp2l,@function
-exp2l:
-	fldt 8(%rsp)
-1:	fld %st(0)
-	sub $16,%rsp
-	fstpt (%rsp)
-	mov 8(%rsp),%ax
-	and $0x7fff,%ax
-	cmp $0x3fff+13,%ax
-	jb 4f             # |x| < 8192
-	cmp $0x3fff+15,%ax
-	jae 3f            # |x| >= 32768
-	fsts (%rsp)
-	cmpl $0xc67ff800,(%rsp)
-	jb 2f             # x > -16382
-	movl $0x5f000000,(%rsp)
-	flds (%rsp)       # 0x1p63
-	fld %st(1)
-	fsub %st(1)
-	faddp
-	fucomip %st(1),%st
-	je 2f             # x - 0x1p63 + 0x1p63 == x
-	movl $1,(%rsp)
-	flds (%rsp)       # 0x1p-149
-	fdiv %st(1)
-	fstps (%rsp)      # raise underflow
-2:	fld1
-	fld %st(1)
-	frndint
-	fxch %st(2)
-	fsub %st(2)       # st(0)=x-rint(x), st(1)=1, st(2)=rint(x)
-	f2xm1
-	faddp             # 2^(x-rint(x))
-1:	fscale
-	fstp %st(1)
-	add $16,%rsp
-	ret
-3:	xor %eax,%eax
-4:	cmp $0x3fff-64,%ax
-	fld1
-	jb 1b             # |x| < 0x1p-64
-	fstpt (%rsp)
-	fistl 8(%rsp)
-	fildl 8(%rsp)
-	fsubrp %st(1)
-	addl $0x3fff,8(%rsp)
-	f2xm1
-	fld1
-	faddp             # 2^(x-rint(x))
-	fldt (%rsp)       # 2^rint(x)
-	fmulp
-	add $16,%rsp
-	ret
diff --git a/src/math/x86_64/expl.s b/src/math/x86_64/expl.s
deleted file mode 100644
index 798261d28353..000000000000
--- a/src/math/x86_64/expl.s
+++ /dev/null
@@ -1,101 +0,0 @@
-# exp(x) = 2^hi + 2^hi (2^lo - 1)
-# where hi+lo = log2e*x with 128bit precision
-# exact log2e*x calculation depends on nearest rounding mode
-# using the exact multiplication method of Dekker and Veltkamp
-
-.global expl
-.type expl,@function
-expl:
-	fldt 8(%rsp)
-
-		# interesting case: 0x1p-32 <= |x| < 16384
-		# check if (exponent|0x8000) is in [0xbfff-32, 0xbfff+13]
-	mov 16(%rsp), %ax
-	or $0x8000, %ax
-	sub $0xbfdf, %ax
-	cmp $45, %ax
-	jbe 2f
-	test %ax, %ax
-	fld1
-	js 1f
-		# if |x|>=0x1p14 or nan return 2^trunc(x)
-	fscale
-	fstp %st(1)
-	ret
-		# if |x|<0x1p-32 return 1+x
-1:	faddp
-	ret
-
-		# should be 0x1.71547652b82fe178p0L == 0x3fff b8aa3b29 5c17f0bc
-		# it will be wrong on non-nearest rounding mode
-2:	fldl2e
-	subq $48, %rsp
-		# hi = log2e_hi*x
-		# 2^hi = exp2l(hi)
-	fmul %st(1),%st
-	fld %st(0)
-	fstpt (%rsp)
-	fstpt 16(%rsp)
-	fstpt 32(%rsp)
-	call exp2l@PLT
-		# if 2^hi == inf return 2^hi
-	fld %st(0)
-	fstpt (%rsp)
-	cmpw $0x7fff, 8(%rsp)
-	je 1f
-	fldt 32(%rsp)
-	fldt 16(%rsp)
-		# fpu stack: 2^hi x hi
-		# exact mult: x*log2e
-	fld %st(1)
-		# c = 0x1p32+1
-	movq $0x41f0000000100000,%rax
-	pushq %rax
-	fldl (%rsp)
-		# xh = x - c*x + c*x
-		# xl = x - xh
-	fmulp
-	fld %st(2)
-	fsub %st(1), %st
-	faddp
-	fld %st(2)
-	fsub %st(1), %st
-		# yh = log2e_hi - c*log2e_hi + c*log2e_hi
-	movq $0x3ff7154765200000,%rax
-	pushq %rax
-	fldl (%rsp)
-		# fpu stack: 2^hi x hi xh xl yh
-		# lo = hi - xh*yh + xl*yh
-	fld %st(2)
-	fmul %st(1), %st
-	fsubp %st, %st(4)
-	fmul %st(1), %st
-	faddp %st, %st(3)
-		# yl = log2e_hi - yh
-	movq $0x3de705fc2f000000,%rax
-	pushq %rax
-	fldl (%rsp)
-		# fpu stack: 2^hi x lo xh xl yl
-		# lo += xh*yl + xl*yl
-	fmul %st, %st(2)
-	fmulp %st, %st(1)
-	fxch %st(2)
-	faddp
-	faddp
-		# log2e_lo
-	movq $0xbfbe,%rax
-	pushq %rax
-	movq $0x82f0025f2dc582ee,%rax
-	pushq %rax
-	fldt (%rsp)
-	addq $40,%rsp
-		# fpu stack: 2^hi x lo log2e_lo
-		# lo += log2e_lo*x
-		# return 2^hi + 2^hi (2^lo - 1)
-	fmulp %st, %st(2)
-	faddp
-	f2xm1
-	fmul %st(1), %st
-	faddp
-1:	addq $48, %rsp
-	ret
diff --git a/src/math/x86_64/expm1l.s b/src/math/x86_64/expm1l.s
deleted file mode 100644
index e773f080534a..000000000000
--- a/src/math/x86_64/expm1l.s
+++ /dev/null
@@ -1 +0,0 @@
-# see exp2l.s
diff --git a/src/math/x86_64/fabs.c b/src/math/x86_64/fabs.c
deleted file mode 100644
index 1656247770f7..000000000000
--- a/src/math/x86_64/fabs.c
+++ /dev/null
@@ -1,10 +0,0 @@
-#include <math.h>
-
-double fabs(double x)
-{
-	double t;
-	__asm__ ("pcmpeqd %0, %0" : "=x"(t));          // t = ~0
-	__asm__ ("psrlq   $1, %0" : "+x"(t));          // t >>= 1
-	__asm__ ("andps   %1, %0" : "+x"(x) : "x"(t)); // x &= t
-	return x;
-}
diff --git a/src/math/x86_64/fabsf.c b/src/math/x86_64/fabsf.c
deleted file mode 100644
index 36ea7481fc40..000000000000
--- a/src/math/x86_64/fabsf.c
+++ /dev/null
@@ -1,10 +0,0 @@
-#include <math.h>
-
-float fabsf(float x)
-{
-	float t;
-	__asm__ ("pcmpeqd %0, %0" : "=x"(t));          // t = ~0
-	__asm__ ("psrld   $1, %0" : "+x"(t));          // t >>= 1
-	__asm__ ("andps   %1, %0" : "+x"(x) : "x"(t)); // x &= t
-	return x;
-}
diff --git a/src/math/x86_64/fabsl.c b/src/math/x86_64/fabsl.c
deleted file mode 100644
index cc1c9ed9c73f..000000000000
--- a/src/math/x86_64/fabsl.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-long double fabsl(long double x)
-{
-	__asm__ ("fabs" : "+t"(x));
-	return x;
-}
diff --git a/src/math/x86_64/floorl.s b/src/math/x86_64/floorl.s
deleted file mode 100644
index 80da46609553..000000000000
--- a/src/math/x86_64/floorl.s
+++ /dev/null
@@ -1,27 +0,0 @@
-.global floorl
-.type floorl,@function
-floorl:
-	fldt 8(%rsp)
-1:	mov $0x7,%al
-1:	fstcw 8(%rsp)
-	mov 9(%rsp),%ah
-	mov %al,9(%rsp)
-	fldcw 8(%rsp)
-	frndint
-	mov %ah,9(%rsp)
-	fldcw 8(%rsp)
-	ret
-
-.global ceill
-.type ceill,@function
-ceill:
-	fldt 8(%rsp)
-	mov $0xb,%al
-	jmp 1b
-
-.global truncl
-.type truncl,@function
-truncl:
-	fldt 8(%rsp)
-	mov $0xf,%al
-	jmp 1b
diff --git a/src/math/x86_64/fma.c b/src/math/x86_64/fma.c
deleted file mode 100644
index 4dd53f2ac86e..000000000000
--- a/src/math/x86_64/fma.c
+++ /dev/null
@@ -1,23 +0,0 @@
-#include <math.h>
-
-#if __FMA__
-
-double fma(double x, double y, double z)
-{
-	__asm__ ("vfmadd132sd %1, %2, %0" : "+x" (x) : "x" (y), "x" (z));
-	return x;
-}
-
-#elif __FMA4__
-
-double fma(double x, double y, double z)
-{
-	__asm__ ("vfmaddsd %3, %2, %1, %0" : "=x" (x) : "x" (x), "x" (y), "x" (z));
-	return x;
-}
-
-#else
-
-#include "../fma.c"
-
-#endif
diff --git a/src/math/x86_64/fmaf.c b/src/math/x86_64/fmaf.c
deleted file mode 100644
index 30b971ff97b5..000000000000
--- a/src/math/x86_64/fmaf.c
+++ /dev/null
@@ -1,23 +0,0 @@
-#include <math.h>
-
-#if __FMA__
-
-float fmaf(float x, float y, float z)
-{
-	__asm__ ("vfmadd132ss %1, %2, %0" : "+x" (x) : "x" (y), "x" (z));
-	return x;
-}
-
-#elif __FMA4__
-
-float fmaf(float x, float y, float z)
-{
-	__asm__ ("vfmaddss %3, %2, %1, %0" : "=x" (x) : "x" (x), "x" (y), "x" (z));
-	return x;
-}
-
-#else
-
-#include "../fmaf.c"
-
-#endif
diff --git a/src/math/x86_64/fmodl.c b/src/math/x86_64/fmodl.c
deleted file mode 100644
index 3daeab060002..000000000000
--- a/src/math/x86_64/fmodl.c
+++ /dev/null
@@ -1,9 +0,0 @@
-#include <math.h>
-
-long double fmodl(long double x, long double y)
-{
-	unsigned short fpsr;
-	do __asm__ ("fprem; fnstsw %%ax" : "+t"(x), "=a"(fpsr) : "u"(y));
-	while (fpsr & 0x400);
-	return x;
-}
diff --git a/src/math/x86_64/llrint.c b/src/math/x86_64/llrint.c
deleted file mode 100644
index dd38a7223a5c..000000000000
--- a/src/math/x86_64/llrint.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <math.h>
-
-long long llrint(double x)
-{
-	long long r;
-	__asm__ ("cvtsd2si %1, %0" : "=r"(r) : "x"(x));
-	return r;
-}
diff --git a/src/math/x86_64/llrintf.c b/src/math/x86_64/llrintf.c
deleted file mode 100644
index fc8625e88c24..000000000000
--- a/src/math/x86_64/llrintf.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <math.h>
-
-long long llrintf(float x)
-{
-	long long r;
-	__asm__ ("cvtss2si %1, %0" : "=r"(r) : "x"(x));
-	return r;
-}
diff --git a/src/math/x86_64/llrintl.c b/src/math/x86_64/llrintl.c
deleted file mode 100644
index c439ef28d1fd..000000000000
--- a/src/math/x86_64/llrintl.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <math.h>
-
-long long llrintl(long double x)
-{
-	long long r;
-	__asm__ ("fistpll %0" : "=m"(r) : "t"(x) : "st");
-	return r;
-}
diff --git a/src/math/x86_64/log10l.s b/src/math/x86_64/log10l.s
deleted file mode 100644
index 48ea4af727c6..000000000000
--- a/src/math/x86_64/log10l.s
+++ /dev/null
@@ -1,7 +0,0 @@
-.global log10l
-.type log10l,@function
-log10l:
-	fldlg2
-	fldt 8(%rsp)
-	fyl2x
-	ret
diff --git a/src/math/x86_64/log1pl.s b/src/math/x86_64/log1pl.s
deleted file mode 100644
index 955c9dbff0c3..000000000000
--- a/src/math/x86_64/log1pl.s
+++ /dev/null
@@ -1,15 +0,0 @@
-.global log1pl
-.type log1pl,@function
-log1pl:
-	mov 14(%rsp),%eax
-	fldln2
-	and $0x7fffffff,%eax
-	fldt 8(%rsp)
-	cmp $0x3ffd9400,%eax
-	ja 1f
-	fyl2xp1
-	ret
-1:	fld1
-	faddp
-	fyl2x
-	ret
diff --git a/src/math/x86_64/log2l.s b/src/math/x86_64/log2l.s
deleted file mode 100644
index ba08b9fb65a2..000000000000
--- a/src/math/x86_64/log2l.s
+++ /dev/null
@@ -1,7 +0,0 @@
-.global log2l
-.type log2l,@function
-log2l:
-	fld1
-	fldt 8(%rsp)
-	fyl2x
-	ret
diff --git a/src/math/x86_64/logl.s b/src/math/x86_64/logl.s
deleted file mode 100644
index 20dd1f819b45..000000000000
--- a/src/math/x86_64/logl.s
+++ /dev/null
@@ -1,7 +0,0 @@
-.global logl
-.type logl,@function
-logl:
-	fldln2
-	fldt 8(%rsp)
-	fyl2x
-	ret
diff --git a/src/math/x86_64/lrint.c b/src/math/x86_64/lrint.c
deleted file mode 100644
index a742fec64c90..000000000000
--- a/src/math/x86_64/lrint.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <math.h>
-
-long lrint(double x)
-{
-	long r;
-	__asm__ ("cvtsd2si %1, %0" : "=r"(r) : "x"(x));
-	return r;
-}
diff --git a/src/math/x86_64/lrintf.c b/src/math/x86_64/lrintf.c
deleted file mode 100644
index 2ba5639dc23f..000000000000
--- a/src/math/x86_64/lrintf.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <math.h>
-
-long lrintf(float x)
-{
-	long r;
-	__asm__ ("cvtss2si %1, %0" : "=r"(r) : "x"(x));
-	return r;
-}
diff --git a/src/math/x86_64/lrintl.c b/src/math/x86_64/lrintl.c
deleted file mode 100644
index 068e2e4d62cf..000000000000
--- a/src/math/x86_64/lrintl.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <math.h>
-
-long lrintl(long double x)
-{
-	long r;
-	__asm__ ("fistpll %0" : "=m"(r) : "t"(x) : "st");
-	return r;
-}
diff --git a/src/math/x86_64/remainderl.c b/src/math/x86_64/remainderl.c
deleted file mode 100644
index 8cf75071ede3..000000000000
--- a/src/math/x86_64/remainderl.c
+++ /dev/null
@@ -1,9 +0,0 @@
-#include <math.h>
-
-long double remainderl(long double x, long double y)
-{
-	unsigned short fpsr;
-	do __asm__ ("fprem1; fnstsw %%ax" : "+t"(x), "=a"(fpsr) : "u"(y));
-	while (fpsr & 0x400);
-	return x;
-}
diff --git a/src/math/x86_64/remquol.c b/src/math/x86_64/remquol.c
deleted file mode 100644
index 60eef089f31b..000000000000
--- a/src/math/x86_64/remquol.c
+++ /dev/null
@@ -1,32 +0,0 @@
-#include <math.h>
-
-long double remquol(long double x, long double y, int *quo)
-{
-	signed char *cx = (void *)&x, *cy = (void *)&y;
-	/* By ensuring that addresses of x and y cannot be discarded,
-	 * this empty asm guides GCC into representing extraction of
-	 * their sign bits as memory loads rather than making x and y
-	 * not-address-taken internally and using bitfield operations,
-	 * which in the end wouldn't work out, as extraction from FPU
-	 * registers needs to go through memory anyway. This way GCC
-	 * should manage to use incoming stack slots without spills. */
-	__asm__ ("" :: "X"(cx), "X"(cy));
-
-	long double t = x;
-	unsigned fpsr;
-	do __asm__ ("fprem1; fnstsw %%ax" : "+t"(t), "=a"(fpsr) : "u"(y));
-	while (fpsr & 0x400);
-	/* C0, C1, C3 flags in x87 status word carry low bits of quotient:
-	 * 15 14 13 12 11 10  9  8
-	 *  . C3  .  .  . C2 C1 C0
-	 *  . b1  .  .  .  0 b0 b2 */
-	unsigned char i = fpsr >> 8;
-	i = i>>4 | i<<4;
-	/* i[5:2] is now {b0 b2 ? b1}. Retrieve {0 b2 b1 b0} via
-	 * in-register table lookup. */
-	unsigned qbits = 0x7575313164642020 >> (i & 60);
-	qbits &= 7;
-
-	*quo = (cx[9]^cy[9]) < 0 ? -qbits : qbits;
-	return t;
-}
diff --git a/src/math/x86_64/rintl.c b/src/math/x86_64/rintl.c
deleted file mode 100644
index e1a92077f558..000000000000
--- a/src/math/x86_64/rintl.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-long double rintl(long double x)
-{
-	__asm__ ("frndint" : "+t"(x));
-	return x;
-}
diff --git a/src/math/x86_64/sqrt.c b/src/math/x86_64/sqrt.c
deleted file mode 100644
index 657e09e3b4d4..000000000000
--- a/src/math/x86_64/sqrt.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-double sqrt(double x)
-{
-	__asm__ ("sqrtsd %1, %0" : "=x"(x) : "x"(x));
-	return x;
-}
diff --git a/src/math/x86_64/sqrtf.c b/src/math/x86_64/sqrtf.c
deleted file mode 100644
index 720baec60128..000000000000
--- a/src/math/x86_64/sqrtf.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-float sqrtf(float x)
-{
-	__asm__ ("sqrtss %1, %0" : "=x"(x) : "x"(x));
-	return x;
-}
diff --git a/src/math/x86_64/sqrtl.c b/src/math/x86_64/sqrtl.c
deleted file mode 100644
index 864cfcc4f66e..000000000000
--- a/src/math/x86_64/sqrtl.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-long double sqrtl(long double x)
-{
-	__asm__ ("fsqrt" : "+t"(x));
-	return x;
-}
diff --git a/src/math/x86_64/truncl.s b/src/math/x86_64/truncl.s
deleted file mode 100644
index f5cfa3b307b4..000000000000
--- a/src/math/x86_64/truncl.s
+++ /dev/null
@@ -1 +0,0 @@
-# see floorl.s
diff --git a/src/misc/getpriority.c b/src/misc/getpriority.c
index 5c0b1682b69a..69359d1ef30d 100644
--- a/src/misc/getpriority.c
+++ b/src/misc/getpriority.c
@@ -3,7 +3,5 @@
 
 int getpriority(int which, id_t who)
 {
-	int ret = syscall(SYS_getpriority, which, who);
-	if (ret < 0) return ret;
-	return 20-ret;
+	return zsys_getpriority(which, who);
 }
diff --git a/src/misc/getresgid.c b/src/misc/getresgid.c
index d00d9a99d353..313259a02f63 100644
--- a/src/misc/getresgid.c
+++ b/src/misc/getresgid.c
@@ -4,5 +4,5 @@
 
 int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid)
 {
-	return syscall(SYS_getresgid, rgid, egid, sgid);
+	return zsys_getresgid(rgid, egid, sgid);
 }
diff --git a/src/misc/getresuid.c b/src/misc/getresuid.c
index d75d5d40867c..1e8f78275c48 100644
--- a/src/misc/getresuid.c
+++ b/src/misc/getresuid.c
@@ -4,5 +4,5 @@
 
 int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid)
 {
-	return syscall(SYS_getresuid, ruid, euid, suid);
+	return zsys_getresuid(ruid, euid, suid);
 }
diff --git a/src/misc/getrlimit.c b/src/misc/getrlimit.c
index a5558d815152..eddfcab81456 100644
--- a/src/misc/getrlimit.c
+++ b/src/misc/getrlimit.c
@@ -1,28 +1,9 @@
 #include <sys/resource.h>
 #include <errno.h>
 #include "syscall.h"
-
-#define FIX(x) do{ if ((x)>=SYSCALL_RLIM_INFINITY) (x)=RLIM_INFINITY; }while(0)
+#include <stdfil.h>
 
 int getrlimit(int resource, struct rlimit *rlim)
 {
-	int ret = syscall(SYS_prlimit64, 0, resource, 0, rlim);
-	if (!ret) {
-		FIX(rlim->rlim_cur);
-		FIX(rlim->rlim_max);
-	}
-#ifdef SYS_getrlimit
-	unsigned long k_rlim[2];
-	if (!ret || errno != ENOSYS)
-		return ret;
-	if (syscall(SYS_getrlimit, resource, k_rlim) < 0)
-		return -1;
-	rlim->rlim_cur = k_rlim[0] == -1UL ? RLIM_INFINITY : k_rlim[0];
-	rlim->rlim_max = k_rlim[1] == -1UL ? RLIM_INFINITY : k_rlim[1];
-	FIX(rlim->rlim_cur);
-	FIX(rlim->rlim_max);
-	return 0;
-#else
-	return ret;
-#endif
+    return zsys_getrlimit(resource, rlim);
 }
diff --git a/src/misc/getrusage.c b/src/misc/getrusage.c
index 8e03e2e3db4e..c116334f765b 100644
--- a/src/misc/getrusage.c
+++ b/src/misc/getrusage.c
@@ -5,31 +5,5 @@
 
 int getrusage(int who, struct rusage *ru)
 {
-	int r;
-#ifdef SYS_getrusage_time64
-	long long kru64[18];
-	r = __syscall(SYS_getrusage_time64, who, kru64);
-	if (!r) {
-		ru->ru_utime = (struct timeval)
-			{ .tv_sec = kru64[0], .tv_usec = kru64[1] };
-		ru->ru_stime = (struct timeval)
-			{ .tv_sec = kru64[2], .tv_usec = kru64[3] };
-		char *slots = (char *)&ru->ru_maxrss;
-		for (int i=0; i<14; i++)
-			*(long *)(slots + i*sizeof(long)) = kru64[4+i];
-	}
-	if (SYS_getrusage_time64 == SYS_getrusage || r != -ENOSYS)
-		return __syscall_ret(r);
-#endif
-	char *dest = (char *)&ru->ru_maxrss - 4*sizeof(long);
-	r = __syscall(SYS_getrusage, who, dest);
-	if (!r && sizeof(time_t) > sizeof(long)) {
-		long kru[4];
-		memcpy(kru, dest, 4*sizeof(long));
-		ru->ru_utime = (struct timeval)
-			{ .tv_sec = kru[0], .tv_usec = kru[1] };
-		ru->ru_stime = (struct timeval)
-			{ .tv_sec = kru[2], .tv_usec = kru[3] };
-	}
-	return __syscall_ret(r);
+	return zsys_getrusage(who, ru);
 }
diff --git a/src/misc/ioctl.c b/src/misc/ioctl.c
index 35804f026ef6..f59e74b85c14 100644
--- a/src/misc/ioctl.c
+++ b/src/misc/ioctl.c
@@ -8,144 +8,9 @@
 #include <string.h>
 #include <endian.h>
 #include "syscall.h"
+#include <stdfil.h>
 
-#define alignof(t) offsetof(struct { char c; t x; }, x)
-
-#define W 1
-#define R 2
-#define WR 3
-
-struct ioctl_compat_map {
-	int new_req, old_req;
-	unsigned char old_size, dir, force_align, noffs;
-	unsigned char offsets[8];
-};
-
-#define NINTH(a,b,c,d,e,f,g,h,i,...) i
-#define COUNT(...) NINTH(__VA_ARGS__,8,7,6,5,4,3,2,1,0)
-#define OFFS(...) COUNT(__VA_ARGS__), { __VA_ARGS__ }
-
-/* yields a type for a struct with original size n, with a misaligned
- * timeval/timespec expanded from 32- to 64-bit. for use with ioctl
- * number producing macros; only size of result is meaningful. */
-#define new_misaligned(n) struct { int i; time_t t; char c[(n)-4]; }
-
-struct v4l2_event {
-	uint32_t a;
-	uint64_t b[8];
-	uint32_t c[2], ts[2], d[9];
-};
-
-static const struct ioctl_compat_map compat_map[] = {
-	{ SIOCGSTAMP, SIOCGSTAMP_OLD, 8, R, 0, OFFS(0, 4) },
-	{ SIOCGSTAMPNS, SIOCGSTAMPNS_OLD, 8, R, 0, OFFS(0, 4) },
-
-	/* SNDRV_TIMER_IOCTL_STATUS */
-	{ _IOR('T', 0x14, char[96]), _IOR('T', 0x14, 88), 88, R, 0, OFFS(0,4) },
-
-	/* SNDRV_PCM_IOCTL_STATUS[_EXT] */
-	{ _IOR('A', 0x20, char[128]), _IOR('A', 0x20, char[108]), 108, R, 1, OFFS(4,8,12,16,52,56,60,64) },
-	{ _IOWR('A', 0x24, char[128]), _IOWR('A', 0x24, char[108]), 108, WR, 1, OFFS(4,8,12,16,52,56,60,64) },
-
-	/* SNDRV_RAWMIDI_IOCTL_STATUS */
-	{ _IOWR('W', 0x20, char[48]), _IOWR('W', 0x20, char[36]), 36, WR, 1, OFFS(4,8) },
-
-	/* SNDRV_PCM_IOCTL_SYNC_PTR - with 3 subtables */
-	{ _IOWR('A', 0x23, char[136]), _IOWR('A', 0x23, char[132]), 0, WR, 1, 0 },
-	{ 0, 0, 4, WR, 1, 0 }, /* snd_pcm_sync_ptr (flags only) */
-	{ 0, 0, 32, WR, 1, OFFS(8,12,16,24,28) }, /* snd_pcm_mmap_status */
-	{ 0, 0, 4, WR, 1, 0 }, /* snd_pcm_mmap_control (each member) */
-
-	/* VIDIOC_QUERYBUF, VIDIOC_QBUF, VIDIOC_DQBUF, VIDIOC_PREPARE_BUF */
-	{ _IOWR('V',  9, new_misaligned(68)), _IOWR('V',  9, char[68]), 68, WR, 1, OFFS(20, 24) },
-	{ _IOWR('V', 15, new_misaligned(68)), _IOWR('V', 15, char[68]), 68, WR, 1, OFFS(20, 24) },
-	{ _IOWR('V', 17, new_misaligned(68)), _IOWR('V', 17, char[68]), 68, WR, 1, OFFS(20, 24) },
-	{ _IOWR('V', 93, new_misaligned(68)), _IOWR('V', 93, char[68]), 68, WR, 1, OFFS(20, 24) },
-
-	/* VIDIOC_DQEVENT */
-	{ _IOR('V', 89, new_misaligned(120)), _IOR('V', 89, struct v4l2_event), sizeof(struct v4l2_event),
-	  R, 0, OFFS(offsetof(struct v4l2_event, ts[0]), offsetof(struct v4l2_event, ts[1])) },
-
-	/* VIDIOC_OMAP3ISP_STAT_REQ */
-	{ _IOWR('V', 192+6, char[32]), _IOWR('V', 192+6, char[24]), 22, WR, 0, OFFS(0,4) },
-
-	/* PPPIOCGIDLE */
-	{ _IOR('t', 63, char[16]), _IOR('t', 63, char[8]), 8, R, 0, OFFS(0,4) },
-
-	/* PPGETTIME, PPSETTIME */
-	{ _IOR('p', 0x95, char[16]), _IOR('p', 0x95, char[8]), 8, R, 0, OFFS(0,4) },
-	{ _IOW('p', 0x96, char[16]), _IOW('p', 0x96, char[8]), 8, W, 0, OFFS(0,4) },
-
-	/* LPSETTIMEOUT */
-	{ _IOW(0x6, 0xf, char[16]), 0x060f, 8, W, 0, OFFS(0,4) },
-};
-
-static void convert_ioctl_struct(const struct ioctl_compat_map *map, char *old, char *new, int dir)
-{
-	int new_offset = 0;
-	int old_offset = 0;
-	int old_size = map->old_size;
-	if (!(dir & map->dir)) return;
-	if (!map->old_size) {
-		/* offsets hard-coded for SNDRV_PCM_IOCTL_SYNC_PTR;
-		 * if another exception appears this needs changing. */
-		convert_ioctl_struct(map+1, old, new, dir);
-		convert_ioctl_struct(map+2, old+4, new+8, dir);
-		/* snd_pcm_mmap_control, special-cased due to kernel
-		 * type definition having been botched. */
-		int adj = BYTE_ORDER==BIG_ENDIAN ? 4 : 0;
-		convert_ioctl_struct(map+3, old+68, new+72+adj, dir);
-		convert_ioctl_struct(map+3, old+72, new+76+3*adj, dir);
-		return;
-	}
-	for (int i=0; i < map->noffs; i++) {
-		int ts_offset = map->offsets[i];
-		int len = ts_offset-old_offset;
-		if (dir==W) memcpy(old+old_offset, new+new_offset, len);
-		else memcpy(new+new_offset, old+old_offset, len);
-		new_offset += len;
-		old_offset += len;
-		long long new_ts;
-		long old_ts;
-		int align = map->force_align ? sizeof(time_t) : alignof(time_t);
-		new_offset += (align-1) & -new_offset;
-		if (dir==W) {
-			memcpy(&new_ts, new+new_offset, sizeof new_ts);
-			old_ts = new_ts;
-			memcpy(old+old_offset, &old_ts, sizeof old_ts);
-		} else {
-			memcpy(&old_ts, old+old_offset, sizeof old_ts);
-			new_ts = old_ts;
-			memcpy(new+new_offset, &new_ts, sizeof new_ts);
-		}
-		new_offset += sizeof new_ts;
-		old_offset += sizeof old_ts;
-	}
-	if (dir==W) memcpy(old+old_offset, new+new_offset, old_size-old_offset);
-	else memcpy(new+new_offset, old+old_offset, old_size-old_offset);
-}
-
-int ioctl(int fd, int req, ...)
+__attribute__((__noinline__)) int ioctl(int fd, int req, ...)
 {
-	void *arg;
-	va_list ap;
-	va_start(ap, req);
-	arg = va_arg(ap, void *);
-	va_end(ap);
-	int r = __syscall(SYS_ioctl, fd, req, arg);
-	if (SIOCGSTAMP != SIOCGSTAMP_OLD && req && r==-ENOTTY) {
-		for (int i=0; i<sizeof compat_map/sizeof *compat_map; i++) {
-			if (compat_map[i].new_req != req) continue;
-			union {
-				long long align;
-				char buf[256];
-			} u;
-			convert_ioctl_struct(&compat_map[i], u.buf, arg, W);
-			r = __syscall(SYS_ioctl, fd, compat_map[i].old_req, u.buf);
-			if (r<0) break;
-			convert_ioctl_struct(&compat_map[i], u.buf, arg, R);
-			break;
-		}
-	}
-	return __syscall_ret(r);
+	return *(int*)zcall(zsys_ioctl, zargs());
 }
diff --git a/src/misc/setpriority.c b/src/misc/setpriority.c
index 3098cdf4d15f..486ac3ddc41a 100644
--- a/src/misc/setpriority.c
+++ b/src/misc/setpriority.c
@@ -3,5 +3,5 @@
 
 int setpriority(int which, id_t who, int prio)
 {
-	return syscall(SYS_setpriority, which, who, prio);
+	return zsys_setpriority(which, who, prio);
 }
diff --git a/src/misc/setrlimit.c b/src/misc/setrlimit.c
index edb413fa78e4..0e008a07a591 100644
--- a/src/misc/setrlimit.c
+++ b/src/misc/setrlimit.c
@@ -3,49 +3,7 @@
 #include "syscall.h"
 #include "libc.h"
 
-#define MIN(a, b) ((a)<(b) ? (a) : (b))
-#define FIX(x) do{ if ((x)>=SYSCALL_RLIM_INFINITY) (x)=RLIM_INFINITY; }while(0)
-
-struct ctx {
-	unsigned long lim[2];
-	int res;
-	int err;
-};
-
-#ifdef SYS_setrlimit
-static void do_setrlimit(void *p)
-{
-	struct ctx *c = p;
-	if (c->err>0) return;
-	c->err = -__syscall(SYS_setrlimit, c->res, c->lim);
-}
-#endif
-
 int setrlimit(int resource, const struct rlimit *rlim)
 {
-	struct rlimit tmp;
-	if (SYSCALL_RLIM_INFINITY != RLIM_INFINITY) {
-		tmp = *rlim;
-		FIX(tmp.rlim_cur);
-		FIX(tmp.rlim_max);
-		rlim = &tmp;
-	}
-	int ret = __syscall(SYS_prlimit64, 0, resource, rlim, 0);
-#ifdef SYS_setrlimit
-	if (ret != -ENOSYS) return __syscall_ret(ret);
-
-	struct ctx c = {
-		.lim[0] = MIN(rlim->rlim_cur, MIN(-1UL, SYSCALL_RLIM_INFINITY)),
-		.lim[1] = MIN(rlim->rlim_max, MIN(-1UL, SYSCALL_RLIM_INFINITY)),
-		.res = resource, .err = -1
-	};
-	__synccall(do_setrlimit, &c);
-	if (c.err) {
-		if (c.err>0) errno = c.err;
-		return -1;
-	}
-	return 0;
-#else
-	return __syscall_ret(ret);
-#endif
+	return zsys_setrlimit(resource, rlim);
 }
diff --git a/src/misc/syscall.c b/src/misc/syscall.c
index 6f3ef65639aa..22b2134bb160 100644
--- a/src/misc/syscall.c
+++ b/src/misc/syscall.c
@@ -1,21 +1,11 @@
 #define _BSD_SOURCE
+#define _GNU_SOURCE
 #include <unistd.h>
 #include "syscall.h"
-#include <stdarg.h>
 
 #undef syscall
 
 long syscall(long n, ...)
 {
-	va_list ap;
-	syscall_arg_t a,b,c,d,e,f;
-	va_start(ap, n);
-	a=va_arg(ap, syscall_arg_t);
-	b=va_arg(ap, syscall_arg_t);
-	c=va_arg(ap, syscall_arg_t);
-	d=va_arg(ap, syscall_arg_t);
-	e=va_arg(ap, syscall_arg_t);
-	f=va_arg(ap, syscall_arg_t);
-	va_end(ap);
-	return __syscall_ret(__syscall(n,a,b,c,d,e,f));
+	return *(long*)zcall(zsys_syscall, zargs());
 }
diff --git a/src/misc/uname.c b/src/misc/uname.c
index 55ea3420232c..55730d85a89c 100644
--- a/src/misc/uname.c
+++ b/src/misc/uname.c
@@ -1,7 +1,8 @@
 #include <sys/utsname.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int uname(struct utsname *uts)
 {
-	return syscall(SYS_uname, uts);
+	return zsys_uname(uts);
 }
diff --git a/src/mman/madvise.c b/src/mman/madvise.c
index e0c7c0ec92b8..479e252481e5 100644
--- a/src/mman/madvise.c
+++ b/src/mman/madvise.c
@@ -3,7 +3,7 @@
 
 int __madvise(void *addr, size_t len, int advice)
 {
-	return syscall(SYS_madvise, addr, len, advice);
+	return zsys_madvise(addr, len, advice);
 }
 
 weak_alias(__madvise, madvise);
diff --git a/src/mman/mlock.c b/src/mman/mlock.c
index 71af582fe6a3..6288c26cb369 100644
--- a/src/mman/mlock.c
+++ b/src/mman/mlock.c
@@ -3,9 +3,5 @@
 
 int mlock(const void *addr, size_t len)
 {
-#ifdef SYS_mlock
-	return syscall(SYS_mlock, addr, len);
-#else
-	return syscall(SYS_mlock2, addr, len, 0);
-#endif
+	return zsys_mlock(addr, len);
 }
diff --git a/src/mman/mlockall.c b/src/mman/mlockall.c
index 0ba4e662c8fa..4b81208b92d1 100644
--- a/src/mman/mlockall.c
+++ b/src/mman/mlockall.c
@@ -3,5 +3,5 @@
 
 int mlockall(int flags)
 {
-	return syscall(SYS_mlockall, flags);
+	return zsys_mlockall(flags);
 }
diff --git a/src/mman/mmap.c b/src/mman/mmap.c
index 43e5e02941dc..4b89dd167295 100644
--- a/src/mman/mmap.c
+++ b/src/mman/mmap.c
@@ -4,6 +4,7 @@
 #include <stdint.h>
 #include <limits.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 static void dummy(void) { }
 weak_alias(dummy, __vm_wait);
@@ -25,15 +26,7 @@ void *__mmap(void *start, size_t len, int prot, int flags, int fd, off_t off)
 	if (flags & MAP_FIXED) {
 		__vm_wait();
 	}
-#ifdef SYS_mmap2
-	ret = __syscall(SYS_mmap2, start, len, prot, flags, fd, off/UNIT);
-#else
-	ret = __syscall(SYS_mmap, start, len, prot, flags, fd, off);
-#endif
-	/* Fixup incorrect EPERM from kernel. */
-	if (ret == -EPERM && !start && (flags&MAP_ANON) && !(flags&MAP_FIXED))
-		ret = -ENOMEM;
-	return (void *)__syscall_ret(ret);
+        return zsys_mmap(start, len, prot, flags, fd, off);
 }
 
 weak_alias(__mmap, mmap);
diff --git a/src/mman/mprotect.c b/src/mman/mprotect.c
index 535787b9ec52..5d78419c4f8f 100644
--- a/src/mman/mprotect.c
+++ b/src/mman/mprotect.c
@@ -4,10 +4,7 @@
 
 int __mprotect(void *addr, size_t len, int prot)
 {
-	size_t start, end;
-	start = (size_t)addr & -PAGE_SIZE;
-	end = (size_t)((char *)addr + len + PAGE_SIZE-1) & -PAGE_SIZE;
-	return syscall(SYS_mprotect, start, end-start, prot);
+    return zsys_mprotect(addr, len, prot);
 }
 
 weak_alias(__mprotect, mprotect);
diff --git a/src/mman/mremap.c b/src/mman/mremap.c
index cc6991a635e1..b2c23bf5421c 100644
--- a/src/mman/mremap.c
+++ b/src/mman/mremap.c
@@ -11,22 +11,14 @@ weak_alias(dummy, __vm_wait);
 
 void *__mremap(void *old_addr, size_t old_len, size_t new_len, int flags, ...)
 {
-	va_list ap;
-	void *new_addr = 0;
-
-	if (new_len >= PTRDIFF_MAX) {
-		errno = ENOMEM;
-		return MAP_FAILED;
-	}
-
-	if (flags & MREMAP_FIXED) {
-		__vm_wait();
-		va_start(ap, flags);
-		new_addr = va_arg(ap, void *);
-		va_end(ap);
-	}
-
-	return (void *)syscall(SYS_mremap, old_addr, old_len, new_len, flags, new_addr);
+	va_list list;
+	va_start(list, flags);
+	void* new_addr;
+	if (zcan_va_arg(list))
+		new_addr = va_arg(list, void*);
+	else
+		new_addr = NULL;
+	return zsys_mremap(old_addr, old_len, new_len, flags, new_addr);
 }
 
 weak_alias(__mremap, mremap);
diff --git a/src/mman/msync.c b/src/mman/msync.c
index fcd8cdf9fc17..2d50b246ea02 100644
--- a/src/mman/msync.c
+++ b/src/mman/msync.c
@@ -3,5 +3,5 @@
 
 int msync(void *start, size_t len, int flags)
 {
-	return syscall_cp(SYS_msync, start, len, flags);
+	return zsys_msync(start, len, flags);
 }
diff --git a/src/mman/munlock.c b/src/mman/munlock.c
index 2cccef0c5077..506ca1a43a8c 100644
--- a/src/mman/munlock.c
+++ b/src/mman/munlock.c
@@ -3,5 +3,5 @@
 
 int munlock(const void *addr, size_t len)
 {
-	return syscall(SYS_munlock, addr, len);
+	return zsys_munlock(addr, len);
 }
diff --git a/src/mman/munlockall.c b/src/mman/munlockall.c
index 6e9d39d68480..e745b4571fc3 100644
--- a/src/mman/munlockall.c
+++ b/src/mman/munlockall.c
@@ -3,5 +3,5 @@
 
 int munlockall(void)
 {
-	return syscall(SYS_munlockall);
+	return zsys_munlockall();
 }
diff --git a/src/mman/munmap.c b/src/mman/munmap.c
index 2bf83bbe9b70..a70967a4a3c6 100644
--- a/src/mman/munmap.c
+++ b/src/mman/munmap.c
@@ -1,5 +1,6 @@
 #include <sys/mman.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 static void dummy(void) { }
 weak_alias(dummy, __vm_wait);
@@ -7,7 +8,7 @@ weak_alias(dummy, __vm_wait);
 int __munmap(void *start, size_t len)
 {
 	__vm_wait();
-	return syscall(SYS_munmap, start, len);
+        return zsys_munmap(start, len);
 }
 
 weak_alias(__munmap, munmap);
diff --git a/src/network/accept.c b/src/network/accept.c
index a92406fa7315..ad27156e798e 100644
--- a/src/network/accept.c
+++ b/src/network/accept.c
@@ -1,7 +1,8 @@
 #include <sys/socket.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int accept(int fd, struct sockaddr *restrict addr, socklen_t *restrict len)
 {
-	return socketcall_cp(accept, fd, addr, len, 0, 0, 0);
+    return zsys_accept(fd, addr, len);
 }
diff --git a/src/network/accept4.c b/src/network/accept4.c
index 765a38edc37d..0c3f91f6b237 100644
--- a/src/network/accept4.c
+++ b/src/network/accept4.c
@@ -6,18 +6,5 @@
 
 int accept4(int fd, struct sockaddr *restrict addr, socklen_t *restrict len, int flg)
 {
-	if (!flg) return accept(fd, addr, len);
-	int ret = socketcall_cp(accept4, fd, addr, len, flg, 0, 0);
-	if (ret>=0 || (errno != ENOSYS && errno != EINVAL)) return ret;
-	if (flg & ~(SOCK_CLOEXEC|SOCK_NONBLOCK)) {
-		errno = EINVAL;
-		return -1;
-	}
-	ret = accept(fd, addr, len);
-	if (ret<0) return ret;
-	if (flg & SOCK_CLOEXEC)
-		__syscall(SYS_fcntl, ret, F_SETFD, FD_CLOEXEC);
-	if (flg & SOCK_NONBLOCK)
-		__syscall(SYS_fcntl, ret, F_SETFL, O_NONBLOCK);
-	return ret;
+	return zsys_accept4(fd, addr, len, flg);
 }
diff --git a/src/network/bind.c b/src/network/bind.c
index 07bb669aade2..7f12ba519aa9 100644
--- a/src/network/bind.c
+++ b/src/network/bind.c
@@ -1,7 +1,8 @@
 #include <sys/socket.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int bind(int fd, const struct sockaddr *addr, socklen_t len)
 {
-	return socketcall(bind, fd, addr, len, 0, 0, 0);
+    return zsys_bind(fd, addr, len);
 }
diff --git a/src/network/connect.c b/src/network/connect.c
index 289127be4875..3422e893def1 100644
--- a/src/network/connect.c
+++ b/src/network/connect.c
@@ -1,7 +1,8 @@
 #include <sys/socket.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int connect(int fd, const struct sockaddr *addr, socklen_t len)
 {
-	return socketcall_cp(connect, fd, addr, len, 0, 0, 0);
+    return zsys_connect(fd, addr, len);
 }
diff --git a/src/network/getpeername.c b/src/network/getpeername.c
index 6567b4519157..52b52374de0f 100644
--- a/src/network/getpeername.c
+++ b/src/network/getpeername.c
@@ -1,7 +1,8 @@
 #include <sys/socket.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int getpeername(int fd, struct sockaddr *restrict addr, socklen_t *restrict len)
 {
-	return socketcall(getpeername, fd, addr, len, 0, 0, 0);
+    return zsys_getpeername(fd, addr, len);
 }
diff --git a/src/network/getsockname.c b/src/network/getsockname.c
index 7885fc13ba4c..64516c655183 100644
--- a/src/network/getsockname.c
+++ b/src/network/getsockname.c
@@ -1,7 +1,8 @@
 #include <sys/socket.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int getsockname(int fd, struct sockaddr *restrict addr, socklen_t *restrict len)
 {
-	return socketcall(getsockname, fd, addr, len, 0, 0, 0);
+    return zsys_getsockname(fd, addr, len);
 }
diff --git a/src/network/getsockopt.c b/src/network/getsockopt.c
index d3640d9c91f2..a5745821180e 100644
--- a/src/network/getsockopt.c
+++ b/src/network/getsockopt.c
@@ -2,40 +2,9 @@
 #include <sys/time.h>
 #include <errno.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int getsockopt(int fd, int level, int optname, void *restrict optval, socklen_t *restrict optlen)
 {
-	long tv32[2];
-	struct timeval *tv;
-
-	int r = __socketcall(getsockopt, fd, level, optname, optval, optlen, 0);
-
-	if (r==-ENOPROTOOPT) switch (level) {
-	case SOL_SOCKET:
-		switch (optname) {
-		case SO_RCVTIMEO:
-		case SO_SNDTIMEO:
-			if (SO_RCVTIMEO == SO_RCVTIMEO_OLD) break;
-			if (*optlen < sizeof *tv) return __syscall_ret(-EINVAL);
-			if (optname==SO_RCVTIMEO) optname=SO_RCVTIMEO_OLD;
-			if (optname==SO_SNDTIMEO) optname=SO_SNDTIMEO_OLD;
-			r = __socketcall(getsockopt, fd, level, optname,
-				tv32, (socklen_t[]){sizeof tv32}, 0);
-			if (r<0) break;
-			tv = optval;
-			tv->tv_sec = tv32[0];
-			tv->tv_usec = tv32[1];
-			*optlen = sizeof *tv;
-			break;
-		case SO_TIMESTAMP:
-		case SO_TIMESTAMPNS:
-			if (SO_TIMESTAMP == SO_TIMESTAMP_OLD) break;
-			if (optname==SO_TIMESTAMP) optname=SO_TIMESTAMP_OLD;
-			if (optname==SO_TIMESTAMPNS) optname=SO_TIMESTAMPNS_OLD;
-			r = __socketcall(getsockopt, fd, level,
-				optname, optval, optlen, 0);
-			break;
-		}
-	}
-	return __syscall_ret(r);
+    return zsys_getsockopt(fd, level, optname, optval, optlen);
 }
diff --git a/src/network/if_indextoname.c b/src/network/if_indextoname.c
index 3b368bf0d132..2586e62da0f8 100644
--- a/src/network/if_indextoname.c
+++ b/src/network/if_indextoname.c
@@ -14,7 +14,7 @@ char *if_indextoname(unsigned index, char *name)
 	if ((fd = socket(AF_UNIX, SOCK_DGRAM|SOCK_CLOEXEC, 0)) < 0) return 0;
 	ifr.ifr_ifindex = index;
 	r = ioctl(fd, SIOCGIFNAME, &ifr);
-	__syscall(SYS_close, fd);
+	zsys_close(fd);
 	if (r < 0) {
 		if (errno == ENODEV) errno = ENXIO;
 		return 0;
diff --git a/src/network/if_nametoindex.c b/src/network/if_nametoindex.c
index 331413c68912..7adc7dc4d610 100644
--- a/src/network/if_nametoindex.c
+++ b/src/network/if_nametoindex.c
@@ -13,6 +13,6 @@ unsigned if_nametoindex(const char *name)
 	if ((fd = socket(AF_UNIX, SOCK_DGRAM|SOCK_CLOEXEC, 0)) < 0) return 0;
 	strncpy(ifr.ifr_name, name, sizeof ifr.ifr_name);
 	r = ioctl(fd, SIOCGIFINDEX, &ifr);
-	__syscall(SYS_close, fd);
+	zsys_close(fd);
 	return r < 0 ? 0 : ifr.ifr_ifindex;
 }
diff --git a/src/network/listen.c b/src/network/listen.c
index f84ad03b7a54..8b6b88cc5e89 100644
--- a/src/network/listen.c
+++ b/src/network/listen.c
@@ -1,7 +1,8 @@
 #include <sys/socket.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int listen(int fd, int backlog)
 {
-	return socketcall(listen, fd, backlog, 0, 0, 0, 0);
+    return zsys_listen(fd, backlog);
 }
diff --git a/src/network/netlink.c b/src/network/netlink.c
index 94dba7f5c9e4..6bdea02e2734 100644
--- a/src/network/netlink.c
+++ b/src/network/netlink.c
@@ -47,6 +47,6 @@ int __rtnetlink_enumerate(int link_af, int addr_af, int (*cb)(void *ctx, struct
 	if (fd < 0) return -1;
 	r = __netlink_enumerate(fd, 1, RTM_GETLINK, link_af, cb, ctx);
 	if (!r) r = __netlink_enumerate(fd, 2, RTM_GETADDR, addr_af, cb, ctx);
-	__syscall(SYS_close,fd);
+	zsys_close(fd);
 	return r;
 }
diff --git a/src/network/recvfrom.c b/src/network/recvfrom.c
index 61911663e086..3d1ecef4b749 100644
--- a/src/network/recvfrom.c
+++ b/src/network/recvfrom.c
@@ -1,7 +1,8 @@
 #include <sys/socket.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 ssize_t recvfrom(int fd, void *restrict buf, size_t len, int flags, struct sockaddr *restrict addr, socklen_t *restrict alen)
 {
-	return socketcall_cp(recvfrom, fd, buf, len, flags, addr, alen);
+    return zsys_recvfrom(fd, buf, len, flags, addr, alen);
 }
diff --git a/src/network/recvmmsg.c b/src/network/recvmmsg.c
index 2978e2f64f34..3a646f8d97df 100644
--- a/src/network/recvmmsg.c
+++ b/src/network/recvmmsg.c
@@ -5,35 +5,7 @@
 #include <time.h>
 #include "syscall.h"
 
-#define IS32BIT(x) !((x)+0x80000000ULL>>32)
-#define CLAMP(x) (int)(IS32BIT(x) ? (x) : 0x7fffffffU+((0ULL+(x))>>63))
-
-hidden void __convert_scm_timestamps(struct msghdr *, socklen_t);
-
 int recvmmsg(int fd, struct mmsghdr *msgvec, unsigned int vlen, unsigned int flags, struct timespec *timeout)
 {
-#if LONG_MAX > INT_MAX
-	struct mmsghdr *mh = msgvec;
-	unsigned int i;
-	for (i = vlen; i; i--, mh++)
-		mh->msg_hdr.__pad1 = mh->msg_hdr.__pad2 = 0;
-#endif
-#ifdef SYS_recvmmsg_time64
-	time_t s = timeout ? timeout->tv_sec : 0;
-	long ns = timeout ? timeout->tv_nsec : 0;
-	int r = __syscall_cp(SYS_recvmmsg_time64, fd, msgvec, vlen, flags,
-			timeout ? ((long long[]){s, ns}) : 0);
-	if (SYS_recvmmsg == SYS_recvmmsg_time64 || r!=-ENOSYS)
-		return __syscall_ret(r);
-	if (vlen > IOV_MAX) vlen = IOV_MAX;
-	socklen_t csize[vlen];
-	for (int i=0; i<vlen; i++) csize[i] = msgvec[i].msg_hdr.msg_controllen;
-	r = __syscall_cp(SYS_recvmmsg, fd, msgvec, vlen, flags,
-		timeout ? ((long[]){CLAMP(s), ns}) : 0);
-	for (int i=0; i<r; i++)
-		__convert_scm_timestamps(&msgvec[i].msg_hdr, csize[i]);
-	return __syscall_ret(r);
-#else
-	return syscall_cp(SYS_recvmmsg, fd, msgvec, vlen, flags, timeout);
-#endif
+	return zsys_recvmmsg(fd, msgvec, vlen, flags, timeout);
 }
diff --git a/src/network/recvmsg.c b/src/network/recvmsg.c
index 03641625e8af..f1ac979aafca 100644
--- a/src/network/recvmsg.c
+++ b/src/network/recvmsg.c
@@ -4,65 +4,9 @@
 #include <sys/time.h>
 #include <string.h>
 #include "syscall.h"
-
-hidden void __convert_scm_timestamps(struct msghdr *, socklen_t);
-
-void __convert_scm_timestamps(struct msghdr *msg, socklen_t csize)
-{
-	if (SCM_TIMESTAMP == SCM_TIMESTAMP_OLD) return;
-	if (!msg->msg_control || !msg->msg_controllen) return;
-
-	struct cmsghdr *cmsg, *last=0;
-	long tmp;
-	long long tvts[2];
-	int type = 0;
-
-	for (cmsg=CMSG_FIRSTHDR(msg); cmsg; cmsg=CMSG_NXTHDR(msg, cmsg)) {
-		if (cmsg->cmsg_level==SOL_SOCKET) switch (cmsg->cmsg_type) {
-		case SCM_TIMESTAMP_OLD:
-			if (type) break;
-			type = SCM_TIMESTAMP;
-			goto common;
-		case SCM_TIMESTAMPNS_OLD:
-			type = SCM_TIMESTAMPNS;
-		common:
-			memcpy(&tmp, CMSG_DATA(cmsg), sizeof tmp);
-			tvts[0] = tmp;
-			memcpy(&tmp, CMSG_DATA(cmsg) + sizeof tmp, sizeof tmp);
-			tvts[1] = tmp;
-			break;
-		}
-		last = cmsg;
-	}
-	if (!last || !type) return;
-	if (CMSG_SPACE(sizeof tvts) > csize-msg->msg_controllen) {
-		msg->msg_flags |= MSG_CTRUNC;
-		return;
-	}
-	msg->msg_controllen += CMSG_SPACE(sizeof tvts);
-	cmsg = CMSG_NXTHDR(msg, last);
-	cmsg->cmsg_level = SOL_SOCKET;
-	cmsg->cmsg_type = type;
-	cmsg->cmsg_len = CMSG_LEN(sizeof tvts);
-	memcpy(CMSG_DATA(cmsg), &tvts, sizeof tvts);
-}
+#include <stdfil.h>
 
 ssize_t recvmsg(int fd, struct msghdr *msg, int flags)
 {
-	ssize_t r;
-	socklen_t orig_controllen = msg->msg_controllen;
-#if LONG_MAX > INT_MAX
-	struct msghdr h, *orig = msg;
-	if (msg) {
-		h = *msg;
-		h.__pad1 = h.__pad2 = 0;
-		msg = &h;
-	}
-#endif
-	r = socketcall_cp(recvmsg, fd, msg, flags, 0, 0, 0);
-	if (r >= 0) __convert_scm_timestamps(msg, orig_controllen);
-#if LONG_MAX > INT_MAX
-	if (orig) *orig = h;
-#endif
-	return r;
+    return zsys_recvmsg(fd, msg, flags);
 }
diff --git a/src/network/res_msend.c b/src/network/res_msend.c
index 86c2fcf4ff21..17fa0f443f7f 100644
--- a/src/network/res_msend.c
+++ b/src/network/res_msend.c
@@ -19,7 +19,7 @@ static void cleanup(void *p)
 {
 	struct pollfd *pfd = p;
 	for (int i=0; pfd[i].fd >= -1; i++)
-		if (pfd[i].fd >= 0) __syscall(SYS_close, pfd[i].fd);
+		if (pfd[i].fd >= 0) zsys_close(pfd[i].fd);
 }
 
 static unsigned long mtime()
@@ -303,7 +303,7 @@ int __res_msend_rc(int nqueries, const unsigned char *const *queries,
 			 * Immediately close TCP socket so as not to consume
 			 * resources we no longer need. */
 			alens[i] = alen;
-			__syscall(SYS_close, pfd[i].fd);
+			zsys_close(pfd[i].fd);
 			pfd[i].fd = -1;
 		}
 	}
diff --git a/src/network/sendmmsg.c b/src/network/sendmmsg.c
index eeae1d0a5822..3b78f9fe9417 100644
--- a/src/network/sendmmsg.c
+++ b/src/network/sendmmsg.c
@@ -6,25 +6,5 @@
 
 int sendmmsg(int fd, struct mmsghdr *msgvec, unsigned int vlen, unsigned int flags)
 {
-#if LONG_MAX > INT_MAX
-	/* Can't use the syscall directly because the kernel has the wrong
-	 * idea for the types of msg_iovlen, msg_controllen, and cmsg_len,
-	 * and the cmsg blocks cannot be modified in-place. */
-	int i;
-	if (vlen > IOV_MAX) vlen = IOV_MAX; /* This matches the kernel. */
-	if (!vlen) return 0;
-	for (i=0; i<vlen; i++) {
-		/* As an unfortunate inconsistency, the sendmmsg API uses
-		 * unsigned int for the resulting msg_len, despite sendmsg
-		 * returning ssize_t. However Linux limits the total bytes
-		 * sent by sendmsg to INT_MAX, so the assignment is safe. */
-		ssize_t r = sendmsg(fd, &msgvec[i].msg_hdr, flags);
-		if (r < 0) goto error;
-		msgvec[i].msg_len = r;
-	}
-error:
-	return i ? i : -1;
-#else
-	return syscall_cp(SYS_sendmmsg, fd, msgvec, vlen, flags);
-#endif
+	return zsys_sendmmsg(fd, msgvec, vlen, flags);
 }
diff --git a/src/network/sendmsg.c b/src/network/sendmsg.c
index acdfdf29247f..56306ad8916d 100644
--- a/src/network/sendmsg.c
+++ b/src/network/sendmsg.c
@@ -3,30 +3,9 @@
 #include <string.h>
 #include <errno.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 ssize_t sendmsg(int fd, const struct msghdr *msg, int flags)
 {
-#if LONG_MAX > INT_MAX
-	struct msghdr h;
-	/* Kernels before 2.6.38 set SCM_MAX_FD to 255, allocate enough
-	 * space to support an SCM_RIGHTS ancillary message with 255 fds.
-	 * Kernels since 2.6.38 set SCM_MAX_FD to 253. */
-	struct cmsghdr chbuf[CMSG_SPACE(255*sizeof(int))/sizeof(struct cmsghdr)+1], *c;
-	if (msg) {
-		h = *msg;
-		h.__pad1 = h.__pad2 = 0;
-		msg = &h;
-		if (h.msg_controllen) {
-			if (h.msg_controllen > sizeof chbuf) {
-				errno = ENOMEM;
-				return -1;
-			}
-			memcpy(chbuf, h.msg_control, h.msg_controllen);
-			h.msg_control = chbuf;
-			for (c=CMSG_FIRSTHDR(&h); c; c=CMSG_NXTHDR(&h,c))
-				c->__pad1 = 0;
-		}
-	}
-#endif
-	return socketcall_cp(sendmsg, fd, msg, flags, 0, 0, 0);
+    return zsys_sendmsg(fd, msg, flags);
 }
diff --git a/src/network/sendto.c b/src/network/sendto.c
index c598797c72b6..eb545c8cab16 100644
--- a/src/network/sendto.c
+++ b/src/network/sendto.c
@@ -1,7 +1,8 @@
 #include <sys/socket.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 ssize_t sendto(int fd, const void *buf, size_t len, int flags, const struct sockaddr *addr, socklen_t alen)
 {
-	return socketcall_cp(sendto, fd, buf, len, flags, addr, alen);
+    return zsys_sendto(fd, buf, len, flags, addr, alen);
 }
diff --git a/src/network/setsockopt.c b/src/network/setsockopt.c
index 612a1947a1f6..2d7ad2d83c66 100644
--- a/src/network/setsockopt.c
+++ b/src/network/setsockopt.c
@@ -2,45 +2,9 @@
 #include <sys/time.h>
 #include <errno.h>
 #include "syscall.h"
-
-#define IS32BIT(x) !((x)+0x80000000ULL>>32)
-#define CLAMP(x) (int)(IS32BIT(x) ? (x) : 0x7fffffffU+((0ULL+(x))>>63))
+#include <stdfil.h>
 
 int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen)
 {
-	const struct timeval *tv;
-	time_t s;
-	suseconds_t us;
-
-	int r = __socketcall(setsockopt, fd, level, optname, optval, optlen, 0);
-
-	if (r==-ENOPROTOOPT) switch (level) {
-	case SOL_SOCKET:
-		switch (optname) {
-		case SO_RCVTIMEO:
-		case SO_SNDTIMEO:
-			if (SO_RCVTIMEO == SO_RCVTIMEO_OLD) break;
-			if (optlen < sizeof *tv) return __syscall_ret(-EINVAL);
-			tv = optval;
-			s = tv->tv_sec;
-			us = tv->tv_usec;
-			if (!IS32BIT(s)) return __syscall_ret(-ENOTSUP);
-
-			if (optname==SO_RCVTIMEO) optname=SO_RCVTIMEO_OLD;
-			if (optname==SO_SNDTIMEO) optname=SO_SNDTIMEO_OLD;
-
-			r = __socketcall(setsockopt, fd, level, optname,
-				((long[]){s, CLAMP(us)}), 2*sizeof(long), 0);
-			break;
-		case SO_TIMESTAMP:
-		case SO_TIMESTAMPNS:
-			if (SO_TIMESTAMP == SO_TIMESTAMP_OLD) break;
-			if (optname==SO_TIMESTAMP) optname=SO_TIMESTAMP_OLD;
-			if (optname==SO_TIMESTAMPNS) optname=SO_TIMESTAMPNS_OLD;
-			r = __socketcall(setsockopt, fd, level,
-				optname, optval, optlen, 0);
-			break;
-		}
-	}
-	return __syscall_ret(r);
+    return zsys_setsockopt(fd, level, optname, optval, optlen);
 }
diff --git a/src/network/shutdown.c b/src/network/shutdown.c
index 10ca21aa3cbe..c7681c82e49a 100644
--- a/src/network/shutdown.c
+++ b/src/network/shutdown.c
@@ -3,5 +3,5 @@
 
 int shutdown(int fd, int how)
 {
-	return socketcall(shutdown, fd, how, 0, 0, 0, 0);
+    return zsys_shutdown(fd, how);
 }
diff --git a/src/network/socket.c b/src/network/socket.c
index afa1a7f3e782..1e103c4fb119 100644
--- a/src/network/socket.c
+++ b/src/network/socket.c
@@ -1,21 +1,16 @@
 #include <sys/socket.h>
 #include <fcntl.h>
 #include <errno.h>
-#include "syscall.h"
+#include <pizlonated_syscalls.h>
 
 int socket(int domain, int type, int protocol)
 {
-	int s = __socketcall(socket, domain, type, protocol, 0, 0, 0);
-	if ((s==-EINVAL || s==-EPROTONOSUPPORT)
-	    && (type&(SOCK_CLOEXEC|SOCK_NONBLOCK))) {
-		s = __socketcall(socket, domain,
-			type & ~(SOCK_CLOEXEC|SOCK_NONBLOCK),
-			protocol, 0, 0, 0);
-		if (s < 0) return __syscall_ret(s);
-		if (type & SOCK_CLOEXEC)
-			__syscall(SYS_fcntl, s, F_SETFD, FD_CLOEXEC);
-		if (type & SOCK_NONBLOCK)
-			__syscall(SYS_fcntl, s, F_SETFL, O_NONBLOCK);
-	}
-	return __syscall_ret(s);
+    int s = zsys_socket(domain, type & ~(SOCK_CLOEXEC | SOCK_NONBLOCK), protocol);
+    if (s < 0)
+        return -1;
+    if (type & SOCK_CLOEXEC)
+        zsys_fcntl(s, F_SETFD, FD_CLOEXEC);
+    if (type & SOCK_NONBLOCK)
+        zsys_fcntl(s, F_SETFL, O_NONBLOCK);
+    return s;
 }
diff --git a/src/network/socketpair.c b/src/network/socketpair.c
index f3489621139a..140741d5f417 100644
--- a/src/network/socketpair.c
+++ b/src/network/socketpair.c
@@ -2,24 +2,9 @@
 #include <fcntl.h>
 #include <errno.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int socketpair(int domain, int type, int protocol, int fd[2])
 {
-	int r = socketcall(socketpair, domain, type, protocol, fd, 0, 0);
-	if (r<0 && (errno==EINVAL || errno==EPROTONOSUPPORT)
-	    && (type&(SOCK_CLOEXEC|SOCK_NONBLOCK))) {
-		r = socketcall(socketpair, domain,
-			type & ~(SOCK_CLOEXEC|SOCK_NONBLOCK),
-			protocol, fd, 0, 0);
-		if (r < 0) return r;
-		if (type & SOCK_CLOEXEC) {
-			__syscall(SYS_fcntl, fd[0], F_SETFD, FD_CLOEXEC);
-			__syscall(SYS_fcntl, fd[1], F_SETFD, FD_CLOEXEC);
-		}
-		if (type & SOCK_NONBLOCK) {
-			__syscall(SYS_fcntl, fd[0], F_SETFL, O_NONBLOCK);
-			__syscall(SYS_fcntl, fd[1], F_SETFL, O_NONBLOCK);
-		}
-	}
-	return r;
+    return zsys_socketpair(domain, type, protocol, fd);
 }
diff --git a/src/process/_Fork.c b/src/process/_Fork.c
index 9c07792dd153..85bd4e9fa723 100644
--- a/src/process/_Fork.c
+++ b/src/process/_Fork.c
@@ -14,7 +14,7 @@ void __post_Fork(int ret)
 {
 	if (!ret) {
 		pthread_t self = __pthread_self();
-		self->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
+		self->tid = zthread_self_id();
 		self->robust_list.off = 0;
 		self->robust_list.pending = 0;
 		self->next = self->prev = self;
@@ -32,12 +32,10 @@ pid_t _Fork(void)
 	sigset_t set;
 	__block_all_sigs(&set);
 	LOCK(__abort_lock);
-#ifdef SYS_fork
-	ret = __syscall(SYS_fork);
-#else
-	ret = __syscall(SYS_clone, SIGCHLD, 0);
-#endif
+	ret = zsys_fork();
+	int saved_errno = errno;
 	__post_Fork(ret);
 	__restore_sigs(&set);
-	return __syscall_ret(ret);
+	errno = saved_errno;
+	return ret;
 }
diff --git a/src/process/aarch64/vfork.s b/src/process/aarch64/vfork.s
deleted file mode 100644
index 429bec8cb8a9..000000000000
--- a/src/process/aarch64/vfork.s
+++ /dev/null
@@ -1,9 +0,0 @@
-.global vfork
-.type vfork,%function
-vfork:
-	mov x8, 220    // SYS_clone
-	mov x0, 0x4111 // SIGCHLD | CLONE_VM | CLONE_VFORK
-	mov x1, 0
-	svc 0
-	.hidden __syscall_ret
-	b __syscall_ret
diff --git a/src/process/arm/vfork.s b/src/process/arm/vfork.s
deleted file mode 100644
index d7ec41b33f4d..000000000000
--- a/src/process/arm/vfork.s
+++ /dev/null
@@ -1,10 +0,0 @@
-.syntax unified
-.global vfork
-.type vfork,%function
-vfork:
-	mov ip, r7
-	mov r7, 190
-	svc 0
-	mov r7, ip
-	.hidden __syscall_ret
-	b __syscall_ret
diff --git a/src/process/execve.c b/src/process/execve.c
index 70286a17397d..fed40b497b34 100644
--- a/src/process/execve.c
+++ b/src/process/execve.c
@@ -1,8 +1,8 @@
 #include <unistd.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int execve(const char *path, char *const argv[], char *const envp[])
 {
-	/* do we need to use environ if envp is null? */
-	return syscall(SYS_execve, path, argv, envp);
+    return zsys_execve(path, argv, envp);
 }
diff --git a/src/process/i386/vfork.s b/src/process/i386/vfork.s
deleted file mode 100644
index 3d0e6d6bde64..000000000000
--- a/src/process/i386/vfork.s
+++ /dev/null
@@ -1,12 +0,0 @@
-.global vfork
-.type vfork,@function
-vfork:
-	pop %edx
-	mov $190,%eax
-	int $128
-	push %edx
-	push %eax
-	.hidden __syscall_ret
-	call __syscall_ret
-	pop %edx
-	ret
diff --git a/src/process/posix_spawn.c b/src/process/posix_spawn.c
index 728551b36792..355403311aec 100644
--- a/src/process/posix_spawn.c
+++ b/src/process/posix_spawn.c
@@ -21,11 +21,7 @@ struct args {
 
 static int __sys_dup2(int old, int new)
 {
-#ifdef SYS_dup2
-	return __syscall(SYS_dup2, old, new);
-#else
-	return __syscall(SYS_dup3, old, new, 0);
-#endif
+	return zsys_dup2(old, new);
 }
 
 static int child(void *args_vp)
@@ -66,19 +62,19 @@ static int child(void *args_vp)
 	}
 
 	if (attr->__flags & POSIX_SPAWN_SETSID)
-		if ((ret=__syscall(SYS_setsid)) < 0)
+		if (zsys_setsid() < 0)
 			goto fail;
 
 	if (attr->__flags & POSIX_SPAWN_SETPGROUP)
-		if ((ret=__syscall(SYS_setpgid, 0, attr->__pgrp)))
+		if (zsys_setpgid(0, attr->__pgrp))
 			goto fail;
 
 	/* Use syscalls directly because the library functions attempt
 	 * to do a multi-threaded synchronized id-change, which would
 	 * trash the parent's state. */
 	if (attr->__flags & POSIX_SPAWN_RESETIDS)
-		if ((ret=__syscall(SYS_setgid, __syscall(SYS_getgid))) ||
-		    (ret=__syscall(SYS_setuid, __syscall(SYS_getuid))) )
+		if (zsys_setgid(zsys_getgid()) ||
+		    zsys_setuid(zsys_getuid()))
 			goto fail;
 
 	if (fa && fa->__actions) {
@@ -91,14 +87,14 @@ static int child(void *args_vp)
 			 * parent. To avoid that, we dup the pipe onto
 			 * an unoccupied fd. */
 			if (op->fd == p) {
-				ret = __syscall(SYS_dup, p);
+				ret = zsys_dup(p);
 				if (ret < 0) goto fail;
-				__syscall(SYS_close, p);
+				zsys_close(p);
 				p = ret;
 			}
 			switch(op->cmd) {
 			case FDOP_CLOSE:
-				__syscall(SYS_close, op->fd);
+				zsys_close(op->fd);
 				break;
 			case FDOP_DUP2:
 				fd = op->srcfd;
@@ -107,31 +103,30 @@ static int child(void *args_vp)
 					goto fail;
 				}
 				if (fd != op->fd) {
-					if ((ret=__sys_dup2(fd, op->fd))<0)
+					if (__sys_dup2(fd, op->fd)<0)
 						goto fail;
 				} else {
-					ret = __syscall(SYS_fcntl, fd, F_GETFD);
-					ret = __syscall(SYS_fcntl, fd, F_SETFD,
-					                ret & ~FD_CLOEXEC);
+					ret = zsys_fcntl(fd, F_GETFD);
+					ret = zsys_fcntl(fd, F_SETFD, ret & ~FD_CLOEXEC);
 					if (ret<0)
 						goto fail;
 				}
 				break;
 			case FDOP_OPEN:
 				fd = __sys_open(op->path, op->oflag, op->mode);
-				if ((ret=fd) < 0) goto fail;
+				if (fd < 0) goto fail;
 				if (fd != op->fd) {
-					if ((ret=__sys_dup2(fd, op->fd))<0)
+					if (__sys_dup2(fd, op->fd)<0)
 						goto fail;
 					__syscall(SYS_close, fd);
 				}
 				break;
 			case FDOP_CHDIR:
-				ret = __syscall(SYS_chdir, op->path);
+				ret = zsys_chdir(op->path);
 				if (ret<0) goto fail;
 				break;
 			case FDOP_FCHDIR:
-				ret = __syscall(SYS_fchdir, op->fd);
+				ret = zsys_fchdir(op->fd);
 				if (ret<0) goto fail;
 				break;
 			}
@@ -142,7 +137,7 @@ static int child(void *args_vp)
 	 * to a different fd. We don't use F_DUPFD_CLOEXEC above because
 	 * it would fail on older kernels and atomicity is not needed --
 	 * in this process there are no threads or signal handlers. */
-	__syscall(SYS_fcntl, p, F_SETFD, FD_CLOEXEC);
+	ZASSERT(!zsys_fcntl(p, F_SETFD, FD_CLOEXEC));
 
 	pthread_sigmask(SIG_SETMASK, (attr->__flags & POSIX_SPAWN_SETSIGMASK)
 		? &attr->__mask : &args->oldmask, 0);
@@ -151,12 +146,11 @@ static int child(void *args_vp)
 		attr->__fn ? (int (*)())attr->__fn : execve;
 
 	exec(args->path, args->argv, args->envp);
-	ret = -errno;
 
 fail:
 	/* Since sizeof errno < PIPE_BUF, the write is atomic. */
-	ret = -ret;
-	if (ret) while (__syscall(SYS_write, p, &ret, sizeof ret) < 0);
+	ret = errno;
+	if (ret) while (zsys_write(p, &ret, sizeof ret) < 0);
 	_exit(127);
 }
 
@@ -167,7 +161,6 @@ int posix_spawn(pid_t *restrict res, const char *restrict path,
 	char *const argv[restrict], char *const envp[restrict])
 {
 	pid_t pid;
-	char stack[1024+PATH_MAX];
 	int ec=0, cs;
 	struct args args;
 
@@ -178,7 +171,9 @@ int posix_spawn(pid_t *restrict res, const char *restrict path,
 	args.attr = attr ? attr : &(const posix_spawnattr_t){0};
 	args.argv = argv;
 	args.envp = envp;
-	pthread_sigmask(SIG_BLOCK, SIGALL_SET, &args.oldmask);
+	sigset_t allset;
+	ZASSERT(!sigfillset(&allset));
+	ZASSERT(!pthread_sigmask(SIG_BLOCK, &allset, &args.oldmask));
 
 	/* The lock guards both against seeing a SIGABRT disposition change
 	 * by abort and against leaking the pipe fd to fork-without-exec. */
@@ -190,8 +185,12 @@ int posix_spawn(pid_t *restrict res, const char *restrict path,
 		goto fail;
 	}
 
-	pid = __clone(child, stack+sizeof stack,
-		CLONE_VM|CLONE_VFORK|SIGCHLD, &args);
+	pid = zsys_fork();
+	int my_errno = errno;
+	if (!pid) {
+		child(&args);
+		ZASSERT(!"Should not get here");
+	}
 	close(args.p[1]);
 	UNLOCK(__abort_lock);
 
@@ -199,7 +198,7 @@ int posix_spawn(pid_t *restrict res, const char *restrict path,
 		if (read(args.p[0], &ec, sizeof ec) != sizeof ec) ec = 0;
 		else waitpid(pid, &(int){0}, 0);
 	} else {
-		ec = -pid;
+		ec = my_errno;
 	}
 
 	close(args.p[0]);
diff --git a/src/process/riscv64/vfork.s b/src/process/riscv64/vfork.s
deleted file mode 100644
index c93dca2396fa..000000000000
--- a/src/process/riscv64/vfork.s
+++ /dev/null
@@ -1,12 +0,0 @@
-.global vfork
-.type vfork,@function
-vfork:
-	/* riscv does not have SYS_vfork, so we must use clone instead */
-	/* note: riscv's clone = clone(flags, sp, ptidptr, tls, ctidptr) */
-	li a7, 220
-	li a0, 0x100 | 0x4000 | 17 /* flags = CLONE_VM | CLONE_VFORK | SIGCHLD */
-	mv a1, sp
-	/* the other arguments are ignoreable */
-	ecall
-	.hidden __syscall_ret
-	j __syscall_ret
diff --git a/src/process/s390x/vfork.s b/src/process/s390x/vfork.s
deleted file mode 100644
index 744f9d78d07c..000000000000
--- a/src/process/s390x/vfork.s
+++ /dev/null
@@ -1,6 +0,0 @@
-	.global vfork
-	.type vfork,%function
-vfork:
-	svc 190
-	.hidden __syscall_ret
-	jg  __syscall_ret
diff --git a/src/process/sh/vfork.s b/src/process/sh/vfork.s
deleted file mode 100644
index 91dbde7b9392..000000000000
--- a/src/process/sh/vfork.s
+++ /dev/null
@@ -1,20 +0,0 @@
-.global vfork
-.type vfork,@function
-vfork:
-	mov #95, r3
-	add r3, r3
-
-	trapa #31
-	or    r0, r0
-	or    r0, r0
-	or    r0, r0
-	or    r0, r0
-	or    r0, r0
-
-	mov r0, r4
-	mov.l 1f, r0
-2:	braf r0
-	 nop
-	.align 2
-	.hidden __syscall_ret
-1:	.long __syscall_ret@PLT-(2b+4-.)
diff --git a/src/process/vfork.c b/src/process/vfork.c
deleted file mode 100644
index d430c13fca36..000000000000
--- a/src/process/vfork.c
+++ /dev/null
@@ -1,14 +0,0 @@
-#define _GNU_SOURCE
-#include <unistd.h>
-#include <signal.h>
-#include "syscall.h"
-
-pid_t vfork(void)
-{
-	/* vfork syscall cannot be made from C code */
-#ifdef SYS_fork
-	return syscall(SYS_fork);
-#else
-	return syscall(SYS_clone, SIGCHLD, 0);
-#endif
-}
diff --git a/src/process/waitpid.c b/src/process/waitpid.c
index 1b65bf051238..e0f02241aa3f 100644
--- a/src/process/waitpid.c
+++ b/src/process/waitpid.c
@@ -1,7 +1,8 @@
 #include <sys/wait.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 pid_t waitpid(pid_t pid, int *status, int options)
 {
-	return syscall_cp(SYS_wait4, pid, status, options, 0);
+    return zsys_waitpid(pid, status, options);
 }
diff --git a/src/process/x32/vfork.s b/src/process/x32/vfork.s
deleted file mode 100644
index 0f0ca3ee4863..000000000000
--- a/src/process/x32/vfork.s
+++ /dev/null
@@ -1,10 +0,0 @@
-.global vfork
-.type vfork,@function
-vfork:
-	pop %rdx
-	mov $0x4000003a,%eax /* SYS_vfork */
-	syscall
-	push %rdx
-	mov %rax,%rdi
-	.hidden __syscall_ret
-	jmp __syscall_ret
diff --git a/src/process/x86_64/vfork.s b/src/process/x86_64/vfork.s
deleted file mode 100644
index 9114439031be..000000000000
--- a/src/process/x86_64/vfork.s
+++ /dev/null
@@ -1,10 +0,0 @@
-.global vfork
-.type vfork,@function
-vfork:
-	pop %rdx
-	mov $58,%eax
-	syscall
-	push %rdx
-	mov %rax,%rdi
-	.hidden __syscall_ret
-	jmp __syscall_ret
diff --git a/src/regex/regexec.c b/src/regex/regexec.c
index 253b0e149560..c25c2ac905c7 100644
--- a/src/regex/regexec.c
+++ b/src/regex/regexec.c
@@ -231,7 +231,7 @@ tre_tnfa_run_parallel(const tre_tnfa_t *tnfa, const void *string,
     pbytes = sizeof(*reach_pos) * tnfa->num_states;
     xbytes = sizeof(regoff_t) * num_tags;
     total_bytes =
-      (sizeof(long) - 1) * 4 /* for alignment paddings */
+      (sizeof(void*) - 1) * 4 /* for alignment paddings */
       + (rbytes + xbytes * tnfa->num_states) * 2 + tbytes + pbytes;
 
     /* Allocate the memory. */
@@ -242,16 +242,16 @@ tre_tnfa_run_parallel(const tre_tnfa_t *tnfa, const void *string,
     /* Get the various pointers within tmp_buf (properly aligned). */
     tmp_tags = (void *)buf;
     tmp_buf = buf + tbytes;
-    tmp_buf += ALIGN(tmp_buf, long);
+    tmp_buf += ALIGN(tmp_buf, void*);
     reach_next = (void *)tmp_buf;
     tmp_buf += rbytes;
-    tmp_buf += ALIGN(tmp_buf, long);
+    tmp_buf += ALIGN(tmp_buf, void*);
     reach = (void *)tmp_buf;
     tmp_buf += rbytes;
-    tmp_buf += ALIGN(tmp_buf, long);
+    tmp_buf += ALIGN(tmp_buf, void*);
     reach_pos = (void *)tmp_buf;
     tmp_buf += pbytes;
-    tmp_buf += ALIGN(tmp_buf, long);
+    tmp_buf += ALIGN(tmp_buf, void*);
     for (i = 0; i < tnfa->num_states; i++)
       {
 	reach[i].tags = (void *)tmp_buf;
diff --git a/src/regex/tre-mem.c b/src/regex/tre-mem.c
index 86f809d45564..f40e8ac069d4 100644
--- a/src/regex/tre-mem.c
+++ b/src/regex/tre-mem.c
@@ -143,7 +143,7 @@ tre_mem_alloc_impl(tre_mem_t mem, int provided, void *provided_block,
     }
 
   /* Make sure the next pointer will be aligned. */
-  size += ALIGN(mem->ptr + size, long);
+  size += ALIGN(mem->ptr + size, void*);
 
   /* Allocate from current block. */
   ptr = mem->ptr;
diff --git a/src/sched/affinity.c b/src/sched/affinity.c
index 948ece413fd4..12a8c4942d95 100644
--- a/src/sched/affinity.c
+++ b/src/sched/affinity.c
@@ -6,28 +6,24 @@
 
 int sched_setaffinity(pid_t tid, size_t size, const cpu_set_t *set)
 {
-	return syscall(SYS_sched_setaffinity, tid, size, set);
+	return zsys_sched_setaffinity(tid, size, set);
 }
 
 int pthread_setaffinity_np(pthread_t td, size_t size, const cpu_set_t *set)
 {
-	return -__syscall(SYS_sched_setaffinity, td->tid, size, set);
-}
-
-static int do_getaffinity(pid_t tid, size_t size, cpu_set_t *set)
-{
-	long ret = __syscall(SYS_sched_getaffinity, tid, size, set);
-	if (ret < 0) return ret;
-	if (ret < size) memset((char *)set+ret, 0, size-ret);
+	if (sched_setaffinity(td->tid, size, set) < 0)
+		return errno;
 	return 0;
 }
 
 int sched_getaffinity(pid_t tid, size_t size, cpu_set_t *set)
 {
-	return __syscall_ret(do_getaffinity(tid, size, set));
+	return zsys_sched_getaffinity(tid, size, set);
 }
 
 int pthread_getaffinity_np(pthread_t td, size_t size, cpu_set_t *set)
 {
-	return -do_getaffinity(td->tid, size, set);
+	if (sched_getaffinity(td->tid, size, set) < 0)
+		return errno;
+	return 0;
 }
diff --git a/src/sched/sched_get_priority_max.c b/src/sched/sched_get_priority_max.c
index 30ae5100e1de..ba0d7bb98cd1 100644
--- a/src/sched/sched_get_priority_max.c
+++ b/src/sched/sched_get_priority_max.c
@@ -3,10 +3,10 @@
 
 int sched_get_priority_max(int policy)
 {
-	return syscall(SYS_sched_get_priority_max, policy);
+	return zsys_sched_get_priority_max(policy);
 }
 
 int sched_get_priority_min(int policy)
 {
-	return syscall(SYS_sched_get_priority_min, policy);
+	return zsys_sched_get_priority_min(policy);
 }
diff --git a/src/sched/sched_getcpu.c b/src/sched/sched_getcpu.c
index 4ec5eaf67961..ec13f7e7faad 100644
--- a/src/sched/sched_getcpu.c
+++ b/src/sched/sched_getcpu.c
@@ -4,39 +4,7 @@
 #include "syscall.h"
 #include "atomic.h"
 
-#ifdef VDSO_GETCPU_SYM
-
-static void *volatile vdso_func;
-
-typedef long (*getcpu_f)(unsigned *, unsigned *, void *);
-
-static long getcpu_init(unsigned *cpu, unsigned *node, void *unused)
-{
-	void *p = __vdsosym(VDSO_GETCPU_VER, VDSO_GETCPU_SYM);
-	getcpu_f f = (getcpu_f)p;
-	a_cas_p(&vdso_func, (void *)getcpu_init, p);
-	return f ? f(cpu, node, unused) : -ENOSYS;
-}
-
-static void *volatile vdso_func = (void *)getcpu_init;
-
-#endif
-
 int sched_getcpu(void)
 {
-	int r;
-	unsigned cpu;
-
-#ifdef VDSO_GETCPU_SYM
-	getcpu_f f = (getcpu_f)vdso_func;
-	if (f) {
-		r = f(&cpu, 0, 0);
-		if (!r) return cpu;
-		if (r != -ENOSYS) return __syscall_ret(r);
-	}
-#endif
-
-	r = __syscall(SYS_getcpu, &cpu, 0, 0);
-	if (!r) return cpu;
-	return __syscall_ret(r);
+        return zsys_sched_getcpu();
 }
diff --git a/src/sched/sched_yield.c b/src/sched/sched_yield.c
index ee6f0e7f1604..68126694124d 100644
--- a/src/sched/sched_yield.c
+++ b/src/sched/sched_yield.c
@@ -1,7 +1,8 @@
 #include <sched.h>
-#include "syscall.h"
+#include <pizlonated_syscalls.h>
 
 int sched_yield()
 {
-	return syscall(SYS_sched_yield);
+    zsys_sched_yield();
+    return 0;
 }
diff --git a/src/select/poll.c b/src/select/poll.c
index 7883dfab478a..c524498a0ebc 100644
--- a/src/select/poll.c
+++ b/src/select/poll.c
@@ -2,19 +2,9 @@
 #include <time.h>
 #include <signal.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int poll(struct pollfd *fds, nfds_t n, int timeout)
 {
-#ifdef SYS_poll
-	return syscall_cp(SYS_poll, fds, n, timeout);
-#else
-#if SYS_ppoll_time64 == SYS_ppoll
-	typedef long long ppoll_ts_t[2];
-#else
-	typedef long ppoll_ts_t[2];
-#endif
-	return syscall_cp(SYS_ppoll, fds, n, timeout>=0 ?
-		((ppoll_ts_t){ timeout/1000, timeout%1000*1000000 }) : 0,
-		0, _NSIG/8);
-#endif
+    return zsys_poll(fds, n, timeout);
 }
diff --git a/src/select/pselect.c b/src/select/pselect.c
index 54cfb291bba2..9954c098ff42 100644
--- a/src/select/pselect.c
+++ b/src/select/pselect.c
@@ -3,24 +3,9 @@
 #include <stdint.h>
 #include <errno.h>
 #include "syscall.h"
-
-#define IS32BIT(x) !((x)+0x80000000ULL>>32)
-#define CLAMP(x) (int)(IS32BIT(x) ? (x) : 0x7fffffffU+((0ULL+(x))>>63))
+#include <stdfil.h>
 
 int pselect(int n, fd_set *restrict rfds, fd_set *restrict wfds, fd_set *restrict efds, const struct timespec *restrict ts, const sigset_t *restrict mask)
 {
-	syscall_arg_t data[2] = { (uintptr_t)mask, _NSIG/8 };
-	time_t s = ts ? ts->tv_sec : 0;
-	long ns = ts ? ts->tv_nsec : 0;
-#ifdef SYS_pselect6_time64
-	int r = -ENOSYS;
-	if (SYS_pselect6 == SYS_pselect6_time64 || !IS32BIT(s))
-		r = __syscall_cp(SYS_pselect6_time64, n, rfds, wfds, efds,
-			ts ? ((long long[]){s, ns}) : 0, data);
-	if (SYS_pselect6 == SYS_pselect6_time64 || r!=-ENOSYS)
-		return __syscall_ret(r);
-	s = CLAMP(s);
-#endif
-	return syscall_cp(SYS_pselect6, n, rfds, wfds, efds,
-		ts ? ((long[]){s, ns}) : 0, data);
+    return zsys_pselect(n, rfds, wfds, efds, ts, mask);
 }
diff --git a/src/select/select.c b/src/select/select.c
index f1d72863c675..9e3c33091548 100644
--- a/src/select/select.c
+++ b/src/select/select.c
@@ -3,43 +3,12 @@
 #include <stdint.h>
 #include <errno.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 #define IS32BIT(x) !((x)+0x80000000ULL>>32)
 #define CLAMP(x) (int)(IS32BIT(x) ? (x) : 0x7fffffffU+((0ULL+(x))>>63))
 
 int select(int n, fd_set *restrict rfds, fd_set *restrict wfds, fd_set *restrict efds, struct timeval *restrict tv)
 {
-	time_t s = tv ? tv->tv_sec : 0;
-	suseconds_t us = tv ? tv->tv_usec : 0;
-	long ns;
-	const time_t max_time = (1ULL<<8*sizeof(time_t)-1)-1;
-
-	if (s<0 || us<0) return __syscall_ret(-EINVAL);
-	if (us/1000000 > max_time - s) {
-		s = max_time;
-		us = 999999;
-		ns = 999999999;
-	} else {
-		s += us/1000000;
-		us %= 1000000;
-		ns = us*1000;
-	}
-
-#ifdef SYS_pselect6_time64
-	int r = -ENOSYS;
-	if (SYS_pselect6 == SYS_pselect6_time64 || !IS32BIT(s))
-		r = __syscall_cp(SYS_pselect6_time64, n, rfds, wfds, efds,
-			tv ? ((long long[]){s, ns}) : 0,
-			((syscall_arg_t[]){ 0, _NSIG/8 }));
-	if (SYS_pselect6 == SYS_pselect6_time64 || r!=-ENOSYS)
-		return __syscall_ret(r);
-	s = CLAMP(s);
-#endif
-#ifdef SYS_select
-	return syscall_cp(SYS_select, n, rfds, wfds, efds,
-		tv ? ((long[]){s, us}) : 0);
-#else
-	return syscall_cp(SYS_pselect6, n, rfds, wfds, efds,
-		tv ? ((long[]){s, ns}) : 0, ((syscall_arg_t[]){ 0, _NSIG/8 }));
-#endif
+    return zsys_select(n, rfds, wfds, efds, tv);
 }
diff --git a/src/setjmp/aarch64/longjmp.s b/src/setjmp/aarch64/longjmp.s
deleted file mode 100644
index 0af9c50ee5c8..000000000000
--- a/src/setjmp/aarch64/longjmp.s
+++ /dev/null
@@ -1,23 +0,0 @@
-.global _longjmp
-.global longjmp
-.type _longjmp,%function
-.type longjmp,%function
-_longjmp:
-longjmp:
-	// IHI0055B_aapcs64.pdf 5.1.1, 5.1.2 callee saved registers
-	ldp x19, x20, [x0,#0]
-	ldp x21, x22, [x0,#16]
-	ldp x23, x24, [x0,#32]
-	ldp x25, x26, [x0,#48]
-	ldp x27, x28, [x0,#64]
-	ldp x29, x30, [x0,#80]
-	ldr x2, [x0,#104]
-	mov sp, x2
-	ldp d8 , d9, [x0,#112]
-	ldp d10, d11, [x0,#128]
-	ldp d12, d13, [x0,#144]
-	ldp d14, d15, [x0,#160]
-
-	cmp w1, 0
-	csinc w0, w1, wzr, ne
-	br x30
diff --git a/src/setjmp/aarch64/setjmp.s b/src/setjmp/aarch64/setjmp.s
deleted file mode 100644
index f49288aa1c61..000000000000
--- a/src/setjmp/aarch64/setjmp.s
+++ /dev/null
@@ -1,24 +0,0 @@
-.global __setjmp
-.global _setjmp
-.global setjmp
-.type __setjmp,@function
-.type _setjmp,@function
-.type setjmp,@function
-__setjmp:
-_setjmp:
-setjmp:
-	// IHI0055B_aapcs64.pdf 5.1.1, 5.1.2 callee saved registers
-	stp x19, x20, [x0,#0]
-	stp x21, x22, [x0,#16]
-	stp x23, x24, [x0,#32]
-	stp x25, x26, [x0,#48]
-	stp x27, x28, [x0,#64]
-	stp x29, x30, [x0,#80]
-	mov x2, sp
-	str x2, [x0,#104]
-	stp  d8,  d9, [x0,#112]
-	stp d10, d11, [x0,#128]
-	stp d12, d13, [x0,#144]
-	stp d14, d15, [x0,#160]
-	mov x0, #0
-	ret
diff --git a/src/setjmp/arm/longjmp.S b/src/setjmp/arm/longjmp.S
deleted file mode 100644
index 8df0b8190dd7..000000000000
--- a/src/setjmp/arm/longjmp.S
+++ /dev/null
@@ -1,50 +0,0 @@
-.syntax unified
-.global _longjmp
-.global longjmp
-.type _longjmp,%function
-.type longjmp,%function
-_longjmp:
-longjmp:
-	mov ip,r0
-	movs r0,r1
-	moveq r0,#1
-	ldmia ip!, {v1,v2,v3,v4,v5,v6,sl,fp}
-	ldmia ip!, {r2,lr}
-	mov sp,r2
-
-	adr r1,1f
-	ldr r2,1f
-	ldr r1,[r1,r2]
-
-#if __ARM_ARCH < 8
-	tst r1,#0x260
-	beq 3f
-	// HWCAP_ARM_FPA
-	tst r1,#0x20
-	beq 2f
-	ldc p2, cr4, [ip], #48
-#endif
-2:	tst r1,#0x40
-	beq 2f
-	.fpu vfp
-	vldmia ip!, {d8-d15}
-	.fpu softvfp
-	.eabi_attribute 10, 0
-	.eabi_attribute 27, 0
-#if __ARM_ARCH < 8
-	// HWCAP_ARM_IWMMXT
-2:	tst r1,#0x200
-	beq 3f
-	ldcl p1, cr10, [ip], #8
-	ldcl p1, cr11, [ip], #8
-	ldcl p1, cr12, [ip], #8
-	ldcl p1, cr13, [ip], #8
-	ldcl p1, cr14, [ip], #8
-	ldcl p1, cr15, [ip], #8
-#endif
-2:
-3:	bx lr
-
-.hidden __hwcap
-.align 2
-1:	.word __hwcap-1b
diff --git a/src/setjmp/arm/setjmp.S b/src/setjmp/arm/setjmp.S
deleted file mode 100644
index 45731d228e80..000000000000
--- a/src/setjmp/arm/setjmp.S
+++ /dev/null
@@ -1,52 +0,0 @@
-.syntax unified
-.global __setjmp
-.global _setjmp
-.global setjmp
-.type __setjmp,%function
-.type _setjmp,%function
-.type setjmp,%function
-__setjmp:
-_setjmp:
-setjmp:
-	mov ip,r0
-	stmia ip!,{v1,v2,v3,v4,v5,v6,sl,fp}
-	mov r2,sp
-	stmia ip!,{r2,lr}
-	mov r0,#0
-
-	adr r1,1f
-	ldr r2,1f
-	ldr r1,[r1,r2]
-
-#if __ARM_ARCH < 8
-	tst r1,#0x260
-	beq 3f
-	// HWCAP_ARM_FPA
-	tst r1,#0x20
-	beq 2f
-	stc p2, cr4, [ip], #48
-#endif
-2:	tst r1,#0x40
-	beq 2f
-	.fpu vfp
-	vstmia ip!, {d8-d15}
-	.fpu softvfp
-	.eabi_attribute 10, 0
-	.eabi_attribute 27, 0
-#if __ARM_ARCH < 8
-	// HWCAP_ARM_IWMMXT
-2:	tst r1,#0x200
-	beq 3f
-	stcl p1, cr10, [ip], #8
-	stcl p1, cr11, [ip], #8
-	stcl p1, cr12, [ip], #8
-	stcl p1, cr13, [ip], #8
-	stcl p1, cr14, [ip], #8
-	stcl p1, cr15, [ip], #8
-#endif
-2:
-3:	bx lr
-
-.hidden __hwcap
-.align 2
-1:	.word __hwcap-1b
diff --git a/src/setjmp/i386/longjmp.s b/src/setjmp/i386/longjmp.s
deleted file mode 100644
index 8188f06bcd7f..000000000000
--- a/src/setjmp/i386/longjmp.s
+++ /dev/null
@@ -1,16 +0,0 @@
-.global _longjmp
-.global longjmp
-.type _longjmp,@function
-.type longjmp,@function
-_longjmp:
-longjmp:
-	mov  4(%esp),%edx
-	mov  8(%esp),%eax
-	cmp       $1,%eax
-	adc       $0, %al
-	mov   (%edx),%ebx
-	mov  4(%edx),%esi
-	mov  8(%edx),%edi
-	mov 12(%edx),%ebp
-	mov 16(%edx),%esp
-	jmp *20(%edx)
diff --git a/src/setjmp/i386/setjmp.s b/src/setjmp/i386/setjmp.s
deleted file mode 100644
index 4d19cf87cbe9..000000000000
--- a/src/setjmp/i386/setjmp.s
+++ /dev/null
@@ -1,23 +0,0 @@
-.global ___setjmp
-.hidden ___setjmp
-.global __setjmp
-.global _setjmp
-.global setjmp
-.type __setjmp,@function
-.type _setjmp,@function
-.type setjmp,@function
-___setjmp:
-__setjmp:
-_setjmp:
-setjmp:
-	mov 4(%esp), %eax
-	mov    %ebx, (%eax)
-	mov    %esi, 4(%eax)
-	mov    %edi, 8(%eax)
-	mov    %ebp, 12(%eax)
-	lea 4(%esp), %ecx
-	mov    %ecx, 16(%eax)
-	mov  (%esp), %ecx
-	mov    %ecx, 20(%eax)
-	xor    %eax, %eax
-	ret
diff --git a/src/setjmp/longjmp.c b/src/setjmp/longjmp.c
index e69de29bb2d1..3a0608064d10 100644
--- a/src/setjmp/longjmp.c
+++ b/src/setjmp/longjmp.c
@@ -0,0 +1,17 @@
+#include <setjmp.h>
+#include <pizlonated_runtime.h>
+
+_Noreturn void longjmp(jmp_buf buf, int value)
+{
+    zlongjmp(*(zjmp_buf**)buf, value);
+}
+
+_Noreturn void _longjmp(jmp_buf buf, int value)
+{
+    zlongjmp(*(zjmp_buf**)buf, value);
+}
+
+_Noreturn void siglongjmp(sigjmp_buf buf, int value)
+{
+    zlongjmp(*(zjmp_buf**)buf, value);
+}
diff --git a/src/setjmp/m68k/longjmp.s b/src/setjmp/m68k/longjmp.s
deleted file mode 100644
index cdb05fb5a603..000000000000
--- a/src/setjmp/m68k/longjmp.s
+++ /dev/null
@@ -1,14 +0,0 @@
-.global _longjmp
-.global longjmp
-.type _longjmp,@function
-.type longjmp,@function
-_longjmp:
-longjmp:
-	movea.l 4(%sp),%a0
-	move.l 8(%sp),%d0
-	bne 1f
-	move.l #1,%d0
-1:	movem.l (%a0),%d2-%d7/%a2-%a7
-	fmovem.x 52(%a0),%fp2-%fp7
-	move.l 48(%a0),(%sp)
-	rts
diff --git a/src/setjmp/m68k/setjmp.s b/src/setjmp/m68k/setjmp.s
deleted file mode 100644
index 15e549b0efc1..000000000000
--- a/src/setjmp/m68k/setjmp.s
+++ /dev/null
@@ -1,18 +0,0 @@
-.global ___setjmp
-.hidden ___setjmp
-.global __setjmp
-.global _setjmp
-.global setjmp
-.type __setjmp,@function
-.type _setjmp,@function
-.type setjmp,@function
-___setjmp:
-__setjmp:
-_setjmp:
-setjmp:
-	movea.l 4(%sp),%a0
-	movem.l %d2-%d7/%a2-%a7,(%a0)
-	move.l (%sp),48(%a0)
-	fmovem.x %fp2-%fp7,52(%a0)
-	clr.l %d0
-	rts
diff --git a/src/setjmp/microblaze/longjmp.s b/src/setjmp/microblaze/longjmp.s
deleted file mode 100644
index c0760288a76c..000000000000
--- a/src/setjmp/microblaze/longjmp.s
+++ /dev/null
@@ -1,29 +0,0 @@
-.global _longjmp
-.global longjmp
-.type   _longjmp,@function
-.type   longjmp,@function
-_longjmp:
-longjmp:
-	addi    r3, r6, 0
-	bnei    r3, 1f
-	addi    r3, r3, 1
-1:      lwi     r1,  r5, 0
-	lwi     r15, r5, 4
-	lwi     r2,  r5, 8
-	lwi     r13, r5, 12
-	lwi     r18, r5, 16
-	lwi     r19, r5, 20
-	lwi     r20, r5, 24
-	lwi     r21, r5, 28
-	lwi     r22, r5, 32
-	lwi     r23, r5, 36
-	lwi     r24, r5, 40
-	lwi     r25, r5, 44
-	lwi     r26, r5, 48
-	lwi     r27, r5, 52
-	lwi     r28, r5, 56
-	lwi     r29, r5, 60
-	lwi     r30, r5, 64
-	lwi     r31, r5, 68
-	rtsd    r15, 8
-	nop
diff --git a/src/setjmp/microblaze/setjmp.s b/src/setjmp/microblaze/setjmp.s
deleted file mode 100644
index 605ab20e4bdd..000000000000
--- a/src/setjmp/microblaze/setjmp.s
+++ /dev/null
@@ -1,32 +0,0 @@
-.global ___setjmp
-.hidden ___setjmp
-.global __setjmp
-.global _setjmp
-.global setjmp
-.type __setjmp,@function
-.type _setjmp,@function
-.type setjmp,@function
-___setjmp:
-__setjmp:
-_setjmp:
-setjmp:
-	swi     r1,  r5, 0
-	swi     r15, r5, 4
-	swi     r2,  r5, 8
-	swi     r13, r5, 12
-	swi     r18, r5, 16
-	swi     r19, r5, 20
-	swi     r20, r5, 24
-	swi     r21, r5, 28
-	swi     r22, r5, 32
-	swi     r23, r5, 36
-	swi     r24, r5, 40
-	swi     r25, r5, 44
-	swi     r26, r5, 48
-	swi     r27, r5, 52
-	swi     r28, r5, 56
-	swi     r29, r5, 60
-	swi     r30, r5, 64
-	swi     r31, r5, 68
-	rtsd    r15, 8
-	ori     r3, r0, 0
diff --git a/src/setjmp/mips/longjmp.S b/src/setjmp/mips/longjmp.S
deleted file mode 100644
index ecf408553880..000000000000
--- a/src/setjmp/mips/longjmp.S
+++ /dev/null
@@ -1,34 +0,0 @@
-.set noreorder
-
-.global _longjmp
-.global longjmp
-.type   _longjmp,@function
-.type   longjmp,@function
-_longjmp:
-longjmp:
-	move    $2, $5
-	bne     $2, $0, 1f
-	nop
-	addu    $2, $2, 1
-1:
-#ifndef __mips_soft_float
-	l.d     $f20, 56($4)
-	l.d     $f22, 64($4)
-	l.d     $f24, 72($4)
-	l.d     $f26, 80($4)
-	l.d     $f28, 88($4)
-	l.d     $f30, 96($4)
-#endif
-	lw      $ra,  0($4)
-	lw      $sp,  4($4)
-	lw      $16,  8($4)
-	lw      $17, 12($4)
-	lw      $18, 16($4)
-	lw      $19, 20($4)
-	lw      $20, 24($4)
-	lw      $21, 28($4)
-	lw      $22, 32($4)
-	lw      $23, 36($4)
-	lw      $30, 40($4)
-	jr      $ra
-	lw      $28, 44($4)
diff --git a/src/setjmp/mips/setjmp.S b/src/setjmp/mips/setjmp.S
deleted file mode 100644
index 7ae8832d516b..000000000000
--- a/src/setjmp/mips/setjmp.S
+++ /dev/null
@@ -1,33 +0,0 @@
-.set noreorder
-
-.global __setjmp
-.global _setjmp
-.global setjmp
-.type   __setjmp,@function
-.type   _setjmp,@function
-.type   setjmp,@function
-__setjmp:
-_setjmp:
-setjmp:
-	sw      $ra,  0($4)
-	sw      $sp,  4($4)
-	sw      $16,  8($4)
-	sw      $17, 12($4)
-	sw      $18, 16($4)
-	sw      $19, 20($4)
-	sw      $20, 24($4)
-	sw      $21, 28($4)
-	sw      $22, 32($4)
-	sw      $23, 36($4)
-	sw      $30, 40($4)
-	sw      $28, 44($4)
-#ifndef __mips_soft_float
-	s.d     $f20, 56($4)
-	s.d     $f22, 64($4)
-	s.d     $f24, 72($4)
-	s.d     $f26, 80($4)
-	s.d     $f28, 88($4)
-	s.d     $f30, 96($4)
-#endif
-	jr      $ra
-	li      $2, 0
diff --git a/src/setjmp/mips64/longjmp.S b/src/setjmp/mips64/longjmp.S
deleted file mode 100644
index 3db8a883c6de..000000000000
--- a/src/setjmp/mips64/longjmp.S
+++ /dev/null
@@ -1,37 +0,0 @@
-.set	noreorder
-.global	_longjmp
-.global	longjmp
-.type	_longjmp,@function
-.type	longjmp,@function
-_longjmp:
-longjmp:
-	move	$2, $5
-
-	bne	$2, $0, 1f
-	nop
-	daddu	$2, $2, 1
-1:
-#ifndef __mips_soft_float
-	ldc1	$24, 96($4)
-	ldc1	$25, 104($4)
-	ldc1	$26, 112($4)
-	ldc1	$27, 120($4)
-	ldc1	$28, 128($4)
-	ldc1	$29, 136($4)
-	ldc1	$30, 144($4)
-	ldc1	$31, 152($4)
-#endif
-	ld	$ra, 0($4)
-	ld	$sp, 8($4)
-	ld	$gp, 16($4)
-	ld	$16, 24($4)
-	ld	$17, 32($4)
-	ld	$18, 40($4)
-	ld	$19, 48($4)
-	ld	$20, 56($4)
-	ld	$21, 64($4)
-	ld	$22, 72($4)
-	ld	$23, 80($4)
-	ld	$30, 88($4)
-	jr	$ra
-	nop
diff --git a/src/setjmp/mips64/setjmp.S b/src/setjmp/mips64/setjmp.S
deleted file mode 100644
index b9646c2abe52..000000000000
--- a/src/setjmp/mips64/setjmp.S
+++ /dev/null
@@ -1,34 +0,0 @@
-.set	noreorder
-.global	__setjmp
-.global	_setjmp
-.global	setjmp
-.type	__setjmp,@function
-.type	_setjmp,@function
-.type	setjmp,@function
-__setjmp:
-_setjmp:
-setjmp:
-	sd	$ra, 0($4)
-	sd	$sp, 8($4)
-	sd	$gp, 16($4)
-	sd	$16, 24($4)
-	sd	$17, 32($4)
-	sd	$18, 40($4)
-	sd	$19, 48($4)
-	sd	$20, 56($4)
-	sd	$21, 64($4)
-	sd	$22, 72($4)
-	sd	$23, 80($4)
-	sd	$30, 88($4)
-#ifndef __mips_soft_float
-	sdc1	$24, 96($4)
-	sdc1	$25, 104($4)
-	sdc1	$26, 112($4)
-	sdc1	$27, 120($4)
-	sdc1	$28, 128($4)
-	sdc1	$29, 136($4)
-	sdc1	$30, 144($4)
-	sdc1	$31, 152($4)
-#endif
-	jr	$ra
-	li	$2, 0
diff --git a/src/setjmp/mipsn32/longjmp.S b/src/setjmp/mipsn32/longjmp.S
deleted file mode 100644
index 30c3ee0b0cbf..000000000000
--- a/src/setjmp/mipsn32/longjmp.S
+++ /dev/null
@@ -1,36 +0,0 @@
-.set	noreorder
-.global	_longjmp
-.global	longjmp
-.type	_longjmp,@function
-.type	longjmp,@function
-_longjmp:
-longjmp:
-	move	$2, $5
-	bne	$2, $0, 1f
-	nop
-	addu	$2, $2, 1
-1:
-#ifndef __mips_soft_float
-	ldc1	$24, 96($4)
-	ldc1	$25, 104($4)
-	ldc1	$26, 112($4)
-	ldc1	$27, 120($4)
-	ldc1	$28, 128($4)
-	ldc1	$29, 136($4)
-	ldc1	$30, 144($4)
-	ldc1	$31, 152($4)
-#endif
-	ld	$ra, 0($4)
-	ld	$sp, 8($4)
-	ld	$gp, 16($4)
-	ld	$16, 24($4)
-	ld	$17, 32($4)
-	ld	$18, 40($4)
-	ld	$19, 48($4)
-	ld	$20, 56($4)
-	ld	$21, 64($4)
-	ld	$22, 72($4)
-	ld	$23, 80($4)
-	ld	$30, 88($4)
-	jr	$ra
-	nop
diff --git a/src/setjmp/mipsn32/setjmp.S b/src/setjmp/mipsn32/setjmp.S
deleted file mode 100644
index b9646c2abe52..000000000000
--- a/src/setjmp/mipsn32/setjmp.S
+++ /dev/null
@@ -1,34 +0,0 @@
-.set	noreorder
-.global	__setjmp
-.global	_setjmp
-.global	setjmp
-.type	__setjmp,@function
-.type	_setjmp,@function
-.type	setjmp,@function
-__setjmp:
-_setjmp:
-setjmp:
-	sd	$ra, 0($4)
-	sd	$sp, 8($4)
-	sd	$gp, 16($4)
-	sd	$16, 24($4)
-	sd	$17, 32($4)
-	sd	$18, 40($4)
-	sd	$19, 48($4)
-	sd	$20, 56($4)
-	sd	$21, 64($4)
-	sd	$22, 72($4)
-	sd	$23, 80($4)
-	sd	$30, 88($4)
-#ifndef __mips_soft_float
-	sdc1	$24, 96($4)
-	sdc1	$25, 104($4)
-	sdc1	$26, 112($4)
-	sdc1	$27, 120($4)
-	sdc1	$28, 128($4)
-	sdc1	$29, 136($4)
-	sdc1	$30, 144($4)
-	sdc1	$31, 152($4)
-#endif
-	jr	$ra
-	li	$2, 0
diff --git a/src/setjmp/or1k/longjmp.s b/src/setjmp/or1k/longjmp.s
deleted file mode 100644
index 1db9fd93391d..000000000000
--- a/src/setjmp/or1k/longjmp.s
+++ /dev/null
@@ -1,25 +0,0 @@
-.global _longjmp
-.global longjmp
-.type   _longjmp,@function
-.type   longjmp,@function
-_longjmp:
-longjmp:
-	l.sfeqi	r4, 0
-	l.bnf	1f
-	 l.addi	r11, r4,0
-	l.ori	r11, r0, 1
-1:	l.lwz	r1, 0(r3)
-	l.lwz	r2, 4(r3)
-	l.lwz	r9, 8(r3)
-	l.lwz	r10, 12(r3)
-	l.lwz	r14, 16(r3)
-	l.lwz	r16, 20(r3)
-	l.lwz	r18, 24(r3)
-	l.lwz	r20, 28(r3)
-	l.lwz	r22, 32(r3)
-	l.lwz	r24, 36(r3)
-	l.lwz	r26, 40(r3)
-	l.lwz	r28, 44(r3)
-	l.lwz	r30, 48(r3)
-	l.jr	r9
-	 l.nop
diff --git a/src/setjmp/or1k/setjmp.s b/src/setjmp/or1k/setjmp.s
deleted file mode 100644
index 0677033843e0..000000000000
--- a/src/setjmp/or1k/setjmp.s
+++ /dev/null
@@ -1,27 +0,0 @@
-.global ___setjmp
-.hidden ___setjmp
-.global __setjmp
-.global _setjmp
-.global setjmp
-.type __setjmp,@function
-.type _setjmp,@function
-.type setjmp,@function
-___setjmp:
-__setjmp:
-_setjmp:
-setjmp:
-	l.sw	0(r3), r1
-	l.sw	4(r3), r2
-	l.sw	8(r3), r9
-	l.sw	12(r3), r10
-	l.sw	16(r3), r14
-	l.sw	20(r3), r16
-	l.sw	24(r3), r18
-	l.sw	28(r3), r20
-	l.sw	32(r3), r22
-	l.sw	36(r3), r24
-	l.sw	40(r3), r26
-	l.sw	44(r3), r28
-	l.sw	48(r3), r30
-	l.jr	r9
-	 l.ori	r11,r0,0
diff --git a/src/setjmp/powerpc/longjmp.S b/src/setjmp/powerpc/longjmp.S
deleted file mode 100644
index 465e4cd79230..000000000000
--- a/src/setjmp/powerpc/longjmp.S
+++ /dev/null
@@ -1,99 +0,0 @@
-	.global _longjmp
-	.global longjmp
-	.type   _longjmp,@function
-	.type   longjmp,@function
-_longjmp:
-longjmp:
-	/*
-	 * void longjmp(jmp_buf env, int val);
-	 * put val into return register and restore the env saved in setjmp
-	 * if val(r4) is 0, put 1 there.
-	 */
-	/* 0) move old return address into r0 */
-	lwz 0, 0(3)
-	/* 1) put it into link reg */
-	mtlr 0
-	/* 2 ) restore stack ptr */
-	lwz 1, 4(3)
-	/* 3) restore control reg */
-	lwz 0, 8(3)
-	mtcr 0
-	/* 4) restore r14-r31 */
-	lwz 14, 12(3)
-	lwz 15, 16(3)
-	lwz 16, 20(3)
-	lwz 17, 24(3)
-	lwz 18, 28(3)
-	lwz 19, 32(3)
-	lwz 20, 36(3)
-	lwz 21, 40(3)
-	lwz 22, 44(3)
-	lwz 23, 48(3)
-	lwz 24, 52(3)
-	lwz 25, 56(3)
-	lwz 26, 60(3)
-	lwz 27, 64(3)
-	lwz 28, 68(3)
-	lwz 29, 72(3)
-	lwz 30, 76(3)
-	lwz 31, 80(3)
-#if defined(_SOFT_FLOAT) || defined(__NO_FPRS__)
-	mflr 0
-	bl 1f
-	.hidden __hwcap
-	.long __hwcap-.
-1:	mflr 6
-	lwz 5, 0(6)
-	lwzx 6, 6, 5
-	andis. 6, 6, 0x80
-	beq 1f
-	.long 0x11c35b01 /* evldd 14,88(3) */
-	.long 0x11e36301 /* ... */
-	.long 0x12036b01
-	.long 0x12237301
-	.long 0x12437b01
-	.long 0x12638301
-	.long 0x12838b01
-	.long 0x12a39301
-	.long 0x12c39b01
-	.long 0x12e3a301
-	.long 0x1303ab01
-	.long 0x1323b301
-	.long 0x1343bb01
-	.long 0x1363c301
-	.long 0x1383cb01
-	.long 0x13a3d301
-	.long 0x13c3db01
-	.long 0x13e3e301 /* evldd 31,224(3) */
-	.long 0x11a3eb01 /* evldd 13,232(3) */
-1:	mtlr 0
-#else
-	lfd 14,88(3)
-	lfd 15,96(3)
-	lfd 16,104(3)
-	lfd 17,112(3)
-	lfd 18,120(3)
-	lfd 19,128(3)
-	lfd 20,136(3)
-	lfd 21,144(3)
-	lfd 22,152(3)
-	lfd 23,160(3)
-	lfd 24,168(3)
-	lfd 25,176(3)
-	lfd 26,184(3)
-	lfd 27,192(3)
-	lfd 28,200(3)
-	lfd 29,208(3)
-	lfd 30,216(3)
-	lfd 31,224(3)
-#endif
-	/* 5) put val into return reg r3 */
-	mr 3, 4
-
-	/* 6) check if return value is 0, make it 1 in that case */
-	cmpwi cr7, 4, 0
-	bne cr7, 1f
-	li 3, 1
-1:
-	blr
-
diff --git a/src/setjmp/powerpc/setjmp.S b/src/setjmp/powerpc/setjmp.S
deleted file mode 100644
index f1fcce339e59..000000000000
--- a/src/setjmp/powerpc/setjmp.S
+++ /dev/null
@@ -1,93 +0,0 @@
-	.global ___setjmp
-	.hidden ___setjmp
-	.global __setjmp
-	.global _setjmp
-	.global setjmp
-	.type   __setjmp,@function
-	.type   _setjmp,@function
-	.type   setjmp,@function
-___setjmp:
-__setjmp:
-_setjmp:
-setjmp:
-	/* 0) store IP int 0, then into the jmpbuf pointed to by r3 (first arg) */
-	mflr 0
-	stw 0, 0(3)
-	/* 1) store reg1 (SP) */
-	stw 1, 4(3)
-	/* 2) store cr */
-	mfcr 0
-	stw 0, 8(3)
-	/* 3) store r14-31 */
-	stw 14, 12(3)
-	stw 15, 16(3)
-	stw 16, 20(3)
-	stw 17, 24(3)
-	stw 18, 28(3)
-	stw 19, 32(3)
-	stw 20, 36(3)
-	stw 21, 40(3)
-	stw 22, 44(3)
-	stw 23, 48(3)
-	stw 24, 52(3)
-	stw 25, 56(3)
-	stw 26, 60(3)
-	stw 27, 64(3)
-	stw 28, 68(3)
-	stw 29, 72(3)
-	stw 30, 76(3)
-	stw 31, 80(3)
-#if defined(_SOFT_FLOAT) || defined(__NO_FPRS__)
-	mflr 0
-	bl 1f
-	.hidden __hwcap
-	.long __hwcap-.
-1:	mflr 4
-	lwz 5, 0(4)
-	lwzx 4, 4, 5
-	andis. 4, 4, 0x80
-	beq 1f
-	.long 0x11c35b21 /* evstdd 14,88(3) */
-	.long 0x11e36321 /* ... */
-	.long 0x12036b21
-	.long 0x12237321
-	.long 0x12437b21
-	.long 0x12638321
-	.long 0x12838b21
-	.long 0x12a39321
-	.long 0x12c39b21
-	.long 0x12e3a321
-	.long 0x1303ab21
-	.long 0x1323b321
-	.long 0x1343bb21
-	.long 0x1363c321
-	.long 0x1383cb21
-	.long 0x13a3d321
-	.long 0x13c3db21
-	.long 0x13e3e321 /* evstdd 31,224(3) */
-	.long 0x11a3eb21 /* evstdd 13,232(3) */
-1:	mtlr 0
-#else
-	stfd 14,88(3)
-	stfd 15,96(3)
-	stfd 16,104(3)
-	stfd 17,112(3)
-	stfd 18,120(3)
-	stfd 19,128(3)
-	stfd 20,136(3)
-	stfd 21,144(3)
-	stfd 22,152(3)
-	stfd 23,160(3)
-	stfd 24,168(3)
-	stfd 25,176(3)
-	stfd 26,184(3)
-	stfd 27,192(3)
-	stfd 28,200(3)
-	stfd 29,208(3)
-	stfd 30,216(3)
-	stfd 31,224(3)
-#endif
-	/* 4) set return value to 0 */
-	li 3, 0
-	/* 5) return */
-	blr
diff --git a/src/setjmp/powerpc64/longjmp.s b/src/setjmp/powerpc64/longjmp.s
deleted file mode 100644
index 81d45ff60bfd..000000000000
--- a/src/setjmp/powerpc64/longjmp.s
+++ /dev/null
@@ -1,81 +0,0 @@
-	.global _longjmp
-	.global longjmp
-	.type   _longjmp,@function
-	.type   longjmp,@function
-_longjmp:
-longjmp:
-	# 0) move old return address into the link register
-	ld   0,  0*8(3)
-	mtlr 0
-	# 1) restore cr
-	ld   0,  1*8(3)
-	mtcr 0
-	# 2) restore SP
-	ld   1,  2*8(3)
-	# 3) restore TOC into both r2 and the caller's stack.
-	#    Which location is required depends on whether setjmp was called
-	#    locally or non-locally, but it's always safe to restore to both.
-	ld   2,  3*8(3)
-	std  2,   24(1)
-	# 4) restore r14-r31
-	ld  14,  4*8(3)
-	ld  15,  5*8(3)
-	ld  16,  6*8(3)
-	ld  17,  7*8(3)
-	ld  18,  8*8(3)
-	ld  19,  9*8(3)
-	ld  20, 10*8(3)
-	ld  21, 11*8(3)
-	ld  22, 12*8(3)
-	ld  23, 13*8(3)
-	ld  24, 14*8(3)
-	ld  25, 15*8(3)
-	ld  26, 16*8(3)
-	ld  27, 17*8(3)
-	ld  28, 18*8(3)
-	ld  29, 19*8(3)
-	ld  30, 20*8(3)
-	ld  31, 21*8(3)
-	# 5) restore floating point registers f14-f31
-	lfd 14, 22*8(3)
-	lfd 15, 23*8(3)
-	lfd 16, 24*8(3)
-	lfd 17, 25*8(3)
-	lfd 18, 26*8(3)
-	lfd 19, 27*8(3)
-	lfd 20, 28*8(3)
-	lfd 21, 29*8(3)
-	lfd 22, 30*8(3)
-	lfd 23, 31*8(3)
-	lfd 24, 32*8(3)
-	lfd 25, 33*8(3)
-	lfd 26, 34*8(3)
-	lfd 27, 35*8(3)
-	lfd 28, 36*8(3)
-	lfd 29, 37*8(3)
-	lfd 30, 38*8(3)
-	lfd 31, 39*8(3)
-
-	# 6) restore vector registers v20-v31
-	addi 3, 3, 40*8
-	lvx 20, 0, 3 ; addi 3, 3, 16
-	lvx 21, 0, 3 ; addi 3, 3, 16
-	lvx 22, 0, 3 ; addi 3, 3, 16
-	lvx 23, 0, 3 ; addi 3, 3, 16
-	lvx 24, 0, 3 ; addi 3, 3, 16
-	lvx 25, 0, 3 ; addi 3, 3, 16
-	lvx 26, 0, 3 ; addi 3, 3, 16
-	lvx 27, 0, 3 ; addi 3, 3, 16
-	lvx 28, 0, 3 ; addi 3, 3, 16
-	lvx 29, 0, 3 ; addi 3, 3, 16
-	lvx 30, 0, 3 ; addi 3, 3, 16
-	lvx 31, 0, 3
-
-	# 7) return r4 ? r4 : 1
-	mr    3,   4
-	cmpwi cr7, 4, 0
-	bne   cr7, 1f
-	li    3,   1
-1:
-	blr
-
diff --git a/src/setjmp/powerpc64/setjmp.s b/src/setjmp/powerpc64/setjmp.s
deleted file mode 100644
index 37683fdaf490..000000000000
--- a/src/setjmp/powerpc64/setjmp.s
+++ /dev/null
@@ -1,89 +0,0 @@
-	.global __setjmp
-	.global _setjmp
-	.global setjmp
-	.type   __setjmp,@function
-	.type   _setjmp,@function
-	.type   setjmp,@function
-__setjmp:
-_setjmp:
-setjmp:
-	ld 5, 24(1)   # load from the TOC slot in the caller's stack frame
-	b __setjmp_toc
-
-	.localentry __setjmp,.-__setjmp
-	.localentry _setjmp,.-_setjmp
-	.localentry setjmp,.-setjmp
-	mr 5, 2
-
-	.global __setjmp_toc
-	.hidden __setjmp_toc
-	# same as normal setjmp, except TOC pointer to save is provided in r5.
-	# r4 would normally be the 2nd parameter, but we're using r5 to simplify calling from sigsetjmp.
-	# solves the problem of knowing whether to save the TOC pointer from r2 or the caller's stack frame.
-__setjmp_toc:
-	# 0) store IP into 0, then into the jmpbuf pointed to by r3 (first arg)
-	mflr  0
-	std   0,  0*8(3)
-	# 1) store cr
-	mfcr  0
-	std   0,  1*8(3)
-	# 2) store SP and TOC
-	std   1,  2*8(3)
-	std   5,  3*8(3)
-	# 3) store r14-31
-	std  14,  4*8(3)
-	std  15,  5*8(3)
-	std  16,  6*8(3)
-	std  17,  7*8(3)
-	std  18,  8*8(3)
-	std  19,  9*8(3)
-	std  20, 10*8(3)
-	std  21, 11*8(3)
-	std  22, 12*8(3)
-	std  23, 13*8(3)
-	std  24, 14*8(3)
-	std  25, 15*8(3)
-	std  26, 16*8(3)
-	std  27, 17*8(3)
-	std  28, 18*8(3)
-	std  29, 19*8(3)
-	std  30, 20*8(3)
-	std  31, 21*8(3)
-	# 4) store floating point registers f14-f31
-	stfd 14, 22*8(3)
-	stfd 15, 23*8(3)
-	stfd 16, 24*8(3)
-	stfd 17, 25*8(3)
-	stfd 18, 26*8(3)
-	stfd 19, 27*8(3)
-	stfd 20, 28*8(3)
-	stfd 21, 29*8(3)
-	stfd 22, 30*8(3)
-	stfd 23, 31*8(3)
-	stfd 24, 32*8(3)
-	stfd 25, 33*8(3)
-	stfd 26, 34*8(3)
-	stfd 27, 35*8(3)
-	stfd 28, 36*8(3)
-	stfd 29, 37*8(3)
-	stfd 30, 38*8(3)
-	stfd 31, 39*8(3)
-
-	# 5) store vector registers v20-v31
-	addi  3, 3, 40*8
-	stvx 20, 0, 3 ; addi 3, 3, 16
-	stvx 21, 0, 3 ; addi 3, 3, 16
-	stvx 22, 0, 3 ; addi 3, 3, 16
-	stvx 23, 0, 3 ; addi 3, 3, 16
-	stvx 24, 0, 3 ; addi 3, 3, 16
-	stvx 25, 0, 3 ; addi 3, 3, 16
-	stvx 26, 0, 3 ; addi 3, 3, 16
-	stvx 27, 0, 3 ; addi 3, 3, 16
-	stvx 28, 0, 3 ; addi 3, 3, 16
-	stvx 29, 0, 3 ; addi 3, 3, 16
-	stvx 30, 0, 3 ; addi 3, 3, 16
-	stvx 31, 0, 3
-
-	# 6) return 0
-	li 3, 0
-	blr
diff --git a/src/setjmp/riscv64/longjmp.S b/src/setjmp/riscv64/longjmp.S
deleted file mode 100644
index 41e2d2102e73..000000000000
--- a/src/setjmp/riscv64/longjmp.S
+++ /dev/null
@@ -1,42 +0,0 @@
-.global __longjmp
-.global _longjmp
-.global longjmp
-.type __longjmp, %function
-.type _longjmp,  %function
-.type longjmp,   %function
-__longjmp:
-_longjmp:
-longjmp:
-	ld s0,    0(a0)
-	ld s1,    8(a0)
-	ld s2,    16(a0)
-	ld s3,    24(a0)
-	ld s4,    32(a0)
-	ld s5,    40(a0)
-	ld s6,    48(a0)
-	ld s7,    56(a0)
-	ld s8,    64(a0)
-	ld s9,    72(a0)
-	ld s10,   80(a0)
-	ld s11,   88(a0)
-	ld sp,    96(a0)
-	ld ra,    104(a0)
-
-#ifndef __riscv_float_abi_soft
-	fld fs0,  112(a0)
-	fld fs1,  120(a0)
-	fld fs2,  128(a0)
-	fld fs3,  136(a0)
-	fld fs4,  144(a0)
-	fld fs5,  152(a0)
-	fld fs6,  160(a0)
-	fld fs7,  168(a0)
-	fld fs8,  176(a0)
-	fld fs9,  184(a0)
-	fld fs10, 192(a0)
-	fld fs11, 200(a0)
-#endif
-
-	seqz a0, a1
-	add a0, a0, a1
-	ret
diff --git a/src/setjmp/riscv64/setjmp.S b/src/setjmp/riscv64/setjmp.S
deleted file mode 100644
index 51249672df22..000000000000
--- a/src/setjmp/riscv64/setjmp.S
+++ /dev/null
@@ -1,41 +0,0 @@
-.global __setjmp
-.global _setjmp
-.global setjmp
-.type __setjmp, %function
-.type _setjmp,  %function
-.type setjmp,   %function
-__setjmp:
-_setjmp:
-setjmp:
-	sd s0,    0(a0)
-	sd s1,    8(a0)
-	sd s2,    16(a0)
-	sd s3,    24(a0)
-	sd s4,    32(a0)
-	sd s5,    40(a0)
-	sd s6,    48(a0)
-	sd s7,    56(a0)
-	sd s8,    64(a0)
-	sd s9,    72(a0)
-	sd s10,   80(a0)
-	sd s11,   88(a0)
-	sd sp,    96(a0)
-	sd ra,    104(a0)
-
-#ifndef __riscv_float_abi_soft
-	fsd fs0,  112(a0)
-	fsd fs1,  120(a0)
-	fsd fs2,  128(a0)
-	fsd fs3,  136(a0)
-	fsd fs4,  144(a0)
-	fsd fs5,  152(a0)
-	fsd fs6,  160(a0)
-	fsd fs7,  168(a0)
-	fsd fs8,  176(a0)
-	fsd fs9,  184(a0)
-	fsd fs10, 192(a0)
-	fsd fs11, 200(a0)
-#endif
-
-	li a0, 0
-	ret
diff --git a/src/setjmp/s390x/longjmp.s b/src/setjmp/s390x/longjmp.s
deleted file mode 100644
index b2310f8ad137..000000000000
--- a/src/setjmp/s390x/longjmp.s
+++ /dev/null
@@ -1,23 +0,0 @@
-	.global _longjmp
-	.global longjmp
-	.type   _longjmp,@function
-	.type   longjmp,@function
-_longjmp:
-longjmp:
-
-1:
-	lmg %r6, %r15, 0(%r2)
-
-	ld  %f8, 10*8(%r2)
-	ld  %f9, 11*8(%r2)
-	ld %f10, 12*8(%r2)
-	ld %f11, 13*8(%r2)
-	ld %f12, 14*8(%r2)
-	ld %f13, 15*8(%r2)
-	ld %f14, 16*8(%r2)
-	ld %f15, 17*8(%r2)
-
-	ltgr %r2, %r3
-	bnzr %r14
-	lhi  %r2, 1
-	br   %r14
diff --git a/src/setjmp/s390x/setjmp.s b/src/setjmp/s390x/setjmp.s
deleted file mode 100644
index afae1b67556d..000000000000
--- a/src/setjmp/s390x/setjmp.s
+++ /dev/null
@@ -1,25 +0,0 @@
-	.global ___setjmp
-	.hidden ___setjmp
-	.global __setjmp
-	.global _setjmp
-	.global setjmp
-	.type   __setjmp,@function
-	.type   _setjmp,@function
-	.type   setjmp,@function
-___setjmp:
-__setjmp:
-_setjmp:
-setjmp:
-	stmg %r6, %r15, 0(%r2)
-
-	std  %f8,  10*8(%r2)
-	std  %f9,  11*8(%r2)
-	std  %f10, 12*8(%r2)
-	std  %f11, 13*8(%r2)
-	std  %f12, 14*8(%r2)
-	std  %f13, 15*8(%r2)
-	std  %f14, 16*8(%r2)
-	std  %f15, 17*8(%r2)
-
-	lghi %r2, 0
-	br   %r14
diff --git a/src/setjmp/setjmp.c b/src/setjmp/setjmp.c
deleted file mode 100644
index e69de29bb2d1..000000000000
diff --git a/src/setjmp/sh/longjmp.S b/src/setjmp/sh/longjmp.S
deleted file mode 100644
index 08f668b88035..000000000000
--- a/src/setjmp/sh/longjmp.S
+++ /dev/null
@@ -1,28 +0,0 @@
-.global _longjmp
-.global longjmp
-.type   _longjmp, @function
-.type   longjmp,  @function
-_longjmp:
-longjmp:
-	mov.l  @r4+, r8
-	mov.l  @r4+, r9
-	mov.l  @r4+, r10
-	mov.l  @r4+, r11
-	mov.l  @r4+, r12
-	mov.l  @r4+, r13
-	mov.l  @r4+, r14
-	mov.l  @r4+, r15
-	lds.l  @r4+, pr
-#if __SH_FPU_ANY__ || __SH4__
-	fmov.s @r4+, fr12
-	fmov.s @r4+, fr13
-	fmov.s @r4+, fr14
-	fmov.s @r4+, fr15
-#endif
-
-	tst  r5, r5
-	movt r0
-	add  r5, r0
-
-	rts
-	 nop
diff --git a/src/setjmp/sh/setjmp.S b/src/setjmp/sh/setjmp.S
deleted file mode 100644
index d476e6395f57..000000000000
--- a/src/setjmp/sh/setjmp.S
+++ /dev/null
@@ -1,32 +0,0 @@
-.global ___setjmp
-.hidden ___setjmp
-.global __setjmp
-.global _setjmp
-.global setjmp
-.type   __setjmp, @function
-.type   _setjmp,  @function
-.type   setjmp,   @function
-___setjmp:
-__setjmp:
-_setjmp:
-setjmp:
-#if __SH_FPU_ANY__ || __SH4__
-	add   #52, r4
-	fmov.s fr15, @-r4
-	fmov.s fr14, @-r4
-	fmov.s fr13, @-r4
-	fmov.s fr12, @-r4
-#else
-	add   #36, r4
-#endif
-	sts.l  pr,   @-r4
-	mov.l  r15,  @-r4
-	mov.l  r14,  @-r4
-	mov.l  r13,  @-r4
-	mov.l  r12,  @-r4
-	mov.l  r11,  @-r4
-	mov.l  r10,  @-r4
-	mov.l  r9,   @-r4
-	mov.l  r8,   @-r4
-	rts
-	 mov  #0, r0
diff --git a/src/setjmp/x32/longjmp.s b/src/setjmp/x32/longjmp.s
deleted file mode 100644
index 1b2661c3e5a9..000000000000
--- a/src/setjmp/x32/longjmp.s
+++ /dev/null
@@ -1,18 +0,0 @@
-/* Copyright 2011-2012 Nicholas J. Kain, licensed under standard MIT license */
-.global _longjmp
-.global longjmp
-.type _longjmp,@function
-.type longjmp,@function
-_longjmp:
-longjmp:
-	xor %eax,%eax
-	cmp $1,%esi             /* CF = val ? 0 : 1 */
-	adc %esi,%eax           /* eax = val + !val */
-	mov (%rdi),%rbx         /* rdi is the jmp_buf, restore regs from it */
-	mov 8(%rdi),%rbp
-	mov 16(%rdi),%r12
-	mov 24(%rdi),%r13
-	mov 32(%rdi),%r14
-	mov 40(%rdi),%r15
-	mov 48(%rdi),%rsp
-	jmp *56(%rdi)           /* goto saved address without altering rsp */
diff --git a/src/setjmp/x32/setjmp.s b/src/setjmp/x32/setjmp.s
deleted file mode 100644
index d95e4853558f..000000000000
--- a/src/setjmp/x32/setjmp.s
+++ /dev/null
@@ -1,22 +0,0 @@
-/* Copyright 2011-2012 Nicholas J. Kain, licensed under standard MIT license */
-.global __setjmp
-.global _setjmp
-.global setjmp
-.type __setjmp,@function
-.type _setjmp,@function
-.type setjmp,@function
-__setjmp:
-_setjmp:
-setjmp:
-	mov %rbx,(%rdi)         /* rdi is jmp_buf, move registers onto it */
-	mov %rbp,8(%rdi)
-	mov %r12,16(%rdi)
-	mov %r13,24(%rdi)
-	mov %r14,32(%rdi)
-	mov %r15,40(%rdi)
-	lea 8(%rsp),%rdx        /* this is our rsp WITHOUT current ret addr */
-	mov %rdx,48(%rdi)
-	mov (%rsp),%rdx         /* save return addr ptr for new rip */
-	mov %rdx,56(%rdi)
-	xor %eax,%eax           /* always return 0 */
-	ret
diff --git a/src/setjmp/x86_64/longjmp.s b/src/setjmp/x86_64/longjmp.s
deleted file mode 100644
index 1b2661c3e5a9..000000000000
--- a/src/setjmp/x86_64/longjmp.s
+++ /dev/null
@@ -1,18 +0,0 @@
-/* Copyright 2011-2012 Nicholas J. Kain, licensed under standard MIT license */
-.global _longjmp
-.global longjmp
-.type _longjmp,@function
-.type longjmp,@function
-_longjmp:
-longjmp:
-	xor %eax,%eax
-	cmp $1,%esi             /* CF = val ? 0 : 1 */
-	adc %esi,%eax           /* eax = val + !val */
-	mov (%rdi),%rbx         /* rdi is the jmp_buf, restore regs from it */
-	mov 8(%rdi),%rbp
-	mov 16(%rdi),%r12
-	mov 24(%rdi),%r13
-	mov 32(%rdi),%r14
-	mov 40(%rdi),%r15
-	mov 48(%rdi),%rsp
-	jmp *56(%rdi)           /* goto saved address without altering rsp */
diff --git a/src/setjmp/x86_64/setjmp.s b/src/setjmp/x86_64/setjmp.s
deleted file mode 100644
index d95e4853558f..000000000000
--- a/src/setjmp/x86_64/setjmp.s
+++ /dev/null
@@ -1,22 +0,0 @@
-/* Copyright 2011-2012 Nicholas J. Kain, licensed under standard MIT license */
-.global __setjmp
-.global _setjmp
-.global setjmp
-.type __setjmp,@function
-.type _setjmp,@function
-.type setjmp,@function
-__setjmp:
-_setjmp:
-setjmp:
-	mov %rbx,(%rdi)         /* rdi is jmp_buf, move registers onto it */
-	mov %rbp,8(%rdi)
-	mov %r12,16(%rdi)
-	mov %r13,24(%rdi)
-	mov %r14,32(%rdi)
-	mov %r15,40(%rdi)
-	lea 8(%rsp),%rdx        /* this is our rsp WITHOUT current ret addr */
-	mov %rdx,48(%rdi)
-	mov (%rsp),%rdx         /* save return addr ptr for new rip */
-	mov %rdx,56(%rdi)
-	xor %eax,%eax           /* always return 0 */
-	ret
diff --git a/src/signal/aarch64/restore.s b/src/signal/aarch64/restore.s
deleted file mode 100644
index d4e5fcf1a327..000000000000
--- a/src/signal/aarch64/restore.s
+++ /dev/null
@@ -1,10 +0,0 @@
-.global __restore
-.hidden __restore
-.type __restore,%function
-__restore:
-.global __restore_rt
-.hidden __restore_rt
-.type __restore_rt,%function
-__restore_rt:
-	mov x8,#139 // SYS_rt_sigreturn
-	svc 0
diff --git a/src/signal/aarch64/sigsetjmp.s b/src/signal/aarch64/sigsetjmp.s
deleted file mode 100644
index 75910c432185..000000000000
--- a/src/signal/aarch64/sigsetjmp.s
+++ /dev/null
@@ -1,21 +0,0 @@
-.global sigsetjmp
-.global __sigsetjmp
-.type sigsetjmp,%function
-.type __sigsetjmp,%function
-sigsetjmp:
-__sigsetjmp:
-	cbz x1,setjmp
-
-	str x30,[x0,#176]
-	str x19,[x0,#176+8+8]
-	mov x19,x0
-
-	bl setjmp
-
-	mov w1,w0
-	mov x0,x19
-	ldr x30,[x0,#176]
-	ldr x19,[x0,#176+8+8]
-
-.hidden __sigsetjmp_tail
-	b __sigsetjmp_tail
diff --git a/src/signal/arm/restore.s b/src/signal/arm/restore.s
deleted file mode 100644
index fb086d9ba7c5..000000000000
--- a/src/signal/arm/restore.s
+++ /dev/null
@@ -1,15 +0,0 @@
-.syntax unified
-
-.global __restore
-.hidden __restore
-.type __restore,%function
-__restore:
-	mov r7,#119
-	swi 0x0
-
-.global __restore_rt
-.hidden __restore_rt
-.type __restore_rt,%function
-__restore_rt:
-	mov r7,#173
-	swi 0x0
diff --git a/src/signal/arm/sigsetjmp.s b/src/signal/arm/sigsetjmp.s
deleted file mode 100644
index 69ebbf4993fd..000000000000
--- a/src/signal/arm/sigsetjmp.s
+++ /dev/null
@@ -1,24 +0,0 @@
-.syntax unified
-.global sigsetjmp
-.global __sigsetjmp
-.type sigsetjmp,%function
-.type __sigsetjmp,%function
-sigsetjmp:
-__sigsetjmp:
-	tst r1,r1
-	bne 1f
-	b setjmp
-
-1:	str lr,[r0,#256]
-	str r4,[r0,#260+8]
-	mov r4,r0
-
-	bl setjmp
-
-	mov r1,r0
-	mov r0,r4
-	ldr lr,[r0,#256]
-	ldr r4,[r0,#260+8]
-
-.hidden __sigsetjmp_tail
-	b __sigsetjmp_tail
diff --git a/src/signal/block.c b/src/signal/block.c
index cc8698f0bb7f..f1c7e12737a7 100644
--- a/src/signal/block.c
+++ b/src/signal/block.c
@@ -2,43 +2,22 @@
 #include "syscall.h"
 #include <signal.h>
 
-static const unsigned long all_mask[] = {
-#if ULONG_MAX == 0xffffffff && _NSIG > 65
-	-1UL, -1UL, -1UL, -1UL
-#elif ULONG_MAX == 0xffffffff || _NSIG > 65
-	-1UL, -1UL
-#else
-	-1UL
-#endif
-};
-
-static const unsigned long app_mask[] = {
-#if ULONG_MAX == 0xffffffff
-#if _NSIG == 65
-	0x7fffffff, 0xfffffffc
-#else
-	0x7fffffff, 0xfffffffc, -1UL, -1UL
-#endif
-#else
-#if _NSIG == 65
-	0xfffffffc7fffffff
-#else
-	0xfffffffc7fffffff, -1UL
-#endif
-#endif
-};
-
 void __block_all_sigs(void *set)
 {
-	__syscall(SYS_rt_sigprocmask, SIG_BLOCK, &all_mask, set, _NSIG/8);
+    sigset_t all_mask;
+    sigfillset(&all_mask);
+    zsys_sigprocmask(SIG_BLOCK, &all_mask, set);
 }
 
 void __block_app_sigs(void *set)
 {
-	__syscall(SYS_rt_sigprocmask, SIG_BLOCK, &app_mask, set, _NSIG/8);
+    sigset_t all_mask;
+    /* FIXME: Is this right? */
+    sigfillset(&all_mask);
+    zsys_sigprocmask(SIG_BLOCK, &all_mask, set);
 }
 
 void __restore_sigs(void *set)
 {
-	__syscall(SYS_rt_sigprocmask, SIG_SETMASK, set, 0, _NSIG/8);
+    zsys_sigprocmask(SIG_SETMASK, set, 0);
 }
diff --git a/src/signal/getitimer.c b/src/signal/getitimer.c
index 36d1eb9dc6e9..085ed1992632 100644
--- a/src/signal/getitimer.c
+++ b/src/signal/getitimer.c
@@ -1,18 +1,8 @@
 #include <sys/time.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int getitimer(int which, struct itimerval *old)
 {
-	if (sizeof(time_t) > sizeof(long)) {
-		long old32[4];
-		int r = __syscall(SYS_getitimer, which, old32);
-		if (!r) {
-			old->it_interval.tv_sec = old32[0];
-			old->it_interval.tv_usec = old32[1];
-			old->it_value.tv_sec = old32[2];
-			old->it_value.tv_usec = old32[3];
-		}
-		return __syscall_ret(r);
-	}
-	return syscall(SYS_getitimer, which, old);
+    return zsys_getitimer(which, old);
 }
diff --git a/src/signal/i386/restore.s b/src/signal/i386/restore.s
deleted file mode 100644
index ccc94307aea9..000000000000
--- a/src/signal/i386/restore.s
+++ /dev/null
@@ -1,14 +0,0 @@
-.global __restore
-.hidden __restore
-.type __restore,@function
-__restore:
-	popl %eax
-	movl $119, %eax
-	int $0x80
-
-.global __restore_rt
-.hidden __restore_rt
-.type __restore_rt,@function
-__restore_rt:
-	movl $173, %eax
-	int $0x80
diff --git a/src/signal/i386/sigsetjmp.s b/src/signal/i386/sigsetjmp.s
deleted file mode 100644
index 690b251c4c9e..000000000000
--- a/src/signal/i386/sigsetjmp.s
+++ /dev/null
@@ -1,26 +0,0 @@
-.global sigsetjmp
-.global __sigsetjmp
-.type sigsetjmp,@function
-.type __sigsetjmp,@function
-sigsetjmp:
-__sigsetjmp:
-	mov 8(%esp),%ecx
-	jecxz 1f
-
-	mov 4(%esp),%eax
-	popl 24(%eax)
-	mov %ebx,28+8(%eax)
-	mov %eax,%ebx
-
-.hidden ___setjmp
-	call ___setjmp
-
-	pushl 24(%ebx)
-	mov %ebx,4(%esp)
-	mov %eax,8(%esp)
-	mov 28+8(%ebx),%ebx
-
-.hidden __sigsetjmp_tail
-	jmp __sigsetjmp_tail
-
-1:	jmp ___setjmp
diff --git a/src/signal/kill.c b/src/signal/kill.c
index 058057330900..8e1d2f1de14a 100644
--- a/src/signal/kill.c
+++ b/src/signal/kill.c
@@ -1,7 +1,8 @@
 #include <signal.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int kill(pid_t pid, int sig)
 {
-	return syscall(SYS_kill, pid, sig);
+	return zsys_kill(pid, sig);
 }
diff --git a/src/signal/m68k/sigsetjmp.s b/src/signal/m68k/sigsetjmp.s
deleted file mode 100644
index 09bfa64680e1..000000000000
--- a/src/signal/m68k/sigsetjmp.s
+++ /dev/null
@@ -1,29 +0,0 @@
-.global sigsetjmp
-.global __sigsetjmp
-.type sigsetjmp,@function
-.type __sigsetjmp,@function
-sigsetjmp:
-__sigsetjmp:
-	move.l 8(%sp),%d0
-	beq 1f
-
-	movea.l 4(%sp),%a1
-	move.l (%sp)+,156(%a1)
-	move.l %a2,156+4+8(%a1)
-	movea.l %a1,%a2
-
-.hidden ___setjmp
-	lea ___setjmp-.-8,%a1
-	jsr (%pc,%a1)
-
-	move.l 156(%a2),-(%sp)
-	move.l %a2,4(%sp)
-	move.l %d0,8(%sp)
-	movea.l 156+4+8(%a2),%a2
-
-.hidden __sigsetjmp_tail
-	lea __sigsetjmp_tail-.-8,%a1
-	jmp (%pc,%a1)
-
-1:	lea ___setjmp-.-8,%a1
-	jmp (%pc,%a1)
diff --git a/src/signal/microblaze/restore.s b/src/signal/microblaze/restore.s
deleted file mode 100644
index b3c9f57b6536..000000000000
--- a/src/signal/microblaze/restore.s
+++ /dev/null
@@ -1,13 +0,0 @@
-.global __restore
-.hidden __restore
-.type __restore,@function
-__restore:
-	ori     r12, r0, 119
-	brki    r14, 0x8
-
-.global __restore_rt
-.hidden __restore_rt
-.type __restore_rt,@function
-__restore_rt:
-	ori     r12, r0, 173
-	brki    r14, 0x8
diff --git a/src/signal/microblaze/sigsetjmp.s b/src/signal/microblaze/sigsetjmp.s
deleted file mode 100644
index d1dd24c02962..000000000000
--- a/src/signal/microblaze/sigsetjmp.s
+++ /dev/null
@@ -1,22 +0,0 @@
-.global sigsetjmp
-.global __sigsetjmp
-.type sigsetjmp,@function
-.type __sigsetjmp,@function
-sigsetjmp:
-__sigsetjmp:
-.hidden ___setjmp
-	beqi r6, ___setjmp
-
-	swi r15,r5,72
-	swi r19,r5,72+4+8
-
-	brlid r15,___setjmp
-	 ori r19,r5,0
-
-	ori r6,r3,0
-	ori r5,r19,0
-	lwi r15,r5,72
-	lwi r19,r5,72+4+8
-
-.hidden __sigsetjmp_tail
-	bri __sigsetjmp_tail
diff --git a/src/signal/mips/sigsetjmp.s b/src/signal/mips/sigsetjmp.s
deleted file mode 100644
index 74b65ff68f25..000000000000
--- a/src/signal/mips/sigsetjmp.s
+++ /dev/null
@@ -1,33 +0,0 @@
-.set noreorder
-
-.global sigsetjmp
-.global __sigsetjmp
-.type sigsetjmp,@function
-.type __sigsetjmp,@function
-sigsetjmp:
-__sigsetjmp:
-	lui $gp, %hi(_gp_disp)
-	addiu $gp, %lo(_gp_disp)
-	beq $5, $0, 1f
-	 addu $gp, $gp, $25
-
-	sw $ra, 104($4)
-	sw $16, 104+4+16($4)
-
-	lw $25, %call16(setjmp)($gp)
-	jalr $25
-	 move $16, $4
-
-	move $5,$2
-	move $4,$16
-	lw $ra, 104($4)
-	lw $16, 104+4+16($4)
-
-.hidden __sigsetjmp_tail
-	lw $25, %call16(__sigsetjmp_tail)($gp)
-	jr $25
-	 nop
-
-1:	lw $25, %call16(setjmp)($gp)
-	jr $25
-	 nop
diff --git a/src/signal/mips64/sigsetjmp.s b/src/signal/mips64/sigsetjmp.s
deleted file mode 100644
index 156e70bd0f6a..000000000000
--- a/src/signal/mips64/sigsetjmp.s
+++ /dev/null
@@ -1,38 +0,0 @@
-.set	noreorder
-.global	sigsetjmp
-.global	__sigsetjmp
-.type	sigsetjmp,@function
-.type	__sigsetjmp,@function
-sigsetjmp:
-__sigsetjmp:
-	lui	$3, %hi(%neg(%gp_rel(sigsetjmp)))
-	daddiu	$3, $3, %lo(%neg(%gp_rel(sigsetjmp)))
-
-	# comparing save mask with 0, if equals to 0 then
-	# sigsetjmp is equal to setjmp.
-	beq	$5, $0, 1f
-	daddu	$3, $3, $25
-	sd	$ra, 160($4)
-	sd	$16, 168($4)
-
-	# save base of got so that we can use it later
-	# once we return from 'longjmp'
-	sd	$3, 176($4)
-	ld	$25, %got_disp(setjmp)($3)
-	jalr	$25
-	move	$16, $4
-
-	move	$5, $2		# Return from 'setjmp' or 'longjmp'
-	move	$4, $16		# Restore the pointer-to-sigjmp_buf
-	ld	$ra, 160($4)	# Restore ra of sigsetjmp
-	ld	$16, 168($4)	# Restore $16 of sigsetjmp
-	ld	$3, 176($4)	# Restore base of got
-
-.hidden	__sigsetjmp_tail
-	ld	$25, %got_disp(__sigsetjmp_tail)($3)
-	jr	$25
-	nop
-1:
-	ld	$25, %got_disp(setjmp)($3)
-	jr	$25
-	nop
diff --git a/src/signal/mipsn32/sigsetjmp.s b/src/signal/mipsn32/sigsetjmp.s
deleted file mode 100644
index c0c6961f8f2a..000000000000
--- a/src/signal/mipsn32/sigsetjmp.s
+++ /dev/null
@@ -1,38 +0,0 @@
-.set	noreorder
-.global	sigsetjmp
-.global	__sigsetjmp
-.type	sigsetjmp,@function
-.type	__sigsetjmp,@function
-sigsetjmp:
-__sigsetjmp:
-	lui	$3, %hi(%neg(%gp_rel(sigsetjmp)))
-	addiu	$3, $3, %lo(%neg(%gp_rel(sigsetjmp)))
-
-	# comparing save mask with 0, if equals to 0 then
-	# sigsetjmp is equal to setjmp.
-	beq	$5, $0, 1f
-	addu	$3, $3, $25
-	sd	$ra, 160($4)
-	sd	$16, 168($4)
-
-	# save base of got so that we can use it later
-	# once we return from 'longjmp'
-	sd	$3, 176($4)
-	lw	$25, %got_disp(setjmp)($3)
-	jalr	$25
-	move	$16, $4
-
-	move	$5, $2		# Return from 'setjmp' or 'longjmp'
-	move	$4, $16		# Restore the pointer-to-sigjmp_buf
-	ld	$ra, 160($4)	# Restore ra of sigsetjmp
-	ld	$16, 168($4)	# Restore $16 of sigsetjmp
-	ld	$3, 176($4)	# Restore base of got
-
-.hidden	__sigsetjmp_tail
-	lw	$25, %got_disp(__sigsetjmp_tail)($3)
-	jr	$25
-	nop
-1:
-	lw	$25, %got_disp(setjmp)($3)
-	jr	$25
-	nop
diff --git a/src/signal/or1k/sigsetjmp.s b/src/signal/or1k/sigsetjmp.s
deleted file mode 100644
index b9bcdae1db3b..000000000000
--- a/src/signal/or1k/sigsetjmp.s
+++ /dev/null
@@ -1,24 +0,0 @@
-.global sigsetjmp
-.global __sigsetjmp
-.type sigsetjmp,@function
-.type __sigsetjmp,@function
-sigsetjmp:
-__sigsetjmp:
-	l.sfeq	r4, r0
-.hidden ___setjmp
-	l.bf	___setjmp
-
-	l.sw    52(r3), r9
-	l.sw    52+4+8(r3), r20
-
-	l.jal	___setjmp
-	 l.ori   r20, r3, 0
-
-	l.ori r4, r11, 0
-	l.ori r3, r20, 0
-
-	l.lwz   r9, 52(r3)
-
-.hidden __sigsetjmp_tail
-	l.j	__sigsetjmp_tail
-	 l.lwz   r20, 52+4+8(r3)
diff --git a/src/signal/powerpc/restore.s b/src/signal/powerpc/restore.s
deleted file mode 100644
index 29c8afd03c6c..000000000000
--- a/src/signal/powerpc/restore.s
+++ /dev/null
@@ -1,13 +0,0 @@
-	.global __restore
-	.hidden __restore
-	.type __restore,%function
-__restore:
-	li      0, 119 #__NR_sigreturn
-	sc
-
-	.global __restore_rt
-	.hidden __restore_rt
-	.type __restore_rt,%function
-__restore_rt:
-	li      0, 172 # __NR_rt_sigreturn
-	sc
diff --git a/src/signal/powerpc/sigsetjmp.s b/src/signal/powerpc/sigsetjmp.s
deleted file mode 100644
index 152c3fedd7a8..000000000000
--- a/src/signal/powerpc/sigsetjmp.s
+++ /dev/null
@@ -1,27 +0,0 @@
-	.global sigsetjmp
-	.global __sigsetjmp
-	.type sigsetjmp,%function
-	.type __sigsetjmp,%function
-sigsetjmp:
-__sigsetjmp:
-	cmpwi cr7, 4, 0
-	beq- cr7, 1f
-
-	mflr 5
-	stw 5, 448(3)
-	stw 16, 448+4+8(3)
-	mr 16, 3
-
-.hidden ___setjmp
-	bl ___setjmp
-
-	mr 4, 3
-	mr 3, 16
-	lwz 5, 448(3)
-	mtlr 5
-	lwz 16, 448+4+8(3)
-
-.hidden __sigsetjmp_tail
-	b __sigsetjmp_tail
-
-1:	b ___setjmp
diff --git a/src/signal/powerpc64/restore.s b/src/signal/powerpc64/restore.s
deleted file mode 100644
index 29c8afd03c6c..000000000000
--- a/src/signal/powerpc64/restore.s
+++ /dev/null
@@ -1,13 +0,0 @@
-	.global __restore
-	.hidden __restore
-	.type __restore,%function
-__restore:
-	li      0, 119 #__NR_sigreturn
-	sc
-
-	.global __restore_rt
-	.hidden __restore_rt
-	.type __restore_rt,%function
-__restore_rt:
-	li      0, 172 # __NR_rt_sigreturn
-	sc
diff --git a/src/signal/powerpc64/sigsetjmp.s b/src/signal/powerpc64/sigsetjmp.s
deleted file mode 100644
index 410c2831918f..000000000000
--- a/src/signal/powerpc64/sigsetjmp.s
+++ /dev/null
@@ -1,37 +0,0 @@
-	.global sigsetjmp
-	.global __sigsetjmp
-	.type sigsetjmp,%function
-	.type __sigsetjmp,%function
-	.hidden __setjmp_toc
-sigsetjmp:
-__sigsetjmp:
-	addis 2, 12, .TOC.-__sigsetjmp@ha
-	addi  2,  2, .TOC.-__sigsetjmp@l
-	ld    5, 24(1)   # load from the TOC slot in the caller's stack frame
-	b     1f
-
-	.localentry sigsetjmp,.-sigsetjmp
-	.localentry __sigsetjmp,.-__sigsetjmp
-	mr    5,  2
-
-1:
-	cmpwi cr7, 4, 0
-	beq-  cr7, __setjmp_toc
-
-	mflr  6
-	std   6, 512(3)
-	std   2, 512+16(3)
-	std  16, 512+24(3)
-	mr   16, 3
-
-	bl __setjmp_toc
-
-	mr   4,  3
-	mr   3, 16
-	ld   5, 512(3)
-	mtlr 5
-	ld   2, 512+16(3)
-	ld  16, 512+24(3)
-
-.hidden __sigsetjmp_tail
-	b __sigsetjmp_tail
diff --git a/src/signal/raise.c b/src/signal/raise.c
index f0512019a192..765d26a12b4d 100644
--- a/src/signal/raise.c
+++ b/src/signal/raise.c
@@ -2,12 +2,9 @@
 #include <stdint.h>
 #include "syscall.h"
 #include "pthread_impl.h"
+#include <stdfil.h>
 
 int raise(int sig)
 {
-	sigset_t set;
-	__block_app_sigs(&set);
-	int ret = syscall(SYS_tkill, __pthread_self()->tid, sig);
-	__restore_sigs(&set);
-	return ret;
+    return zsys_raise(sig);
 }
diff --git a/src/signal/riscv64/restore.s b/src/signal/riscv64/restore.s
deleted file mode 100644
index 40012c757a4f..000000000000
--- a/src/signal/riscv64/restore.s
+++ /dev/null
@@ -1,8 +0,0 @@
-.global __restore
-.type __restore, %function
-__restore:
-.global __restore_rt
-.type __restore_rt, %function
-__restore_rt:
-	li a7, 139 # SYS_rt_sigreturn
-	ecall
diff --git a/src/signal/riscv64/sigsetjmp.s b/src/signal/riscv64/sigsetjmp.s
deleted file mode 100644
index f9bc162a0aa6..000000000000
--- a/src/signal/riscv64/sigsetjmp.s
+++ /dev/null
@@ -1,23 +0,0 @@
-.global sigsetjmp
-.global __sigsetjmp
-.type sigsetjmp, %function
-.type __sigsetjmp, %function
-sigsetjmp:
-__sigsetjmp:
-	bnez a1, 1f
-	tail setjmp
-1:
-
-	sd ra, 208(a0)
-	sd s0, 224(a0)
-	mv s0, a0
-
-	call setjmp
-
-	mv a1, a0
-	mv a0, s0
-	ld s0, 224(a0)
-	ld ra, 208(a0)
-
-.hidden __sigsetjmp_tail
-	tail __sigsetjmp_tail
diff --git a/src/signal/s390x/restore.s b/src/signal/s390x/restore.s
deleted file mode 100644
index 88e33dbc2223..000000000000
--- a/src/signal/s390x/restore.s
+++ /dev/null
@@ -1,11 +0,0 @@
-	.global __restore
-	.hidden __restore
-	.type __restore,%function
-__restore:
-	svc 119 #__NR_sigreturn
-
-	.global __restore_rt
-	.hidden __restore_rt
-	.type __restore_rt,%function
-__restore_rt:
-	svc 173 # __NR_rt_sigreturn
diff --git a/src/signal/s390x/sigsetjmp.s b/src/signal/s390x/sigsetjmp.s
deleted file mode 100644
index 41b1bd9a1683..000000000000
--- a/src/signal/s390x/sigsetjmp.s
+++ /dev/null
@@ -1,23 +0,0 @@
-	.global sigsetjmp
-	.global __sigsetjmp
-	.type sigsetjmp,%function
-	.type __sigsetjmp,%function
-	.hidden ___setjmp
-sigsetjmp:
-__sigsetjmp:
-	ltgr  %r3, %r3
-	jz    ___setjmp
-
-	stg   %r14, 18*8(%r2)
-	stg   %r6,  20*8(%r2)
-	lgr   %r6,  %r2
-
-	brasl %r14, ___setjmp
-
-	lgr   %r3,  %r2
-	lgr   %r2,  %r6
-	lg    %r14, 18*8(%r2)
-	lg    %r6,  20*8(%r2)
-
-.hidden __sigsetjmp_tail
-	jg __sigsetjmp_tail
diff --git a/src/signal/setitimer.c b/src/signal/setitimer.c
index 0dfbeb4db5a7..79768efdda5e 100644
--- a/src/signal/setitimer.c
+++ b/src/signal/setitimer.c
@@ -1,26 +1,9 @@
 #include <sys/time.h>
 #include <errno.h>
 #include "syscall.h"
-
-#define IS32BIT(x) !((x)+0x80000000ULL>>32)
+#include <stdfil.h>
 
 int setitimer(int which, const struct itimerval *restrict new, struct itimerval *restrict old)
 {
-	if (sizeof(time_t) > sizeof(long)) {
-		time_t is = new->it_interval.tv_sec, vs = new->it_value.tv_sec;
-		long ius = new->it_interval.tv_usec, vus = new->it_value.tv_usec;
-		if (!IS32BIT(is) || !IS32BIT(vs))
-			return __syscall_ret(-ENOTSUP);
-		long old32[4];
-		int r = __syscall(SYS_setitimer, which,
-			((long[]){is, ius, vs, vus}), old32);
-		if (!r && old) {
-			old->it_interval.tv_sec = old32[0];
-			old->it_interval.tv_usec = old32[1];
-			old->it_value.tv_sec = old32[2];
-			old->it_value.tv_usec = old32[3];
-		}
-		return __syscall_ret(r);
-	}
-	return syscall(SYS_setitimer, which, new, old);
+    return zsys_setitimer(which, new, old);
 }
diff --git a/src/signal/sh/restore.s b/src/signal/sh/restore.s
deleted file mode 100644
index 3a92199db632..000000000000
--- a/src/signal/sh/restore.s
+++ /dev/null
@@ -1,24 +0,0 @@
-.global __restore
-.hidden __restore
-__restore:
-	mov   #119, r3  !__NR_sigreturn
-	trapa #31
-
-	or    r0, r0
-	or    r0, r0
-	or    r0, r0
-	or    r0, r0
-	or    r0, r0
-
-.global __restore_rt
-.hidden __restore_rt
-__restore_rt:
-	mov   #100, r3  !__NR_rt_sigreturn
-	add   #73, r3
-	trapa #31
-
-	or    r0, r0
-	or    r0, r0
-	or    r0, r0
-	or    r0, r0
-	or    r0, r0
diff --git a/src/signal/sh/sigsetjmp.s b/src/signal/sh/sigsetjmp.s
deleted file mode 100644
index 1e2270beeccb..000000000000
--- a/src/signal/sh/sigsetjmp.s
+++ /dev/null
@@ -1,41 +0,0 @@
-.global sigsetjmp
-.global __sigsetjmp
-.type sigsetjmp,@function
-.type __sigsetjmp,@function
-sigsetjmp:
-__sigsetjmp:
-	tst r5, r5
-	bt 9f
-
-	mov r4, r6
-	add #60, r6
-	sts pr, r0
-	mov.l r0, @r6
-	mov.l r8, @(4+8,r6)
-
-	mov.l 1f, r0
-2:	bsrf r0
-	 mov r4, r8
-
-	mov r0, r5
-	mov r8, r4
-	mov r4, r6
-	add #60, r6
-
-	mov.l @r6, r0
-	lds r0, pr
-
-	mov.l 3f, r0
-4:	braf r0
-	 mov.l @(4+8,r4), r8
-
-9:	mov.l 5f, r0
-6:	braf r0
-	 nop
-
-.align 2
-.hidden ___setjmp
-1:	.long ___setjmp@PLT-(2b+4-.)
-.hidden __sigsetjmp_tail
-3:	.long __sigsetjmp_tail@PLT-(4b+4-.)
-5:	.long ___setjmp@PLT-(6b+4-.)
diff --git a/src/signal/sigaction.c b/src/signal/sigaction.c
index e45308fae5fb..f2665ec24382 100644
--- a/src/signal/sigaction.c
+++ b/src/signal/sigaction.c
@@ -19,50 +19,22 @@ volatile int __eintr_valid_flag;
 
 int __libc_sigaction(int sig, const struct sigaction *restrict sa, struct sigaction *restrict old)
 {
-	struct k_sigaction ksa, ksa_old;
 	if (sa) {
 		if ((uintptr_t)sa->sa_handler > 1UL) {
 			a_or_l(handler_set+(sig-1)/(8*sizeof(long)),
 				1UL<<(sig-1)%(8*sizeof(long)));
 
-			/* If pthread_create has not yet been called,
-			 * implementation-internal signals might not
-			 * yet have been unblocked. They must be
-			 * unblocked before any signal handler is
-			 * installed, so that an application cannot
-			 * receive an illegal sigset_t (with them
-			 * blocked) as part of the ucontext_t passed
-			 * to the signal handler. */
-			if (!libc.threaded && !unmask_done) {
-				__syscall(SYS_rt_sigprocmask, SIG_UNBLOCK,
-					SIGPT_SET, 0, _NSIG/8);
-				unmask_done = 1;
-			}
-
 			if (!(sa->sa_flags & SA_RESTART)) {
 				a_store(&__eintr_valid_flag, 1);
 			}
 		}
-		ksa.handler = sa->sa_handler;
-		ksa.flags = sa->sa_flags;
-#ifdef SA_RESTORER
-		ksa.flags |= SA_RESTORER;
-		ksa.restorer = (sa->sa_flags & SA_SIGINFO) ? __restore_rt : __restore;
-#endif
-		memcpy(&ksa.mask, &sa->sa_mask, _NSIG/8);
-	}
-	int r = __syscall(SYS_rt_sigaction, sig, sa?&ksa:0, old?&ksa_old:0, _NSIG/8);
-	if (old && !r) {
-		old->sa_handler = ksa_old.handler;
-		old->sa_flags = ksa_old.flags;
-		memcpy(&old->sa_mask, &ksa_old.mask, _NSIG/8);
 	}
-	return __syscall_ret(r);
+	return zsys_sigaction(sig, sa, old);
 }
 
 int __sigaction(int sig, const struct sigaction *restrict sa, struct sigaction *restrict old)
 {
-	unsigned long set[_NSIG/(8*sizeof(long))];
+	sigset_t set;
 
 	if (sig-32U < 3 || sig-1U >= _NSIG-1) {
 		errno = EINVAL;
diff --git a/src/signal/sigdelset.c b/src/signal/sigdelset.c
index ce69280e0cbf..c96dc052222e 100644
--- a/src/signal/sigdelset.c
+++ b/src/signal/sigdelset.c
@@ -1,13 +1,23 @@
 #include <signal.h>
 #include <errno.h>
 
-int sigdelset(sigset_t *set, int sig)
+int __sigdelsetyolo(sigset_t *set, int sig)
 {
 	unsigned s = sig-1;
-	if (s >= _NSIG-1 || sig-32U < 3) {
+	if (s >= _NSIG-1) {
 		errno = EINVAL;
 		return -1;
 	}
 	set->__bits[s/8/sizeof *set->__bits] &=~(1UL<<(s&8*sizeof *set->__bits-1));
 	return 0;
 }
+
+int sigdelset(sigset_t *set, int sig)
+{
+	unsigned s = sig-1;
+	if (sig-32U < 3) {
+		errno = EINVAL;
+		return -1;
+	}
+	return __sigdelsetyolo(set, sig);
+}
diff --git a/src/signal/siglongjmp.c b/src/signal/siglongjmp.c
deleted file mode 100644
index bc317acce931..000000000000
--- a/src/signal/siglongjmp.c
+++ /dev/null
@@ -1,9 +0,0 @@
-#include <setjmp.h>
-#include <signal.h>
-#include "syscall.h"
-#include "pthread_impl.h"
-
-_Noreturn void siglongjmp(sigjmp_buf buf, int ret)
-{
-	longjmp(buf, ret);
-}
diff --git a/src/signal/sigpending.c b/src/signal/sigpending.c
index 3d193df83c68..7e2d6e851ae0 100644
--- a/src/signal/sigpending.c
+++ b/src/signal/sigpending.c
@@ -3,5 +3,5 @@
 
 int sigpending(sigset_t *set)
 {
-	return syscall(SYS_rt_sigpending, set, _NSIG/8);
+	return zsys_sigpending(set);
 }
diff --git a/src/signal/sigqueue.c b/src/signal/sigqueue.c
index b75f0c5cea42..9c75e22b8465 100644
--- a/src/signal/sigqueue.c
+++ b/src/signal/sigqueue.c
@@ -6,17 +6,5 @@
 
 int sigqueue(pid_t pid, int sig, const union sigval value)
 {
-	siginfo_t si;
-	sigset_t set;
-	int r;
-	memset(&si, 0, sizeof si);
-	si.si_signo = sig;
-	si.si_code = SI_QUEUE;
-	si.si_value = value;
-	si.si_uid = getuid();
-	__block_app_sigs(&set);
-	si.si_pid = getpid();
-	r = syscall(SYS_rt_sigqueueinfo, pid, sig, &si);
-	__restore_sigs(&set);
-	return r;
+	return zsys_sigqueue(pid, sig, value.sival_ptr);
 }
diff --git a/src/signal/sigrtmin.c b/src/signal/sigrtmin.c
index c5a1fd92dae7..04e3094a4392 100644
--- a/src/signal/sigrtmin.c
+++ b/src/signal/sigrtmin.c
@@ -2,5 +2,5 @@
 
 int __libc_current_sigrtmin()
 {
-	return 35;
+	return 36;
 }
diff --git a/src/signal/sigsetjmp.c b/src/signal/sigsetjmp.c
deleted file mode 100644
index e69de29bb2d1..000000000000
diff --git a/src/signal/sigsetjmp_tail.c b/src/signal/sigsetjmp_tail.c
deleted file mode 100644
index f2aa28878e47..000000000000
--- a/src/signal/sigsetjmp_tail.c
+++ /dev/null
@@ -1,10 +0,0 @@
-#include <setjmp.h>
-#include <signal.h>
-#include "syscall.h"
-
-hidden int __sigsetjmp_tail(sigjmp_buf jb, int ret)
-{
-	void *p = jb->__ss;
-	__syscall(SYS_rt_sigprocmask, SIG_SETMASK, ret?p:0, ret?0:p, _NSIG/8);
-	return ret;
-}
diff --git a/src/signal/sigsuspend.c b/src/signal/sigsuspend.c
index 36e0602c60bf..709d9fb3b1f7 100644
--- a/src/signal/sigsuspend.c
+++ b/src/signal/sigsuspend.c
@@ -3,5 +3,5 @@
 
 int sigsuspend(const sigset_t *mask)
 {
-	return syscall_cp(SYS_rt_sigsuspend, mask, _NSIG/8);
+	return zsys_sigsuspend(mask);
 }
diff --git a/src/signal/sigtimedwait.c b/src/signal/sigtimedwait.c
index 1287174ebafd..19f08b990553 100644
--- a/src/signal/sigtimedwait.c
+++ b/src/signal/sigtimedwait.c
@@ -2,31 +2,7 @@
 #include <errno.h>
 #include "syscall.h"
 
-#define IS32BIT(x) !((x)+0x80000000ULL>>32)
-#define CLAMP(x) (int)(IS32BIT(x) ? (x) : 0x7fffffffU+((0ULL+(x))>>63))
-
-static int do_sigtimedwait(const sigset_t *restrict mask, siginfo_t *restrict si, const struct timespec *restrict ts)
-{
-#ifdef SYS_rt_sigtimedwait_time64
-	time_t s = ts ? ts->tv_sec : 0;
-	long ns = ts ? ts->tv_nsec : 0;
-	int r = -ENOSYS;
-	if (SYS_rt_sigtimedwait == SYS_rt_sigtimedwait_time64 || !IS32BIT(s))
-		r = __syscall_cp(SYS_rt_sigtimedwait_time64, mask, si,
-			ts ? ((long long[]){s, ns}) : 0, _NSIG/8);
-	if (SYS_rt_sigtimedwait == SYS_rt_sigtimedwait_time64 || r!=-ENOSYS)
-		return r;
-	return __syscall_cp(SYS_rt_sigtimedwait, mask, si,
-		ts ? ((long[]){CLAMP(s), ns}) : 0, _NSIG/8);;
-#else
-	return __syscall_cp(SYS_rt_sigtimedwait, mask, si, ts, _NSIG/8);
-#endif
-}
-
 int sigtimedwait(const sigset_t *restrict mask, siginfo_t *restrict si, const struct timespec *restrict timeout)
 {
-	int ret;
-	do ret = do_sigtimedwait(mask, si, timeout);
-	while (ret==-EINTR);
-	return __syscall_ret(ret);
+        return zsys_sigtimedwait(mask, si, timeout);
 }
diff --git a/src/signal/sigwait.c b/src/signal/sigwait.c
index c8822eea4983..18b5dfe8cab7 100644
--- a/src/signal/sigwait.c
+++ b/src/signal/sigwait.c
@@ -1,10 +1,7 @@
 #include <signal.h>
+#include <pizlonated_syscalls.h>
 
 int sigwait(const sigset_t *restrict mask, int *restrict sig)
 {
-	siginfo_t si;
-	if (sigtimedwait(mask, &si, 0) < 0)
-		return -1;
-	*sig = si.si_signo;
-	return 0;
+	return zsys_sigwait(mask, sig);
 }
diff --git a/src/signal/x32/restore.s b/src/signal/x32/restore.s
deleted file mode 100644
index 1117446a6cb3..000000000000
--- a/src/signal/x32/restore.s
+++ /dev/null
@@ -1,8 +0,0 @@
-	nop
-.global __restore_rt
-.hidden __restore_rt
-.type __restore_rt,@function
-__restore_rt:
-	mov $0x40000201, %rax /* SYS_rt_sigreturn */
-	syscall
-.size __restore_rt,.-__restore_rt
diff --git a/src/signal/x32/sigsetjmp.s b/src/signal/x32/sigsetjmp.s
deleted file mode 100644
index 1f02b0e50282..000000000000
--- a/src/signal/x32/sigsetjmp.s
+++ /dev/null
@@ -1,25 +0,0 @@
-.global sigsetjmp
-.global __sigsetjmp
-.type sigsetjmp,@function
-.type __sigsetjmp,@function
-sigsetjmp:
-__sigsetjmp:
-	test %esi,%esi
-	jz 1f
-
-	popq 64(%rdi)
-	mov %rbx,72+8(%rdi)
-	mov %rdi,%rbx
-
-	call setjmp@PLT
-
-	pushq 64(%rbx)
-	movl $0, 4(%rsp)
-	mov %rbx,%rdi
-	mov %eax,%esi
-	mov 72+8(%rbx),%rbx
-
-.hidden __sigsetjmp_tail
-	jmp __sigsetjmp_tail
-
-1:	jmp setjmp@PLT
diff --git a/src/signal/x86_64/restore.s b/src/signal/x86_64/restore.s
deleted file mode 100644
index 27d6cf310337..000000000000
--- a/src/signal/x86_64/restore.s
+++ /dev/null
@@ -1,8 +0,0 @@
-	nop
-.global __restore_rt
-.hidden __restore_rt
-.type __restore_rt,@function
-__restore_rt:
-	mov $15, %rax
-	syscall
-.size __restore_rt,.-__restore_rt
diff --git a/src/signal/x86_64/sigsetjmp.s b/src/signal/x86_64/sigsetjmp.s
deleted file mode 100644
index 9a7695f96dc9..000000000000
--- a/src/signal/x86_64/sigsetjmp.s
+++ /dev/null
@@ -1,24 +0,0 @@
-.global sigsetjmp
-.global __sigsetjmp
-.type sigsetjmp,@function
-.type __sigsetjmp,@function
-sigsetjmp:
-__sigsetjmp:
-	test %esi,%esi
-	jz 1f
-
-	popq 64(%rdi)
-	mov %rbx,72+8(%rdi)
-	mov %rdi,%rbx
-
-	call setjmp@PLT
-
-	pushq 64(%rbx)
-	mov %rbx,%rdi
-	mov %eax,%esi
-	mov 72+8(%rbx),%rbx
-
-.hidden __sigsetjmp_tail
-	jmp __sigsetjmp_tail
-
-1:	jmp setjmp@PLT
diff --git a/src/stat/chmod.c b/src/stat/chmod.c
index d4f53c564e14..f3af92738f3d 100644
--- a/src/stat/chmod.c
+++ b/src/stat/chmod.c
@@ -4,9 +4,5 @@
 
 int chmod(const char *path, mode_t mode)
 {
-#ifdef SYS_chmod
-	return syscall(SYS_chmod, path, mode);
-#else
-	return syscall(SYS_fchmodat, AT_FDCWD, path, mode);
-#endif
+    return zsys_chmod(path, mode);
 }
diff --git a/src/stat/fchmod.c b/src/stat/fchmod.c
index 7a503eefc46e..3d7ba4a9fcda 100644
--- a/src/stat/fchmod.c
+++ b/src/stat/fchmod.c
@@ -5,15 +5,5 @@
 
 int fchmod(int fd, mode_t mode)
 {
-	int ret = __syscall(SYS_fchmod, fd, mode);
-	if (ret != -EBADF || __syscall(SYS_fcntl, fd, F_GETFD) < 0)
-		return __syscall_ret(ret);
-
-	char buf[15+3*sizeof(int)];
-	__procfdname(buf, fd);
-#ifdef SYS_chmod
-	return syscall(SYS_chmod, buf, mode);
-#else
-	return syscall(SYS_fchmodat, AT_FDCWD, buf, mode);
-#endif
+    return zsys_fchmod(fd, mode);
 }
diff --git a/src/stat/fchmodat.c b/src/stat/fchmodat.c
index bc581050eeb7..5323186c934c 100644
--- a/src/stat/fchmodat.c
+++ b/src/stat/fchmodat.c
@@ -5,33 +5,5 @@
 
 int fchmodat(int fd, const char *path, mode_t mode, int flag)
 {
-	if (!flag) return syscall(SYS_fchmodat, fd, path, mode, flag);
-
-	if (flag != AT_SYMLINK_NOFOLLOW)
-		return __syscall_ret(-EINVAL);
-
-	struct stat st;
-	int ret, fd2;
-	char proc[15+3*sizeof(int)];
-
-	if (fstatat(fd, path, &st, flag))
-		return -1;
-	if (S_ISLNK(st.st_mode))
-		return __syscall_ret(-EOPNOTSUPP);
-
-	if ((fd2 = __syscall(SYS_openat, fd, path, O_RDONLY|O_PATH|O_NOFOLLOW|O_NOCTTY|O_CLOEXEC)) < 0) {
-		if (fd2 == -ELOOP)
-			return __syscall_ret(-EOPNOTSUPP);
-		return __syscall_ret(fd2);
-	}
-
-	__procfdname(proc, fd2);
-	ret = stat(proc, &st);
-	if (!ret) {
-		if (S_ISLNK(st.st_mode)) ret = __syscall_ret(-EOPNOTSUPP);
-		else ret = syscall(SYS_fchmodat, AT_FDCWD, proc, mode);
-	}
-
-	__syscall(SYS_close, fd2);
-	return ret;
+	return zsys_fchmodat(fd, path, mode, flag);
 }
diff --git a/src/stat/fstat.c b/src/stat/fstat.c
index fd28b8ac405a..859769de1873 100644
--- a/src/stat/fstat.c
+++ b/src/stat/fstat.c
@@ -3,11 +3,11 @@
 #include <errno.h>
 #include <fcntl.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int __fstat(int fd, struct stat *st)
 {
-	if (fd<0) return __syscall_ret(-EBADF);
-	return __fstatat(fd, "", st, AT_EMPTY_PATH);
+    return zsys_fstat(fd, st);
 }
 
 weak_alias(__fstat, fstat);
diff --git a/src/stat/fstatat.c b/src/stat/fstatat.c
index 9eed063b26bc..6daa79ca3960 100644
--- a/src/stat/fstatat.c
+++ b/src/stat/fstatat.c
@@ -6,6 +6,7 @@
 #include <stdint.h>
 #include <sys/sysmacros.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 struct statx {
 	uint32_t stx_mask;
@@ -138,17 +139,7 @@ static int fstatat_kstat(int fd, const char *restrict path, struct stat *restric
 
 int __fstatat(int fd, const char *restrict path, struct stat *restrict st, int flag)
 {
-	int ret;
-#ifdef SYS_fstatat
-	if (sizeof((struct kstat){0}.st_atime_sec) < sizeof(time_t)) {
-		ret = fstatat_statx(fd, path, st, flag);
-		if (ret!=-ENOSYS) return __syscall_ret(ret);
-	}
-	ret = fstatat_kstat(fd, path, st, flag);
-#else
-	ret = fstatat_statx(fd, path, st, flag);
-#endif
-	return __syscall_ret(ret);
+    return zsys_fstatat(fd, path, st, flag);
 }
 
 weak_alias(__fstatat, fstatat);
diff --git a/src/stat/futimens.c b/src/stat/futimens.c
index 360225b86c42..b2730e83d63f 100644
--- a/src/stat/futimens.c
+++ b/src/stat/futimens.c
@@ -1,6 +1,7 @@
 #include <sys/stat.h>
+#include <pizlonated_syscalls.h>
 
 int futimens(int fd, const struct timespec times[2])
 {
-	return utimensat(fd, 0, times, 0);
+    return zsys_futimens(fd, times);
 }
diff --git a/src/stat/mkdir.c b/src/stat/mkdir.c
index 32625b7de327..197ce0fcb583 100644
--- a/src/stat/mkdir.c
+++ b/src/stat/mkdir.c
@@ -1,12 +1,9 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int mkdir(const char *path, mode_t mode)
 {
-#ifdef SYS_mkdir
-	return syscall(SYS_mkdir, path, mode);
-#else
-	return syscall(SYS_mkdirat, AT_FDCWD, path, mode);
-#endif
+    return zsys_mkdirat(AT_FDCWD, path, mode);
 }
diff --git a/src/stat/mkdirat.c b/src/stat/mkdirat.c
index b8bc2527d757..0e9ac8a84bfd 100644
--- a/src/stat/mkdirat.c
+++ b/src/stat/mkdirat.c
@@ -3,5 +3,5 @@
 
 int mkdirat(int fd, const char *path, mode_t mode)
 {
-	return syscall(SYS_mkdirat, fd, path, mode);
+	return zsys_mkdirat(fd, path, mode);
 }
diff --git a/src/stat/mkfifo.c b/src/stat/mkfifo.c
index 60efcf73f221..abb368680c44 100644
--- a/src/stat/mkfifo.c
+++ b/src/stat/mkfifo.c
@@ -1,6 +1,7 @@
 #include <sys/stat.h>
+#include <pizlonated_syscalls.h>
 
 int mkfifo(const char *path, mode_t mode)
 {
-	return mknod(path, mode | S_IFIFO, 0);
+	return zsys_mkfifo(path, mode);
 }
diff --git a/src/stat/mknod.c b/src/stat/mknod.c
index beebd84e0899..b69c6ea31b84 100644
--- a/src/stat/mknod.c
+++ b/src/stat/mknod.c
@@ -4,9 +4,5 @@
 
 int mknod(const char *path, mode_t mode, dev_t dev)
 {
-#ifdef SYS_mknod
-	return syscall(SYS_mknod, path, mode, dev);
-#else
-	return syscall(SYS_mknodat, AT_FDCWD, path, mode, dev);
-#endif
+	return zsys_mknod(path, mode, dev);
 }
diff --git a/src/stat/mknodat.c b/src/stat/mknodat.c
index 7c97c91aaa58..f9fe6070fbd5 100644
--- a/src/stat/mknodat.c
+++ b/src/stat/mknodat.c
@@ -3,5 +3,5 @@
 
 int mknodat(int fd, const char *path, mode_t mode, dev_t dev)
 {
-	return syscall(SYS_mknodat, fd, path, mode, dev);
+	return zsys_mknodat(fd, path, mode, dev);
 }
diff --git a/src/stat/statvfs.c b/src/stat/statvfs.c
index bc12da8bf1ed..0e0860b8bf34 100644
--- a/src/stat/statvfs.c
+++ b/src/stat/statvfs.c
@@ -4,56 +4,23 @@
 
 static int __statfs(const char *path, struct statfs *buf)
 {
-	*buf = (struct statfs){0};
-#ifdef SYS_statfs64
-	return syscall(SYS_statfs64, path, sizeof *buf, buf);
-#else
-	return syscall(SYS_statfs, path, buf);
-#endif
+	return zsys_statfs(path, buf);
 }
 
 static int __fstatfs(int fd, struct statfs *buf)
 {
-	*buf = (struct statfs){0};
-#ifdef SYS_fstatfs64
-	return syscall(SYS_fstatfs64, fd, sizeof *buf, buf);
-#else
-	return syscall(SYS_fstatfs, fd, buf);
-#endif
+	return zsys_fstatfs(fd, buf);
 }
 
 weak_alias(__statfs, statfs);
 weak_alias(__fstatfs, fstatfs);
 
-static void fixup(struct statvfs *out, const struct statfs *in)
-{
-	*out = (struct statvfs){0};
-	out->f_bsize = in->f_bsize;
-	out->f_frsize = in->f_frsize ? in->f_frsize : in->f_bsize;
-	out->f_blocks = in->f_blocks;
-	out->f_bfree = in->f_bfree;
-	out->f_bavail = in->f_bavail;
-	out->f_files = in->f_files;
-	out->f_ffree = in->f_ffree;
-	out->f_favail = in->f_ffree;
-	out->f_fsid = in->f_fsid.__val[0];
-	out->f_flag = in->f_flags;
-	out->f_namemax = in->f_namelen;
-	out->f_type = in->f_type;
-}
-
 int statvfs(const char *restrict path, struct statvfs *restrict buf)
 {
-	struct statfs kbuf;
-	if (__statfs(path, &kbuf)<0) return -1;
-	fixup(buf, &kbuf);
-	return 0;
+	return zsys_statvfs(path, buf);
 }
 
 int fstatvfs(int fd, struct statvfs *buf)
 {
-	struct statfs kbuf;
-	if (__fstatfs(fd, &kbuf)<0) return -1;
-	fixup(buf, &kbuf);
-	return 0;
+	return zsys_fstatvfs(fd, buf);
 }
diff --git a/src/stat/umask.c b/src/stat/umask.c
index 5ee913e2d088..c0e83fa1b0d1 100644
--- a/src/stat/umask.c
+++ b/src/stat/umask.c
@@ -1,7 +1,8 @@
 #include <sys/stat.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 mode_t umask(mode_t mode)
 {
-	return syscall(SYS_umask, mode);
+	return zsys_umask(mode);
 }
diff --git a/src/stat/utimensat.c b/src/stat/utimensat.c
index 730723a9ea70..332406632994 100644
--- a/src/stat/utimensat.c
+++ b/src/stat/utimensat.c
@@ -4,57 +4,7 @@
 #include <errno.h>
 #include "syscall.h"
 
-#define IS32BIT(x) !((x)+0x80000000ULL>>32)
-#define NS_SPECIAL(ns) ((ns)==UTIME_NOW || (ns)==UTIME_OMIT)
-
 int utimensat(int fd, const char *path, const struct timespec times[2], int flags)
 {
-	int r;
-	if (times && times[0].tv_nsec==UTIME_NOW && times[1].tv_nsec==UTIME_NOW)
-		times = 0;
-#ifdef SYS_utimensat_time64
-	r = -ENOSYS;
-	time_t s0=0, s1=0;
-	long ns0=0, ns1=0;
-	if (times) {
-		ns0 = times[0].tv_nsec;
-		ns1 = times[1].tv_nsec;
-		if (!NS_SPECIAL(ns0)) s0 = times[0].tv_sec;
-		if (!NS_SPECIAL(ns1)) s1 = times[1].tv_sec;
-	}
-	if (SYS_utimensat == SYS_utimensat_time64 || !IS32BIT(s0) || !IS32BIT(s1))
-		r = __syscall(SYS_utimensat_time64, fd, path, times ?
-			((long long[]){s0, ns0, s1, ns1}) : 0, flags);
-	if (SYS_utimensat == SYS_utimensat_time64 || r!=-ENOSYS)
-		return __syscall_ret(r);
-	if (!IS32BIT(s0) || !IS32BIT(s1))
-		return __syscall_ret(-ENOTSUP);
-	r = __syscall(SYS_utimensat, fd, path,
-		times ? ((long[]){s0, ns0, s1, ns1}) : 0, flags);
-#else
-	r = __syscall(SYS_utimensat, fd, path, times, flags);
-#endif
-
-#ifdef SYS_futimesat
-	if (r != -ENOSYS || flags) return __syscall_ret(r);
-	long *tv=0, tmp[4];
-	if (times) {
-		int i;
-		tv = tmp;
-		for (i=0; i<2; i++) {
-			if (times[i].tv_nsec >= 1000000000ULL) {
-				if (NS_SPECIAL(times[i].tv_nsec))
-					return __syscall_ret(-ENOSYS);
-				return __syscall_ret(-EINVAL);
-			}
-			tmp[2*i+0] = times[i].tv_sec;
-			tmp[2*i+1] = times[i].tv_nsec / 1000;
-		}
-	}
-
-	r = __syscall(SYS_futimesat, fd, path, tv);
-	if (r != -ENOSYS || fd != AT_FDCWD) return __syscall_ret(r);
-	r = __syscall(SYS_utimes, path, tv);
-#endif
-	return __syscall_ret(r);
+	return zsys_utimensat(fd, path, times, flags);
 }
diff --git a/src/stdio/__fdopen.c b/src/stdio/__fdopen.c
index 116e78e56d2a..ba2bdfd1c92d 100644
--- a/src/stdio/__fdopen.c
+++ b/src/stdio/__fdopen.c
@@ -5,6 +5,7 @@
 #include <errno.h>
 #include <string.h>
 #include "libc.h"
+#include <stdfil.h>
 
 FILE *__fdopen(int fd, const char *mode)
 {
@@ -27,13 +28,13 @@ FILE *__fdopen(int fd, const char *mode)
 	if (!strchr(mode, '+')) f->flags = (*mode == 'r') ? F_NOWR : F_NORD;
 
 	/* Apply close-on-exec flag */
-	if (strchr(mode, 'e')) __syscall(SYS_fcntl, fd, F_SETFD, FD_CLOEXEC);
+	if (strchr(mode, 'e')) zsys_fcntl(fd, F_SETFD, FD_CLOEXEC);
 
 	/* Set append mode on fd if opened for append */
 	if (*mode == 'a') {
-		int flags = __syscall(SYS_fcntl, fd, F_GETFL);
+		int flags = zsys_fcntl(fd, F_GETFL);
 		if (!(flags & O_APPEND))
-			__syscall(SYS_fcntl, fd, F_SETFL, flags | O_APPEND);
+			zsys_fcntl(fd, F_SETFL, flags | O_APPEND);
 		f->flags |= F_APP;
 	}
 
@@ -43,8 +44,10 @@ FILE *__fdopen(int fd, const char *mode)
 
 	/* Activate line buffered mode for terminals */
 	f->lbf = EOF;
-	if (!(f->flags & F_NOWR) && !__syscall(SYS_ioctl, fd, TIOCGWINSZ, &wsz))
+        int saved_errno = errno;
+	if (!(f->flags & F_NOWR) && !zsys_ioctl(fd, TIOCGWINSZ, &wsz))
 		f->lbf = '\n';
+        errno = saved_errno;
 
 	/* Initialize op ptrs. No problem if some are unneeded. */
 	f->read = __stdio_read;
diff --git a/src/stdio/__fopen_rb_ca.c b/src/stdio/__fopen_rb_ca.c
index 183a5d553895..00ed650775b1 100644
--- a/src/stdio/__fopen_rb_ca.c
+++ b/src/stdio/__fopen_rb_ca.c
@@ -1,14 +1,15 @@
 #include "stdio_impl.h"
 #include <fcntl.h>
 #include <string.h>
+#include <stdfil.h>
 
 FILE *__fopen_rb_ca(const char *filename, FILE *f, unsigned char *buf, size_t len)
 {
 	memset(f, 0, sizeof *f);
 
-	f->fd = sys_open(filename, O_RDONLY|O_CLOEXEC);
+	f->fd = zsys_open(filename, O_RDONLY|O_CLOEXEC);
 	if (f->fd < 0) return 0;
-	__syscall(SYS_fcntl, f->fd, F_SETFD, FD_CLOEXEC);
+	zsys_fcntl(f->fd, F_SETFD, FD_CLOEXEC);
 
 	f->flags = F_NOWR | F_PERM;
 	f->buf = buf + UNGET;
diff --git a/src/stdio/__lockfile.c b/src/stdio/__lockfile.c
index 0f60a1499094..1d2dcfbf132a 100644
--- a/src/stdio/__lockfile.c
+++ b/src/stdio/__lockfile.c
@@ -1,5 +1,6 @@
 #include "stdio_impl.h"
 #include "pthread_impl.h"
+#include <stdfil.h>
 
 int __lockfile(FILE *f)
 {
diff --git a/src/stdio/__stdio_close.c b/src/stdio/__stdio_close.c
index 302913285187..48055828a231 100644
--- a/src/stdio/__stdio_close.c
+++ b/src/stdio/__stdio_close.c
@@ -1,5 +1,6 @@
 #include "stdio_impl.h"
 #include "aio_impl.h"
+#include <stdfil.h>
 
 static int dummy(int fd)
 {
@@ -10,5 +11,5 @@ weak_alias(dummy, __aio_close);
 
 int __stdio_close(FILE *f)
 {
-	return syscall(SYS_close, __aio_close(f->fd));
+	return zsys_close(__aio_close(f->fd));
 }
diff --git a/src/stdio/__stdio_read.c b/src/stdio/__stdio_read.c
index ea675da34abb..856dc64c4f5e 100644
--- a/src/stdio/__stdio_read.c
+++ b/src/stdio/__stdio_read.c
@@ -1,5 +1,6 @@
 #include "stdio_impl.h"
 #include <sys/uio.h>
+#include <stdfil.h>
 
 size_t __stdio_read(FILE *f, unsigned char *buf, size_t len)
 {
@@ -9,8 +10,8 @@ size_t __stdio_read(FILE *f, unsigned char *buf, size_t len)
 	};
 	ssize_t cnt;
 
-	cnt = iov[0].iov_len ? syscall(SYS_readv, f->fd, iov, 2)
-		: syscall(SYS_read, f->fd, iov[1].iov_base, iov[1].iov_len);
+	cnt = iov[0].iov_len ? zsys_readv(f->fd, iov, 2)
+            : zsys_read(f->fd, iov[1].iov_base, iov[1].iov_len);
 	if (cnt <= 0) {
 		f->flags |= cnt ? F_ERR : F_EOF;
 		return 0;
diff --git a/src/stdio/__stdio_write.c b/src/stdio/__stdio_write.c
index d2d89475b0f9..ae28da0c2939 100644
--- a/src/stdio/__stdio_write.c
+++ b/src/stdio/__stdio_write.c
@@ -1,5 +1,6 @@
 #include "stdio_impl.h"
 #include <sys/uio.h>
+#include <stdfil.h>
 
 size_t __stdio_write(FILE *f, const unsigned char *buf, size_t len)
 {
@@ -12,7 +13,7 @@ size_t __stdio_write(FILE *f, const unsigned char *buf, size_t len)
 	int iovcnt = 2;
 	ssize_t cnt;
 	for (;;) {
-		cnt = syscall(SYS_writev, f->fd, iov, iovcnt);
+		cnt = zsys_writev(f->fd, iov, iovcnt);
 		if (cnt == rem) {
 			f->wend = f->buf + f->buf_size;
 			f->wpos = f->wbase = f->buf;
diff --git a/src/stdio/__stdout_write.c b/src/stdio/__stdout_write.c
index dd1ec60ff703..13904b338f83 100644
--- a/src/stdio/__stdout_write.c
+++ b/src/stdio/__stdout_write.c
@@ -1,11 +1,12 @@
 #include "stdio_impl.h"
 #include <sys/ioctl.h>
+#include <stdfil.h>
 
 size_t __stdout_write(FILE *f, const unsigned char *buf, size_t len)
 {
 	struct winsize wsz;
 	f->write = __stdio_write;
-	if (!(f->flags & F_SVB) && __syscall(SYS_ioctl, f->fd, TIOCGWINSZ, &wsz))
+	if (!(f->flags & F_SVB) && zsys_ioctl(f->fd, TIOCGWINSZ, &wsz))
 		f->lbf = -1;
 	return __stdio_write(f, buf, len);
 }
diff --git a/src/stdio/fopen.c b/src/stdio/fopen.c
index 80bc341e669b..305bd674aa59 100644
--- a/src/stdio/fopen.c
+++ b/src/stdio/fopen.c
@@ -2,6 +2,7 @@
 #include <fcntl.h>
 #include <string.h>
 #include <errno.h>
+#include <pizlonated_syscalls.h>
 
 FILE *fopen(const char *restrict filename, const char *restrict mode)
 {
@@ -18,14 +19,14 @@ FILE *fopen(const char *restrict filename, const char *restrict mode)
 	/* Compute the flags to pass to open() */
 	flags = __fmodeflags(mode);
 
-	fd = sys_open(filename, flags, 0666);
+	fd = zsys_open(filename, flags, 0666);
 	if (fd < 0) return 0;
 	if (flags & O_CLOEXEC)
-		__syscall(SYS_fcntl, fd, F_SETFD, FD_CLOEXEC);
+		zsys_fcntl(fd, F_SETFD, FD_CLOEXEC);
 
 	f = __fdopen(fd, mode);
 	if (f) return f;
 
-	__syscall(SYS_close, fd);
+	zsys_close(fd);
 	return 0;
 }
diff --git a/src/stdio/fread.c b/src/stdio/fread.c
index a2116da61370..17362bc9bb77 100644
--- a/src/stdio/fread.c
+++ b/src/stdio/fread.c
@@ -1,5 +1,6 @@
 #include "stdio_impl.h"
 #include <string.h>
+#include <stdfil.h>
 
 #define MIN(a,b) ((a)<(b) ? (a) : (b))
 
@@ -36,3 +37,4 @@ size_t fread(void *restrict destv, size_t size, size_t nmemb, FILE *restrict f)
 }
 
 weak_alias(fread, fread_unlocked);
+
diff --git a/src/stdio/fwrite.c b/src/stdio/fwrite.c
index 7a567b2c55a9..8ef9f46fb2f7 100644
--- a/src/stdio/fwrite.c
+++ b/src/stdio/fwrite.c
@@ -36,3 +36,4 @@ size_t fwrite(const void *restrict src, size_t size, size_t nmemb, FILE *restric
 }
 
 weak_alias(fwrite, fwrite_unlocked);
+
diff --git a/src/stdio/pclose.c b/src/stdio/pclose.c
index 080a426245b6..9ca5d7601dcb 100644
--- a/src/stdio/pclose.c
+++ b/src/stdio/pclose.c
@@ -7,7 +7,13 @@ int pclose(FILE *f)
 	int status, r;
 	pid_t pid = f->pipe_pid;
 	fclose(f);
-	while ((r=__syscall(SYS_wait4, pid, &status, 0, 0)) == -EINTR);
-	if (r<0) return __syscall_ret(r);
+    for (;;) {
+        r = zsys_waitpid(pid, &status, 0);
+        ZASSERT(r == pid || r == -1);
+        if (r == pid)
+            break;
+        if (errno != EINTR)
+            return -1;
+    }
 	return status;
 }
diff --git a/src/stdio/popen.c b/src/stdio/popen.c
index 3ec833941c82..a2377c5d1179 100644
--- a/src/stdio/popen.c
+++ b/src/stdio/popen.c
@@ -27,8 +27,8 @@ FILE *popen(const char *cmd, const char *mode)
 	if (pipe2(p, O_CLOEXEC)) return NULL;
 	f = fdopen(p[op], mode);
 	if (!f) {
-		__syscall(SYS_close, p[0]);
-		__syscall(SYS_close, p[1]);
+		zsys_close(p[0]);
+		zsys_close(p[1]);
 		return NULL;
 	}
 
@@ -44,7 +44,7 @@ FILE *popen(const char *cmd, const char *mode)
 				f->pipe_pid = pid;
 				if (!strchr(mode, 'e'))
 					fcntl(p[op], F_SETFD, 0);
-				__syscall(SYS_close, p[1-op]);
+				zsys_close(p[1-op]);
 				__ofl_unlock();
 				return f;
 			}
@@ -54,7 +54,7 @@ fail:
 		posix_spawn_file_actions_destroy(&fa);
 	}
 	fclose(f);
-	__syscall(SYS_close, p[1-op]);
+	zsys_close(p[1-op]);
 
 	errno = e;
 	return 0;
diff --git a/src/stdio/remove.c b/src/stdio/remove.c
index 942e301a4c03..f3677dba65c0 100644
--- a/src/stdio/remove.c
+++ b/src/stdio/remove.c
@@ -5,15 +5,7 @@
 
 int remove(const char *path)
 {
-#ifdef SYS_unlink
-	int r = __syscall(SYS_unlink, path);
-#else
-	int r = __syscall(SYS_unlinkat, AT_FDCWD, path, 0);
-#endif
-#ifdef SYS_rmdir
-	if (r==-EISDIR) r = __syscall(SYS_rmdir, path);
-#else
-	if (r==-EISDIR) r = __syscall(SYS_unlinkat, AT_FDCWD, path, AT_REMOVEDIR);
-#endif
-	return __syscall_ret(r);
+	int r = zsys_unlink(path);
+	if (r < 0 && errno == EISDIR) r = zsys_rmdir(path);
+	return r;
 }
diff --git a/src/stdio/rename.c b/src/stdio/rename.c
index f540adb6cd9c..330786d6c039 100644
--- a/src/stdio/rename.c
+++ b/src/stdio/rename.c
@@ -4,11 +4,5 @@
 
 int rename(const char *old, const char *new)
 {
-#if defined(SYS_rename)
-	return syscall(SYS_rename, old, new);
-#elif defined(SYS_renameat)
-	return syscall(SYS_renameat, AT_FDCWD, old, AT_FDCWD, new);
-#else
-	return syscall(SYS_renameat2, AT_FDCWD, old, AT_FDCWD, new, 0);
-#endif
+    return zsys_rename(old, new);
 }
diff --git a/src/stdio/tmpfile.c b/src/stdio/tmpfile.c
index 2fa8803fc231..201de10c898c 100644
--- a/src/stdio/tmpfile.c
+++ b/src/stdio/tmpfile.c
@@ -13,15 +13,11 @@ FILE *tmpfile(void)
 	int try;
 	for (try=0; try<MAXTRIES; try++) {
 		__randname(s+13);
-		fd = sys_open(s, O_RDWR|O_CREAT|O_EXCL, 0600);
+		fd = zsys_open(s, O_RDWR|O_CREAT|O_EXCL, 0600);
 		if (fd >= 0) {
-#ifdef SYS_unlink
-			__syscall(SYS_unlink, s);
-#else
-			__syscall(SYS_unlinkat, AT_FDCWD, s, 0);
-#endif
+			zsys_unlink(s);
 			f = __fdopen(fd, "w+");
-			if (!f) __syscall(SYS_close, fd);
+			if (!f) zsys_close(fd);
 			return f;
 		}
 	}
diff --git a/src/stdlib/qsort.c b/src/stdlib/qsort.c
index 314ddc29da1d..8813095565ce 100644
--- a/src/stdlib/qsort.c
+++ b/src/stdlib/qsort.c
@@ -28,6 +28,7 @@
 #include <stdint.h>
 #include <stdlib.h>
 #include <string.h>
+#include <stdfil.h>
 
 #include "atomic.h"
 #define ntz(x) a_ctz_l((x))
@@ -42,9 +43,8 @@ static inline int pntz(size_t p[2]) {
 	return 0;
 }
 
-static void cycle(size_t width, unsigned char* ar[], int n)
+static void cycle(size_t width, unsigned char* ar[], int n, void* tmp)
 {
-	unsigned char tmp[256];
 	size_t l;
 	int i;
 
@@ -53,14 +53,10 @@ static void cycle(size_t width, unsigned char* ar[], int n)
 	}
 
 	ar[n] = tmp;
-	while(width) {
-		l = sizeof(tmp) < width ? sizeof(tmp) : width;
-		memcpy(ar[n], ar[0], l);
-		for(i = 0; i < n; i++) {
-			memcpy(ar[i], ar[i + 1], l);
-			ar[i] += l;
-		}
-		width -= l;
+	memcpy(ar[n], ar[0], width);
+	for(i = 0; i < n; i++) {
+		memcpy(ar[i], ar[i + 1], width);
+		ar[i] += width;
 	}
 }
 
@@ -89,7 +85,7 @@ static inline void shr(size_t p[2], int n)
 	p[1] >>= n;
 }
 
-static void sift(unsigned char *head, size_t width, cmpfun cmp, void *arg, int pshift, size_t lp[])
+static void sift(unsigned char *head, size_t width, cmpfun cmp, void *arg, int pshift, size_t lp[], void* tmp)
 {
 	unsigned char *rt, *lf;
 	unsigned char *ar[14 * sizeof(size_t) + 1];
@@ -113,10 +109,10 @@ static void sift(unsigned char *head, size_t width, cmpfun cmp, void *arg, int p
 			pshift -= 2;
 		}
 	}
-	cycle(width, ar, i);
+	cycle(width, ar, i, tmp);
 }
 
-static void trinkle(unsigned char *head, size_t width, cmpfun cmp, void *arg, size_t pp[2], int pshift, int trusty, size_t lp[])
+static void trinkle(unsigned char *head, size_t width, cmpfun cmp, void *arg, size_t pp[2], int pshift, int trusty, size_t lp[], void* tmp)
 {
 	unsigned char *stepson,
 	              *rt, *lf;
@@ -150,8 +146,8 @@ static void trinkle(unsigned char *head, size_t width, cmpfun cmp, void *arg, si
 		trusty = 0;
 	}
 	if(!trusty) {
-		cycle(width, ar, i);
-		sift(head, width, cmp, arg, pshift, lp);
+                cycle(width, ar, i, tmp);
+		sift(head, width, cmp, arg, pshift, lp, tmp);
 	}
 }
 
@@ -163,9 +159,12 @@ void __qsort_r(void *base, size_t nel, size_t width, cmpfun cmp, void *arg)
 	size_t p[2] = {1, 0};
 	int pshift = 1;
 	int trail;
+        void* tmp;
 
 	if (!size) return;
 
+        tmp = zgc_alloc(width);
+
 	head = base;
 	high = head + size - width;
 
@@ -174,14 +173,14 @@ void __qsort_r(void *base, size_t nel, size_t width, cmpfun cmp, void *arg)
 
 	while(head < high) {
 		if((p[0] & 3) == 3) {
-			sift(head, width, cmp, arg, pshift, lp);
+			sift(head, width, cmp, arg, pshift, lp, tmp);
 			shr(p, 2);
 			pshift += 2;
 		} else {
 			if(lp[pshift - 1] >= high - head) {
-				trinkle(head, width, cmp, arg, p, pshift, 0, lp);
+                                trinkle(head, width, cmp, arg, p, pshift, 0, lp, tmp);
 			} else {
-				sift(head, width, cmp, arg, pshift, lp);
+				sift(head, width, cmp, arg, pshift, lp, tmp);
 			}
 
 			if(pshift == 1) {
@@ -197,7 +196,7 @@ void __qsort_r(void *base, size_t nel, size_t width, cmpfun cmp, void *arg)
 		head += width;
 	}
 
-	trinkle(head, width, cmp, arg, p, pshift, 0, lp);
+	trinkle(head, width, cmp, arg, p, pshift, 0, lp, tmp);
 
 	while(pshift != 1 || p[0] != 1 || p[1] != 0) {
 		if(pshift <= 1) {
@@ -209,10 +208,10 @@ void __qsort_r(void *base, size_t nel, size_t width, cmpfun cmp, void *arg)
 			pshift -= 2;
 			p[0] ^= 7;
 			shr(p, 1);
-			trinkle(head - lp[pshift] - width, width, cmp, arg, p, pshift + 1, 1, lp);
+			trinkle(head - lp[pshift] - width, width, cmp, arg, p, pshift + 1, 1, lp, tmp);
 			shl(p, 1);
 			p[0] |= 1;
-			trinkle(head - width, width, cmp, arg, p, pshift, 1, lp);
+			trinkle(head - width, width, cmp, arg, p, pshift, 1, lp, tmp);
 		}
 		head -= width;
 	}
diff --git a/src/string/aarch64/memcpy.S b/src/string/aarch64/memcpy.S
deleted file mode 100644
index 48bb8a8d3bd3..000000000000
--- a/src/string/aarch64/memcpy.S
+++ /dev/null
@@ -1,186 +0,0 @@
-/*
- * memcpy - copy memory area
- *
- * Copyright (c) 2012-2020, Arm Limited.
- * SPDX-License-Identifier: MIT
- */
-
-/* Assumptions:
- *
- * ARMv8-a, AArch64, unaligned accesses.
- *
- */
-
-#define dstin   x0
-#define src     x1
-#define count   x2
-#define dst     x3
-#define srcend  x4
-#define dstend  x5
-#define A_l     x6
-#define A_lw    w6
-#define A_h     x7
-#define B_l     x8
-#define B_lw    w8
-#define B_h     x9
-#define C_l     x10
-#define C_lw    w10
-#define C_h     x11
-#define D_l     x12
-#define D_h     x13
-#define E_l     x14
-#define E_h     x15
-#define F_l     x16
-#define F_h     x17
-#define G_l     count
-#define G_h     dst
-#define H_l     src
-#define H_h     srcend
-#define tmp1    x14
-
-/* This implementation of memcpy uses unaligned accesses and branchless
-   sequences to keep the code small, simple and improve performance.
-
-   Copies are split into 3 main cases: small copies of up to 32 bytes, medium
-   copies of up to 128 bytes, and large copies.  The overhead of the overlap
-   check is negligible since it is only required for large copies.
-
-   Large copies use a software pipelined loop processing 64 bytes per iteration.
-   The destination pointer is 16-byte aligned to minimize unaligned accesses.
-   The loop tail is handled by always copying 64 bytes from the end.
-*/
-
-.global memcpy
-.type memcpy,%function
-memcpy:
-	add     srcend, src, count
-	add     dstend, dstin, count
-	cmp     count, 128
-	b.hi    .Lcopy_long
-	cmp     count, 32
-	b.hi    .Lcopy32_128
-
-	/* Small copies: 0..32 bytes.  */
-	cmp     count, 16
-	b.lo    .Lcopy16
-	ldp     A_l, A_h, [src]
-	ldp     D_l, D_h, [srcend, -16]
-	stp     A_l, A_h, [dstin]
-	stp     D_l, D_h, [dstend, -16]
-	ret
-
-	/* Copy 8-15 bytes.  */
-.Lcopy16:
-	tbz     count, 3, .Lcopy8
-	ldr     A_l, [src]
-	ldr     A_h, [srcend, -8]
-	str     A_l, [dstin]
-	str     A_h, [dstend, -8]
-	ret
-
-	.p2align 3
-	/* Copy 4-7 bytes.  */
-.Lcopy8:
-	tbz     count, 2, .Lcopy4
-	ldr     A_lw, [src]
-	ldr     B_lw, [srcend, -4]
-	str     A_lw, [dstin]
-	str     B_lw, [dstend, -4]
-	ret
-
-	/* Copy 0..3 bytes using a branchless sequence.  */
-.Lcopy4:
-	cbz     count, .Lcopy0
-	lsr     tmp1, count, 1
-	ldrb    A_lw, [src]
-	ldrb    C_lw, [srcend, -1]
-	ldrb    B_lw, [src, tmp1]
-	strb    A_lw, [dstin]
-	strb    B_lw, [dstin, tmp1]
-	strb    C_lw, [dstend, -1]
-.Lcopy0:
-	ret
-
-	.p2align 4
-	/* Medium copies: 33..128 bytes.  */
-.Lcopy32_128:
-	ldp     A_l, A_h, [src]
-	ldp     B_l, B_h, [src, 16]
-	ldp     C_l, C_h, [srcend, -32]
-	ldp     D_l, D_h, [srcend, -16]
-	cmp     count, 64
-	b.hi    .Lcopy128
-	stp     A_l, A_h, [dstin]
-	stp     B_l, B_h, [dstin, 16]
-	stp     C_l, C_h, [dstend, -32]
-	stp     D_l, D_h, [dstend, -16]
-	ret
-
-	.p2align 4
-	/* Copy 65..128 bytes.  */
-.Lcopy128:
-	ldp     E_l, E_h, [src, 32]
-	ldp     F_l, F_h, [src, 48]
-	cmp     count, 96
-	b.ls    .Lcopy96
-	ldp     G_l, G_h, [srcend, -64]
-	ldp     H_l, H_h, [srcend, -48]
-	stp     G_l, G_h, [dstend, -64]
-	stp     H_l, H_h, [dstend, -48]
-.Lcopy96:
-	stp     A_l, A_h, [dstin]
-	stp     B_l, B_h, [dstin, 16]
-	stp     E_l, E_h, [dstin, 32]
-	stp     F_l, F_h, [dstin, 48]
-	stp     C_l, C_h, [dstend, -32]
-	stp     D_l, D_h, [dstend, -16]
-	ret
-
-	.p2align 4
-	/* Copy more than 128 bytes.  */
-.Lcopy_long:
-
-	/* Copy 16 bytes and then align dst to 16-byte alignment.  */
-
-	ldp     D_l, D_h, [src]
-	and     tmp1, dstin, 15
-	bic     dst, dstin, 15
-	sub     src, src, tmp1
-	add     count, count, tmp1      /* Count is now 16 too large.  */
-	ldp     A_l, A_h, [src, 16]
-	stp     D_l, D_h, [dstin]
-	ldp     B_l, B_h, [src, 32]
-	ldp     C_l, C_h, [src, 48]
-	ldp     D_l, D_h, [src, 64]!
-	subs    count, count, 128 + 16  /* Test and readjust count.  */
-	b.ls    .Lcopy64_from_end
-
-.Lloop64:
-	stp     A_l, A_h, [dst, 16]
-	ldp     A_l, A_h, [src, 16]
-	stp     B_l, B_h, [dst, 32]
-	ldp     B_l, B_h, [src, 32]
-	stp     C_l, C_h, [dst, 48]
-	ldp     C_l, C_h, [src, 48]
-	stp     D_l, D_h, [dst, 64]!
-	ldp     D_l, D_h, [src, 64]!
-	subs    count, count, 64
-	b.hi    .Lloop64
-
-	/* Write the last iteration and copy 64 bytes from the end.  */
-.Lcopy64_from_end:
-	ldp     E_l, E_h, [srcend, -64]
-	stp     A_l, A_h, [dst, 16]
-	ldp     A_l, A_h, [srcend, -48]
-	stp     B_l, B_h, [dst, 32]
-	ldp     B_l, B_h, [srcend, -32]
-	stp     C_l, C_h, [dst, 48]
-	ldp     C_l, C_h, [srcend, -16]
-	stp     D_l, D_h, [dst, 64]
-	stp     E_l, E_h, [dstend, -64]
-	stp     A_l, A_h, [dstend, -48]
-	stp     B_l, B_h, [dstend, -32]
-	stp     C_l, C_h, [dstend, -16]
-	ret
-
-.size memcpy,.-memcpy
diff --git a/src/string/aarch64/memset.S b/src/string/aarch64/memset.S
deleted file mode 100644
index f0d29b7fa39b..000000000000
--- a/src/string/aarch64/memset.S
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * memset - fill memory with a constant byte
- *
- * Copyright (c) 2012-2020, Arm Limited.
- * SPDX-License-Identifier: MIT
- */
-
-/* Assumptions:
- *
- * ARMv8-a, AArch64, Advanced SIMD, unaligned accesses.
- *
- */
-
-#define dstin   x0
-#define val     x1
-#define valw    w1
-#define count   x2
-#define dst     x3
-#define dstend  x4
-#define zva_val x5
-
-.global memset
-.type memset,%function
-memset:
-
-	dup     v0.16B, valw
-	add     dstend, dstin, count
-
-	cmp     count, 96
-	b.hi    .Lset_long
-	cmp     count, 16
-	b.hs    .Lset_medium
-	mov     val, v0.D[0]
-
-	/* Set 0..15 bytes.  */
-	tbz     count, 3, 1f
-	str     val, [dstin]
-	str     val, [dstend, -8]
-	ret
-	nop
-1:      tbz     count, 2, 2f
-	str     valw, [dstin]
-	str     valw, [dstend, -4]
-	ret
-2:      cbz     count, 3f
-	strb    valw, [dstin]
-	tbz     count, 1, 3f
-	strh    valw, [dstend, -2]
-3:      ret
-
-	/* Set 17..96 bytes.  */
-.Lset_medium:
-	str     q0, [dstin]
-	tbnz    count, 6, .Lset96
-	str     q0, [dstend, -16]
-	tbz     count, 5, 1f
-	str     q0, [dstin, 16]
-	str     q0, [dstend, -32]
-1:      ret
-
-	.p2align 4
-	/* Set 64..96 bytes.  Write 64 bytes from the start and
-	   32 bytes from the end.  */
-.Lset96:
-	str     q0, [dstin, 16]
-	stp     q0, q0, [dstin, 32]
-	stp     q0, q0, [dstend, -32]
-	ret
-
-	.p2align 4
-.Lset_long:
-	and     valw, valw, 255
-	bic     dst, dstin, 15
-	str     q0, [dstin]
-	cmp     count, 160
-	ccmp    valw, 0, 0, hs
-	b.ne    .Lno_zva
-
-#ifndef SKIP_ZVA_CHECK
-	mrs     zva_val, dczid_el0
-	and     zva_val, zva_val, 31
-	cmp     zva_val, 4              /* ZVA size is 64 bytes.  */
-	b.ne    .Lno_zva
-#endif
-	str     q0, [dst, 16]
-	stp     q0, q0, [dst, 32]
-	bic     dst, dst, 63
-	sub     count, dstend, dst      /* Count is now 64 too large.  */
-	sub     count, count, 128       /* Adjust count and bias for loop.  */
-
-	.p2align 4
-.Lzva_loop:
-	add     dst, dst, 64
-	dc      zva, dst
-	subs    count, count, 64
-	b.hi    .Lzva_loop
-	stp     q0, q0, [dstend, -64]
-	stp     q0, q0, [dstend, -32]
-	ret
-
-.Lno_zva:
-	sub     count, dstend, dst      /* Count is 16 too large.  */
-	sub     dst, dst, 16            /* Dst is biased by -32.  */
-	sub     count, count, 64 + 16   /* Adjust count and bias for loop.  */
-.Lno_zva_loop:
-	stp     q0, q0, [dst, 32]
-	stp     q0, q0, [dst, 64]!
-	subs    count, count, 64
-	b.hi    .Lno_zva_loop
-	stp     q0, q0, [dstend, -64]
-	stp     q0, q0, [dstend, -32]
-	ret
-
-.size memset,.-memset
-
diff --git a/src/string/arm/__aeabi_memcpy.s b/src/string/arm/__aeabi_memcpy.s
deleted file mode 100644
index 3a527e41b8f0..000000000000
--- a/src/string/arm/__aeabi_memcpy.s
+++ /dev/null
@@ -1,45 +0,0 @@
-.syntax unified
-
-.global __aeabi_memcpy8
-.global __aeabi_memcpy4
-.global __aeabi_memcpy
-.global __aeabi_memmove8
-.global __aeabi_memmove4
-.global __aeabi_memmove
-
-.type __aeabi_memcpy8,%function
-.type __aeabi_memcpy4,%function
-.type __aeabi_memcpy,%function
-.type __aeabi_memmove8,%function
-.type __aeabi_memmove4,%function
-.type __aeabi_memmove,%function
-
-__aeabi_memmove8:
-__aeabi_memmove4:
-__aeabi_memmove:
-	cmp   r0, r1
-	bls   3f
-	cmp   r2, #0
-	beq   2f
-	adds  r0, r0, r2
-	adds  r2, r1, r2
-1:	subs  r2, r2, #1
-	ldrb  r3, [r2]
-	subs  r0, r0, #1
-	strb  r3, [r0]
-	cmp   r1, r2
-	bne   1b
-2:	bx    lr
-__aeabi_memcpy8:
-__aeabi_memcpy4:
-__aeabi_memcpy:
-3:	cmp   r2, #0
-	beq   2f
-	adds  r2, r1, r2
-1:	ldrb  r3, [r1]
-	adds  r1, r1, #1
-	strb  r3, [r0]
-	adds  r0, r0, #1
-	cmp   r1, r2
-	bne   1b
-2:	bx    lr
diff --git a/src/string/arm/__aeabi_memset.s b/src/string/arm/__aeabi_memset.s
deleted file mode 100644
index f9f605838bd9..000000000000
--- a/src/string/arm/__aeabi_memset.s
+++ /dev/null
@@ -1,31 +0,0 @@
-.syntax unified
-
-.global __aeabi_memclr8
-.global __aeabi_memclr4
-.global __aeabi_memclr
-.global __aeabi_memset8
-.global __aeabi_memset4
-.global __aeabi_memset
-
-.type __aeabi_memclr8,%function
-.type __aeabi_memclr4,%function
-.type __aeabi_memclr,%function
-.type __aeabi_memset8,%function
-.type __aeabi_memset4,%function
-.type __aeabi_memset,%function
-
-__aeabi_memclr8:
-__aeabi_memclr4:
-__aeabi_memclr:
-	movs  r2, #0
-__aeabi_memset8:
-__aeabi_memset4:
-__aeabi_memset:
-	cmp   r1, #0
-	beq   2f
-	adds  r1, r0, r1
-1:	strb  r2, [r0]
-	adds  r0, r0, #1
-	cmp   r1, r0
-	bne   1b
-2:	bx    lr
diff --git a/src/string/arm/memcpy.S b/src/string/arm/memcpy.S
deleted file mode 100644
index 869e34481c96..000000000000
--- a/src/string/arm/memcpy.S
+++ /dev/null
@@ -1,479 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-
-/*
- * Optimized memcpy() for ARM.
- *
- * note that memcpy() always returns the destination pointer,
- * so we have to preserve R0.
-  */
-
-/*
- * This file has been modified from the original for use in musl libc.
- * The main changes are: addition of .type memcpy,%function to make the
- * code safely callable from thumb mode, adjusting the return
- * instructions to be compatible with pre-thumb ARM cpus, removal of
- * prefetch code that is not compatible with older cpus and support for
- * building as thumb 2 and big-endian.
- */
-
-.syntax unified
-
-.global memcpy
-.type memcpy,%function
-memcpy:
-	/* The stack must always be 64-bits aligned to be compliant with the
-	 * ARM ABI. Since we have to save R0, we might as well save R4
-	 * which we can use for better pipelining of the reads below
-	 */
-	.fnstart
-	.save       {r0, r4, lr}
-	stmfd       sp!, {r0, r4, lr}
-	/* Making room for r5-r11 which will be spilled later */
-	.pad        #28
-	sub         sp, sp, #28
-
-	/* it simplifies things to take care of len<4 early */
-	cmp     r2, #4
-	blo     copy_last_3_and_return
-
-	/* compute the offset to align the source
-	 * offset = (4-(src&3))&3 = -src & 3
-	 */
-	rsb     r3, r1, #0
-	ands    r3, r3, #3
-	beq     src_aligned
-
-	/* align source to 32 bits. We need to insert 2 instructions between
-	 * a ldr[b|h] and str[b|h] because byte and half-word instructions
-	 * stall 2 cycles.
-	 */
-	movs    r12, r3, lsl #31
-	sub     r2, r2, r3              /* we know that r3 <= r2 because r2 >= 4 */
-	ldrbmi r3, [r1], #1
-	ldrbcs r4, [r1], #1
-	ldrbcs r12,[r1], #1
-	strbmi r3, [r0], #1
-	strbcs r4, [r0], #1
-	strbcs r12,[r0], #1
-
-src_aligned:
-
-	/* see if src and dst are aligned together (congruent) */
-	eor     r12, r0, r1
-	tst     r12, #3
-	bne     non_congruent
-
-	/* Use post-incriment mode for stm to spill r5-r11 to reserved stack
-	 * frame. Don't update sp.
-	 */
-	stmea   sp, {r5-r11}
-
-	/* align the destination to a cache-line */
-	rsb     r3, r0, #0
-	ands    r3, r3, #0x1C
-	beq     congruent_aligned32
-	cmp     r3, r2
-	andhi   r3, r2, #0x1C
-
-	/* conditionnaly copies 0 to 7 words (length in r3) */
-	movs    r12, r3, lsl #28
-	ldmcs   r1!, {r4, r5, r6, r7}           /* 16 bytes */
-	ldmmi   r1!, {r8, r9}                   /*  8 bytes */
-	stmcs   r0!, {r4, r5, r6, r7}
-	stmmi   r0!, {r8, r9}
-	tst     r3, #0x4
-	ldrne   r10,[r1], #4                    /*  4 bytes */
-	strne   r10,[r0], #4
-	sub     r2, r2, r3
-
-congruent_aligned32:
-	/*
-	 * here source is aligned to 32 bytes.
-	 */
-
-cached_aligned32:
-	subs    r2, r2, #32
-	blo     less_than_32_left
-
-	/*
-	 * We preload a cache-line up to 64 bytes ahead. On the 926, this will
-	 * stall only until the requested world is fetched, but the linefill
-	 * continues in the the background.
-	 * While the linefill is going, we write our previous cache-line
-	 * into the write-buffer (which should have some free space).
-	 * When the linefill is done, the writebuffer will
-	 * start dumping its content into memory
-	 *
-	 * While all this is going, we then load a full cache line into
-	 * 8 registers, this cache line should be in the cache by now
-	 * (or partly in the cache).
-	 *
-	 * This code should work well regardless of the source/dest alignment.
-	 *
-	 */
-
-	/* Align the preload register to a cache-line because the cpu does
-	 * "critical word first" (the first word requested is loaded first).
-	 */
-	@ bic           r12, r1, #0x1F
-	@ add           r12, r12, #64
-
-1:      ldmia   r1!, { r4-r11 }
-	subs    r2, r2, #32
-
-	/* 
-	 * NOTE: if r12 is more than 64 ahead of r1, the following ldrhi
-	 * for ARM9 preload will not be safely guarded by the preceding subs.
-	 * When it is safely guarded the only possibility to have SIGSEGV here
-	 * is because the caller overstates the length.
-	 */
-	@ ldrhi         r3, [r12], #32      /* cheap ARM9 preload */
-	stmia   r0!, { r4-r11 }
-	bhs     1b
-
-	add     r2, r2, #32
-
-less_than_32_left:
-	/*
-	 * less than 32 bytes left at this point (length in r2)
-	 */
-
-	/* skip all this if there is nothing to do, which should
-	 * be a common case (if not executed the code below takes
-	 * about 16 cycles)
-	 */
-	tst     r2, #0x1F
-	beq     1f
-
-	/* conditionnaly copies 0 to 31 bytes */
-	movs    r12, r2, lsl #28
-	ldmcs   r1!, {r4, r5, r6, r7}           /* 16 bytes */
-	ldmmi   r1!, {r8, r9}                   /*  8 bytes */
-	stmcs   r0!, {r4, r5, r6, r7}
-	stmmi   r0!, {r8, r9}
-	movs    r12, r2, lsl #30
-	ldrcs   r3, [r1], #4                    /*  4 bytes */
-	ldrhmi r4, [r1], #2                     /*  2 bytes */
-	strcs   r3, [r0], #4
-	strhmi r4, [r0], #2
-	tst     r2, #0x1
-	ldrbne r3, [r1]                         /*  last byte  */
-	strbne r3, [r0]
-
-	/* we're done! restore everything and return */
-1:      ldmfd   sp!, {r5-r11}
-	ldmfd   sp!, {r0, r4, lr}
-	bx      lr
-
-	/********************************************************************/
-
-non_congruent:
-	/*
-	 * here source is aligned to 4 bytes
-	 * but destination is not.
-	 *
-	 * in the code below r2 is the number of bytes read
-	 * (the number of bytes written is always smaller, because we have
-	 * partial words in the shift queue)
-	 */
-	cmp     r2, #4
-	blo     copy_last_3_and_return
-
-	/* Use post-incriment mode for stm to spill r5-r11 to reserved stack
-	 * frame. Don't update sp.
-	 */
-	stmea   sp, {r5-r11}
-
-	/* compute shifts needed to align src to dest */
-	rsb     r5, r0, #0
-	and     r5, r5, #3                      /* r5 = # bytes in partial words */
-	mov     r12, r5, lsl #3         /* r12 = right */
-	rsb     lr, r12, #32            /* lr = left  */
-
-	/* read the first word */
-	ldr     r3, [r1], #4
-	sub     r2, r2, #4
-
-	/* write a partial word (0 to 3 bytes), such that destination
-	 * becomes aligned to 32 bits (r5 = nb of words to copy for alignment)
-	 */
-	movs    r5, r5, lsl #31
-
-#if __ARMEB__
-	movmi   r3, r3, ror #24
-	strbmi	r3, [r0], #1
-	movcs   r3, r3, ror #24
-	strbcs	r3, [r0], #1
-	movcs   r3, r3, ror #24
-	strbcs	r3, [r0], #1
-#else
-	strbmi r3, [r0], #1
-	movmi   r3, r3, lsr #8
-	strbcs r3, [r0], #1
-	movcs   r3, r3, lsr #8
-	strbcs r3, [r0], #1
-	movcs   r3, r3, lsr #8
-#endif
-
-	cmp     r2, #4
-	blo     partial_word_tail
-
-#if __ARMEB__
-	mov	r3, r3, lsr r12
-	mov	r3, r3, lsl r12
-#endif
-
-	/* Align destination to 32 bytes (cache line boundary) */
-1:      tst     r0, #0x1c
-	beq     2f
-	ldr     r5, [r1], #4
-	sub     r2, r2, #4
-#if __ARMEB__
-	mov     r4, r5,                 lsr lr
-	orr     r4, r4, r3
-	mov     r3, r5,                 lsl r12
-#else
-	mov     r4, r5,                 lsl lr
-	orr     r4, r4, r3
-	mov     r3, r5,                 lsr r12
-#endif
-	str     r4, [r0], #4
-	cmp     r2, #4
-	bhs     1b
-	blo     partial_word_tail
-
-	/* copy 32 bytes at a time */
-2:      subs    r2, r2, #32
-	blo     less_than_thirtytwo
-
-	/* Use immediate mode for the shifts, because there is an extra cycle
-	 * for register shifts, which could account for up to 50% of
-	 * performance hit.
-	 */
-
-	cmp     r12, #24
-	beq     loop24
-	cmp     r12, #8
-	beq     loop8
-
-loop16:
-	ldr     r12, [r1], #4
-1:      mov     r4, r12
-	ldmia   r1!, {   r5,r6,r7,  r8,r9,r10,r11}
-	subs    r2, r2, #32
-	ldrhs   r12, [r1], #4
-#if __ARMEB__
-	orr     r3, r3, r4, lsr #16
-	mov     r4, r4, lsl #16
-	orr     r4, r4, r5, lsr #16
-	mov     r5, r5, lsl #16
-	orr     r5, r5, r6, lsr #16
-	mov     r6, r6, lsl #16
-	orr     r6, r6, r7, lsr #16
-	mov     r7, r7, lsl #16
-	orr     r7, r7, r8, lsr #16
-	mov     r8, r8, lsl #16
-	orr     r8, r8, r9, lsr #16
-	mov     r9, r9, lsl #16
-	orr     r9, r9, r10, lsr #16
-	mov     r10, r10,               lsl #16
-	orr     r10, r10, r11, lsr #16
-	stmia   r0!, {r3,r4,r5,r6, r7,r8,r9,r10}
-	mov     r3, r11, lsl #16
-#else
-	orr     r3, r3, r4, lsl #16
-	mov     r4, r4, lsr #16
-	orr     r4, r4, r5, lsl #16
-	mov     r5, r5, lsr #16
-	orr     r5, r5, r6, lsl #16
-	mov     r6, r6, lsr #16
-	orr     r6, r6, r7, lsl #16
-	mov     r7, r7, lsr #16
-	orr     r7, r7, r8, lsl #16
-	mov     r8, r8, lsr #16
-	orr     r8, r8, r9, lsl #16
-	mov     r9, r9, lsr #16
-	orr     r9, r9, r10, lsl #16
-	mov     r10, r10,               lsr #16
-	orr     r10, r10, r11, lsl #16
-	stmia   r0!, {r3,r4,r5,r6, r7,r8,r9,r10}
-	mov     r3, r11, lsr #16
-#endif
-	bhs     1b
-	b       less_than_thirtytwo
-
-loop8:
-	ldr     r12, [r1], #4
-1:      mov     r4, r12
-	ldmia   r1!, {   r5,r6,r7,  r8,r9,r10,r11}
-	subs    r2, r2, #32
-	ldrhs   r12, [r1], #4
-#if __ARMEB__
-	orr     r3, r3, r4, lsr #24
-	mov     r4, r4, lsl #8
-	orr     r4, r4, r5, lsr #24
-	mov     r5, r5, lsl #8
-	orr     r5, r5, r6, lsr #24
-	mov     r6, r6,  lsl #8
-	orr     r6, r6, r7, lsr #24
-	mov     r7, r7,  lsl #8
-	orr     r7, r7, r8,             lsr #24
-	mov     r8, r8,  lsl #8
-	orr     r8, r8, r9,             lsr #24
-	mov     r9, r9,  lsl #8
-	orr     r9, r9, r10,    lsr #24
-	mov     r10, r10, lsl #8
-	orr     r10, r10, r11,  lsr #24
-	stmia   r0!, {r3,r4,r5,r6, r7,r8,r9,r10}
-	mov     r3, r11, lsl #8
-#else
-	orr     r3, r3, r4, lsl #24
-	mov     r4, r4, lsr #8
-	orr     r4, r4, r5, lsl #24
-	mov     r5, r5, lsr #8
-	orr     r5, r5, r6, lsl #24
-	mov     r6, r6,  lsr #8
-	orr     r6, r6, r7, lsl #24
-	mov     r7, r7,  lsr #8
-	orr     r7, r7, r8,             lsl #24
-	mov     r8, r8,  lsr #8
-	orr     r8, r8, r9,             lsl #24
-	mov     r9, r9,  lsr #8
-	orr     r9, r9, r10,    lsl #24
-	mov     r10, r10, lsr #8
-	orr     r10, r10, r11,  lsl #24
-	stmia   r0!, {r3,r4,r5,r6, r7,r8,r9,r10}
-	mov     r3, r11, lsr #8
-#endif
-	bhs     1b
-	b       less_than_thirtytwo
-
-loop24:
-	ldr     r12, [r1], #4
-1:      mov     r4, r12
-	ldmia   r1!, {   r5,r6,r7,  r8,r9,r10,r11}
-	subs    r2, r2, #32
-	ldrhs   r12, [r1], #4
-#if __ARMEB__
-	orr     r3, r3, r4, lsr #8
-	mov     r4, r4, lsl #24
-	orr     r4, r4, r5, lsr #8
-	mov     r5, r5, lsl #24
-	orr     r5, r5, r6, lsr #8
-	mov     r6, r6, lsl #24
-	orr     r6, r6, r7, lsr #8
-	mov     r7, r7, lsl #24
-	orr     r7, r7, r8, lsr #8
-	mov     r8, r8, lsl #24
-	orr     r8, r8, r9, lsr #8
-	mov     r9, r9, lsl #24
-	orr     r9, r9, r10, lsr #8
-	mov     r10, r10, lsl #24
-	orr     r10, r10, r11, lsr #8
-	stmia   r0!, {r3,r4,r5,r6, r7,r8,r9,r10}
-	mov     r3, r11, lsl #24
-#else
-	orr     r3, r3, r4, lsl #8
-	mov     r4, r4, lsr #24
-	orr     r4, r4, r5, lsl #8
-	mov     r5, r5, lsr #24
-	orr     r5, r5, r6, lsl #8
-	mov     r6, r6, lsr #24
-	orr     r6, r6, r7, lsl #8
-	mov     r7, r7, lsr #24
-	orr     r7, r7, r8, lsl #8
-	mov     r8, r8, lsr #24
-	orr     r8, r8, r9, lsl #8
-	mov     r9, r9, lsr #24
-	orr     r9, r9, r10, lsl #8
-	mov     r10, r10, lsr #24
-	orr     r10, r10, r11, lsl #8
-	stmia   r0!, {r3,r4,r5,r6, r7,r8,r9,r10}
-	mov     r3, r11, lsr #24
-#endif
-	bhs     1b
-
-less_than_thirtytwo:
-	/* copy the last 0 to 31 bytes of the source */
-	rsb     r12, lr, #32            /* we corrupted r12, recompute it  */
-	add     r2, r2, #32
-	cmp     r2, #4
-	blo     partial_word_tail
-
-1:      ldr     r5, [r1], #4
-	sub     r2, r2, #4
-#if __ARMEB__
-	mov     r4, r5,                 lsr lr
-	orr     r4, r4, r3
-	mov     r3,     r5,                     lsl r12
-#else
-	mov     r4, r5,                 lsl lr
-	orr     r4, r4, r3
-	mov     r3,     r5,                     lsr r12
-#endif
-	str     r4, [r0], #4
-	cmp     r2, #4
-	bhs     1b
-
-partial_word_tail:
-	/* we have a partial word in the input buffer */
-	movs    r5, lr, lsl #(31-3)
-#if __ARMEB__
-	movmi   r3, r3, ror #24
-	strbmi r3, [r0], #1
-	movcs   r3, r3, ror #24
-	strbcs r3, [r0], #1
-	movcs   r3, r3, ror #24
-	strbcs r3, [r0], #1
-#else
-	strbmi r3, [r0], #1
-	movmi   r3, r3, lsr #8
-	strbcs r3, [r0], #1
-	movcs   r3, r3, lsr #8
-	strbcs r3, [r0], #1
-#endif
-
-	/* Refill spilled registers from the stack. Don't update sp. */
-	ldmfd   sp, {r5-r11}
-
-copy_last_3_and_return:
-	movs    r2, r2, lsl #31 /* copy remaining 0, 1, 2 or 3 bytes */
-	ldrbmi r2, [r1], #1
-	ldrbcs r3, [r1], #1
-	ldrbcs r12,[r1]
-	strbmi r2, [r0], #1
-	strbcs r3, [r0], #1
-	strbcs r12,[r0]
-
-	/* we're done! restore sp and spilled registers and return */
-	add     sp,  sp, #28
-	ldmfd   sp!, {r0, r4, lr}
-	bx      lr
-
diff --git a/src/string/explicit_bzero.c b/src/string/explicit_bzero.c
index f2e12f2375e2..4e555de9676c 100644
--- a/src/string/explicit_bzero.c
+++ b/src/string/explicit_bzero.c
@@ -1,8 +1,8 @@
 #define _BSD_SOURCE
 #include <string.h>
+#include <stdfil.h>
 
 void explicit_bzero(void *d, size_t n)
 {
-	d = memset(d, 0, n);
-	__asm__ __volatile__ ("" : : "r"(d) : "memory");
+    zmemset(d, 0, n);
 }
diff --git a/src/string/i386/memcpy.s b/src/string/i386/memcpy.s
deleted file mode 100644
index 0608dd83c761..000000000000
--- a/src/string/i386/memcpy.s
+++ /dev/null
@@ -1,32 +0,0 @@
-.global memcpy
-.global __memcpy_fwd
-.hidden __memcpy_fwd
-.type memcpy,@function
-memcpy:
-__memcpy_fwd:
-	push %esi
-	push %edi
-	mov 12(%esp),%edi
-	mov 16(%esp),%esi
-	mov 20(%esp),%ecx
-	mov %edi,%eax
-	cmp $4,%ecx
-	jc 1f
-	test $3,%edi
-	jz 1f
-2:	movsb
-	dec %ecx
-	test $3,%edi
-	jnz 2b
-1:	mov %ecx,%edx
-	shr $2,%ecx
-	rep
-	movsl
-	and $3,%edx
-	jz 1f
-2:	movsb
-	dec %edx
-	jnz 2b
-1:	pop %edi
-	pop %esi
-	ret
diff --git a/src/string/i386/memmove.s b/src/string/i386/memmove.s
deleted file mode 100644
index 2a6a504b3295..000000000000
--- a/src/string/i386/memmove.s
+++ /dev/null
@@ -1,22 +0,0 @@
-.global memmove
-.type memmove,@function
-memmove:
-	mov 4(%esp),%eax
-	sub 8(%esp),%eax
-	cmp 12(%esp),%eax
-.hidden __memcpy_fwd
-	jae __memcpy_fwd
-	push %esi
-	push %edi
-	mov 12(%esp),%edi
-	mov 16(%esp),%esi
-	mov 20(%esp),%ecx
-	lea -1(%edi,%ecx),%edi
-	lea -1(%esi,%ecx),%esi
-	std
-	rep movsb
-	cld
-	lea 1(%edi),%eax
-	pop %edi
-	pop %esi
-	ret
diff --git a/src/string/i386/memset.s b/src/string/i386/memset.s
deleted file mode 100644
index d00422c4ac15..000000000000
--- a/src/string/i386/memset.s
+++ /dev/null
@@ -1,76 +0,0 @@
-.global memset
-.type memset,@function
-memset:
-	mov 12(%esp),%ecx
-	cmp $62,%ecx
-	ja 2f
-
-	mov 8(%esp),%dl
-	mov 4(%esp),%eax
-	test %ecx,%ecx
-	jz 1f
-
-	mov %dl,%dh
-
-	mov %dl,(%eax)
-	mov %dl,-1(%eax,%ecx)
-	cmp $2,%ecx
-	jbe 1f
-
-	mov %dx,1(%eax)
-	mov %dx,(-1-2)(%eax,%ecx)
-	cmp $6,%ecx
-	jbe 1f
-
-	shl $16,%edx
-	mov 8(%esp),%dl
-	mov 8(%esp),%dh
-
-	mov %edx,(1+2)(%eax)
-	mov %edx,(-1-2-4)(%eax,%ecx)
-	cmp $14,%ecx
-	jbe 1f
-
-	mov %edx,(1+2+4)(%eax)
-	mov %edx,(1+2+4+4)(%eax)
-	mov %edx,(-1-2-4-8)(%eax,%ecx)
-	mov %edx,(-1-2-4-4)(%eax,%ecx)
-	cmp $30,%ecx
-	jbe 1f
-
-	mov %edx,(1+2+4+8)(%eax)
-	mov %edx,(1+2+4+8+4)(%eax)
-	mov %edx,(1+2+4+8+8)(%eax)
-	mov %edx,(1+2+4+8+12)(%eax)
-	mov %edx,(-1-2-4-8-16)(%eax,%ecx)
-	mov %edx,(-1-2-4-8-12)(%eax,%ecx)
-	mov %edx,(-1-2-4-8-8)(%eax,%ecx)
-	mov %edx,(-1-2-4-8-4)(%eax,%ecx)
-
-1:	ret 	
-
-2:	movzbl 8(%esp),%eax
-	mov %edi,12(%esp)
-	imul $0x1010101,%eax
-	mov 4(%esp),%edi
-	test $15,%edi
-	mov %eax,-4(%edi,%ecx)
-	jnz 2f
-
-1:	shr $2, %ecx
-	rep
-	stosl
-	mov 4(%esp),%eax
-	mov 12(%esp),%edi
-	ret
-	
-2:	xor %edx,%edx
-	sub %edi,%edx
-	and $15,%edx
-	mov %eax,(%edi)
-	mov %eax,4(%edi)
-	mov %eax,8(%edi)
-	mov %eax,12(%edi)
-	sub %edx,%ecx
-	add %edx,%edi
-	jmp 1b
diff --git a/src/string/memchr.c b/src/string/memchr.c
index 65f0d789b2c9..38d47ffe48ee 100644
--- a/src/string/memchr.c
+++ b/src/string/memchr.c
@@ -2,26 +2,10 @@
 #include <stdint.h>
 #include <limits.h>
 
-#define SS (sizeof(size_t))
-#define ALIGN (sizeof(size_t)-1)
-#define ONES ((size_t)-1/UCHAR_MAX)
-#define HIGHS (ONES * (UCHAR_MAX/2+1))
-#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)
-
 void *memchr(const void *src, int c, size_t n)
 {
 	const unsigned char *s = src;
 	c = (unsigned char)c;
-#ifdef __GNUC__
-	for (; ((uintptr_t)s & ALIGN) && n && *s != c; s++, n--);
-	if (n && *s != c) {
-		typedef size_t __attribute__((__may_alias__)) word;
-		const word *w;
-		size_t k = ONES * c;
-		for (w = (const void *)s; n>=SS && !HASZERO(*w^k); w++, n-=SS);
-		s = (const void *)w;
-	}
-#endif
 	for (; n && *s != c; s++, n--);
 	return n ? (void *)s : 0;
 }
diff --git a/src/string/memcpy.c b/src/string/memcpy.c
index 06e88742b114..027d3654607e 100644
--- a/src/string/memcpy.c
+++ b/src/string/memcpy.c
@@ -4,121 +4,6 @@
 
 void *memcpy(void *restrict dest, const void *restrict src, size_t n)
 {
-	unsigned char *d = dest;
-	const unsigned char *s = src;
-
-#ifdef __GNUC__
-
-#if __BYTE_ORDER == __LITTLE_ENDIAN
-#define LS >>
-#define RS <<
-#else
-#define LS <<
-#define RS >>
-#endif
-
-	typedef uint32_t __attribute__((__may_alias__)) u32;
-	uint32_t w, x;
-
-	for (; (uintptr_t)s % 4 && n; n--) *d++ = *s++;
-
-	if ((uintptr_t)d % 4 == 0) {
-		for (; n>=16; s+=16, d+=16, n-=16) {
-			*(u32 *)(d+0) = *(u32 *)(s+0);
-			*(u32 *)(d+4) = *(u32 *)(s+4);
-			*(u32 *)(d+8) = *(u32 *)(s+8);
-			*(u32 *)(d+12) = *(u32 *)(s+12);
-		}
-		if (n&8) {
-			*(u32 *)(d+0) = *(u32 *)(s+0);
-			*(u32 *)(d+4) = *(u32 *)(s+4);
-			d += 8; s += 8;
-		}
-		if (n&4) {
-			*(u32 *)(d+0) = *(u32 *)(s+0);
-			d += 4; s += 4;
-		}
-		if (n&2) {
-			*d++ = *s++; *d++ = *s++;
-		}
-		if (n&1) {
-			*d = *s;
-		}
-		return dest;
-	}
-
-	if (n >= 32) switch ((uintptr_t)d % 4) {
-	case 1:
-		w = *(u32 *)s;
-		*d++ = *s++;
-		*d++ = *s++;
-		*d++ = *s++;
-		n -= 3;
-		for (; n>=17; s+=16, d+=16, n-=16) {
-			x = *(u32 *)(s+1);
-			*(u32 *)(d+0) = (w LS 24) | (x RS 8);
-			w = *(u32 *)(s+5);
-			*(u32 *)(d+4) = (x LS 24) | (w RS 8);
-			x = *(u32 *)(s+9);
-			*(u32 *)(d+8) = (w LS 24) | (x RS 8);
-			w = *(u32 *)(s+13);
-			*(u32 *)(d+12) = (x LS 24) | (w RS 8);
-		}
-		break;
-	case 2:
-		w = *(u32 *)s;
-		*d++ = *s++;
-		*d++ = *s++;
-		n -= 2;
-		for (; n>=18; s+=16, d+=16, n-=16) {
-			x = *(u32 *)(s+2);
-			*(u32 *)(d+0) = (w LS 16) | (x RS 16);
-			w = *(u32 *)(s+6);
-			*(u32 *)(d+4) = (x LS 16) | (w RS 16);
-			x = *(u32 *)(s+10);
-			*(u32 *)(d+8) = (w LS 16) | (x RS 16);
-			w = *(u32 *)(s+14);
-			*(u32 *)(d+12) = (x LS 16) | (w RS 16);
-		}
-		break;
-	case 3:
-		w = *(u32 *)s;
-		*d++ = *s++;
-		n -= 1;
-		for (; n>=19; s+=16, d+=16, n-=16) {
-			x = *(u32 *)(s+3);
-			*(u32 *)(d+0) = (w LS 8) | (x RS 24);
-			w = *(u32 *)(s+7);
-			*(u32 *)(d+4) = (x LS 8) | (w RS 24);
-			x = *(u32 *)(s+11);
-			*(u32 *)(d+8) = (w LS 8) | (x RS 24);
-			w = *(u32 *)(s+15);
-			*(u32 *)(d+12) = (x LS 8) | (w RS 24);
-		}
-		break;
-	}
-	if (n&16) {
-		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
-		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
-		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
-		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
-	}
-	if (n&8) {
-		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
-		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
-	}
-	if (n&4) {
-		*d++ = *s++; *d++ = *s++; *d++ = *s++; *d++ = *s++;
-	}
-	if (n&2) {
-		*d++ = *s++; *d++ = *s++;
-	}
-	if (n&1) {
-		*d = *s;
-	}
-	return dest;
-#endif
-
-	for (; n; n--) *d++ = *s++;
-	return dest;
+    __builtin_memcpy(dest, src, n);
+    return dest;
 }
diff --git a/src/string/memset.c b/src/string/memset.c
index 5613a1486e6a..b5906a1ccff0 100644
--- a/src/string/memset.c
+++ b/src/string/memset.c
@@ -3,88 +3,6 @@
 
 void *memset(void *dest, int c, size_t n)
 {
-	unsigned char *s = dest;
-	size_t k;
-
-	/* Fill head and tail with minimal branching. Each
-	 * conditional ensures that all the subsequently used
-	 * offsets are well-defined and in the dest region. */
-
-	if (!n) return dest;
-	s[0] = c;
-	s[n-1] = c;
-	if (n <= 2) return dest;
-	s[1] = c;
-	s[2] = c;
-	s[n-2] = c;
-	s[n-3] = c;
-	if (n <= 6) return dest;
-	s[3] = c;
-	s[n-4] = c;
-	if (n <= 8) return dest;
-
-	/* Advance pointer to align it at a 4-byte boundary,
-	 * and truncate n to a multiple of 4. The previous code
-	 * already took care of any head/tail that get cut off
-	 * by the alignment. */
-
-	k = -(uintptr_t)s & 3;
-	s += k;
-	n -= k;
-	n &= -4;
-
-#ifdef __GNUC__
-	typedef uint32_t __attribute__((__may_alias__)) u32;
-	typedef uint64_t __attribute__((__may_alias__)) u64;
-
-	u32 c32 = ((u32)-1)/255 * (unsigned char)c;
-
-	/* In preparation to copy 32 bytes at a time, aligned on
-	 * an 8-byte bounary, fill head/tail up to 28 bytes each.
-	 * As in the initial byte-based head/tail fill, each
-	 * conditional below ensures that the subsequent offsets
-	 * are valid (e.g. !(n<=24) implies n>=28). */
-
-	*(u32 *)(s+0) = c32;
-	*(u32 *)(s+n-4) = c32;
-	if (n <= 8) return dest;
-	*(u32 *)(s+4) = c32;
-	*(u32 *)(s+8) = c32;
-	*(u32 *)(s+n-12) = c32;
-	*(u32 *)(s+n-8) = c32;
-	if (n <= 24) return dest;
-	*(u32 *)(s+12) = c32;
-	*(u32 *)(s+16) = c32;
-	*(u32 *)(s+20) = c32;
-	*(u32 *)(s+24) = c32;
-	*(u32 *)(s+n-28) = c32;
-	*(u32 *)(s+n-24) = c32;
-	*(u32 *)(s+n-20) = c32;
-	*(u32 *)(s+n-16) = c32;
-
-	/* Align to a multiple of 8 so we can fill 64 bits at a time,
-	 * and avoid writing the same bytes twice as much as is
-	 * practical without introducing additional branching. */
-
-	k = 24 + ((uintptr_t)s & 4);
-	s += k;
-	n -= k;
-
-	/* If this loop is reached, 28 tail bytes have already been
-	 * filled, so any remainder when n drops below 32 can be
-	 * safely ignored. */
-
-	u64 c64 = c32 | ((u64)c32 << 32);
-	for (; n >= 32; n-=32, s+=32) {
-		*(u64 *)(s+0) = c64;
-		*(u64 *)(s+8) = c64;
-		*(u64 *)(s+16) = c64;
-		*(u64 *)(s+24) = c64;
-	}
-#else
-	/* Pure C fallback with no aliasing violations. */
-	for (; n; n--, s++) *s = c;
-#endif
-
-	return dest;
+    __builtin_memset(dest, c, n);
+    return dest;
 }
diff --git a/src/string/stpcpy.c b/src/string/stpcpy.c
index 4db46a9e50b2..ca9b385fe703 100644
--- a/src/string/stpcpy.c
+++ b/src/string/stpcpy.c
@@ -9,18 +9,6 @@
 
 char *__stpcpy(char *restrict d, const char *restrict s)
 {
-#ifdef __GNUC__
-	typedef size_t __attribute__((__may_alias__)) word;
-	word *wd;
-	const word *ws;
-	if ((uintptr_t)s % ALIGN == (uintptr_t)d % ALIGN) {
-		for (; (uintptr_t)s % ALIGN; s++, d++)
-			if (!(*d=*s)) return d;
-		wd=(void *)d; ws=(const void *)s;
-		for (; !HASZERO(*ws); *wd++ = *ws++);
-		d=(void *)wd; s=(const void *)ws;
-	}
-#endif
 	for (; (*d=*s); s++, d++);
 
 	return d;
diff --git a/src/string/stpncpy.c b/src/string/stpncpy.c
index f57fa6b71bf3..9c8fd8c2e50e 100644
--- a/src/string/stpncpy.c
+++ b/src/string/stpncpy.c
@@ -9,19 +9,6 @@
 
 char *__stpncpy(char *restrict d, const char *restrict s, size_t n)
 {
-#ifdef __GNUC__
-	typedef size_t __attribute__((__may_alias__)) word;
-	word *wd;
-	const word *ws;
-	if (((uintptr_t)s & ALIGN) == ((uintptr_t)d & ALIGN)) {
-		for (; ((uintptr_t)s & ALIGN) && n && (*d=*s); n--, s++, d++);
-		if (!n || !*s) goto tail;
-		wd=(void *)d; ws=(const void *)s;
-		for (; n>=sizeof(size_t) && !HASZERO(*ws);
-		       n-=sizeof(size_t), ws++, wd++) *wd = *ws;
-		d=(void *)wd; s=(const void *)ws;
-	}
-#endif
 	for (; n && (*d=*s); n--, s++, d++);
 tail:
 	memset(d, 0, n);
diff --git a/src/string/strchrnul.c b/src/string/strchrnul.c
index 39e2635b3064..3ea8d50f0d98 100644
--- a/src/string/strchrnul.c
+++ b/src/string/strchrnul.c
@@ -12,15 +12,6 @@ char *__strchrnul(const char *s, int c)
 	c = (unsigned char)c;
 	if (!c) return (char *)s + strlen(s);
 
-#ifdef __GNUC__
-	typedef size_t __attribute__((__may_alias__)) word;
-	const word *w;
-	for (; (uintptr_t)s % ALIGN; s++)
-		if (!*s || *(unsigned char *)s == c) return (char *)s;
-	size_t k = ONES * c;
-	for (w = (void *)s; !HASZERO(*w) && !HASZERO(*w^k); w++);
-	s = (void *)w;
-#endif
 	for (; *s && *(unsigned char *)s != c; s++);
 	return (char *)s;
 }
diff --git a/src/string/strlcpy.c b/src/string/strlcpy.c
index ffa0b0b01458..849b7da563f3 100644
--- a/src/string/strlcpy.c
+++ b/src/string/strlcpy.c
@@ -14,19 +14,6 @@ size_t strlcpy(char *d, const char *s, size_t n)
 	size_t *wd;
 
 	if (!n--) goto finish;
-#ifdef __GNUC__
-	typedef size_t __attribute__((__may_alias__)) word;
-	const word *ws;
-	if (((uintptr_t)s & ALIGN) == ((uintptr_t)d & ALIGN)) {
-		for (; ((uintptr_t)s & ALIGN) && n && (*d=*s); n--, s++, d++);
-		if (n && *s) {
-			wd=(void *)d; ws=(const void *)s;
-			for (; n>=sizeof(size_t) && !HASZERO(*ws);
-			       n-=sizeof(size_t), ws++, wd++) *wd = *ws;
-			d=(void *)wd; s=(const void *)ws;
-		}
-	}
-#endif
 	for (; n && (*d=*s); n--, s++, d++);
 	*d = 0;
 finish:
diff --git a/src/string/strlen.c b/src/string/strlen.c
index 309990f029f0..094238efddb9 100644
--- a/src/string/strlen.c
+++ b/src/string/strlen.c
@@ -2,21 +2,9 @@
 #include <stdint.h>
 #include <limits.h>
 
-#define ALIGN (sizeof(size_t))
-#define ONES ((size_t)-1/UCHAR_MAX)
-#define HIGHS (ONES * (UCHAR_MAX/2+1))
-#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)
-
 size_t strlen(const char *s)
 {
 	const char *a = s;
-#ifdef __GNUC__
-	typedef size_t __attribute__((__may_alias__)) word;
-	const word *w;
-	for (; (uintptr_t)s % ALIGN; s++) if (!*s) return s-a;
-	for (w = (const void *)s; !HASZERO(*w); w++);
-	s = (const void *)w;
-#endif
 	for (; *s; s++);
 	return s-a;
 }
diff --git a/src/string/strnlen.c b/src/string/strnlen.c
index 6442eb793fbe..21ef23f759bb 100644
--- a/src/string/strnlen.c
+++ b/src/string/strnlen.c
@@ -1,4 +1,5 @@
 #include <string.h>
+#include <stdfil.h>
 
 size_t strnlen(const char *s, size_t n)
 {
diff --git a/src/string/x86_64/memcpy.s b/src/string/x86_64/memcpy.s
deleted file mode 100644
index 3d960efa8936..000000000000
--- a/src/string/x86_64/memcpy.s
+++ /dev/null
@@ -1,25 +0,0 @@
-.global memcpy
-.global __memcpy_fwd
-.hidden __memcpy_fwd
-.type memcpy,@function
-memcpy:
-__memcpy_fwd:
-	mov %rdi,%rax
-	cmp $8,%rdx
-	jc 1f
-	test $7,%edi
-	jz 1f
-2:	movsb
-	dec %rdx
-	test $7,%edi
-	jnz 2b
-1:	mov %rdx,%rcx
-	shr $3,%rcx
-	rep
-	movsq
-	and $7,%edx
-	jz 1f
-2:	movsb
-	dec %edx
-	jnz 2b
-1:	ret
diff --git a/src/string/x86_64/memmove.s b/src/string/x86_64/memmove.s
deleted file mode 100644
index 172c025206a3..000000000000
--- a/src/string/x86_64/memmove.s
+++ /dev/null
@@ -1,16 +0,0 @@
-.global memmove
-.type memmove,@function
-memmove:
-	mov %rdi,%rax
-	sub %rsi,%rax
-	cmp %rdx,%rax
-.hidden __memcpy_fwd
-	jae __memcpy_fwd
-	mov %rdx,%rcx
-	lea -1(%rdi,%rdx),%rdi
-	lea -1(%rsi,%rdx),%rsi
-	std
-	rep movsb
-	cld
-	lea 1(%rdi),%rax
-	ret
diff --git a/src/string/x86_64/memset.s b/src/string/x86_64/memset.s
deleted file mode 100644
index 2d3f5e52b8af..000000000000
--- a/src/string/x86_64/memset.s
+++ /dev/null
@@ -1,72 +0,0 @@
-.global memset
-.type memset,@function
-memset:
-	movzbq %sil,%rax
-	mov $0x101010101010101,%r8
-	imul %r8,%rax
-
-	cmp $126,%rdx
-	ja 2f
-
-	test %edx,%edx
-	jz 1f
-
-	mov %sil,(%rdi)
-	mov %sil,-1(%rdi,%rdx)
-	cmp $2,%edx
-	jbe 1f
-
-	mov %ax,1(%rdi)
-	mov %ax,(-1-2)(%rdi,%rdx)
-	cmp $6,%edx
-	jbe 1f
-
-	mov %eax,(1+2)(%rdi)
-	mov %eax,(-1-2-4)(%rdi,%rdx)
-	cmp $14,%edx
-	jbe 1f
-
-	mov %rax,(1+2+4)(%rdi)
-	mov %rax,(-1-2-4-8)(%rdi,%rdx)
-	cmp $30,%edx
-	jbe 1f
-
-	mov %rax,(1+2+4+8)(%rdi)
-	mov %rax,(1+2+4+8+8)(%rdi)
-	mov %rax,(-1-2-4-8-16)(%rdi,%rdx)
-	mov %rax,(-1-2-4-8-8)(%rdi,%rdx)
-	cmp $62,%edx
-	jbe 1f
-
-	mov %rax,(1+2+4+8+16)(%rdi)
-	mov %rax,(1+2+4+8+16+8)(%rdi)
-	mov %rax,(1+2+4+8+16+16)(%rdi)
-	mov %rax,(1+2+4+8+16+24)(%rdi)
-	mov %rax,(-1-2-4-8-16-32)(%rdi,%rdx)
-	mov %rax,(-1-2-4-8-16-24)(%rdi,%rdx)
-	mov %rax,(-1-2-4-8-16-16)(%rdi,%rdx)
-	mov %rax,(-1-2-4-8-16-8)(%rdi,%rdx)
-
-1:	mov %rdi,%rax
-	ret
-
-2:	test $15,%edi
-	mov %rdi,%r8
-	mov %rax,-8(%rdi,%rdx)
-	mov %rdx,%rcx
-	jnz 2f
-
-1:	shr $3,%rcx
-	rep
-	stosq
-	mov %r8,%rax
-	ret
-
-2:	xor %edx,%edx
-	sub %edi,%edx
-	and $15,%edx
-	mov %rax,(%rdi)
-	mov %rax,8(%rdi)
-	sub %rdx,%rcx
-	add %rdx,%rdi
-	jmp 1b
diff --git a/src/termios/tcdrain.c b/src/termios/tcdrain.c
index c0e542b3e5fb..1487c1137621 100644
--- a/src/termios/tcdrain.c
+++ b/src/termios/tcdrain.c
@@ -4,5 +4,5 @@
 
 int tcdrain(int fd)
 {
-	return syscall_cp(SYS_ioctl, fd, TCSBRK, 1);
+	return zsys_ioctl(fd, TCSBRK, 1);
 }
diff --git a/src/termios/tcgetwinsize.c b/src/termios/tcgetwinsize.c
index 9b3a65a40d3e..a5008403f5ed 100644
--- a/src/termios/tcgetwinsize.c
+++ b/src/termios/tcgetwinsize.c
@@ -4,5 +4,5 @@
 
 int tcgetwinsize(int fd, struct winsize *wsz)
 {
-	return syscall(SYS_ioctl, fd, TIOCGWINSZ, wsz);
+	return zsys_ioctl(fd, TIOCGWINSZ, wsz);
 }
diff --git a/src/thread/__syscall_cp.c b/src/thread/__syscall_cp.c
index 42a01674bf40..b40fab6b51b4 100644
--- a/src/thread/__syscall_cp.c
+++ b/src/thread/__syscall_cp.c
@@ -1,20 +1,11 @@
 #include "pthread_impl.h"
 #include "syscall.h"
-
-hidden long __syscall_cp_c();
-
-static long sccp(syscall_arg_t nr,
-                 syscall_arg_t u, syscall_arg_t v, syscall_arg_t w,
-                 syscall_arg_t x, syscall_arg_t y, syscall_arg_t z)
-{
-	return __syscall(nr, u, v, w, x, y, z);
-}
-
-weak_alias(sccp, __syscall_cp_c);
+#include <stdfil.h>
 
 long (__syscall_cp)(syscall_arg_t nr,
                     syscall_arg_t u, syscall_arg_t v, syscall_arg_t w,
                     syscall_arg_t x, syscall_arg_t y, syscall_arg_t z)
 {
-	return __syscall_cp_c(nr, u, v, w, x, y, z);
+    zerror("Don't do syscalls like this");
+    return 0;
 }
diff --git a/src/thread/__timedwait.c b/src/thread/__timedwait.c
index 666093be9851..a42804f34004 100644
--- a/src/thread/__timedwait.c
+++ b/src/thread/__timedwait.c
@@ -5,67 +5,15 @@
 #include "syscall.h"
 #include "pthread_impl.h"
 
-#define IS32BIT(x) !((x)+0x80000000ULL>>32)
-#define CLAMP(x) (int)(IS32BIT(x) ? (x) : 0x7fffffffU+((0ULL+(x))>>63))
-
-static int __futex4_cp(volatile void *addr, int op, int val, const struct timespec *to)
-{
-	int r;
-#ifdef SYS_futex_time64
-	time_t s = to ? to->tv_sec : 0;
-	long ns = to ? to->tv_nsec : 0;
-	r = -ENOSYS;
-	if (SYS_futex == SYS_futex_time64 || !IS32BIT(s))
-		r = __syscall_cp(SYS_futex_time64, addr, op, val,
-			to ? ((long long[]){s, ns}) : 0);
-	if (SYS_futex == SYS_futex_time64 || r!=-ENOSYS) return r;
-	to = to ? (void *)(long[]){CLAMP(s), ns} : 0;
-#endif
-	r = __syscall_cp(SYS_futex, addr, op, val, to);
-	if (r != -ENOSYS) return r;
-	return __syscall_cp(SYS_futex, addr, op & ~FUTEX_PRIVATE, val, to);
-}
-
-static volatile int dummy = 0;
-weak_alias(dummy, __eintr_valid_flag);
-
 int __timedwait_cp(volatile int *addr, int val,
 	clockid_t clk, const struct timespec *at, int priv)
 {
-	int r;
-	struct timespec to, *top=0;
-
-	if (priv) priv = FUTEX_PRIVATE;
-
-	if (at) {
-		if (at->tv_nsec >= 1000000000UL) return EINVAL;
-		if (__clock_gettime(clk, &to)) return EINVAL;
-		to.tv_sec = at->tv_sec - to.tv_sec;
-		if ((to.tv_nsec = at->tv_nsec - to.tv_nsec) < 0) {
-			to.tv_sec--;
-			to.tv_nsec += 1000000000;
-		}
-		if (to.tv_sec < 0) return ETIMEDOUT;
-		top = &to;
-	}
-
-	r = -__futex4_cp(addr, FUTEX_WAIT|priv, val, top);
-	if (r != EINTR && r != ETIMEDOUT && r != ECANCELED) r = 0;
-	/* Mitigate bug in old kernels wrongly reporting EINTR for non-
-	 * interrupting (SA_RESTART) signal handlers. This is only practical
-	 * when NO interrupting signal handlers have been installed, and
-	 * works by sigaction tracking whether that's the case. */
-	if (r == EINTR && !__eintr_valid_flag) r = 0;
-
-	return r;
+	/* FIXME: This should be a cancel point, but whatever. */
+	return zsys_futex_timedwait(addr, val, clk, at, priv);
 }
 
 int __timedwait(volatile int *addr, int val,
 	clockid_t clk, const struct timespec *at, int priv)
 {
-	int cs, r;
-	__pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
-	r = __timedwait_cp(addr, val, clk, at, priv);
-	__pthread_setcancelstate(cs, 0);
-	return r;
+	return zsys_futex_timedwait(addr, val, clk, at, priv);
 }
diff --git a/src/thread/__wait.c b/src/thread/__wait.c
index dc33c1a30992..684e4a55a117 100644
--- a/src/thread/__wait.c
+++ b/src/thread/__wait.c
@@ -9,9 +9,7 @@ void __wait(volatile int *addr, volatile int *waiters, int val, int priv)
 		else return;
 	}
 	if (waiters) a_inc(waiters);
-	while (*addr==val) {
-		__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS
-		|| __syscall(SYS_futex, addr, FUTEX_WAIT, val, 0);
-	}
+	while (*addr==val)
+		zsys_futex_wait(addr, val, priv);
 	if (waiters) a_dec(waiters);
 }
diff --git a/src/thread/aarch64/__set_thread_area.s b/src/thread/aarch64/__set_thread_area.s
deleted file mode 100644
index fd0df34b0458..000000000000
--- a/src/thread/aarch64/__set_thread_area.s
+++ /dev/null
@@ -1,7 +0,0 @@
-.global __set_thread_area
-.hidden __set_thread_area
-.type   __set_thread_area,@function
-__set_thread_area:
-	msr tpidr_el0,x0
-	mov w0,#0
-	ret
diff --git a/src/thread/aarch64/__unmapself.s b/src/thread/aarch64/__unmapself.s
deleted file mode 100644
index 2c5d254f7bef..000000000000
--- a/src/thread/aarch64/__unmapself.s
+++ /dev/null
@@ -1,7 +0,0 @@
-.global __unmapself
-.type   __unmapself,%function
-__unmapself:
-	mov x8,#215 // SYS_munmap
-	svc 0
-	mov x8,#93 // SYS_exit
-	svc 0
diff --git a/src/thread/aarch64/clone.s b/src/thread/aarch64/clone.s
deleted file mode 100644
index e3c83395cad2..000000000000
--- a/src/thread/aarch64/clone.s
+++ /dev/null
@@ -1,30 +0,0 @@
-// __clone(func, stack, flags, arg, ptid, tls, ctid)
-//         x0,   x1,    w2,    x3,  x4,   x5,  x6
-
-// syscall(SYS_clone, flags, stack, ptid, tls, ctid)
-//         x8,        x0,    x1,    x2,   x3,  x4
-
-.global __clone
-.hidden __clone
-.type   __clone,%function
-__clone:
-	// align stack and save func,arg
-	and x1,x1,#-16
-	stp x0,x3,[x1,#-16]!
-
-	// syscall
-	uxtw x0,w2
-	mov x2,x4
-	mov x3,x5
-	mov x4,x6
-	mov x8,#220 // SYS_clone
-	svc #0
-
-	cbz x0,1f
-	// parent
-	ret
-	// child
-1:	ldp x1,x0,[sp],#16
-	blr x1
-	mov x8,#93 // SYS_exit
-	svc #0
diff --git a/src/thread/aarch64/syscall_cp.s b/src/thread/aarch64/syscall_cp.s
deleted file mode 100644
index 41db68af9588..000000000000
--- a/src/thread/aarch64/syscall_cp.s
+++ /dev/null
@@ -1,32 +0,0 @@
-// __syscall_cp_asm(&self->cancel, nr, u, v, w, x, y, z)
-//                  x0             x1  x2 x3 x4 x5 x6 x7
-
-// syscall(nr, u, v, w, x, y, z)
-//         x8  x0 x1 x2 x3 x4 x5
-
-.global __cp_begin
-.hidden __cp_begin
-.global __cp_end
-.hidden __cp_end
-.global __cp_cancel
-.hidden __cp_cancel
-.hidden __cancel
-.global __syscall_cp_asm
-.hidden __syscall_cp_asm
-.type __syscall_cp_asm,%function
-__syscall_cp_asm:
-__cp_begin:
-	ldr w0,[x0]
-	cbnz w0,__cp_cancel
-	mov x8,x1
-	mov x0,x2
-	mov x1,x3
-	mov x2,x4
-	mov x3,x5
-	mov x4,x6
-	mov x5,x7
-	svc 0
-__cp_end:
-	ret
-__cp_cancel:
-	b __cancel
diff --git a/src/thread/arm/__aeabi_read_tp.s b/src/thread/arm/__aeabi_read_tp.s
deleted file mode 100644
index 2585620c447e..000000000000
--- a/src/thread/arm/__aeabi_read_tp.s
+++ /dev/null
@@ -1,10 +0,0 @@
-.syntax unified
-.global __aeabi_read_tp
-.type __aeabi_read_tp,%function
-__aeabi_read_tp:
-	ldr r0,1f
-	add r0,r0,pc
-	ldr r0,[r0]
-2:	bx r0
-	.align 2
-1:	.word __a_gettp_ptr - 2b
diff --git a/src/thread/arm/__set_thread_area.c b/src/thread/arm/__set_thread_area.c
deleted file mode 100644
index 09de65aab04a..000000000000
--- a/src/thread/arm/__set_thread_area.c
+++ /dev/null
@@ -1,52 +0,0 @@
-#include <stdint.h>
-#include <elf.h>
-#include "pthread_impl.h"
-#include "libc.h"
-
-#define HWCAP_TLS (1 << 15)
-
-extern hidden const unsigned char
-	__a_barrier_oldkuser[], __a_barrier_v6[], __a_barrier_v7[],
-	__a_cas_v6[], __a_cas_v7[],
-	__a_gettp_cp15[];
-
-#define __a_barrier_kuser 0xffff0fa0
-#define __a_barrier_oldkuser (uintptr_t)__a_barrier_oldkuser
-#define __a_barrier_v6 (uintptr_t)__a_barrier_v6
-#define __a_barrier_v7 (uintptr_t)__a_barrier_v7
-
-#define __a_cas_kuser 0xffff0fc0
-#define __a_cas_v6 (uintptr_t)__a_cas_v6
-#define __a_cas_v7 (uintptr_t)__a_cas_v7
-
-#define __a_gettp_kuser 0xffff0fe0
-#define __a_gettp_cp15 (uintptr_t)__a_gettp_cp15
-
-extern hidden uintptr_t __a_barrier_ptr, __a_cas_ptr, __a_gettp_ptr;
-
-int __set_thread_area(void *p)
-{
-#if !__ARM_ARCH_7A__ && !__ARM_ARCH_7R__ && __ARM_ARCH < 7
-	if (__hwcap & HWCAP_TLS) {
-		size_t *aux;
-		__a_cas_ptr = __a_cas_v7;
-		__a_barrier_ptr = __a_barrier_v7;
-		for (aux=libc.auxv; *aux; aux+=2) {
-			if (*aux != AT_PLATFORM) continue;
-			const char *s = (void *)aux[1];
-			if (s[0]!='v' || s[1]!='6' || s[2]-'0'<10u) break;
-			__a_cas_ptr = __a_cas_v6;
-			__a_barrier_ptr = __a_barrier_v6;
-			break;
-		}
-	} else {
-		int ver = *(int *)0xffff0ffc;
-		__a_gettp_ptr = __a_gettp_kuser;
-		__a_cas_ptr = __a_cas_kuser;
-		__a_barrier_ptr = __a_barrier_kuser;
-		if (ver < 2) a_crash();
-		if (ver < 3) __a_barrier_ptr = __a_barrier_oldkuser;
-	}
-#endif
-	return __syscall(0xf0005, p);
-}
diff --git a/src/thread/arm/__unmapself.s b/src/thread/arm/__unmapself.s
deleted file mode 100644
index 29c2d07b1660..000000000000
--- a/src/thread/arm/__unmapself.s
+++ /dev/null
@@ -1,9 +0,0 @@
-.syntax unified
-.text
-.global __unmapself
-.type   __unmapself,%function
-__unmapself:
-	mov r7,#91
-	svc 0
-	mov r7,#1
-	svc 0
diff --git a/src/thread/arm/atomics.s b/src/thread/arm/atomics.s
deleted file mode 100644
index da50508d8d45..000000000000
--- a/src/thread/arm/atomics.s
+++ /dev/null
@@ -1,106 +0,0 @@
-.syntax unified
-.text
-
-.global __a_barrier_dummy
-.hidden __a_barrier_dummy
-.type __a_barrier_dummy,%function
-__a_barrier_dummy:
-	bx lr
-
-.global __a_barrier_oldkuser
-.hidden __a_barrier_oldkuser
-.type __a_barrier_oldkuser,%function
-__a_barrier_oldkuser:
-	push {r0,r1,r2,r3,ip,lr}
-	mov r1,r0
-	mov r2,sp
-	ldr ip,=0xffff0fc0
-	bl 1f
-	pop {r0,r1,r2,r3,ip,lr}
-	bx lr
-1:	bx ip
-
-.global __a_barrier_v6
-.hidden __a_barrier_v6
-.type __a_barrier_v6,%function
-__a_barrier_v6:
-	.arch armv6t2
-	mcr p15,0,r0,c7,c10,5
-	bx lr
-
-.global __a_barrier_v7
-.hidden __a_barrier_v7
-.type __a_barrier_v7,%function
-__a_barrier_v7:
-	.arch armv7-a
-	dmb ish
-	bx lr
-
-.global __a_cas_dummy
-.hidden __a_cas_dummy
-.type __a_cas_dummy,%function
-__a_cas_dummy:
-	mov r3,r0
-	ldr r0,[r2]
-	subs r0,r3,r0
-	streq r1,[r2]
-	bx lr
-
-.global __a_cas_v6
-.hidden __a_cas_v6
-.type __a_cas_v6,%function
-__a_cas_v6:
-	.arch armv6t2
-	mov r3,r0
-	mcr p15,0,r0,c7,c10,5
-1:	ldrex r0,[r2]
-	subs r0,r3,r0
-	strexeq r0,r1,[r2]
-	teqeq r0,#1
-	beq 1b
-	mcr p15,0,r0,c7,c10,5
-	bx lr
-
-.global __a_cas_v7
-.hidden __a_cas_v7
-.type __a_cas_v7,%function
-__a_cas_v7:
-	.arch armv7-a
-	mov r3,r0
-	dmb ish
-1:	ldrex r0,[r2]
-	subs r0,r3,r0
-	strexeq r0,r1,[r2]
-	teqeq r0,#1
-	beq 1b
-	dmb ish
-	bx lr
-
-.global __a_gettp_cp15
-.hidden __a_gettp_cp15
-.type __a_gettp_cp15,%function
-__a_gettp_cp15:
-	mrc p15,0,r0,c13,c0,3
-	bx lr
-
-/* Tag this file with minimum ISA level so as not to affect linking. */
-.object_arch armv4t
-.eabi_attribute 6,2
-
-.data
-.align 2
-
-.global __a_barrier_ptr
-.hidden __a_barrier_ptr
-__a_barrier_ptr:
-	.word __a_barrier_dummy
-
-.global __a_cas_ptr
-.hidden __a_cas_ptr
-__a_cas_ptr:
-	.word __a_cas_dummy
-
-.global __a_gettp_ptr
-.hidden __a_gettp_ptr
-__a_gettp_ptr:
-	.word __a_gettp_cp15
diff --git a/src/thread/arm/clone.s b/src/thread/arm/clone.s
deleted file mode 100644
index bb0965dafe82..000000000000
--- a/src/thread/arm/clone.s
+++ /dev/null
@@ -1,28 +0,0 @@
-.syntax unified
-.text
-.global __clone
-.hidden __clone
-.type   __clone,%function
-__clone:
-	stmfd sp!,{r4,r5,r6,r7}
-	mov r7,#120
-	mov r6,r3
-	mov r5,r0
-	mov r0,r2
-	and r1,r1,#-16
-	ldr r2,[sp,#16]
-	ldr r3,[sp,#20]
-	ldr r4,[sp,#24]
-	svc 0
-	tst r0,r0
-	beq 1f
-	ldmfd sp!,{r4,r5,r6,r7}
-	bx lr
-
-1:	mov r0,r6
-	bl 3f
-2:	mov r7,#1
-	svc 0
-	b 2b
-
-3:	bx r5
diff --git a/src/thread/arm/syscall_cp.s b/src/thread/arm/syscall_cp.s
deleted file mode 100644
index e607dd426afc..000000000000
--- a/src/thread/arm/syscall_cp.s
+++ /dev/null
@@ -1,29 +0,0 @@
-.syntax unified
-.global __cp_begin
-.hidden __cp_begin
-.global __cp_end
-.hidden __cp_end
-.global __cp_cancel
-.hidden __cp_cancel
-.hidden __cancel
-.global __syscall_cp_asm
-.hidden __syscall_cp_asm
-.type __syscall_cp_asm,%function
-__syscall_cp_asm:
-	mov ip,sp
-	stmfd sp!,{r4,r5,r6,r7}
-__cp_begin:
-	ldr r0,[r0]
-	cmp r0,#0
-	bne __cp_cancel
-	mov r7,r1
-	mov r0,r2
-	mov r1,r3
-	ldmfd ip,{r2,r3,r4,r5,r6}
-	svc 0
-__cp_end:
-	ldmfd sp!,{r4,r5,r6,r7}
-	bx lr
-__cp_cancel:
-	ldmfd sp!,{r4,r5,r6,r7}
-	b __cancel
diff --git a/src/thread/i386/__set_thread_area.s b/src/thread/i386/__set_thread_area.s
deleted file mode 100644
index aa6852beb66b..000000000000
--- a/src/thread/i386/__set_thread_area.s
+++ /dev/null
@@ -1,47 +0,0 @@
-.text
-.global __set_thread_area
-.hidden __set_thread_area
-.type   __set_thread_area,@function
-__set_thread_area:
-	push %ebx
-	push $0x51
-	push $0xfffff
-	push 16(%esp)
-	call 1f
-1:	addl $4f-1b,(%esp)
-	pop %ecx
-	mov (%ecx),%edx
-	push %edx
-	mov %esp,%ebx
-	xor %eax,%eax
-	mov $243,%al
-	int $128
-	testl %eax,%eax
-	jnz 2f
-	movl (%esp),%edx
-	movl %edx,(%ecx)
-	leal 3(,%edx,8),%edx
-3:	movw %dx,%gs
-1:
-	addl $16,%esp
-	popl %ebx
-	ret
-2:
-	mov %ebx,%ecx
-	xor %eax,%eax
-	xor %ebx,%ebx
-	xor %edx,%edx
-	mov %ebx,(%esp)
-	mov $1,%bl
-	mov $16,%dl
-	mov $123,%al
-	int $128
-	testl %eax,%eax
-	jnz 1b
-	mov $7,%dl
-	inc %al
-	jmp 3b
-
-.data
-	.align 4
-4:	.long -1
diff --git a/src/thread/i386/__unmapself.s b/src/thread/i386/__unmapself.s
deleted file mode 100644
index d6569594ae0c..000000000000
--- a/src/thread/i386/__unmapself.s
+++ /dev/null
@@ -1,11 +0,0 @@
-.text
-.global __unmapself
-.type   __unmapself,@function
-__unmapself:
-	movl $91,%eax
-	movl 4(%esp),%ebx
-	movl 8(%esp),%ecx
-	int $128
-	xorl %ebx,%ebx
-	movl $1,%eax
-	int $128
diff --git a/src/thread/i386/clone.s b/src/thread/i386/clone.s
deleted file mode 100644
index e237d3c6324b..000000000000
--- a/src/thread/i386/clone.s
+++ /dev/null
@@ -1,49 +0,0 @@
-.text
-.global __clone
-.hidden __clone
-.type   __clone,@function
-__clone:
-	push %ebp
-	mov %esp,%ebp
-	push %ebx
-	push %esi
-	push %edi
-
-	xor %eax,%eax
-	push $0x51
-	mov %gs,%ax
-	push $0xfffff
-	shr $3,%eax
-	push 28(%ebp)
-	push %eax
-	mov $120,%al
-
-	mov 12(%ebp),%ecx
-	mov 16(%ebp),%ebx
-	and $-16,%ecx
-	sub $16,%ecx
-	mov 20(%ebp),%edi
-	mov %edi,(%ecx)
-	mov 24(%ebp),%edx
-	mov %esp,%esi
-	mov 32(%ebp),%edi
-	mov 8(%ebp),%ebp
-	int $128
-	test %eax,%eax
-	jnz 1f
-
-	mov %ebp,%eax
-	xor %ebp,%ebp
-	call *%eax
-	mov %eax,%ebx
-	xor %eax,%eax
-	inc %eax
-	int $128
-	hlt
-
-1:	add $16,%esp
-	pop %edi
-	pop %esi
-	pop %ebx
-	pop %ebp
-	ret
diff --git a/src/thread/i386/syscall_cp.s b/src/thread/i386/syscall_cp.s
deleted file mode 100644
index 7dce1eb3ae9e..000000000000
--- a/src/thread/i386/syscall_cp.s
+++ /dev/null
@@ -1,41 +0,0 @@
-.text
-.global __cp_begin
-.hidden __cp_begin
-.global __cp_end
-.hidden __cp_end
-.global __cp_cancel
-.hidden __cp_cancel
-.hidden __cancel
-.global __syscall_cp_asm
-.hidden __syscall_cp_asm
-.type   __syscall_cp_asm,@function
-__syscall_cp_asm:
-	mov 4(%esp),%ecx
-	pushl %ebx
-	pushl %esi
-	pushl %edi
-	pushl %ebp
-__cp_begin:
-	movl (%ecx),%eax
-	testl %eax,%eax
-	jnz __cp_cancel
-	movl 24(%esp),%eax
-	movl 28(%esp),%ebx
-	movl 32(%esp),%ecx
-	movl 36(%esp),%edx
-	movl 40(%esp),%esi
-	movl 44(%esp),%edi
-	movl 48(%esp),%ebp
-	int $128
-__cp_end:
-	popl %ebp
-	popl %edi
-	popl %esi
-	popl %ebx
-	ret
-__cp_cancel:
-	popl %ebp
-	popl %edi
-	popl %esi
-	popl %ebx
-	jmp __cancel
diff --git a/src/thread/i386/tls.s b/src/thread/i386/tls.s
deleted file mode 100644
index 6e4c4cb92867..000000000000
--- a/src/thread/i386/tls.s
+++ /dev/null
@@ -1,9 +0,0 @@
-.text
-.global ___tls_get_addr
-.type ___tls_get_addr,@function
-___tls_get_addr:
-	mov %gs:4,%edx
-	mov (%eax),%ecx
-	mov 4(%eax),%eax
-	add (%edx,%ecx,4),%eax
-	ret
diff --git a/src/thread/m68k/__m68k_read_tp.s b/src/thread/m68k/__m68k_read_tp.s
deleted file mode 100644
index 86886da8a56d..000000000000
--- a/src/thread/m68k/__m68k_read_tp.s
+++ /dev/null
@@ -1,8 +0,0 @@
-.text
-.global __m68k_read_tp
-.type   __m68k_read_tp,@function
-__m68k_read_tp:
-	move.l #333,%d0
-	trap #0
-	move.l %d0,%a0
-	rts
diff --git a/src/thread/m68k/clone.s b/src/thread/m68k/clone.s
deleted file mode 100644
index f6dfa06f49da..000000000000
--- a/src/thread/m68k/clone.s
+++ /dev/null
@@ -1,25 +0,0 @@
-.text
-.global __clone
-.hidden __clone
-.type   __clone,@function
-__clone:
-	movem.l %d2-%d5,-(%sp)
-	move.l #120,%d0
-	move.l 28(%sp),%d1
-	move.l 24(%sp),%d2
-	and.l #-16,%d2
-	move.l 36(%sp),%d3
-	move.l 44(%sp),%d4
-	move.l 40(%sp),%d5
-	move.l 20(%sp),%a0
-	move.l 32(%sp),%a1
-	trap #0
-	tst.l %d0
-	beq 1f
-	movem.l (%sp)+,%d2-%d5
-	rts
-1:	move.l %a1,-(%sp)
-	jsr (%a0)
-	move.l #1,%d0
-	trap #0
-	clr.b 0
diff --git a/src/thread/m68k/syscall_cp.s b/src/thread/m68k/syscall_cp.s
deleted file mode 100644
index 5628a896e56b..000000000000
--- a/src/thread/m68k/syscall_cp.s
+++ /dev/null
@@ -1,26 +0,0 @@
-.text
-.global __cp_begin
-.hidden __cp_begin
-.global __cp_end
-.hidden __cp_end
-.global __cp_cancel
-.hidden __cp_cancel
-.hidden __cancel
-.global __syscall_cp_asm
-.hidden __syscall_cp_asm
-.type   __syscall_cp_asm,@function
-__syscall_cp_asm:
-	movem.l %d2-%d5,-(%sp)
-	movea.l 20(%sp),%a0
-__cp_begin:
-	move.l (%a0),%d0
-	bne __cp_cancel
-	movem.l 24(%sp),%d0-%d5/%a0
-	trap #0
-__cp_end:
-	movem.l (%sp)+,%d2-%d5
-	rts
-__cp_cancel:
-	movem.l (%sp)+,%d2-%d5
-	move.l __cancel-.-8,%a1
-	jmp (%pc,%a1)
diff --git a/src/thread/microblaze/__set_thread_area.s b/src/thread/microblaze/__set_thread_area.s
deleted file mode 100644
index 9a226a915780..000000000000
--- a/src/thread/microblaze/__set_thread_area.s
+++ /dev/null
@@ -1,7 +0,0 @@
-.global __set_thread_area
-.hidden __set_thread_area
-.type   __set_thread_area,@function
-__set_thread_area:
-	ori      r21, r5, 0
-	rtsd     r15, 8
-	ori      r3, r0, 0
diff --git a/src/thread/microblaze/__unmapself.s b/src/thread/microblaze/__unmapself.s
deleted file mode 100644
index b180de60a6bd..000000000000
--- a/src/thread/microblaze/__unmapself.s
+++ /dev/null
@@ -1,8 +0,0 @@
-.global __unmapself
-.type   __unmapself,@function
-__unmapself:
-	ori     r12, r0, 91
-	brki    r14, 0x8
-	ori     r12, r0, 1
-	brki    r14, 0x8
-	nop
diff --git a/src/thread/microblaze/clone.s b/src/thread/microblaze/clone.s
deleted file mode 100644
index b68cc5fc2213..000000000000
--- a/src/thread/microblaze/clone.s
+++ /dev/null
@@ -1,30 +0,0 @@
-.global __clone
-.hidden __clone
-.type   __clone,@function
-
-# r5, r6, r7, r8, r9, r10, stack
-# fn, st, fl, ar, pt, tl, ct
-# fl, st, __, pt, ct, tl
-
-__clone:
-	andi    r6, r6, -16
-	addi    r6, r6, -16
-	swi     r5, r6, 0
-	swi     r8, r6, 4
-
-	ori     r5, r7, 0
-	ori     r8, r9, 0
-	lwi     r9, r1, 28
-	ori     r12, r0, 120
-
-	brki    r14, 8
-	beqi	r3, 1f
-	rtsd    r15, 8
-	nop
-
-1:	lwi     r3, r1, 0
-	lwi     r5, r1, 4
-	brald   r15, r3
-	nop
-	ori     r12, r0, 1
-	brki    r14, 8
diff --git a/src/thread/microblaze/syscall_cp.s b/src/thread/microblaze/syscall_cp.s
deleted file mode 100644
index b0df61c571ee..000000000000
--- a/src/thread/microblaze/syscall_cp.s
+++ /dev/null
@@ -1,27 +0,0 @@
-.global __cp_begin
-.hidden __cp_begin
-.global __cp_end
-.hidden __cp_end
-.global __cp_cancel
-.hidden __cp_cancel
-.hidden __cancel
-.global __syscall_cp_asm
-.hidden __syscall_cp_asm
-.type   __syscall_cp_asm,@function
-__syscall_cp_asm:
-__cp_begin:
-	lwi     r5, r5, 0
-	bnei    r5, __cp_cancel
-	addi    r12, r6, 0
-	add     r5, r7, r0
-	add     r6, r8, r0
-	add     r7, r9, r0
-	add     r8, r10, r0
-	lwi     r9, r1, 28
-	lwi     r10, r1, 32
-	brki    r14, 0x8
-__cp_end:
-	rtsd    r15, 8
-	nop
-__cp_cancel:
-	bri     __cancel
diff --git a/src/thread/mips/__unmapself.s b/src/thread/mips/__unmapself.s
deleted file mode 100644
index ba139dc8e7ba..000000000000
--- a/src/thread/mips/__unmapself.s
+++ /dev/null
@@ -1,10 +0,0 @@
-.set noreorder
-.global __unmapself
-.type   __unmapself,@function
-__unmapself:
-	move $sp, $25
-	li $2, 4091
-	syscall
-	li $4, 0
-	li $2, 4001
-	syscall
diff --git a/src/thread/mips/clone.s b/src/thread/mips/clone.s
deleted file mode 100644
index 0446338568f0..000000000000
--- a/src/thread/mips/clone.s
+++ /dev/null
@@ -1,36 +0,0 @@
-.set noreorder
-.global __clone
-.hidden __clone
-.type   __clone,@function
-__clone:
-	# Save function pointer and argument pointer on new thread stack
-	and $5, $5, -8
-	subu $5, $5, 16
-	sw $4, 0($5)
-	sw $7, 4($5)
-	# Shuffle (fn,sp,fl,arg,ptid,tls,ctid) to (fl,sp,ptid,tls,ctid)
-	move $4, $6
-	lw $6, 16($sp)
-	lw $7, 20($sp)
-	lw $9, 24($sp)
-	subu $sp, $sp, 16
-	sw $9, 16($sp)
-	li $2, 4120
-	syscall
-	beq $7, $0, 1f
-	nop
-	addu $sp, $sp, 16
-	jr $ra
-	subu $2, $0, $2
-1:	beq $2, $0, 1f
-	nop
-	addu $sp, $sp, 16
-	jr $ra
-	nop
-1:	lw $25, 0($sp)
-	lw $4, 4($sp)
-	jalr $25
-	nop
-	move $4, $2
-	li $2, 4001
-	syscall
diff --git a/src/thread/mips/syscall_cp.s b/src/thread/mips/syscall_cp.s
deleted file mode 100644
index d284626450f9..000000000000
--- a/src/thread/mips/syscall_cp.s
+++ /dev/null
@@ -1,53 +0,0 @@
-.set    noreorder
-
-.global __cp_begin
-.hidden __cp_begin
-.type   __cp_begin,@function
-.global __cp_end
-.hidden __cp_end
-.type   __cp_end,@function
-.global __cp_cancel
-.hidden __cp_cancel
-.type   __cp_cancel,@function
-.hidden __cancel
-.global __syscall_cp_asm
-.hidden __syscall_cp_asm
-.type   __syscall_cp_asm,@function
-__syscall_cp_asm:
-	subu    $sp, $sp, 32
-__cp_begin:
-	lw      $4, 0($4)
-	bne     $4, $0, __cp_cancel
-	move    $2, $5
-	move    $4, $6
-	move    $5, $7
-	lw      $6, 48($sp)
-	lw      $7, 52($sp)
-	lw      $8, 56($sp)
-	lw      $9, 60($sp)
-	lw      $10,64($sp)
-	sw      $8, 16($sp)
-	sw      $9, 20($sp)
-	sw      $10,24($sp)
-	sw      $2, 28($sp)
-	lw      $2, 28($sp)
-	syscall
-__cp_end:
-	beq     $7, $0, 1f
-	addu    $sp, $sp, 32
-	subu    $2, $0, $2
-1:	jr      $ra
-	nop
-
-__cp_cancel:
-	move    $2, $ra
-	bal     1f
-	addu    $sp, $sp, 32
-	.gpword .
-	.gpword __cancel
-1:	lw      $3, ($ra)
-	subu    $3, $ra, $3
-	lw      $25, 4($ra)
-	addu    $25, $25, $3
-	jr      $25
-	move    $ra, $2
diff --git a/src/thread/mips64/__unmapself.s b/src/thread/mips64/__unmapself.s
deleted file mode 100644
index f6795cda2872..000000000000
--- a/src/thread/mips64/__unmapself.s
+++ /dev/null
@@ -1,9 +0,0 @@
-.set	noreorder
-.global	__unmapself
-.type	__unmapself, @function
-__unmapself:
-	li	$2, 5011
-	syscall
-	li	$4, 0
-	li	$2, 5058
-	syscall
diff --git a/src/thread/mips64/clone.s b/src/thread/mips64/clone.s
deleted file mode 100644
index 2d86899a1daa..000000000000
--- a/src/thread/mips64/clone.s
+++ /dev/null
@@ -1,34 +0,0 @@
-.set	noreorder
-.global	__clone
-.hidden __clone
-.type	__clone,@function
-__clone:
-	# Save function pointer and argument pointer on new thread stack
-	and	$5, $5, -16	# aligning stack to double word
-	dsubu	$5, $5, 16
-	sd	$4, 0($5)	# save function pointer
-	sd	$7, 8($5)	# save argument pointer
-
-	# Shuffle (fn,sp,fl,arg,ptid,tls,ctid) to (fl,sp,ptid,tls,ctid)
-	# sys_clone(u64 flags, u64 ustack_base, u64 parent_tidptr, u64 child_tidptr, u64 tls)
-	move	$4, $6
-	move	$6, $8
-	move	$7, $9
-	move	$8, $10
-	li	$2, 5055
-	syscall
-	beq	$7, $0, 1f
-	nop
-	jr	$ra
-	dsubu	$2, $0, $2
-1:	beq	$2, $0, 1f
-	nop
-	jr	$ra
-	nop
-1:	ld	$25, 0($sp)	# function pointer
-	ld	$4, 8($sp)	# argument pointer
-	jalr	$25		# call the user's function
-	nop
-	move 	$4, $2
-	li	$2, 5058
-	syscall
diff --git a/src/thread/mips64/syscall_cp.s b/src/thread/mips64/syscall_cp.s
deleted file mode 100644
index 0d4ede7635f4..000000000000
--- a/src/thread/mips64/syscall_cp.s
+++ /dev/null
@@ -1,52 +0,0 @@
-.set	noreorder
-.global	__cp_begin
-.hidden	__cp_begin
-.type	__cp_begin,@function
-.global	__cp_end
-.hidden	__cp_end
-.type	__cp_end,@function
-.global	__cp_cancel
-.hidden	__cp_cancel
-.type	__cp_cancel,@function
-.global	__cp_cancel_data
-.hidden	__cp_cancel_data
-.type	__cp_cancel_data,@function
-.hidden	__cancel
-.global	__syscall_cp_asm
-.hidden	__syscall_cp_asm
-.type	__syscall_cp_asm,@function
-__syscall_cp_asm:
-__cp_begin:
-	lw	$4, 0($4)
-	bne	$4, $0, __cp_cancel
-	move	$2, $5
-	move	$4, $6
-	move	$5, $7
-	move	$6, $8
-	move	$7, $9
-	move	$8, $10
-	move	$9, $11
-	ld	$10, 0($sp)
-	syscall
-__cp_end:
-	beq	$7, $0, 1f
-	nop
-	dsubu	$2, $0, $2
-1:	jr	$ra
-	nop
-
-	# if cancellation flag is 1 then call __cancel
-__cp_cancel:
-	move	$2, $ra
-.align 8
-	bal	1f
-	nop
-__cp_cancel_data:
-	.gpdword __cp_cancel_data
-	.gpdword __cancel
-1:	ld	$3, ($ra)
-	dsubu	$3, $ra, $3
-	ld	$25, 8($ra)
-	daddu	$25, $25, $3
-	jr	$25
-	move	$ra, $2
diff --git a/src/thread/mipsn32/__unmapself.s b/src/thread/mipsn32/__unmapself.s
deleted file mode 100644
index 4b032e5e58c9..000000000000
--- a/src/thread/mipsn32/__unmapself.s
+++ /dev/null
@@ -1,9 +0,0 @@
-.set	noreorder
-.global	__unmapself
-.type	__unmapself,@function
-__unmapself:
-	li	$2, 6011
-	syscall
-	li	$4, 0
-	li	$2, 6058
-	syscall
diff --git a/src/thread/mipsn32/clone.s b/src/thread/mipsn32/clone.s
deleted file mode 100644
index 4d3c8c7a2502..000000000000
--- a/src/thread/mipsn32/clone.s
+++ /dev/null
@@ -1,34 +0,0 @@
-.set	noreorder
-.global	__clone
-.hidden __clone
-.type	__clone,@function
-__clone:
-	# Save function pointer and argument pointer on new thread stack
-	and	$5, $5, -16	# aligning stack to double word
-	subu	$5, $5, 16
-	sw	$4, 0($5)	# save function pointer
-	sw	$7, 4($5)	# save argument pointer
-
-	# Shuffle (fn,sp,fl,arg,ptid,tls,ctid) to (fl,sp,ptid,tls,ctid)
-	# sys_clone(u64 flags, u64 ustack_base, u64 parent_tidptr, u64 child_tidptr, u64 tls)
-	move	$4, $6
-	move	$6, $8
-	move	$7, $9
-	move	$8, $10
-	li	$2, 6055
-	syscall
-	beq	$7, $0, 1f
-	nop
-	jr	$ra
-	subu	$2, $0, $2
-1:	beq	$2, $0, 1f
-	nop
-	jr	$ra
-	nop
-1:	lw	$25, 0($sp)	# function pointer
-	lw	$4, 4($sp)	# argument pointer
-	jalr	$25		# call the user's function
-	nop
-	move 	$4, $2
-	li	$2, 6058
-	syscall
diff --git a/src/thread/mipsn32/syscall_cp.s b/src/thread/mipsn32/syscall_cp.s
deleted file mode 100644
index e85615bcb35d..000000000000
--- a/src/thread/mipsn32/syscall_cp.s
+++ /dev/null
@@ -1,51 +0,0 @@
-.set	noreorder
-.global	__cp_begin
-.hidden	__cp_begin
-.type	__cp_begin,@function
-.global	__cp_end
-.hidden	__cp_end
-.type	__cp_end,@function
-.global	__cp_cancel
-.hidden	__cp_cancel
-.type	__cp_cancel,@function
-.global	__cp_cancel_data
-.hidden	__cp_cancel_data
-.type	__cp_cancel_data,@function
-.hidden	__cancel
-.global	__syscall_cp_asm
-.hidden	__syscall_cp_asm
-.type	__syscall_cp_asm,@function
-__syscall_cp_asm:
-__cp_begin:
-	lw	$4, 0($4)
-	bne	$4, $0, __cp_cancel
-	move	$2, $5
-	move	$4, $6
-	move	$5, $7
-	move	$6, $8
-	move	$7, $9
-	move	$8, $10
-	move	$9, $11
-	lw	$10, 0($sp)
-	syscall
-__cp_end:
-	beq	$7, $0, 1f
-	nop
-	subu	$2, $0, $2
-1:	jr	$ra
-	nop
-
-	# if cancellation flag is 1 then call __cancel
-__cp_cancel:
-	move	$2, $ra
-	bal	1f
-	nop
-__cp_cancel_data:
-	.gpword __cp_cancel_data
-	.gpword __cancel
-1:	lw	$3, 0($ra)
-	subu	$3, $ra, $3
-	lw	$25, 4($ra)
-	addu	$25, $25, $3
-	jr	$25
-	move	$ra, $2
diff --git a/src/thread/or1k/__set_thread_area.s b/src/thread/or1k/__set_thread_area.s
deleted file mode 100644
index b9ffb9303b0d..000000000000
--- a/src/thread/or1k/__set_thread_area.s
+++ /dev/null
@@ -1,7 +0,0 @@
-.global __set_thread_area
-.hidden __set_thread_area
-.type   __set_thread_area,@function
-__set_thread_area:
-	l.ori	r10, r3, 0
-	l.jr	r9
-	 l.ori	r11, r0, 0
diff --git a/src/thread/or1k/__unmapself.s b/src/thread/or1k/__unmapself.s
deleted file mode 100644
index 6c0fa2acf2e3..000000000000
--- a/src/thread/or1k/__unmapself.s
+++ /dev/null
@@ -1,8 +0,0 @@
-.global __unmapself
-.type   __unmapself,@function
-__unmapself:
-	l.ori	r11, r0, 215 /* __NR_munmap */
-	l.sys	1
-	l.ori	r3, r0, 0
-	l.ori	r11, r0, 93 /* __NR_exit */
-	l.sys	1
diff --git a/src/thread/or1k/clone.s b/src/thread/or1k/clone.s
deleted file mode 100644
index 2473ac204036..000000000000
--- a/src/thread/or1k/clone.s
+++ /dev/null
@@ -1,31 +0,0 @@
-/* int clone(fn, stack, flags, arg, ptid, tls, ctid)
- *           r3  r4     r5     r6   sp+0  sp+4 sp+8
- * sys_clone(flags, stack, ptid, ctid, tls)
- */
-.global __clone
-.hidden __clone
-.type   __clone,@function
-__clone:
-	l.addi	r4, r4, -8
-	l.sw	0(r4), r3
-	l.sw	4(r4), r6
-	/* (fn, st, fl, ar, pt, tl, ct) => (fl, st, pt, ct, tl) */
-	l.ori	r3, r5, 0
-	l.lwz	r5, 0(r1)
-	l.lwz	r6, 8(r1)
-	l.lwz	r7, 4(r1)
-	l.ori	r11, r0, 220 /* __NR_clone */
-	l.sys	1
-
-	l.sfeqi	r11, 0
-	l.bf	1f
-	 l.nop
-	l.jr	r9
-	 l.nop
-
-1:	l.lwz	r11, 0(r1)
-	l.jalr	r11
-	 l.lwz	r3, 4(r1)
-
-	l.ori	r11, r0, 93 /* __NR_exit */
-	l.sys	1
diff --git a/src/thread/or1k/syscall_cp.s b/src/thread/or1k/syscall_cp.s
deleted file mode 100644
index 7951166ed93d..000000000000
--- a/src/thread/or1k/syscall_cp.s
+++ /dev/null
@@ -1,29 +0,0 @@
-.global __cp_begin
-.hidden __cp_begin
-.global __cp_end
-.hidden __cp_end
-.global __cp_cancel
-.hidden __cp_cancel
-.hidden __cancel
-.global __syscall_cp_asm
-.hidden __syscall_cp_asm
-.type   __syscall_cp_asm,@function
-__syscall_cp_asm:
-__cp_begin:
-	l.lwz	r3, 0(r3)
-	l.sfeqi	r3, 0
-	l.bnf	__cp_cancel
-	 l.ori	r11, r4, 0
-	l.ori	r3, r5, 0
-	l.ori	r4, r6, 0
-	l.ori	r5, r7, 0
-	l.ori	r6, r8, 0
-	l.lwz	r7, 0(r1)
-	l.lwz	r8, 4(r1)
-	l.sys	1
-__cp_end:
-	l.jr	r9
-	 l.nop
-__cp_cancel:
-	l.j	__cancel
-	 l.nop
diff --git a/src/thread/powerpc/__set_thread_area.s b/src/thread/powerpc/__set_thread_area.s
deleted file mode 100644
index 86c498fa3822..000000000000
--- a/src/thread/powerpc/__set_thread_area.s
+++ /dev/null
@@ -1,12 +0,0 @@
-.text
-.global __set_thread_area
-.hidden __set_thread_area
-.type   __set_thread_area, %function
-__set_thread_area:
-	# mov pointer in reg3 into r2
-	mr 2, 3
-	# put 0 into return reg
-	li 3, 0
-	# return
-	blr
-
diff --git a/src/thread/powerpc/__unmapself.s b/src/thread/powerpc/__unmapself.s
deleted file mode 100644
index c9360b47a692..000000000000
--- a/src/thread/powerpc/__unmapself.s
+++ /dev/null
@@ -1,9 +0,0 @@
-	.text
-	.global __unmapself
-	.type   __unmapself,%function
-__unmapself:
-	li      0, 91 # __NR_munmap
-	sc
-	li      0, 1 #__NR_exit
-	sc
-	blr
diff --git a/src/thread/powerpc/clone.s b/src/thread/powerpc/clone.s
deleted file mode 100644
index da13f446c03a..000000000000
--- a/src/thread/powerpc/clone.s
+++ /dev/null
@@ -1,73 +0,0 @@
-.text
-.global __clone
-.hidden __clone
-.type __clone, %function
-__clone:
-# int clone(fn, stack, flags, arg, ptid, tls, ctid)
-#            a  b       c     d     e    f    g
-#            3  4       5     6     7    8    9
-# pseudo C code:
-# tid = syscall(SYS_clone,c,b,e,f,g);
-# if (!tid) syscall(SYS_exit, a(d));
-# return tid;
-
-# SYS_clone = 120
-# SYS_exit = 1
-
-# store non-volatile regs r30, r31 on stack in order to put our
-# start func and its arg there
-stwu 30, -16(1)
-stw 31, 4(1)
-
-# save r3 (func) into r30, and r6(arg) into r31
-mr 30, 3
-mr 31, 6
-
-# create initial stack frame for new thread
-clrrwi 4, 4, 4
-li 0, 0
-stwu 0, -16(4)
-
-#move c into first arg
-mr 3, 5
-#mr 4, 4
-mr 5, 7
-mr 6, 8
-mr 7, 9
-
-# move syscall number into r0    
-li 0, 120
-
-sc
-
-# check for syscall error
-bns+ 1f # jump to label 1 if no summary overflow.
-#else
-neg 3, 3 #negate the result (errno)
-1:
-# compare sc result with 0
-cmpwi cr7, 3, 0
-
-# if not 0, jump to end
-bne cr7, 2f
-
-#else: we're the child
-#call funcptr: move arg (d) into r3
-mr 3, 31
-#move r30 (funcptr) into CTR reg
-mtctr 30
-# call CTR reg
-bctrl
-# mov SYS_exit into r0 (the exit param is already in r3)
-li 0, 1
-sc
-
-2:
-
-# restore stack
-lwz 30, 0(1)
-lwz 31, 4(1)
-addi 1, 1, 16
-
-blr
-
diff --git a/src/thread/powerpc/syscall_cp.s b/src/thread/powerpc/syscall_cp.s
deleted file mode 100644
index 77f8938dc8b7..000000000000
--- a/src/thread/powerpc/syscall_cp.s
+++ /dev/null
@@ -1,59 +0,0 @@
-.global __cp_begin
-.hidden __cp_begin
-.global __cp_end
-.hidden __cp_end
-.global __cp_cancel
-.hidden __cp_cancel
-.hidden __cancel
-.global __syscall_cp_asm
-.hidden __syscall_cp_asm
-
-#r0: volatile. may be modified during linkage.
-#r1: stack frame: 16 byte alignment.
-#r2: tls/thread pointer on pp32
-#r3,r4: return values, first args
-#r5-r10: args
-#r11-r12: volatile. may be modified during linkage
-#r13: "small data area" pointer
-#r14 - r30: local vars
-#r31: local or environment pointer
-
-#r1, r14-31: belong to the caller, must be saved and restored
-#r0, r3-r12, ctr, xer: volatile, not preserved
-#r0,r11,r12: may be altered by cross-module call, 
-#"a func cannot depend on that these regs have the values placed by the caller"
-
-#the fields CR2,CR2,CR4 of the cond reg must be preserved
-#LR (link reg) shall contain the funcs return address
-	.text
-	.type   __syscall_cp_asm,%function
-__syscall_cp_asm:
-	# at enter: r3 = pointer to self->cancel, r4: syscall no, r5: first arg, r6: 2nd, r7: 3rd, r8: 4th, r9: 5th, r10: 6th
-__cp_begin:
-	# r3 holds first argument, its a pointer to self->cancel. 
-	# we must compare the dereferenced value with 0 and jump to __cancel if its not
-	
-	lwz 0, 0(3) #deref pointer into r0
-	
-	cmpwi cr7, 0, 0 #compare r0 with 0, store result in cr7. 
-	beq+ cr7, 1f #jump to label 1 if r0 was 0
-	
-	b __cp_cancel #else call cancel
-1:
-	#ok, the cancel flag was not set
-	# syscall: number goes to r0, the rest 3-8
-	mr      0, 4                  # put the system call number into r0
-	mr      3, 5                  # Shift the arguments: arg1
-	mr      4, 6                  # arg2
-	mr      5, 7                  # arg3
-	mr      6, 8                  # arg4
-	mr      7, 9                  # arg5
-	mr      8, 10                  # arg6
-	sc
-__cp_end:
-	bnslr+ # return if no summary overflow. 
-	#else negate result.
-	neg 3, 3
-	blr
-__cp_cancel:
-	b __cancel
diff --git a/src/thread/powerpc64/__set_thread_area.s b/src/thread/powerpc64/__set_thread_area.s
deleted file mode 100644
index bb9c55d6d354..000000000000
--- a/src/thread/powerpc64/__set_thread_area.s
+++ /dev/null
@@ -1,9 +0,0 @@
-.text
-.global __set_thread_area
-.hidden __set_thread_area
-.type   __set_thread_area, %function
-__set_thread_area:
-	mr 13, 3
-	li  3, 0
-	blr
-
diff --git a/src/thread/powerpc64/__unmapself.s b/src/thread/powerpc64/__unmapself.s
deleted file mode 100644
index c9360b47a692..000000000000
--- a/src/thread/powerpc64/__unmapself.s
+++ /dev/null
@@ -1,9 +0,0 @@
-	.text
-	.global __unmapself
-	.type   __unmapself,%function
-__unmapself:
-	li      0, 91 # __NR_munmap
-	sc
-	li      0, 1 #__NR_exit
-	sc
-	blr
diff --git a/src/thread/powerpc64/clone.s b/src/thread/powerpc64/clone.s
deleted file mode 100644
index 41cb6787a7bc..000000000000
--- a/src/thread/powerpc64/clone.s
+++ /dev/null
@@ -1,48 +0,0 @@
-.text
-.global __clone
-.hidden __clone
-.type __clone, %function
-__clone:
-	# int clone(fn, stack, flags, arg, ptid, tls, ctid)
-	#            a  b       c     d     e    f    g
-	#            3  4       5     6     7    8    9
-	# pseudo C code:
-	# tid = syscall(SYS_clone,c,b,e,f,g);
-	# if (!tid) syscall(SYS_exit, a(d));
-	# return tid;
-
-	# create initial stack frame for new thread
-	clrrdi 4, 4, 4
-	li     0, 0
-	stdu   0,-32(4)
-
-	# save fn and arg to child stack
-	std    3,  8(4)
-	std    6, 16(4)
-
-	# shuffle args into correct registers and call SYS_clone
-	mr    3, 5
-	#mr   4, 4
-	mr    5, 7
-	mr    6, 8
-	mr    7, 9
-	li    0, 120  # SYS_clone = 120
-	sc
-
-	# if error, negate return (errno)
-	bns+  1f
-	neg   3, 3
-
-1:	# if we're the parent, return
-	cmpwi cr7, 3, 0
-	bnelr cr7
-
-	# we're the child. call fn(arg)
-	ld     3, 16(1)
-	ld    12,  8(1)
-	mtctr 12
-	bctrl
-
-	# call SYS_exit. exit code is already in r3 from fn return value
-	li    0, 1    # SYS_exit = 1
-	sc
diff --git a/src/thread/powerpc64/syscall_cp.s b/src/thread/powerpc64/syscall_cp.s
deleted file mode 100644
index ef50ed0073c4..000000000000
--- a/src/thread/powerpc64/syscall_cp.s
+++ /dev/null
@@ -1,44 +0,0 @@
-	.global __cp_begin
-	.hidden __cp_begin
-	.global __cp_end
-	.hidden __cp_end
-	.global __cp_cancel
-	.hidden __cp_cancel
-	.hidden __cancel
-	.global __syscall_cp_asm
-	.hidden __syscall_cp_asm
-	.text
-	.type   __syscall_cp_asm,%function
-__syscall_cp_asm:
-	# at enter: r3 = pointer to self->cancel, r4: syscall no, r5: first arg, r6: 2nd, r7: 3rd, r8: 4th, r9: 5th, r10: 6th
-__cp_begin:
-	# if (self->cancel) goto __cp_cancel
-	lwz   0, 0(3)
-	cmpwi cr7, 0, 0
-	bne-  cr7, __cp_cancel
-
-	# make syscall
-	mr    0,  4
-	mr    3,  5
-	mr    4,  6
-	mr    5,  7
-	mr    6,  8
-	mr    7,  9
-	mr    8, 10
-	sc
-
-__cp_end:
-	# return error ? -r3 : r3
-	bnslr+
-	neg 3, 3
-	blr
-
-__cp_cancel:
-	mflr 0
-	bl 1f
-	.long .TOC.-.
-1:	mflr 3
-	lwa 2, 0(3)
-	add 2, 2, 3
-	mtlr 0
-	b __cancel
diff --git a/src/thread/pthread_barrier_wait.c b/src/thread/pthread_barrier_wait.c
index cc2a8bbf58a9..8884fecf6708 100644
--- a/src/thread/pthread_barrier_wait.c
+++ b/src/thread/pthread_barrier_wait.c
@@ -84,8 +84,7 @@ int pthread_barrier_wait(pthread_barrier_t *b)
 			a_spin();
 		a_inc(&inst->finished);
 		while (inst->finished == 1)
-			__syscall(SYS_futex,&inst->finished,FUTEX_WAIT|FUTEX_PRIVATE,1,0) != -ENOSYS
-			|| __syscall(SYS_futex,&inst->finished,FUTEX_WAIT,1,0);
+			zsys_futex_wait(&inst->finished, 1, 1);
 		return PTHREAD_BARRIER_SERIAL_THREAD;
 	}
 
diff --git a/src/thread/pthread_cancel.c b/src/thread/pthread_cancel.c
index 139a6fc84e81..21ad177c8ff6 100644
--- a/src/thread/pthread_cancel.c
+++ b/src/thread/pthread_cancel.c
@@ -2,8 +2,9 @@
 #include <string.h>
 #include "pthread_impl.h"
 #include "syscall.h"
+#include <stdfil.h>
 
-hidden long __cancel(), __syscall_cp_asm(), __syscall_cp_c();
+hidden long __cancel();
 
 long __cancel()
 {
@@ -14,62 +15,15 @@ long __cancel()
 	return -ECANCELED;
 }
 
-long __syscall_cp_asm(volatile void *, syscall_arg_t,
-                      syscall_arg_t, syscall_arg_t, syscall_arg_t,
-                      syscall_arg_t, syscall_arg_t, syscall_arg_t);
-
-long __syscall_cp_c(syscall_arg_t nr,
-                    syscall_arg_t u, syscall_arg_t v, syscall_arg_t w,
-                    syscall_arg_t x, syscall_arg_t y, syscall_arg_t z)
-{
-	pthread_t self;
-	long r;
-	int st;
-
-	if ((st=(self=__pthread_self())->canceldisable)
-	    && (st==PTHREAD_CANCEL_DISABLE || nr==SYS_close))
-		return __syscall(nr, u, v, w, x, y, z);
-
-	r = __syscall_cp_asm(&self->cancel, nr, u, v, w, x, y, z);
-	if (r==-EINTR && nr!=SYS_close && self->cancel &&
-	    self->canceldisable != PTHREAD_CANCEL_DISABLE)
-		r = __cancel();
-	return r;
-}
-
 static void _sigaddset(sigset_t *set, int sig)
 {
 	unsigned s = sig-1;
 	set->__bits[s/8/sizeof *set->__bits] |= 1UL<<(s&8*sizeof *set->__bits-1);
 }
 
-extern hidden const char __cp_begin[1], __cp_end[1], __cp_cancel[1];
-
 static void cancel_handler(int sig, siginfo_t *si, void *ctx)
 {
-	pthread_t self = __pthread_self();
-	ucontext_t *uc = ctx;
-	uintptr_t pc = uc->uc_mcontext.MC_PC;
-
-	a_barrier();
-	if (!self->cancel || self->canceldisable == PTHREAD_CANCEL_DISABLE) return;
-
-	_sigaddset(&uc->uc_sigmask, SIGCANCEL);
-
-	if (self->cancelasync) {
-		pthread_sigmask(SIG_SETMASK, &uc->uc_sigmask, 0);
-		__cancel();
-	}
-
-	if (pc >= (uintptr_t)__cp_begin && pc < (uintptr_t)__cp_end) {
-		uc->uc_mcontext.MC_PC = (uintptr_t)__cp_cancel;
-#ifdef CANCEL_GOT
-		uc->uc_mcontext.MC_GOT = CANCEL_GOT;
-#endif
-		return;
-	}
-
-	__syscall(SYS_tkill, self->tid, SIGCANCEL);
+    zerror("cancel_handler not implemented");
 }
 
 void __testcancel()
diff --git a/src/thread/pthread_cond_init.c b/src/thread/pthread_cond_init.c
index 8c484ddcded2..75ea3136b57a 100644
--- a/src/thread/pthread_cond_init.c
+++ b/src/thread/pthread_cond_init.c
@@ -5,7 +5,7 @@ int pthread_cond_init(pthread_cond_t *restrict c, const pthread_condattr_t *rest
 	*c = (pthread_cond_t){0};
 	if (a) {
 		c->_c_clock = a->__attr & 0x7fffffff;
-		if (a->__attr>>31) c->_c_shared = (void *)-1;
+		if (a->__attr>>31) c->_c_shared = 1;
 	}
 	return 0;
 }
diff --git a/src/thread/pthread_cond_timedwait.c b/src/thread/pthread_cond_timedwait.c
index 6b761455c47f..af09a3556efc 100644
--- a/src/thread/pthread_cond_timedwait.c
+++ b/src/thread/pthread_cond_timedwait.c
@@ -49,8 +49,7 @@ static inline void unlock_requeue(volatile int *l, volatile int *r, int w)
 {
 	a_store(l, 0);
 	if (w) __wake(l, 1, 1);
-	else __syscall(SYS_futex, l, FUTEX_REQUEUE|FUTEX_PRIVATE, 0, 1, r) != -ENOSYS
-		|| __syscall(SYS_futex, l, FUTEX_REQUEUE, 0, 1, r);
+	else zsys_futex_requeue(l, 1, 0, 1, r);
 }
 
 enum {
diff --git a/src/thread/pthread_create.c b/src/thread/pthread_create.c
index 087f6206d5d6..7c051c3eea84 100644
--- a/src/thread/pthread_create.c
+++ b/src/thread/pthread_create.c
@@ -15,7 +15,6 @@ weak_alias(dummy_0, __release_ptc);
 weak_alias(dummy_0, __pthread_tsd_run_dtors);
 weak_alias(dummy_0, __do_orphaned_stdio_locks);
 weak_alias(dummy_0, __dl_thread_cleanup);
-weak_alias(dummy_0, __membarrier_init);
 
 static int tl_lock_count;
 static int tl_lock_waiters;
@@ -23,6 +22,7 @@ static int tl_lock_waiters;
 void __tl_lock(void)
 {
 	int tid = __pthread_self()->tid;
+	ZASSERT(tid);
 	int val = __thread_list_lock;
 	if (val == tid) {
 		tl_lock_count++;
@@ -114,6 +114,7 @@ _Noreturn void __pthread_exit(void *result)
 	 * see the thread as having exited. Release it now so that no
 	 * remaining locks (except thread list) are held if we end up
 	 * resetting need_locks below. */
+	ZASSERT(self->tid == zthread_self_id());
 	self->tid = 0;
 	UNLOCK(self->killlock);
 
@@ -150,26 +151,16 @@ _Noreturn void __pthread_exit(void *result)
 	self->prev = self->next = self;
 
 	if (state==DT_DETACHED && self->map_base) {
-		/* Detached threads must block even implementation-internal
-		 * signals, since they will not have a stack in their last
-		 * moments of existence. */
-		__block_all_sigs(&set);
-
-		/* Robust list will no longer be valid, and was already
-		 * processed above, so unregister it with the kernel. */
-		if (self->robust_list.off)
-			__syscall(SYS_set_robust_list, 0, 3*sizeof(long));
-
-		/* The following call unmaps the thread's stack mapping
-		 * and then exits without touching the stack. */
-		__unmapself(self->map_base, self->map_size);
+		/* I don't think we have to do anything special for detached threads. */
 	}
 
 	/* Wake any joiner. */
 	a_store(&self->detach_state, DT_EXITED);
 	__wake(&self->detach_state, 1, 1);
 
-	for (;;) __syscall(SYS_exit, 0);
+	__tl_unlock();
+	zthread_exit(0);
+	ZASSERT(!"Should not get here");
 }
 
 void __do_cleanup_push(struct __ptcb *cb)
@@ -188,29 +179,42 @@ struct start_args {
 	void *(*start_func)(void *);
 	void *start_arg;
 	volatile int control;
-	unsigned long sig_mask[_NSIG/8/sizeof(long)];
+	sigset_t sig_mask;
+	struct pthread *thread;
 };
 
-static int start(void *p)
+static void setup_thread(struct pthread* thread)
+{
+	ZASSERT(thread);
+	zthread_set_self_cookie(thread);
+	ZASSERT(!thread->tid || thread->tid == zthread_self_id());
+	thread->tid = zthread_self_id();
+}
+
+static void* start(void *p)
 {
 	struct start_args *args = p;
+	setup_thread(args->thread);
 	int state = args->control;
 	if (state) {
 		if (a_cas(&args->control, 1, 2)==1)
 			__wait(&args->control, 0, 2, 1);
 		if (args->control) {
-			__syscall(SYS_set_tid_address, &args->control);
-			for (;;) __syscall(SYS_exit, 0);
+			args->control = 0;
+			__wake(&args->control, 1, 0);
+			zthread_exit(0);
+			ZASSERT(!"Should not get here");
 		}
 	}
-	__syscall(SYS_rt_sigprocmask, SIG_SETMASK, &args->sig_mask, 0, _NSIG/8);
+	zsys_sigprocmask(SIG_SETMASK, &args->sig_mask, 0);
 	__pthread_exit(args->start_func(args->start_arg));
 	return 0;
 }
 
-static int start_c11(void *p)
+static void* start_c11(void *p)
 {
 	struct start_args *args = p;
+	setup_thread(args->thread);
 	int (*start)(void*) = (int(*)(void*)) args->start_func;
 	__pthread_exit((void *)(uintptr_t)start(args->start_arg));
 	return 0;
@@ -255,9 +259,7 @@ int __pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict att
 		init_file_lock(__stdin_used);
 		init_file_lock(__stdout_used);
 		init_file_lock(__stderr_used);
-		__syscall(SYS_rt_sigprocmask, SIG_UNBLOCK, SIGPT_SET, 0, _NSIG/8);
 		self->tsd = (void **)__pthread_tsd_main;
-		__membarrier_init();
 		libc.threaded = 1;
 	}
 	if (attrp && !c11) attr = *attrp;
@@ -269,48 +271,16 @@ int __pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict att
 	}
 
 	if (attr._a_stackaddr) {
-		size_t need = libc.tls_size + __pthread_tsd_size;
-		size = attr._a_stacksize;
-		stack = (void *)(attr._a_stackaddr & -16);
-		stack_limit = (void *)(attr._a_stackaddr - size);
-		/* Use application-provided stack for TLS only when
-		 * it does not take more than ~12% or 2k of the
-		 * application's stack space. */
-		if (need < size/8 && need < 2048) {
-			tsd = stack - __pthread_tsd_size;
-			stack = tsd - libc.tls_size;
-			memset(stack, 0, need);
-		} else {
-			size = ROUND(need);
-		}
-		guard = 0;
+		zerror("Cannot set custom stack address because memory safety.");
 	} else {
 		guard = ROUND(attr._a_guardsize);
 		size = guard + ROUND(attr._a_stacksize
 			+ libc.tls_size +  __pthread_tsd_size);
 	}
 
-	if (!tsd) {
-		if (guard) {
-			map = __mmap(0, size, PROT_NONE, MAP_PRIVATE|MAP_ANON, -1, 0);
-			if (map == MAP_FAILED) goto fail;
-			if (__mprotect(map+guard, size-guard, PROT_READ|PROT_WRITE)
-			    && errno != ENOSYS) {
-				__munmap(map, size);
-				goto fail;
-			}
-		} else {
-			map = __mmap(0, size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0);
-			if (map == MAP_FAILED) goto fail;
-		}
-		tsd = map + size - __pthread_tsd_size;
-		if (!stack) {
-			stack = tsd - libc.tls_size;
-			stack_limit = map + guard;
-		}
-	}
+	tsd = zgc_alloc(__pthread_tsd_size);
 
-	new = __copy_tls(tsd - libc.tls_size);
+	new = zgc_alloc(sizeof(struct pthread));
 	new->map_base = map;
 	new->map_size = size;
 	new->stack = stack;
@@ -328,12 +298,8 @@ int __pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict att
 	new->canary = self->canary;
 	new->sysinfo = self->sysinfo;
 
-	/* Setup argument structure for the new thread on its stack.
-	 * It's safe to access from the caller only until the thread
-	 * list is unlocked. */
-	stack -= (uintptr_t)stack % sizeof(uintptr_t);
-	stack -= sizeof(struct start_args);
-	struct start_args *args = (void *)stack;
+	struct start_args *args = zgc_alloc(sizeof(struct start_args));
+	args->thread = new;
 	args->start_func = entry;
 	args->start_arg = arg;
 	args->control = attr._a_sched ? 1 : 0;
@@ -347,13 +313,22 @@ int __pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict att
 	 * working with a copy of the set so we can restore the
 	 * original mask in the calling thread. */
 	memcpy(&args->sig_mask, &set, sizeof args->sig_mask);
-	args->sig_mask[(SIGCANCEL-1)/8/sizeof(long)] &=
-		~(1UL<<((SIGCANCEL-1)%(8*sizeof(long))));
+	ZASSERT(!__sigdelsetyolo(&args->sig_mask, SIGCANCEL));
 
 	__tl_lock();
 	if (!libc.threads_minus_1++) libc.need_locks = 1;
-	ret = __clone((c11 ? start_c11 : start), stack, flags, args, &new->tid, TP_ADJ(new), &__thread_list_lock);
-
+	void* zthread = zthread_create((c11 ? start_c11 : start), args);
+
+	if (zthread) {
+		unsigned new_tid = zthread_get_id(zthread);
+		ZASSERT(!new->tid || new->tid == new_tid);
+                new->zthread = zthread;
+		new->tid = new_tid;
+		ret = 0;
+	} else {
+		ret = -errno;
+	}
+	
 	/* All clone failures translate to EAGAIN. If explicit scheduling
 	 * was requested, attempt it before unlocking the thread list so
 	 * that the failed thread is never exposed and so that we can
@@ -362,7 +337,7 @@ int __pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict att
 		ret = -EAGAIN;
 	} else if (attr._a_sched) {
 		ret = __syscall(SYS_sched_setscheduler,
-			new->tid, attr._a_policy, &attr._a_prio);
+			new_tid, attr._a_policy, &attr._a_prio);
 		if (a_swap(&args->control, ret ? 3 : 0)==2)
 			__wake(&args->control, 1, 1);
 		if (ret)
@@ -382,7 +357,6 @@ int __pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict att
 	__release_ptc();
 
 	if (ret < 0) {
-		if (map) __munmap(map, size);
 		return -ret;
 	}
 
diff --git a/src/thread/pthread_getschedparam.c b/src/thread/pthread_getschedparam.c
index c098befb1b7f..f1ed13ca4476 100644
--- a/src/thread/pthread_getschedparam.c
+++ b/src/thread/pthread_getschedparam.c
@@ -10,10 +10,16 @@ int pthread_getschedparam(pthread_t t, int *restrict policy, struct sched_param
 	if (!t->tid) {
 		r = ESRCH;
 	} else {
-		r = -__syscall(SYS_sched_getparam, t->tid, param);
-		if (!r) {
-			*policy = __syscall(SYS_sched_getscheduler, t->tid);
-		}
+                int saved_errno = errno;
+                if (!zsys_sched_getparam(t->tid, param)) {
+                        int policy_result = zsys_sched_getscheduler(t->tid);
+                        ZASSERT(policy_result >= 0);
+                        *policy = policy_result;
+                        r = 0;
+                } else {
+                        r = errno;
+                }
+                errno = saved_errno;
 	}
 	UNLOCK(t->killlock);
 	__restore_sigs(&set);
diff --git a/src/thread/pthread_getspecific.c b/src/thread/pthread_getspecific.c
index d9342a560f7b..61b7dab1aece 100644
--- a/src/thread/pthread_getspecific.c
+++ b/src/thread/pthread_getspecific.c
@@ -9,3 +9,4 @@ static void *__pthread_getspecific(pthread_key_t k)
 
 weak_alias(__pthread_getspecific, pthread_getspecific);
 weak_alias(__pthread_getspecific, tss_get);
+
diff --git a/src/thread/pthread_kill.c b/src/thread/pthread_kill.c
index 79ddb20978f7..4d278e1251bf 100644
--- a/src/thread/pthread_kill.c
+++ b/src/thread/pthread_kill.c
@@ -3,16 +3,5 @@
 
 int pthread_kill(pthread_t t, int sig)
 {
-	int r;
-	sigset_t set;
-	/* Block not just app signals, but internal ones too, since
-	 * pthread_kill is used to implement pthread_cancel, which
-	 * must be async-cancel-safe. */
-	__block_all_sigs(&set);
-	LOCK(t->killlock);
-	r = t->tid ? -__syscall(SYS_tkill, t->tid, sig)
-		: (sig+0U >= _NSIG ? EINVAL : 0);
-	UNLOCK(t->killlock);
-	__restore_sigs(&set);
-	return r;
+	return zthread_kill(t->zthread, sig) ? 0 : errno;
 }
diff --git a/src/thread/pthread_mutex_timedlock.c b/src/thread/pthread_mutex_timedlock.c
index 9279fc54308a..b79c24c5fc5d 100644
--- a/src/thread/pthread_mutex_timedlock.c
+++ b/src/thread/pthread_mutex_timedlock.c
@@ -1,23 +1,5 @@
 #include "pthread_impl.h"
 
-#define IS32BIT(x) !((x)+0x80000000ULL>>32)
-#define CLAMP(x) (int)(IS32BIT(x) ? (x) : 0x7fffffffU+((0ULL+(x))>>63))
-
-static int __futex4(volatile void *addr, int op, int val, const struct timespec *to)
-{
-#ifdef SYS_futex_time64
-	time_t s = to ? to->tv_sec : 0;
-	long ns = to ? to->tv_nsec : 0;
-	int r = -ENOSYS;
-	if (SYS_futex == SYS_futex_time64 || !IS32BIT(s))
-		r = __syscall(SYS_futex_time64, addr, op, val,
-			to ? ((long long[]){s, ns}) : 0);
-	if (SYS_futex == SYS_futex_time64 || r!=-ENOSYS) return r;
-	to = to ? (void *)(long[]){CLAMP(s), ns} : 0;
-#endif
-	return __syscall(SYS_futex, addr, op, val, to);
-}
-
 static int pthread_mutex_timedlock_pi(pthread_mutex_t *restrict m, const struct timespec *restrict at)
 {
 	int type = m->_m_type;
@@ -27,7 +9,7 @@ static int pthread_mutex_timedlock_pi(pthread_mutex_t *restrict m, const struct
 
 	if (!priv) self->robust_list.pending = &m->_m_next;
 
-	do e = -__futex4(&m->_m_lock, FUTEX_LOCK_PI|priv, 0, at);
+	do e = -zsys_futex_lock_pi(&m->_m_lock, priv, at);
 	while (e==EINTR);
 	if (e) self->robust_list.pending = 0;
 
@@ -36,7 +18,7 @@ static int pthread_mutex_timedlock_pi(pthread_mutex_t *restrict m, const struct
 		/* Catch spurious success for non-robust mutexes. */
 		if (!(type&4) && ((m->_m_lock & 0x40000000) || m->_m_waiters)) {
 			a_store(&m->_m_waiters, -1);
-			__syscall(SYS_futex, &m->_m_lock, FUTEX_UNLOCK_PI|priv);
+			zsys_futex_unlock_pi(&m->_m_lock, priv);
 			self->robust_list.pending = 0;
 			break;
 		}
diff --git a/src/thread/pthread_mutex_trylock.c b/src/thread/pthread_mutex_trylock.c
index a24e7c58ac39..b337b0fadd8a 100644
--- a/src/thread/pthread_mutex_trylock.c
+++ b/src/thread/pthread_mutex_trylock.c
@@ -43,7 +43,7 @@ int __pthread_mutex_trylock_owner(pthread_mutex_t *m)
 success:
 	if ((type&8) && m->_m_waiters) {
 		int priv = (type & 128) ^ 128;
-		__syscall(SYS_futex, &m->_m_lock, FUTEX_UNLOCK_PI|priv);
+		zsys_futex_unlock_pi(&m->_m_lock, priv);
 		self->robust_list.pending = 0;
 		return (type&4) ? ENOTRECOVERABLE : EBUSY;
 	}
diff --git a/src/thread/pthread_mutex_unlock.c b/src/thread/pthread_mutex_unlock.c
index b66423e6c34f..2d67f54a6aa2 100644
--- a/src/thread/pthread_mutex_unlock.c
+++ b/src/thread/pthread_mutex_unlock.c
@@ -33,7 +33,7 @@ int __pthread_mutex_unlock(pthread_mutex_t *m)
 	if (type&8) {
 		if (old<0 || a_cas(&m->_m_lock, old, new)!=old) {
 			if (new) a_store(&m->_m_waiters, -1);
-			__syscall(SYS_futex, &m->_m_lock, FUTEX_UNLOCK_PI|priv);
+			zsys_futex_unlock_pi(&m->_m_lock, priv);
 		}
 		cont = 0;
 		waiters = 0;
diff --git a/src/thread/pthread_mutexattr_setprotocol.c b/src/thread/pthread_mutexattr_setprotocol.c
index 8b80c1ce9b14..444756a3f6d6 100644
--- a/src/thread/pthread_mutexattr_setprotocol.c
+++ b/src/thread/pthread_mutexattr_setprotocol.c
@@ -14,7 +14,7 @@ int pthread_mutexattr_setprotocol(pthread_mutexattr_t *a, int protocol)
 		r = check_pi_result;
 		if (r < 0) {
 			volatile int lk = 0;
-			r = -__syscall(SYS_futex, &lk, FUTEX_LOCK_PI, 0, 0);
+			r = -zsys_futex_lock_pi(&lk, 0, 0);
 			a_store(&check_pi_result, r);
 		}
 		if (r) return r;
diff --git a/src/thread/pthread_sigmask.c b/src/thread/pthread_sigmask.c
index f188782a3277..ed09c5e6a8e8 100644
--- a/src/thread/pthread_sigmask.c
+++ b/src/thread/pthread_sigmask.c
@@ -1,19 +1,12 @@
 #include <signal.h>
 #include <errno.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int pthread_sigmask(int how, const sigset_t *restrict set, sigset_t *restrict old)
 {
-	int ret;
-	if (set && (unsigned)how - SIG_BLOCK > 2U) return EINVAL;
-	ret = -__syscall(SYS_rt_sigprocmask, how, set, old, _NSIG/8);
-	if (!ret && old) {
-		if (sizeof old->__bits[0] == 8) {
-			old->__bits[0] &= ~0x380000000ULL;
-		} else {
-			old->__bits[0] &= ~0x80000000UL;
-			old->__bits[1] &= ~0x3UL;
-		}
-	}
-	return ret;
+    int result = zsys_sigprocmask(how, set, old);
+    if (result < 0)
+        return errno;
+    return 0;
 }
diff --git a/src/thread/riscv64/__set_thread_area.s b/src/thread/riscv64/__set_thread_area.s
deleted file mode 100644
index 828154d2976c..000000000000
--- a/src/thread/riscv64/__set_thread_area.s
+++ /dev/null
@@ -1,6 +0,0 @@
-.global __set_thread_area
-.type   __set_thread_area, %function
-__set_thread_area:
-	mv tp, a0
-	li a0, 0
-	ret
diff --git a/src/thread/riscv64/__unmapself.s b/src/thread/riscv64/__unmapself.s
deleted file mode 100644
index 2849119c395e..000000000000
--- a/src/thread/riscv64/__unmapself.s
+++ /dev/null
@@ -1,7 +0,0 @@
-.global __unmapself
-.type __unmapself, %function
-__unmapself:
-	li a7, 215 # SYS_munmap
-	ecall
-	li a7, 93  # SYS_exit
-	ecall
diff --git a/src/thread/riscv64/clone.s b/src/thread/riscv64/clone.s
deleted file mode 100644
index db908248cdcc..000000000000
--- a/src/thread/riscv64/clone.s
+++ /dev/null
@@ -1,34 +0,0 @@
-# __clone(func, stack, flags, arg, ptid, tls, ctid)
-#           a0,    a1,    a2,  a3,   a4,  a5,   a6
-
-# syscall(SYS_clone, flags, stack, ptid, tls, ctid)
-#                a7     a0,    a1,   a2,  a3,   a4
-
-.global __clone
-.type  __clone, %function
-__clone:
-	# Save func and arg to stack
-	addi a1, a1, -16
-	sd a0, 0(a1)
-	sd a3, 8(a1)
-
-	# Call SYS_clone
-	mv a0, a2
-	mv a2, a4
-	mv a3, a5
-	mv a4, a6
-	li a7, 220 # SYS_clone
-	ecall
-
-	beqz a0, 1f
-	# Parent
-	ret
-
-	# Child
-1:      ld a1, 0(sp)
-	ld a0, 8(sp)
-	jalr a1
-
-	# Exit
-	li a7, 93 # SYS_exit
-	ecall
diff --git a/src/thread/riscv64/syscall_cp.s b/src/thread/riscv64/syscall_cp.s
deleted file mode 100644
index eeef6391bf0f..000000000000
--- a/src/thread/riscv64/syscall_cp.s
+++ /dev/null
@@ -1,29 +0,0 @@
-.global __cp_begin
-.hidden __cp_begin
-.global __cp_end
-.hidden __cp_end
-.global __cp_cancel
-.hidden __cp_cancel
-.hidden __cancel
-.global __syscall_cp_asm
-.hidden __syscall_cp_asm
-.type __syscall_cp_asm, %function
-__syscall_cp_asm:
-__cp_begin:
-	lw t0, 0(a0)
-	bnez t0, __cp_cancel
-
-	mv t0, a1
-	mv a0, a2
-	mv a1, a3
-	mv a2, a4
-	mv a3, a5
-	mv a4, a6
-	mv a5, a7
-	ld a6, 0(sp)
-	mv a7, t0
-	ecall
-__cp_end:
-	ret
-__cp_cancel:
-	tail __cancel
diff --git a/src/thread/s390x/__set_thread_area.s b/src/thread/s390x/__set_thread_area.s
deleted file mode 100644
index 00a11e25444c..000000000000
--- a/src/thread/s390x/__set_thread_area.s
+++ /dev/null
@@ -1,10 +0,0 @@
-.text
-.global __set_thread_area
-.hidden __set_thread_area
-.type   __set_thread_area, %function
-__set_thread_area:
-	sar  %a1, %r2
-	srlg %r2, %r2, 32
-	sar  %a0, %r2
-	lghi %r2, 0
-	br   %r14
diff --git a/src/thread/s390x/__tls_get_offset.s b/src/thread/s390x/__tls_get_offset.s
deleted file mode 100644
index 8ee92de8eaea..000000000000
--- a/src/thread/s390x/__tls_get_offset.s
+++ /dev/null
@@ -1,17 +0,0 @@
-	.global __tls_get_offset
-	.type __tls_get_offset,%function
-__tls_get_offset:
-	stmg  %r14, %r15, 112(%r15)
-	aghi  %r15, -160
-
-	la    %r2, 0(%r2, %r12)
-	brasl %r14, __tls_get_addr
-
-	ear   %r1, %a0
-	sllg  %r1, %r1, 32
-	ear   %r1, %a1
-
-	sgr   %r2, %r1
-
-	lmg   %r14, %r15, 272(%r15)
-	br    %r14
diff --git a/src/thread/s390x/__unmapself.s b/src/thread/s390x/__unmapself.s
deleted file mode 100644
index 48b312cd301d..000000000000
--- a/src/thread/s390x/__unmapself.s
+++ /dev/null
@@ -1,6 +0,0 @@
-.text
-.global __unmapself
-.type   __unmapself, @function
-__unmapself:
-	svc 91 # SYS_munmap
-	svc 1  # SYS_exit
diff --git a/src/thread/s390x/clone.s b/src/thread/s390x/clone.s
deleted file mode 100644
index 2125f20b83c7..000000000000
--- a/src/thread/s390x/clone.s
+++ /dev/null
@@ -1,54 +0,0 @@
-.text
-.global __clone
-.hidden __clone
-.type __clone, %function
-__clone:
-	# int clone(
-	#    fn,      a = r2
-	#    stack,   b = r3
-	#    flags,   c = r4
-	#    arg,     d = r5
-	#    ptid,    e = r6
-	#    tls,     f = *(r15+160)
-	#    ctid)    g = *(r15+168)
-	#
-	# pseudo C code:
-	# tid = syscall(SYS_clone,b,c,e,g,f);
-	# if (!tid) syscall(SYS_exit, a(d));
-	# return tid;
-
-	# preserve call-saved register used as syscall arg
-	stg  %r6, 48(%r15)
-
-	# create initial stack frame for new thread
-	nill %r3, 0xfff8
-	aghi %r3, -160
-	lghi %r0, 0
-	stg  %r0, 0(%r3)
-
-	# save fn and arg to child stack
-	stg  %r2,  8(%r3)
-	stg  %r5, 16(%r3)
-
-	# shuffle args into correct registers and call SYS_clone
-	lgr  %r2, %r3
-	lgr  %r3, %r4
-	lgr  %r4, %r6
-	lg   %r5, 168(%r15)
-	lg   %r6, 160(%r15)
-	svc  120
-
-	# restore call-saved register
-	lg   %r6, 48(%r15)
-
-	# if error or if we're the parent, return
-	ltgr %r2, %r2
-	bnzr %r14
-
-	# we're the child. call fn(arg)
-	lg   %r1,  8(%r15)
-	lg   %r2, 16(%r15)
-	basr %r14, %r1
-
-	# call SYS_exit. exit code is already in r2 from fn return value
-	svc  1
diff --git a/src/thread/s390x/syscall_cp.s b/src/thread/s390x/syscall_cp.s
deleted file mode 100644
index d094cbf5ae10..000000000000
--- a/src/thread/s390x/syscall_cp.s
+++ /dev/null
@@ -1,34 +0,0 @@
-	.global __cp_begin
-	.hidden __cp_begin
-	.global __cp_end
-	.hidden __cp_end
-	.global __cp_cancel
-	.hidden __cp_cancel
-	.hidden __cancel
-	.global __syscall_cp_asm
-	.hidden __syscall_cp_asm
-	.text
-	.type   __syscall_cp_asm,%function
-__syscall_cp_asm:
-__cp_begin:
-	icm %r2, 15, 0(%r2)
-	jne __cp_cancel
-
-	stg %r6, 48(%r15)
-	stg %r7, 56(%r15)
-	lgr %r1, %r3
-	lgr %r2, %r4
-	lgr %r3, %r5
-	lgr %r4, %r6
-	lg  %r5, 160(%r15)
-	lg  %r6, 168(%r15)
-	lg  %r7, 176(%r15)
-	svc 0
-
-__cp_end:
-	lg  %r7, 56(%r15)
-	lg  %r6, 48(%r15)
-	br  %r14
-
-__cp_cancel:
-	jg  __cancel
diff --git a/src/thread/sh/__set_thread_area.c b/src/thread/sh/__set_thread_area.c
deleted file mode 100644
index 34264bddd9c1..000000000000
--- a/src/thread/sh/__set_thread_area.c
+++ /dev/null
@@ -1,37 +0,0 @@
-#include "pthread_impl.h"
-#include "libc.h"
-#include <elf.h>
-
-/* Also perform sh-specific init */
-
-#define CPU_HAS_LLSC 0x0040
-#define CPU_HAS_CAS_L 0x0400
-
-extern hidden const char __sh_cas_gusa[], __sh_cas_llsc[], __sh_cas_imask[], __sh_cas_cas_l[];
-
-hidden const void *__sh_cas_ptr;
-
-hidden unsigned __sh_nommu;
-
-int __set_thread_area(void *p)
-{
-	size_t *aux;
-	__asm__ __volatile__ ( "ldc %0, gbr" : : "r"(p) : "memory" );
-#ifndef __SH4A__
-	__sh_cas_ptr = __sh_cas_gusa;
-#if !defined(__SH3__) && !defined(__SH4__)
-	for (aux=libc.auxv; *aux; aux+=2) {
-		if (*aux != AT_PLATFORM) continue;
-		const char *s = (void *)aux[1];
-		if (s[0]!='s' || s[1]!='h' || s[2]!='2' || s[3]-'0'<10u) break;
-		__sh_cas_ptr = __sh_cas_imask;
-		__sh_nommu = 1;
-	}
-#endif
-	if (__hwcap & CPU_HAS_CAS_L)
-		__sh_cas_ptr = __sh_cas_cas_l;
-	else if (__hwcap & CPU_HAS_LLSC)
-		__sh_cas_ptr = __sh_cas_llsc;
-#endif
-	return 0;
-}
diff --git a/src/thread/sh/__unmapself.c b/src/thread/sh/__unmapself.c
deleted file mode 100644
index 35fb3c92d076..000000000000
--- a/src/thread/sh/__unmapself.c
+++ /dev/null
@@ -1,24 +0,0 @@
-#include "pthread_impl.h"
-
-hidden void __unmapself_sh_mmu(void *, size_t);
-hidden void __unmapself_sh_nommu(void *, size_t);
-
-#if !defined(__SH3__) && !defined(__SH4__)
-#define __unmapself __unmapself_sh_nommu
-#include "dynlink.h"
-#undef CRTJMP
-#define CRTJMP(pc,sp) __asm__ __volatile__( \
-	"mov.l @%0+,r0 ; mov.l @%0,r12 ; jmp @r0 ; mov %1,r15" \
-	: : "r"(pc), "r"(sp) : "r0", "memory" )
-#include "../__unmapself.c"
-#undef __unmapself
-extern hidden unsigned __sh_nommu;
-#else
-#define __sh_nommu 0
-#endif
-
-void __unmapself(void *base, size_t size)
-{
-	if (__sh_nommu) __unmapself_sh_nommu(base, size);
-	else __unmapself_sh_mmu(base, size);
-}
diff --git a/src/thread/sh/__unmapself_mmu.s b/src/thread/sh/__unmapself_mmu.s
deleted file mode 100644
index 688087b80fef..000000000000
--- a/src/thread/sh/__unmapself_mmu.s
+++ /dev/null
@@ -1,23 +0,0 @@
-.text
-.global __unmapself_sh_mmu
-.hidden __unmapself_sh_mmu
-.type   __unmapself_sh_mmu, @function
-__unmapself_sh_mmu:
-	mov   #91, r3  ! SYS_munmap
-	trapa #31
-
-	or    r0, r0
-	or    r0, r0
-	or    r0, r0
-	or    r0, r0
-	or    r0, r0
-
-	mov   #1, r3   ! SYS_exit
-	mov   #0, r4
-	trapa #31
-
-	or    r0, r0
-	or    r0, r0
-	or    r0, r0
-	or    r0, r0
-	or    r0, r0
diff --git a/src/thread/sh/atomics.s b/src/thread/sh/atomics.s
deleted file mode 100644
index 9d9fcb6eda58..000000000000
--- a/src/thread/sh/atomics.s
+++ /dev/null
@@ -1,65 +0,0 @@
-/* Contract for all versions is same as cas.l r2,r3,@r0
- * pr and r1 are also clobbered (by jsr & r1 as temp).
- * r0,r2,r4-r15 must be preserved.
- * r3 contains result (==r2 iff cas succeeded). */
-
-	.align 2
-.global __sh_cas_gusa
-.hidden __sh_cas_gusa
-__sh_cas_gusa:
-	mov.l r5,@-r15
-	mov.l r4,@-r15
-	mov r0,r4
-	mova 1f,r0
-	mov r15,r1
-	mov #(0f-1f),r15
-0:	mov.l @r4,r5
-	cmp/eq r5,r2
-	bf 1f
-	mov.l r3,@r4
-1:	mov r1,r15
-	mov r5,r3
-	mov r4,r0
-	mov.l @r15+,r4
-	rts
-	 mov.l @r15+,r5
-
-.global __sh_cas_llsc
-.hidden __sh_cas_llsc
-__sh_cas_llsc:
-	mov r0,r1
-	.word 0x00ab /* synco */
-0:	.word 0x0163 /* movli.l @r1,r0 */
-	cmp/eq r0,r2
-	bf 1f
-	mov r3,r0
-	.word 0x0173 /* movco.l r0,@r1 */
-	bf 0b
-	mov r2,r0
-1:	.word 0x00ab /* synco */
-	mov r0,r3
-	rts
-	 mov r1,r0
-
-.global __sh_cas_imask
-.hidden __sh_cas_imask
-__sh_cas_imask:
-	mov r0,r1
-	stc sr,r0
-	mov.l r0,@-r15
-	or #0xf0,r0
-	ldc r0,sr
-	mov.l @r1,r0
-	cmp/eq r0,r2
-	bf 1f
-	mov.l r3,@r1
-1:	ldc.l @r15+,sr
-	mov r0,r3
-	rts
-	 mov r1,r0
-
-.global __sh_cas_cas_l
-.hidden __sh_cas_cas_l
-__sh_cas_cas_l:
-	rts
-	 .word 0x2323 /* cas.l r2,r3,@r0 */
diff --git a/src/thread/sh/clone.s b/src/thread/sh/clone.s
deleted file mode 100644
index 9cfd8623c5d3..000000000000
--- a/src/thread/sh/clone.s
+++ /dev/null
@@ -1,54 +0,0 @@
-.text
-.global __clone
-.hidden __clone
-.type   __clone, @function
-__clone:
-! incoming: fn stack flags arg ptid tls      ctid
-!           r4 r5    r6    r7  @r15 @(4,r15) @(8,r15)
-
-	mov   #-16, r0
-	and   r0, r5
-
-	mov   r4, r1         ! r1 = fn
-	mov   r7, r2         ! r2 = arg
-
-	mov   #120,     r3   ! r3 = __NR_clone
-	mov   r6,       r4   ! r4 = flags
-	!mov  r5,       r5   ! r5 = stack
-	mov.l @r15,     r6   ! r6 = ptid
-	mov.l @(8,r15), r7   ! r7 = ctid
-	mov.l @(4,r15), r0   ! r0 = tls
-	trapa #31
-
-	or r0, r0
-	or r0, r0
-	or r0, r0
-	or r0, r0
-	or r0, r0
-
-	cmp/eq #0, r0
-	bt     1f
-
-	! we are the parent, return
-	rts
-	 nop
-
-1:	! we are the child, call fn(arg)
-	mov.l  1f, r0
-	mov    r1, r5
-	bsrf   r0
-	 mov    r2, r4
-
-2:	mov   #1, r3   ! __NR_exit
-	mov   r0, r4
-	trapa #31
-
-	or   r0, r0
-	or   r0, r0
-	or   r0, r0
-	or   r0, r0
-	or   r0, r0
-
-.align 2
-.hidden __shcall
-1:	.long __shcall@PCREL+(.-2b)
diff --git a/src/thread/sh/syscall_cp.s b/src/thread/sh/syscall_cp.s
deleted file mode 100644
index bb848ef3b671..000000000000
--- a/src/thread/sh/syscall_cp.s
+++ /dev/null
@@ -1,45 +0,0 @@
-.text
-.global __cp_begin
-.hidden __cp_begin
-.global __cp_end
-.hidden __cp_end
-.global __cp_cancel
-.hidden __cp_cancel
-.hidden __cancel
-.global __syscall_cp_asm
-.hidden __syscall_cp_asm
-.type   __syscall_cp_asm, @function
-__syscall_cp_asm:
-
-__cp_begin:
-	mov.l @r4, r4
-	tst   r4, r4
-	bf    __cp_cancel
-	mov   r5, r3
-	mov   r6, r4
-	mov   r7, r5
-	mov.l @r15, r6
-	mov.l @(4,r15), r7
-	mov.l @(8,r15), r0
-	mov.l @(12,r15), r1
-	trapa #31
-
-__cp_end:
-	! work around hardware bug
-	or   r0, r0
-	or   r0, r0
-	or   r0, r0
-	or   r0, r0
-	or   r0, r0
-
-	rts
-	 nop
-
-__cp_cancel:
-	mov.l 2f, r0
-	braf  r0
-	 nop
-1:
-
-.align 2
-2:	.long __cancel@PCREL-(1b-.)
diff --git a/src/thread/synccall.c b/src/thread/synccall.c
deleted file mode 100644
index 3859725428ce..000000000000
--- a/src/thread/synccall.c
+++ /dev/null
@@ -1,122 +0,0 @@
-#include "pthread_impl.h"
-#include <semaphore.h>
-#include <string.h>
-
-static void dummy_0(void)
-{
-}
-
-weak_alias(dummy_0, __tl_lock);
-weak_alias(dummy_0, __tl_unlock);
-
-static int target_tid;
-static void (*callback)(void *), *context;
-static sem_t target_sem, caller_sem, exit_sem;
-
-static void dummy(void *p)
-{
-}
-
-static void handler(int sig)
-{
-	if (__pthread_self()->tid != target_tid) return;
-
-	int old_errno = errno;
-
-	/* Inform caller we have received signal and wait for
-	 * the caller to let us make the callback. */
-	sem_post(&caller_sem);
-	sem_wait(&target_sem);
-
-	callback(context);
-
-	/* Inform caller we've complered the callback and wait
-	 * for the caller to release us to return. */
-	sem_post(&caller_sem);
-	sem_wait(&exit_sem);
-
-	/* Inform caller we are returning and state is destroyable. */
-	sem_post(&caller_sem);
-
-	errno = old_errno;
-}
-
-void __synccall(void (*func)(void *), void *ctx)
-{
-	sigset_t oldmask;
-	int cs, i, r;
-	struct sigaction sa = { .sa_flags = SA_RESTART | SA_ONSTACK, .sa_handler = handler };
-	pthread_t self = __pthread_self(), td;
-	int count = 0;
-
-	/* Blocking signals in two steps, first only app-level signals
-	 * before taking the lock, then all signals after taking the lock,
-	 * is necessary to achieve AS-safety. Blocking them all first would
-	 * deadlock if multiple threads called __synccall. Waiting to block
-	 * any until after the lock would allow re-entry in the same thread
-	 * with the lock already held. */
-	__block_app_sigs(&oldmask);
-	__tl_lock();
-	__block_all_sigs(0);
-	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
-
-	sem_init(&target_sem, 0, 0);
-	sem_init(&caller_sem, 0, 0);
-	sem_init(&exit_sem, 0, 0);
-
-	if (!libc.threads_minus_1 || __syscall(SYS_gettid) != self->tid)
-		goto single_threaded;
-
-	callback = func;
-	context = ctx;
-
-	/* Block even implementation-internal signals, so that nothing
-	 * interrupts the SIGSYNCCALL handlers. The main possible source
-	 * of trouble is asynchronous cancellation. */
-	memset(&sa.sa_mask, -1, sizeof sa.sa_mask);
-	__libc_sigaction(SIGSYNCCALL, &sa, 0);
-
-
-	for (td=self->next; td!=self; td=td->next) {
-		target_tid = td->tid;
-		while ((r = -__syscall(SYS_tkill, td->tid, SIGSYNCCALL)) == EAGAIN);
-		if (r) {
-			/* If we failed to signal any thread, nop out the
-			 * callback to abort the synccall and just release
-			 * any threads already caught. */
-			callback = func = dummy;
-			break;
-		}
-		sem_wait(&caller_sem);
-		count++;
-	}
-	target_tid = 0;
-
-	/* Serialize execution of callback in caught threads, or just
-	 * release them all if synccall is being aborted. */
-	for (i=0; i<count; i++) {
-		sem_post(&target_sem);
-		sem_wait(&caller_sem);
-	}
-
-	sa.sa_handler = SIG_IGN;
-	__libc_sigaction(SIGSYNCCALL, &sa, 0);
-
-single_threaded:
-	func(ctx);
-
-	/* Only release the caught threads once all threads, including the
-	 * caller, have returned from the callback function. */
-	for (i=0; i<count; i++)
-		sem_post(&exit_sem);
-	for (i=0; i<count; i++)
-		sem_wait(&caller_sem);
-
-	sem_destroy(&caller_sem);
-	sem_destroy(&target_sem);
-	sem_destroy(&exit_sem);
-
-	pthread_setcancelstate(cs, 0);
-	__tl_unlock();
-	__restore_sigs(&oldmask);
-}
diff --git a/src/thread/thrd_yield.c b/src/thread/thrd_yield.c
index f7ad13219ce0..341673293261 100644
--- a/src/thread/thrd_yield.c
+++ b/src/thread/thrd_yield.c
@@ -3,5 +3,5 @@
 
 void thrd_yield()
 {
-	__syscall(SYS_sched_yield);
+	zsys_sched_yield();
 }
diff --git a/src/thread/x32/__set_thread_area.s b/src/thread/x32/__set_thread_area.s
deleted file mode 100644
index c0fee87e6a17..000000000000
--- a/src/thread/x32/__set_thread_area.s
+++ /dev/null
@@ -1,11 +0,0 @@
-/* Copyright 2011-2012 Nicholas J. Kain, licensed under standard MIT license */
-.text
-.global __set_thread_area
-.hidden __set_thread_area
-.type __set_thread_area,@function
-__set_thread_area:
-	mov %edi,%esi           /* shift for syscall */
-	movl $0x1002,%edi       /* SET_FS register */
-	movl $0x4000009e,%eax          /* set fs segment to */
-	syscall                 /* arch_prctl(SET_FS, arg)*/
-	ret
diff --git a/src/thread/x32/__unmapself.s b/src/thread/x32/__unmapself.s
deleted file mode 100644
index d9254601ff76..000000000000
--- a/src/thread/x32/__unmapself.s
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Copyright 2011-2012 Nicholas J. Kain, licensed under standard MIT license */
-.text
-.global __unmapself
-.type   __unmapself,@function
-__unmapself:
-	movl $0x4000000b,%eax   /* SYS_munmap */
-	syscall         /* munmap(arg2,arg3) */
-	xor %rdi,%rdi   /* exit() args: always return success */
-	movl $0x4000003c,%eax   /* SYS_exit */
-	syscall         /* exit(0) */
diff --git a/src/thread/x32/clone.s b/src/thread/x32/clone.s
deleted file mode 100644
index b870880f93d4..000000000000
--- a/src/thread/x32/clone.s
+++ /dev/null
@@ -1,26 +0,0 @@
-.text
-.global __clone
-.hidden __clone
-.type   __clone,@function
-__clone:
-	movl $0x40000038,%eax /* SYS_clone */
-	mov %rdi,%r11
-	mov %rdx,%rdi
-	mov %r8,%rdx
-	mov %r9,%r8
-	mov 8(%rsp),%r10
-	mov %r11,%r9
-	and $-16,%rsi
-	sub $8,%rsi
-	mov %rcx,(%rsi)
-	syscall
-	test %eax,%eax
-	jnz 1f
-	xor %ebp,%ebp
-	pop %rdi
-	call *%r9
-	mov %eax,%edi
-	movl $0x4000003c,%eax /* SYS_exit */
-	syscall
-	hlt
-1:	ret
diff --git a/src/thread/x32/syscall_cp.s b/src/thread/x32/syscall_cp.s
deleted file mode 100644
index 4f101716d4ee..000000000000
--- a/src/thread/x32/syscall_cp.s
+++ /dev/null
@@ -1,31 +0,0 @@
-.text
-.global __cp_begin
-.hidden __cp_begin
-.global __cp_end
-.hidden __cp_end
-.global __cp_cancel
-.hidden __cp_cancel
-.hidden __cancel
-.global __syscall_cp_asm
-.hidden __syscall_cp_asm
-.type   __syscall_cp_asm,@function
-__syscall_cp_asm:
-
-__cp_begin:
-	mov (%rdi),%eax
-	test %eax,%eax
-	jnz __cp_cancel
-	mov %rdi,%r11
-	mov %rsi,%rax
-	mov %rdx,%rdi
-	mov %rcx,%rsi
-	mov %r8,%rdx
-	mov %r9,%r10
-	mov 8(%rsp),%r8
-	mov 16(%rsp),%r9
-	mov %r11,8(%rsp)
-	syscall
-__cp_end:
-	ret
-__cp_cancel:
-	jmp __cancel
diff --git a/src/thread/x86_64/__set_thread_area.s b/src/thread/x86_64/__set_thread_area.s
deleted file mode 100644
index 7347ff4dc1e1..000000000000
--- a/src/thread/x86_64/__set_thread_area.s
+++ /dev/null
@@ -1,11 +0,0 @@
-/* Copyright 2011-2012 Nicholas J. Kain, licensed under standard MIT license */
-.text
-.global __set_thread_area
-.hidden __set_thread_area
-.type __set_thread_area,@function
-__set_thread_area:
-	mov %rdi,%rsi           /* shift for syscall */
-	movl $0x1002,%edi       /* SET_FS register */
-	movl $158,%eax          /* set fs segment to */
-	syscall                 /* arch_prctl(SET_FS, arg)*/
-	ret
diff --git a/src/thread/x86_64/__unmapself.s b/src/thread/x86_64/__unmapself.s
deleted file mode 100644
index e2689e65052c..000000000000
--- a/src/thread/x86_64/__unmapself.s
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Copyright 2011-2012 Nicholas J. Kain, licensed under standard MIT license */
-.text
-.global __unmapself
-.type   __unmapself,@function
-__unmapself:
-	movl $11,%eax   /* SYS_munmap */
-	syscall         /* munmap(arg2,arg3) */
-	xor %rdi,%rdi   /* exit() args: always return success */
-	movl $60,%eax   /* SYS_exit */
-	syscall         /* exit(0) */
diff --git a/src/thread/x86_64/clone.s b/src/thread/x86_64/clone.s
deleted file mode 100644
index 6e47bc0a37de..000000000000
--- a/src/thread/x86_64/clone.s
+++ /dev/null
@@ -1,28 +0,0 @@
-.text
-.global __clone
-.hidden __clone
-.type   __clone,@function
-__clone:
-	xor %eax,%eax
-	mov $56,%al
-	mov %rdi,%r11
-	mov %rdx,%rdi
-	mov %r8,%rdx
-	mov %r9,%r8
-	mov 8(%rsp),%r10
-	mov %r11,%r9
-	and $-16,%rsi
-	sub $8,%rsi
-	mov %rcx,(%rsi)
-	syscall
-	test %eax,%eax
-	jnz 1f
-	xor %ebp,%ebp
-	pop %rdi
-	call *%r9
-	mov %eax,%edi
-	xor %eax,%eax
-	mov $60,%al
-	syscall
-	hlt
-1:	ret
diff --git a/src/thread/x86_64/syscall_cp.s b/src/thread/x86_64/syscall_cp.s
deleted file mode 100644
index 4f101716d4ee..000000000000
--- a/src/thread/x86_64/syscall_cp.s
+++ /dev/null
@@ -1,31 +0,0 @@
-.text
-.global __cp_begin
-.hidden __cp_begin
-.global __cp_end
-.hidden __cp_end
-.global __cp_cancel
-.hidden __cp_cancel
-.hidden __cancel
-.global __syscall_cp_asm
-.hidden __syscall_cp_asm
-.type   __syscall_cp_asm,@function
-__syscall_cp_asm:
-
-__cp_begin:
-	mov (%rdi),%eax
-	test %eax,%eax
-	jnz __cp_cancel
-	mov %rdi,%r11
-	mov %rsi,%rax
-	mov %rdx,%rdi
-	mov %rcx,%rsi
-	mov %r8,%rdx
-	mov %r9,%r10
-	mov 8(%rsp),%r8
-	mov 16(%rsp),%r9
-	mov %r11,8(%rsp)
-	syscall
-__cp_end:
-	ret
-__cp_cancel:
-	jmp __cancel
diff --git a/src/time/__map_file.c b/src/time/__map_file.c
index c2b29fe81b90..51ad1334de7b 100644
--- a/src/time/__map_file.c
+++ b/src/time/__map_file.c
@@ -2,17 +2,18 @@
 #include <fcntl.h>
 #include <sys/stat.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 const char unsigned *__map_file(const char *pathname, size_t *size)
 {
 	struct stat st;
 	const unsigned char *map = MAP_FAILED;
-	int fd = sys_open(pathname, O_RDONLY|O_CLOEXEC|O_NONBLOCK);
+	int fd = zsys_open(pathname, O_RDONLY|O_CLOEXEC|O_NONBLOCK);
 	if (fd < 0) return 0;
 	if (!__fstat(fd, &st)) {
 		map = __mmap(0, st.st_size, PROT_READ, MAP_SHARED, fd, 0);
 		*size = st.st_size;
 	}
-	__syscall(SYS_close, fd);
+	zsys_close(fd);
 	return map == MAP_FAILED ? 0 : map;
 }
diff --git a/src/time/clock_getres.c b/src/time/clock_getres.c
index 81c6703761d4..ac3ae3c1bec0 100644
--- a/src/time/clock_getres.c
+++ b/src/time/clock_getres.c
@@ -3,19 +3,5 @@
 
 int clock_getres(clockid_t clk, struct timespec *ts)
 {
-#ifdef SYS_clock_getres_time64
-	/* On a 32-bit arch, use the old syscall if it exists. */
-	if (SYS_clock_getres != SYS_clock_getres_time64) {
-		long ts32[2];
-		int r = __syscall(SYS_clock_getres, clk, ts32);
-		if (!r && ts) {
-			ts->tv_sec = ts32[0];
-			ts->tv_nsec = ts32[1];
-		}
-		return __syscall_ret(r);
-	}
-#endif
-	/* If reaching this point, it's a 64-bit arch or time64-only
-	 * 32-bit arch and we can get result directly into timespec. */
-	return syscall(SYS_clock_getres, clk, ts);
+        return zsys_clock_getres(clk, ts);
 }
diff --git a/src/time/clock_gettime.c b/src/time/clock_gettime.c
index 4d2ec22f38a0..f55fb05fc0d8 100644
--- a/src/time/clock_gettime.c
+++ b/src/time/clock_gettime.c
@@ -3,6 +3,7 @@
 #include <stdint.h>
 #include "syscall.h"
 #include "atomic.h"
+#include <stdfil.h>
 
 #ifdef VDSO_CGT_SYM
 
@@ -58,57 +59,7 @@ static void *volatile vdso_func = (void *)cgt_init;
 
 int __clock_gettime(clockid_t clk, struct timespec *ts)
 {
-	int r;
-
-#ifdef VDSO_CGT_SYM
-	int (*f)(clockid_t, struct timespec *) =
-		(int (*)(clockid_t, struct timespec *))vdso_func;
-	if (f) {
-		r = f(clk, ts);
-		if (!r) return r;
-		if (r == -EINVAL) return __syscall_ret(r);
-		/* Fall through on errors other than EINVAL. Some buggy
-		 * vdso implementations return ENOSYS for clocks they
-		 * can't handle, rather than making the syscall. This
-		 * also handles the case where cgt_init fails to find
-		 * a vdso function to use. */
-	}
-#endif
-
-#ifdef SYS_clock_gettime64
-	r = -ENOSYS;
-	if (sizeof(time_t) > 4)
-		r = __syscall(SYS_clock_gettime64, clk, ts);
-	if (SYS_clock_gettime == SYS_clock_gettime64 || r!=-ENOSYS)
-		return __syscall_ret(r);
-	long ts32[2];
-	r = __syscall(SYS_clock_gettime, clk, ts32);
-#ifdef SYS_gettimeofday
-	if (r==-ENOSYS && clk==CLOCK_REALTIME) {
-		r = __syscall(SYS_gettimeofday, ts32, 0);
-		ts32[1] *= 1000;
-	}
-#endif
-	if (!r) {
-		ts->tv_sec = ts32[0];
-		ts->tv_nsec = ts32[1];
-		return r;
-	}
-	return __syscall_ret(r);
-#else
-	r = __syscall(SYS_clock_gettime, clk, ts);
-#ifdef SYS_gettimeofday
-	if (r == -ENOSYS) {
-		if (clk == CLOCK_REALTIME) {
-			__syscall(SYS_gettimeofday, ts, 0);
-			ts->tv_nsec = (int)ts->tv_nsec * 1000;
-			return 0;
-		}
-		r = -EINVAL;
-	}
-#endif
-	return __syscall_ret(r);
-#endif
+    return zsys_clock_gettime(clk, (unsigned long long*)ts);
 }
 
 weak_alias(__clock_gettime, clock_gettime);
diff --git a/src/time/clock_nanosleep.c b/src/time/clock_nanosleep.c
index e195499cc072..4e7a2d15c291 100644
--- a/src/time/clock_nanosleep.c
+++ b/src/time/clock_nanosleep.c
@@ -2,37 +2,9 @@
 #include <errno.h>
 #include "syscall.h"
 
-#define IS32BIT(x) !((x)+0x80000000ULL>>32)
-#define CLAMP(x) (int)(IS32BIT(x) ? (x) : 0x7fffffffU+((0ULL+(x))>>63))
-
 int __clock_nanosleep(clockid_t clk, int flags, const struct timespec *req, struct timespec *rem)
 {
-	if (clk == CLOCK_THREAD_CPUTIME_ID) return EINVAL;
-#ifdef SYS_clock_nanosleep_time64
-	time_t s = req->tv_sec;
-	long ns = req->tv_nsec;
-	int r = -ENOSYS;
-	if (SYS_clock_nanosleep == SYS_clock_nanosleep_time64 || !IS32BIT(s))
-		r = __syscall_cp(SYS_clock_nanosleep_time64, clk, flags,
-			((long long[]){s, ns}), rem);
-	if (SYS_clock_nanosleep == SYS_clock_nanosleep_time64 || r!=-ENOSYS)
-		return -r;
-	long long extra = s - CLAMP(s);
-	long ts32[2] = { CLAMP(s), ns };
-	if (clk == CLOCK_REALTIME && !flags)
-		r = __syscall_cp(SYS_nanosleep, &ts32, &ts32);
-	else
-		r = __syscall_cp(SYS_clock_nanosleep, clk, flags, &ts32, &ts32);
-	if (r==-EINTR && rem && !(flags & TIMER_ABSTIME)) {
-		rem->tv_sec = ts32[0] + extra;
-		rem->tv_nsec = ts32[1];
-	}
-	return -r;
-#else
-	if (clk == CLOCK_REALTIME && !flags)
-		return -__syscall_cp(SYS_nanosleep, req, rem);
-	return -__syscall_cp(SYS_clock_nanosleep, clk, flags, req, rem);
-#endif
+	return zsys_clock_nanosleep(clk, flags, req, rem);
 }
 
 weak_alias(__clock_nanosleep, clock_nanosleep);
diff --git a/src/time/nanosleep.c b/src/time/nanosleep.c
index bc9f7895fa08..6c6c5c92fd00 100644
--- a/src/time/nanosleep.c
+++ b/src/time/nanosleep.c
@@ -3,5 +3,5 @@
 
 int nanosleep(const struct timespec *req, struct timespec *rem)
 {
-	return __syscall_ret(-__clock_nanosleep(CLOCK_REALTIME, 0, req, rem));
+    return zsys_nanosleep(req, rem);
 }
diff --git a/src/time/strftime.c b/src/time/strftime.c
index cc53d5369ca7..9301b68dbfc8 100644
--- a/src/time/strftime.c
+++ b/src/time/strftime.c
@@ -5,6 +5,7 @@
 #include <locale.h>
 #include <time.h>
 #include <limits.h>
+#include <ctype.h>
 #include "locale_impl.h"
 #include "time_impl.h"
 
@@ -48,6 +49,7 @@ const char *__strftime_fmt_1(char (*s)[100], size_t *l, int f, const struct tm *
 	long long val;
 	const char *fmt = "-";
 	int width = 2, def_pad = '0';
+	int do_tolower = 0;
 
 	switch (f) {
 	case 'a':
@@ -113,6 +115,8 @@ const char *__strftime_fmt_1(char (*s)[100], size_t *l, int f, const struct tm *
 	case 'n':
 		*l = 1;
 		return "\n";
+	case 'P':
+		do_tolower = 1;
 	case 'p':
 		item = tm->tm_hour >= 12 ? PM_STR : AM_STR;
 		goto nl_strcat;
@@ -188,6 +192,20 @@ const char *__strftime_fmt_1(char (*s)[100], size_t *l, int f, const struct tm *
 	case '%':
 		*l = 1;
 		return "%";
+	case 'k':
+		val = tm->tm_hour;
+		def_pad = '_';
+		width = 2;
+		goto number;
+	case 'l':
+		val = tm->tm_hour;
+		if (!val)
+			val = 12;
+		else if (val > 12)
+			val -= 12;
+		def_pad = '_';
+		width = 2;
+		goto number;
 	default:
 		return 0;
 	}
@@ -201,6 +219,14 @@ number:
 	return *s;
 nl_strcat:
 	fmt = __nl_langinfo_l(item, loc);
+	if (do_tolower) {
+		char* new_fmt = malloc(strlen(fmt) + 1);
+		size_t i;
+		/* OMG this is so wrong lmao. Should it, like, use ICU or something? */
+		for (i = 0; fmt[i]; ++i)
+			new_fmt[i] = tolower_l(fmt[i], loc);
+		fmt = new_fmt;
+	}
 string:
 	*l = strlen(fmt);
 	return fmt;
diff --git a/src/time/timer_create.c b/src/time/timer_create.c
index 9216b3abc568..9031f9ac20ea 100644
--- a/src/time/timer_create.c
+++ b/src/time/timer_create.c
@@ -38,6 +38,7 @@ static void *start(void *arg)
 	pthread_t self = __pthread_self();
 	struct start_args *args = arg;
 	jmp_buf jb;
+        sigset_t timer_set;
 
 	void (*notify)(union sigval) = args->sev->sigev_notify_function;
 	union sigval val = args->sev->sigev_value;
@@ -45,9 +46,10 @@ static void *start(void *arg)
 	pthread_barrier_wait(&args->b);
 	if (self->cancel)
 		return 0;
+        sigaddset(&timer_set, SIGTIMER);
 	for (;;) {
 		siginfo_t si;
-		while (sigwaitinfo(SIGTIMER_SET, &si) < 0);
+		while (sigwaitinfo(&timer_set, &si) < 0);
 		if (si.si_code == SI_TIMER && !setjmp(jb)) {
 			pthread_cleanup_push(cleanup_fromsig, jb);
 			notify(val);
@@ -55,7 +57,7 @@ static void *start(void *arg)
 		}
 		if (self->timer_id < 0) break;
 	}
-	__syscall(SYS_timer_delete, self->timer_id & INT_MAX);
+        zsys_timer_delete(self->timer_id & INT_MAX);
 	return 0;
 }
 
@@ -69,6 +71,7 @@ int timer_create(clockid_t clk, struct sigevent *restrict evp, timer_t *restrict
 	struct ksigevent ksev, *ksevp=0;
 	int timerid;
 	sigset_t set;
+	sigset_t timer_set;
 
 	switch (evp ? evp->sigev_notify : SIGEV_SIGNAL) {
 	case SIGEV_NONE:
@@ -84,7 +87,7 @@ int timer_create(clockid_t clk, struct sigevent *restrict evp, timer_t *restrict
 				ksev.sigev_tid = 0;
 			ksevp = &ksev;
 		}
-		if (syscall(SYS_timer_create, clk, ksevp, &timerid) < 0)
+		if (zsys_timer_create(clk, ksevp, &timerid) < 0)
 			return -1;
 		*res = (void *)(intptr_t)timerid;
 		break;
@@ -103,7 +106,8 @@ int timer_create(clockid_t clk, struct sigevent *restrict evp, timer_t *restrict
 		args.sev = evp;
 
 		__block_app_sigs(&set);
-		__syscall(SYS_rt_sigprocmask, SIG_BLOCK, SIGTIMER_SET, 0, _NSIG/8);
+                sigaddset(&timer_set, SIGTIMER);
+                zsys_sigprocmask(SIG_BLOCK, &timer_set, NULL);
 		r = pthread_create(&td, &attr, start, &args);
 		__restore_sigs(&set);
 		if (r) {
@@ -115,7 +119,7 @@ int timer_create(clockid_t clk, struct sigevent *restrict evp, timer_t *restrict
 		ksev.sigev_signo = SIGTIMER;
 		ksev.sigev_notify = SIGEV_THREAD_ID;
 		ksev.sigev_tid = td->tid;
-		if (syscall(SYS_timer_create, clk, &ksev, &timerid) < 0) {
+		if (zsys_timer_create(clk, &ksev, &timerid) < 0) {
 			timerid = -1;
 			td->cancel = 1;
 		}
diff --git a/src/time/timer_delete.c b/src/time/timer_delete.c
index b0bfac0968a7..4f722392489c 100644
--- a/src/time/timer_delete.c
+++ b/src/time/timer_delete.c
@@ -7,8 +7,8 @@ int timer_delete(timer_t t)
 	if ((intptr_t)t < 0) {
 		pthread_t td = (void *)((uintptr_t)t << 1);
 		a_store(&td->timer_id, td->timer_id | INT_MIN);
-		__syscall(SYS_tkill, td->tid, SIGTIMER);
+		zthread_kill(td->zthread, SIGTIMER);
 		return 0;
 	}
-	return __syscall(SYS_timer_delete, t);
+	return zsys_timer_delete((intptr_t)t);
 }
diff --git a/src/time/timer_getoverrun.c b/src/time/timer_getoverrun.c
index e7f891e4040f..6e2bb86e0d71 100644
--- a/src/time/timer_getoverrun.c
+++ b/src/time/timer_getoverrun.c
@@ -8,5 +8,5 @@ int timer_getoverrun(timer_t t)
 		pthread_t td = (void *)((uintptr_t)t << 1);
 		t = (void *)(uintptr_t)(td->timer_id & INT_MAX);
 	}
-	return syscall(SYS_timer_getoverrun, t);
+	return zsys_timer_getoverrun((intptr_t)t);
 }
diff --git a/src/time/timer_gettime.c b/src/time/timer_gettime.c
index 21c9d32c3fe5..ba247c141d66 100644
--- a/src/time/timer_gettime.c
+++ b/src/time/timer_gettime.c
@@ -8,21 +8,5 @@ int timer_gettime(timer_t t, struct itimerspec *val)
 		pthread_t td = (void *)((uintptr_t)t << 1);
 		t = (void *)(uintptr_t)(td->timer_id & INT_MAX);
 	}
-#ifdef SYS_timer_gettime64
-	int r = -ENOSYS;
-	if (sizeof(time_t) > 4)
-		r = __syscall(SYS_timer_gettime64, t, val);
-	if (SYS_timer_gettime == SYS_timer_gettime64 || r!=-ENOSYS)
-		return __syscall_ret(r);
-	long val32[4];
-	r = __syscall(SYS_timer_gettime, t, val32);
-	if (!r) {
-		val->it_interval.tv_sec = val32[0];
-		val->it_interval.tv_nsec = val32[1];
-		val->it_value.tv_sec = val32[2];
-		val->it_value.tv_nsec = val32[3];
-	}
-	return __syscall_ret(r);
-#endif
-	return syscall(SYS_timer_gettime, t, val);
+	return zsys_timer_gettime((intptr_t)t, val);
 }
diff --git a/src/time/timer_settime.c b/src/time/timer_settime.c
index 373f00ced7f2..75b936cdd505 100644
--- a/src/time/timer_settime.c
+++ b/src/time/timer_settime.c
@@ -10,28 +10,5 @@ int timer_settime(timer_t t, int flags, const struct itimerspec *restrict val, s
 		pthread_t td = (void *)((uintptr_t)t << 1);
 		t = (void *)(uintptr_t)(td->timer_id & INT_MAX);
 	}
-#ifdef SYS_timer_settime64
-	time_t is = val->it_interval.tv_sec, vs = val->it_value.tv_sec;
-	long ins = val->it_interval.tv_nsec, vns = val->it_value.tv_nsec;
-	int r = -ENOSYS;
-	if (SYS_timer_settime == SYS_timer_settime64
-	    || !IS32BIT(is) || !IS32BIT(vs) || (sizeof(time_t)>4 && old))
-		r = __syscall(SYS_timer_settime64, t, flags,
-			((long long[]){is, ins, vs, vns}), old);
-	if (SYS_timer_settime == SYS_timer_settime64 || r!=-ENOSYS)
-		return __syscall_ret(r);
-	if (!IS32BIT(is) || !IS32BIT(vs))
-		return __syscall_ret(-ENOTSUP);
-	long old32[4];
-	r = __syscall(SYS_timer_settime, t, flags,
-		((long[]){is, ins, vs, vns}), old32);
-	if (!r && old) {
-		old->it_interval.tv_sec = old32[0];
-		old->it_interval.tv_nsec = old32[1];
-		old->it_value.tv_sec = old32[2];
-		old->it_value.tv_nsec = old32[3];
-	}
-	return __syscall_ret(r);
-#endif
-	return syscall(SYS_timer_settime, t, flags, val, old);
+	return zsys_timer_settime((intptr_t)t, flags, val, old);
 }
diff --git a/src/time/times.c b/src/time/times.c
index c4a100f79b10..534e167b16d6 100644
--- a/src/time/times.c
+++ b/src/time/times.c
@@ -3,5 +3,5 @@
 
 clock_t times(struct tms *tms)
 {
-	return __syscall(SYS_times, tms);
+	return zsys_times(tms);
 }
diff --git a/src/unistd/access.c b/src/unistd/access.c
index d6eed6839822..38fbdd46b46f 100644
--- a/src/unistd/access.c
+++ b/src/unistd/access.c
@@ -4,9 +4,5 @@
 
 int access(const char *filename, int amode)
 {
-#ifdef SYS_access
-	return syscall(SYS_access, filename, amode);
-#else
-	return syscall(SYS_faccessat, AT_FDCWD, filename, amode, 0);
-#endif
+	return zsys_faccessat(AT_FDCWD, filename, amode, 0);
 }
diff --git a/src/unistd/chdir.c b/src/unistd/chdir.c
index 5ba78b6317dc..34490f432d7a 100644
--- a/src/unistd/chdir.c
+++ b/src/unistd/chdir.c
@@ -1,7 +1,8 @@
 #include <unistd.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int chdir(const char *path)
 {
-	return syscall(SYS_chdir, path);
+    return zsys_chdir(path);
 }
diff --git a/src/unistd/chown.c b/src/unistd/chown.c
index 14b032550d67..58193dad287a 100644
--- a/src/unistd/chown.c
+++ b/src/unistd/chown.c
@@ -4,9 +4,5 @@
 
 int chown(const char *path, uid_t uid, gid_t gid)
 {
-#ifdef SYS_chown
-	return syscall(SYS_chown, path, uid, gid);
-#else
-	return syscall(SYS_fchownat, AT_FDCWD, path, uid, gid, 0);
-#endif
+    return zsys_chown(path, uid, gid);
 }
diff --git a/src/unistd/close.c b/src/unistd/close.c
index a2105f5060e2..681e0b935c92 100644
--- a/src/unistd/close.c
+++ b/src/unistd/close.c
@@ -2,6 +2,7 @@
 #include <errno.h>
 #include "aio_impl.h"
 #include "syscall.h"
+#include <stdfil.h>
 
 static int dummy(int fd)
 {
@@ -13,7 +14,10 @@ weak_alias(dummy, __aio_close);
 int close(int fd)
 {
 	fd = __aio_close(fd);
-	int r = __syscall_cp(SYS_close, fd);
-	if (r == -EINTR) r = 0;
-	return __syscall_ret(r);
+        return zsys_close(fd);
+
+        // WTF, do we need this thing about EINTR?
+	//int r = __syscall_cp(SYS_close, fd);
+	//if (r == -EINTR) r = 0;
+	//return __syscall_ret(r);
 }
diff --git a/src/unistd/dup.c b/src/unistd/dup.c
index 7fee01201b82..b615de68fb70 100644
--- a/src/unistd/dup.c
+++ b/src/unistd/dup.c
@@ -1,7 +1,8 @@
 #include <unistd.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int dup(int fd)
 {
-	return syscall(SYS_dup, fd);
+	return zsys_dup(fd);
 }
diff --git a/src/unistd/dup2.c b/src/unistd/dup2.c
index 8f43c6ddfe89..91b4ed3b5044 100644
--- a/src/unistd/dup2.c
+++ b/src/unistd/dup2.c
@@ -2,19 +2,9 @@
 #include <errno.h>
 #include <fcntl.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int dup2(int old, int new)
 {
-	int r;
-#ifdef SYS_dup2
-	while ((r=__syscall(SYS_dup2, old, new))==-EBUSY);
-#else
-	if (old==new) {
-		r = __syscall(SYS_fcntl, old, F_GETFD);
-		if (r >= 0) return old;
-	} else {
-		while ((r=__syscall(SYS_dup3, old, new, 0))==-EBUSY);
-	}
-#endif
-	return __syscall_ret(r);
+    return zsys_dup2(old, new);
 }
diff --git a/src/unistd/dup3.c b/src/unistd/dup3.c
index 40798bdeed12..4691fcb50f9b 100644
--- a/src/unistd/dup3.c
+++ b/src/unistd/dup3.c
@@ -6,21 +6,7 @@
 
 int __dup3(int old, int new, int flags)
 {
-	int r;
-#ifdef SYS_dup2
-	if (old==new) return __syscall_ret(-EINVAL);
-	if (flags) {
-		while ((r=__syscall(SYS_dup3, old, new, flags))==-EBUSY);
-		if (r!=-ENOSYS) return __syscall_ret(r);
-		if (flags & ~O_CLOEXEC) return __syscall_ret(-EINVAL);
-	}
-	while ((r=__syscall(SYS_dup2, old, new))==-EBUSY);
-	if (r >= 0 && (flags & O_CLOEXEC))
-		__syscall(SYS_fcntl, new, F_SETFD, FD_CLOEXEC);
-#else
-	while ((r=__syscall(SYS_dup3, old, new, flags))==-EBUSY);
-#endif
-	return __syscall_ret(r);
+	return zsys_dup3(old, new, flags);
 }
 
 weak_alias(__dup3, dup3);
diff --git a/src/unistd/faccessat.c b/src/unistd/faccessat.c
index 557503eb6d81..036b6053a53c 100644
--- a/src/unistd/faccessat.c
+++ b/src/unistd/faccessat.c
@@ -2,60 +2,8 @@
 #include <fcntl.h>
 #include <sys/wait.h>
 #include "syscall.h"
-#include "pthread_impl.h"
-
-struct ctx {
-	int fd;
-	const char *filename;
-	int amode;
-	int p;
-};
-
-static int checker(void *p)
-{
-	struct ctx *c = p;
-	int ret;
-	if (__syscall(SYS_setregid, __syscall(SYS_getegid), -1)
-	    || __syscall(SYS_setreuid, __syscall(SYS_geteuid), -1))
-		__syscall(SYS_exit, 1);
-	ret = __syscall(SYS_faccessat, c->fd, c->filename, c->amode, 0);
-	__syscall(SYS_write, c->p, &ret, sizeof ret);
-	return 0;
-}
 
 int faccessat(int fd, const char *filename, int amode, int flag)
 {
-	if (flag) {
-		int ret = __syscall(SYS_faccessat2, fd, filename, amode, flag);
-		if (ret != -ENOSYS) return __syscall_ret(ret);
-	}
-
-	if (flag & ~AT_EACCESS)
-		return __syscall_ret(-EINVAL);
-
-	if (!flag || (getuid()==geteuid() && getgid()==getegid()))
-		return syscall(SYS_faccessat, fd, filename, amode);
-
-	char stack[1024];
-	sigset_t set;
-	pid_t pid;
-	int status;
-	int ret, p[2];
-
-	if (pipe2(p, O_CLOEXEC)) return __syscall_ret(-EBUSY);
-	struct ctx c = { .fd = fd, .filename = filename, .amode = amode, .p = p[1] };
-
-	__block_all_sigs(&set);
-	
-	pid = __clone(checker, stack+sizeof stack, 0, &c);
-	__syscall(SYS_close, p[1]);
-
-	if (pid<0 || __syscall(SYS_read, p[0], &ret, sizeof ret) != sizeof(ret))
-		ret = -EBUSY;
-	__syscall(SYS_close, p[0]);
-	__syscall(SYS_wait4, pid, &status, __WCLONE, 0);
-
-	__restore_sigs(&set);
-
-	return __syscall_ret(ret);
+    return zsys_faccessat(fd, filename, amode, flag);
 }
diff --git a/src/unistd/fchdir.c b/src/unistd/fchdir.c
index dee45ba68e64..a7102003b52c 100644
--- a/src/unistd/fchdir.c
+++ b/src/unistd/fchdir.c
@@ -5,11 +5,5 @@
 
 int fchdir(int fd)
 {
-	int ret = __syscall(SYS_fchdir, fd);
-	if (ret != -EBADF || __syscall(SYS_fcntl, fd, F_GETFD) < 0)
-		return __syscall_ret(ret);
-
-	char buf[15+3*sizeof(int)];
-	__procfdname(buf, fd);
-	return syscall(SYS_chdir, buf);
+    return zsys_fchdir(fd);
 }
diff --git a/src/unistd/fchown.c b/src/unistd/fchown.c
index 737b3672fcce..a5e933560550 100644
--- a/src/unistd/fchown.c
+++ b/src/unistd/fchown.c
@@ -5,16 +5,5 @@
 
 int fchown(int fd, uid_t uid, gid_t gid)
 {
-	int ret = __syscall(SYS_fchown, fd, uid, gid);
-	if (ret != -EBADF || __syscall(SYS_fcntl, fd, F_GETFD) < 0)
-		return __syscall_ret(ret);
-
-	char buf[15+3*sizeof(int)];
-	__procfdname(buf, fd);
-#ifdef SYS_chown
-	return syscall(SYS_chown, buf, uid, gid);
-#else
-	return syscall(SYS_fchownat, AT_FDCWD, buf, uid, gid, 0);
-#endif
-
+    return zsys_fchown(fd, uid, gid);
 }
diff --git a/src/unistd/fchownat.c b/src/unistd/fchownat.c
index 62457a3ec0eb..5fea244f3db0 100644
--- a/src/unistd/fchownat.c
+++ b/src/unistd/fchownat.c
@@ -3,5 +3,5 @@
 
 int fchownat(int fd, const char *path, uid_t uid, gid_t gid, int flag)
 {
-	return syscall(SYS_fchownat, fd, path, uid, gid, flag);
+	return zsys_fchownat(fd, path, uid, gid, flag);
 }
diff --git a/src/unistd/fdatasync.c b/src/unistd/fdatasync.c
index 3895ae530c75..6bdc3d7698c4 100644
--- a/src/unistd/fdatasync.c
+++ b/src/unistd/fdatasync.c
@@ -3,5 +3,5 @@
 
 int fdatasync(int fd)
 {
-	return syscall_cp(SYS_fdatasync, fd);
+	return zsys_fdatasync(fd);
 }
diff --git a/src/unistd/fsync.c b/src/unistd/fsync.c
index 7a1c80b5de0d..057f12580f8e 100644
--- a/src/unistd/fsync.c
+++ b/src/unistd/fsync.c
@@ -3,5 +3,5 @@
 
 int fsync(int fd)
 {
-	return syscall_cp(SYS_fsync, fd);
+    return zsys_fsync(fd);
 }
diff --git a/src/unistd/ftruncate.c b/src/unistd/ftruncate.c
index 54ff34bc3ebd..b09bef2c6571 100644
--- a/src/unistd/ftruncate.c
+++ b/src/unistd/ftruncate.c
@@ -1,7 +1,8 @@
 #include <unistd.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int ftruncate(int fd, off_t length)
 {
-	return syscall(SYS_ftruncate, fd, __SYSCALL_LL_O(length));
+    return zsys_ftruncate(fd, length);
 }
diff --git a/src/unistd/getcwd.c b/src/unistd/getcwd.c
index f407ffe07ed6..0892730a0794 100644
--- a/src/unistd/getcwd.c
+++ b/src/unistd/getcwd.c
@@ -3,6 +3,7 @@
 #include <limits.h>
 #include <string.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 char *getcwd(char *buf, size_t size)
 {
@@ -14,10 +15,11 @@ char *getcwd(char *buf, size_t size)
 		errno = EINVAL;
 		return 0;
 	}
-	long ret = syscall(SYS_getcwd, buf, size);
-	if (ret < 0)
+	char* ret = zsys_getcwd(buf, size);
+	if (!ret)
 		return 0;
-	if (ret == 0 || buf[0] != '/') {
+        ZASSERT(ret == buf);
+	if (!buf[0] || buf[0] != '/') {
 		errno = ENOENT;
 		return 0;
 	}
diff --git a/src/unistd/getegid.c b/src/unistd/getegid.c
index 6287490da2c0..ceb5c91a479f 100644
--- a/src/unistd/getegid.c
+++ b/src/unistd/getegid.c
@@ -1,7 +1,8 @@
 #include <unistd.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 gid_t getegid(void)
 {
-	return __syscall(SYS_getegid);
+    return zsys_getegid();
 }
diff --git a/src/unistd/geteuid.c b/src/unistd/geteuid.c
index 88f2cd538252..b091eb5dfc3e 100644
--- a/src/unistd/geteuid.c
+++ b/src/unistd/geteuid.c
@@ -1,7 +1,8 @@
 #include <unistd.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 uid_t geteuid(void)
 {
-	return __syscall(SYS_geteuid);
+    return zsys_geteuid();
 }
diff --git a/src/unistd/getgid.c b/src/unistd/getgid.c
index 1c9fe7157b35..39e2341c8098 100644
--- a/src/unistd/getgid.c
+++ b/src/unistd/getgid.c
@@ -1,7 +1,8 @@
 #include <unistd.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 gid_t getgid(void)
 {
-	return __syscall(SYS_getgid);
+    return zsys_getgid();
 }
diff --git a/src/unistd/getgroups.c b/src/unistd/getgroups.c
index 0e6e63af0129..b127c6dd5fc0 100644
--- a/src/unistd/getgroups.c
+++ b/src/unistd/getgroups.c
@@ -3,5 +3,5 @@
 
 int getgroups(int count, gid_t list[])
 {
-	return syscall(SYS_getgroups, count, list);
+	return zsys_getgroups(count, list);
 }
diff --git a/src/unistd/getpgid.c b/src/unistd/getpgid.c
index d295bfd59b07..7bc7ada9a32c 100644
--- a/src/unistd/getpgid.c
+++ b/src/unistd/getpgid.c
@@ -3,5 +3,5 @@
 
 pid_t getpgid(pid_t pid)
 {
-	return syscall(SYS_getpgid, pid);
+    return zsys_getpgid(pid);
 }
diff --git a/src/unistd/getpgrp.c b/src/unistd/getpgrp.c
index 90e9bb07f6e3..5913766b21bb 100644
--- a/src/unistd/getpgrp.c
+++ b/src/unistd/getpgrp.c
@@ -3,5 +3,5 @@
 
 pid_t getpgrp(void)
 {
-	return __syscall(SYS_getpgid, 0);
+    return zsys_getpgrp();
 }
diff --git a/src/unistd/getpid.c b/src/unistd/getpid.c
index a6d4e6d1bc9f..9ef5890dad07 100644
--- a/src/unistd/getpid.c
+++ b/src/unistd/getpid.c
@@ -1,7 +1,8 @@
 #include <unistd.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 pid_t getpid(void)
 {
-	return __syscall(SYS_getpid);
+    return zsys_getpid();
 }
diff --git a/src/unistd/getppid.c b/src/unistd/getppid.c
index 05cade53b689..2bb1270a8727 100644
--- a/src/unistd/getppid.c
+++ b/src/unistd/getppid.c
@@ -1,7 +1,8 @@
 #include <unistd.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 pid_t getppid(void)
 {
-	return __syscall(SYS_getppid);
+    return zsys_getppid();
 }
diff --git a/src/unistd/getsid.c b/src/unistd/getsid.c
index 93ba690e7ec2..4c72ff37e28f 100644
--- a/src/unistd/getsid.c
+++ b/src/unistd/getsid.c
@@ -3,5 +3,5 @@
 
 pid_t getsid(pid_t pid)
 {
-	return syscall(SYS_getsid, pid);
+	return zsys_getsid(pid);
 }
diff --git a/src/unistd/getuid.c b/src/unistd/getuid.c
index 61309d1b7914..439cd4767be1 100644
--- a/src/unistd/getuid.c
+++ b/src/unistd/getuid.c
@@ -1,7 +1,8 @@
 #include <unistd.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 uid_t getuid(void)
 {
-	return __syscall(SYS_getuid);
+    return zsys_getuid();
 }
diff --git a/src/unistd/isatty.c b/src/unistd/isatty.c
index 75a9c186a941..4b9177a01d02 100644
--- a/src/unistd/isatty.c
+++ b/src/unistd/isatty.c
@@ -2,12 +2,9 @@
 #include <errno.h>
 #include <sys/ioctl.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int isatty(int fd)
 {
-	struct winsize wsz;
-	unsigned long r = syscall(SYS_ioctl, fd, TIOCGWINSZ, &wsz);
-	if (r == 0) return 1;
-	if (errno != EBADF) errno = ENOTTY;
-	return 0;
+    return zsys_isatty(fd);
 }
diff --git a/src/unistd/lchown.c b/src/unistd/lchown.c
index ccd5ee0255ee..9edf1fa59409 100644
--- a/src/unistd/lchown.c
+++ b/src/unistd/lchown.c
@@ -4,9 +4,5 @@
 
 int lchown(const char *path, uid_t uid, gid_t gid)
 {
-#ifdef SYS_lchown
-	return syscall(SYS_lchown, path, uid, gid);
-#else
-	return syscall(SYS_fchownat, AT_FDCWD, path, uid, gid, AT_SYMLINK_NOFOLLOW);
-#endif
+    return zsys_lchown(path, uid, gid);
 }
diff --git a/src/unistd/link.c b/src/unistd/link.c
index feec18e533d9..d7d35abba2a7 100644
--- a/src/unistd/link.c
+++ b/src/unistd/link.c
@@ -4,9 +4,5 @@
 
 int link(const char *existing, const char *new)
 {
-#ifdef SYS_link
-	return syscall(SYS_link, existing, new);
-#else
-	return syscall(SYS_linkat, AT_FDCWD, existing, AT_FDCWD, new, 0);
-#endif
+    return zsys_link(existing, new);
 }
diff --git a/src/unistd/linkat.c b/src/unistd/linkat.c
index 6a9a0b77591a..24886c1fd698 100644
--- a/src/unistd/linkat.c
+++ b/src/unistd/linkat.c
@@ -3,5 +3,5 @@
 
 int linkat(int fd1, const char *existing, int fd2, const char *new, int flag)
 {
-	return syscall(SYS_linkat, fd1, existing, fd2, new, flag);
+	return zsys_linkat(fd1, existing, fd2, new, flag);
 }
diff --git a/src/unistd/lseek.c b/src/unistd/lseek.c
index f5b66682abc4..5fca74ecb80e 100644
--- a/src/unistd/lseek.c
+++ b/src/unistd/lseek.c
@@ -1,14 +1,10 @@
 #include <unistd.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 off_t __lseek(int fd, off_t offset, int whence)
 {
-#ifdef SYS__llseek
-	off_t result;
-	return syscall(SYS__llseek, fd, offset>>32, offset, &result, whence) ? -1 : result;
-#else
-	return syscall(SYS_lseek, fd, offset, whence);
-#endif
+    return zsys_lseek(fd, offset, whence);
 }
 
 weak_alias(__lseek, lseek);
diff --git a/src/unistd/pause.c b/src/unistd/pause.c
index 90bbf4ca8ab5..c7030db11cbd 100644
--- a/src/unistd/pause.c
+++ b/src/unistd/pause.c
@@ -1,11 +1,8 @@
 #include <unistd.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int pause(void)
 {
-#ifdef SYS_pause
-	return syscall_cp(SYS_pause);
-#else
-	return syscall_cp(SYS_ppoll, 0, 0, 0, 0);
-#endif
+    return zsys_pause();
 }
diff --git a/src/unistd/pipe.c b/src/unistd/pipe.c
index d07b8d24ae3b..b75607a21398 100644
--- a/src/unistd/pipe.c
+++ b/src/unistd/pipe.c
@@ -1,11 +1,8 @@
 #include <unistd.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 int pipe(int fd[2])
 {
-#ifdef SYS_pipe
-	return syscall(SYS_pipe, fd);
-#else
-	return syscall(SYS_pipe2, fd, 0);
-#endif
+    return zsys_pipe(fd);
 }
diff --git a/src/unistd/pipe2.c b/src/unistd/pipe2.c
index a096990b1503..cab91507aa6c 100644
--- a/src/unistd/pipe2.c
+++ b/src/unistd/pipe2.c
@@ -6,18 +6,16 @@
 int pipe2(int fd[2], int flag)
 {
 	if (!flag) return pipe(fd);
-	int ret = __syscall(SYS_pipe2, fd, flag);
-	if (ret != -ENOSYS) return __syscall_ret(ret);
 	if (flag & ~(O_CLOEXEC|O_NONBLOCK)) return __syscall_ret(-EINVAL);
-	ret = pipe(fd);
+	int ret = pipe(fd);
 	if (ret) return ret;
 	if (flag & O_CLOEXEC) {
-		__syscall(SYS_fcntl, fd[0], F_SETFD, FD_CLOEXEC);
-		__syscall(SYS_fcntl, fd[1], F_SETFD, FD_CLOEXEC);
+		zsys_fcntl(fd[0], F_SETFD, FD_CLOEXEC);
+		zsys_fcntl(fd[1], F_SETFD, FD_CLOEXEC);
 	}
 	if (flag & O_NONBLOCK) {
-		__syscall(SYS_fcntl, fd[0], F_SETFL, O_NONBLOCK);
-		__syscall(SYS_fcntl, fd[1], F_SETFL, O_NONBLOCK);
+		zsys_fcntl(fd[0], F_SETFL, O_NONBLOCK);
+		zsys_fcntl(fd[1], F_SETFL, O_NONBLOCK);
 	}
 	return 0;
 }
diff --git a/src/unistd/pread.c b/src/unistd/pread.c
index b03fb0ad9407..453ac45f0fd2 100644
--- a/src/unistd/pread.c
+++ b/src/unistd/pread.c
@@ -3,5 +3,5 @@
 
 ssize_t pread(int fd, void *buf, size_t size, off_t ofs)
 {
-	return syscall_cp(SYS_pread, fd, buf, size, __SYSCALL_LL_PRW(ofs));
+	return zsys_pread(fd, buf, size, ofs);
 }
diff --git a/src/unistd/preadv.c b/src/unistd/preadv.c
index 890ab403f9db..5d036448cda1 100644
--- a/src/unistd/preadv.c
+++ b/src/unistd/preadv.c
@@ -5,6 +5,5 @@
 
 ssize_t preadv(int fd, const struct iovec *iov, int count, off_t ofs)
 {
-	return syscall_cp(SYS_preadv, fd, iov, count,
-		(long)(ofs), (long)(ofs>>32));
+	return zsys_preadv(fd, iov, count, ofs);
 }
diff --git a/src/unistd/pwrite.c b/src/unistd/pwrite.c
index 869b69f03b88..8ae90beb57f8 100644
--- a/src/unistd/pwrite.c
+++ b/src/unistd/pwrite.c
@@ -3,5 +3,5 @@
 
 ssize_t pwrite(int fd, const void *buf, size_t size, off_t ofs)
 {
-	return syscall_cp(SYS_pwrite, fd, buf, size, __SYSCALL_LL_PRW(ofs));
+	return zsys_pwrite(fd, buf, size, ofs);
 }
diff --git a/src/unistd/pwritev.c b/src/unistd/pwritev.c
index becf9debfc3c..9f8f4aa4d47c 100644
--- a/src/unistd/pwritev.c
+++ b/src/unistd/pwritev.c
@@ -5,6 +5,5 @@
 
 ssize_t pwritev(int fd, const struct iovec *iov, int count, off_t ofs)
 {
-	return syscall_cp(SYS_pwritev, fd, iov, count,
-		(long)(ofs), (long)(ofs>>32));
+	return zsys_pwritev(fd, iov, count, ofs);
 }
diff --git a/src/unistd/read.c b/src/unistd/read.c
index f3589c05c3e3..05d08fb22307 100644
--- a/src/unistd/read.c
+++ b/src/unistd/read.c
@@ -1,7 +1,8 @@
 #include <unistd.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 ssize_t read(int fd, void *buf, size_t count)
 {
-	return syscall_cp(SYS_read, fd, buf, count);
+	return zsys_read(fd, buf, count);
 }
diff --git a/src/unistd/readlink.c b/src/unistd/readlink.c
index 32f4537f972b..9cdf78ef16c9 100644
--- a/src/unistd/readlink.c
+++ b/src/unistd/readlink.c
@@ -4,16 +4,5 @@
 
 ssize_t readlink(const char *restrict path, char *restrict buf, size_t bufsize)
 {
-	char dummy[1];
-	if (!bufsize) {
-		buf = dummy;
-		bufsize = 1;
-	}
-#ifdef SYS_readlink
-	int r = __syscall(SYS_readlink, path, buf, bufsize);
-#else
-	int r = __syscall(SYS_readlinkat, AT_FDCWD, path, buf, bufsize);
-#endif
-	if (buf == dummy && r > 0) r = 0;
-	return __syscall_ret(r);
+    return zsys_readlink(path, buf, bufsize);
 }
diff --git a/src/unistd/readlinkat.c b/src/unistd/readlinkat.c
index f79d3d14280e..4cdd4c80e433 100644
--- a/src/unistd/readlinkat.c
+++ b/src/unistd/readlinkat.c
@@ -3,12 +3,5 @@
 
 ssize_t readlinkat(int fd, const char *restrict path, char *restrict buf, size_t bufsize)
 {
-	char dummy[1];
-	if (!bufsize) {
-		buf = dummy;
-		bufsize = 1;
-	}
-	int r = __syscall(SYS_readlinkat, fd, path, buf, bufsize);
-	if (buf == dummy && r > 0) r = 0;
-	return __syscall_ret(r);
+	return zsys_readlinkat(fd, path, buf, bufsize);
 }
diff --git a/src/unistd/readv.c b/src/unistd/readv.c
index 91e6de816779..016ce544d8d0 100644
--- a/src/unistd/readv.c
+++ b/src/unistd/readv.c
@@ -3,5 +3,5 @@
 
 ssize_t readv(int fd, const struct iovec *iov, int count)
 {
-	return syscall_cp(SYS_readv, fd, iov, count);
+	return zsys_readv(fd, iov, count);
 }
diff --git a/src/unistd/renameat.c b/src/unistd/renameat.c
index c3b40a258b28..5debea3c711c 100644
--- a/src/unistd/renameat.c
+++ b/src/unistd/renameat.c
@@ -3,9 +3,5 @@
 
 int renameat(int oldfd, const char *old, int newfd, const char *new)
 {
-#ifdef SYS_renameat
-	return syscall(SYS_renameat, oldfd, old, newfd, new);
-#else
-	return syscall(SYS_renameat2, oldfd, old, newfd, new, 0);
-#endif
+	return zsys_renameat(oldfd, old, newfd, new);
 }
diff --git a/src/unistd/rmdir.c b/src/unistd/rmdir.c
index 6825ffc8359a..8b9dcab3b070 100644
--- a/src/unistd/rmdir.c
+++ b/src/unistd/rmdir.c
@@ -4,9 +4,5 @@
 
 int rmdir(const char *path)
 {
-#ifdef SYS_rmdir
-	return syscall(SYS_rmdir, path);
-#else
-	return syscall(SYS_unlinkat, AT_FDCWD, path, AT_REMOVEDIR);
-#endif
+    return zsys_rmdir(path);
 }
diff --git a/src/unistd/setegid.c b/src/unistd/setegid.c
index e6da2573c0d4..fae63f4a210b 100644
--- a/src/unistd/setegid.c
+++ b/src/unistd/setegid.c
@@ -4,5 +4,5 @@
 
 int setegid(gid_t egid)
 {
-	return __setxid(SYS_setresgid, -1, egid, -1);
+    return zsys_setegid(egid);
 }
diff --git a/src/unistd/seteuid.c b/src/unistd/seteuid.c
index ef8b9df43bd7..5cebb3a122aa 100644
--- a/src/unistd/seteuid.c
+++ b/src/unistd/seteuid.c
@@ -4,5 +4,5 @@
 
 int seteuid(uid_t euid)
 {
-	return __setxid(SYS_setresuid, -1, euid, -1);
+    return zsys_seteuid(euid);
 }
diff --git a/src/unistd/setgid.c b/src/unistd/setgid.c
index bae4616adb3b..f66dccbfb75e 100644
--- a/src/unistd/setgid.c
+++ b/src/unistd/setgid.c
@@ -4,5 +4,5 @@
 
 int setgid(gid_t gid)
 {
-	return __setxid(SYS_setgid, gid, 0, 0);
+    return zsys_setgid(gid);
 }
diff --git a/src/unistd/setpgid.c b/src/unistd/setpgid.c
index 061606951d4f..2c6c1faa817b 100644
--- a/src/unistd/setpgid.c
+++ b/src/unistd/setpgid.c
@@ -3,5 +3,5 @@
 
 int setpgid(pid_t pid, pid_t pgid)
 {
-	return syscall(SYS_setpgid, pid, pgid);
+    return zsys_setpgid(pid, pgid);
 }
diff --git a/src/unistd/setregid.c b/src/unistd/setregid.c
index f5a8972ae4f5..8cc6f3102757 100644
--- a/src/unistd/setregid.c
+++ b/src/unistd/setregid.c
@@ -4,5 +4,5 @@
 
 int setregid(gid_t rgid, gid_t egid)
 {
-	return __setxid(SYS_setregid, rgid, egid, 0);
+    return zsys_setregid(rgid, egid);
 }
diff --git a/src/unistd/setresgid.c b/src/unistd/setresgid.c
index b9af540af2e6..5c403232bd4d 100644
--- a/src/unistd/setresgid.c
+++ b/src/unistd/setresgid.c
@@ -5,5 +5,5 @@
 
 int setresgid(gid_t rgid, gid_t egid, gid_t sgid)
 {
-	return __setxid(SYS_setresgid, rgid, egid, sgid);
+	return zsys_setresgid(rgid, egid, sgid);
 }
diff --git a/src/unistd/setresuid.c b/src/unistd/setresuid.c
index 83692b4c99c5..9318e19996fd 100644
--- a/src/unistd/setresuid.c
+++ b/src/unistd/setresuid.c
@@ -5,5 +5,5 @@
 
 int setresuid(uid_t ruid, uid_t euid, uid_t suid)
 {
-	return __setxid(SYS_setresuid, ruid, euid, suid);
+	return zsys_setresuid(ruid, euid, suid);
 }
diff --git a/src/unistd/setreuid.c b/src/unistd/setreuid.c
index 3fcc59e292a7..f4fd06a36c63 100644
--- a/src/unistd/setreuid.c
+++ b/src/unistd/setreuid.c
@@ -4,5 +4,5 @@
 
 int setreuid(uid_t ruid, uid_t euid)
 {
-	return __setxid(SYS_setreuid, ruid, euid, 0);
+    return zsys_setreuid(ruid, euid);
 }
diff --git a/src/unistd/setsid.c b/src/unistd/setsid.c
index 609bbe4ace41..cf0624aa2e37 100644
--- a/src/unistd/setsid.c
+++ b/src/unistd/setsid.c
@@ -1,7 +1,8 @@
 #include <unistd.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 pid_t setsid(void)
 {
-	return syscall(SYS_setsid);
+    return zsys_setsid();
 }
diff --git a/src/unistd/setuid.c b/src/unistd/setuid.c
index 602ecbbf44b3..be34a08f65ef 100644
--- a/src/unistd/setuid.c
+++ b/src/unistd/setuid.c
@@ -1,8 +1,9 @@
 #include <unistd.h>
 #include "syscall.h"
 #include "libc.h"
+#include <stdfil.h>
 
 int setuid(uid_t uid)
 {
-	return __setxid(SYS_setuid, uid, 0, 0);
+    return zsys_setuid(uid);
 }
diff --git a/src/unistd/symlink.c b/src/unistd/symlink.c
index 0973d78a8936..3a230a1089f3 100644
--- a/src/unistd/symlink.c
+++ b/src/unistd/symlink.c
@@ -4,9 +4,5 @@
 
 int symlink(const char *existing, const char *new)
 {
-#ifdef SYS_symlink
-	return syscall(SYS_symlink, existing, new);
-#else
-	return syscall(SYS_symlinkat, existing, AT_FDCWD, new);
-#endif
+    return zsys_symlink(existing, new);
 }
diff --git a/src/unistd/symlinkat.c b/src/unistd/symlinkat.c
index d1c59b4db099..2c8d5a83fe57 100644
--- a/src/unistd/symlinkat.c
+++ b/src/unistd/symlinkat.c
@@ -3,5 +3,5 @@
 
 int symlinkat(const char *existing, int fd, const char *new)
 {
-	return syscall(SYS_symlinkat, existing, fd, new);
+	return zsys_symlinkat(existing, fd, new);
 }
diff --git a/src/unistd/sync.c b/src/unistd/sync.c
index f18765aa8506..51cba7f8e548 100644
--- a/src/unistd/sync.c
+++ b/src/unistd/sync.c
@@ -3,5 +3,5 @@
 
 void sync(void)
 {
-	__syscall(SYS_sync);
+    zsys_sync();
 }
diff --git a/src/unistd/truncate.c b/src/unistd/truncate.c
index 077351e1be24..faefebfaec82 100644
--- a/src/unistd/truncate.c
+++ b/src/unistd/truncate.c
@@ -3,5 +3,5 @@
 
 int truncate(const char *path, off_t length)
 {
-	return syscall(SYS_truncate, path, __SYSCALL_LL_O(length));
+	return zsys_truncate(path, length);
 }
diff --git a/src/unistd/unlink.c b/src/unistd/unlink.c
index c40c28d50be4..154599c59de8 100644
--- a/src/unistd/unlink.c
+++ b/src/unistd/unlink.c
@@ -4,9 +4,5 @@
 
 int unlink(const char *path)
 {
-#ifdef SYS_unlink
-	return syscall(SYS_unlink, path);
-#else
-	return syscall(SYS_unlinkat, AT_FDCWD, path, 0);
-#endif
+    return zsys_unlink(path);
 }
diff --git a/src/unistd/unlinkat.c b/src/unistd/unlinkat.c
index e0e25d22a30c..c8122b538c84 100644
--- a/src/unistd/unlinkat.c
+++ b/src/unistd/unlinkat.c
@@ -3,5 +3,5 @@
 
 int unlinkat(int fd, const char *path, int flag)
 {
-	return syscall(SYS_unlinkat, fd, path, flag);
+	return zsys_unlinkat(fd, path, flag);
 }
diff --git a/src/unistd/write.c b/src/unistd/write.c
index 8fd5bc5c261c..71e1db38a489 100644
--- a/src/unistd/write.c
+++ b/src/unistd/write.c
@@ -1,7 +1,8 @@
 #include <unistd.h>
 #include "syscall.h"
+#include <stdfil.h>
 
 ssize_t write(int fd, const void *buf, size_t count)
 {
-	return syscall_cp(SYS_write, fd, buf, count);
+	return zsys_write(fd, buf, count);
 }
diff --git a/src/unistd/writev.c b/src/unistd/writev.c
index 5a46c951af57..51b4496b4fb0 100644
--- a/src/unistd/writev.c
+++ b/src/unistd/writev.c
@@ -3,5 +3,5 @@
 
 ssize_t writev(int fd, const struct iovec *iov, int count)
 {
-	return syscall_cp(SYS_writev, fd, iov, count);
+	return zsys_writev(fd, iov, count);
 }
diff --git a/src/yescrypt/insecure_memzero.h b/src/yescrypt/insecure_memzero.h
new file mode 100644
index 000000000000..6ccb1fd75d2b
--- /dev/null
+++ b/src/yescrypt/insecure_memzero.h
@@ -0,0 +1,79 @@
+/*-
+ * Copyright 2014 Colin Percival
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _INSECURE_MEMZERO_H_
+#define _INSECURE_MEMZERO_H_
+
+#ifdef __PIZLONATOR_WAS_HERE__
+
+#include <stdfil.h>
+
+#define insecure_memzero(buf, len) zmemset(buf, 0, len)
+
+#else /* __PIZLONATOR_WAS_HERE__ -> so pizlonator wasn't here */
+
+#ifdef SKIP_MEMZERO
+#define insecure_memzero(buf, len) /* empty */
+#else
+
+#include <stddef.h>
+
+/* Pointer to memory-zeroing function. */
+extern void (* volatile insecure_memzero_ptr)(volatile void *, size_t);
+
+/**
+ * insecure_memzero(buf, len):
+ * Attempt to zero ${len} bytes at ${buf} in spite of optimizing compilers'
+ * best (standards-compliant) attempts to remove the buffer-zeroing.  In
+ * particular, to avoid performing the zeroing, a compiler would need to
+ * use optimistic devirtualization; recognize that non-volatile objects do not
+ * need to be treated as volatile, even if they are accessed via volatile
+ * qualified pointers; and perform link-time optimization; in addition to the
+ * dead-code elimination which often causes buffer-zeroing to be elided.
+ *
+ * Note however that zeroing a buffer does not guarantee that the data held
+ * in the buffer is not stored elsewhere; in particular, there may be copies
+ * held in CPU registers or in anonymous allocations on the stack, even if
+ * every named variable is successfully sanitized.  Solving the "wipe data
+ * from the system" problem will require a C language extension which does not
+ * yet exist.
+ *
+ * For more information, see:
+ * http://www.daemonology.net/blog/2014-09-04-how-to-zero-a-buffer.html
+ * http://www.daemonology.net/blog/2014-09-06-zeroing-buffers-is-insufficient.html
+ */
+static inline void
+insecure_memzero(volatile void * buf, size_t len)
+{
+
+	(insecure_memzero_ptr)(buf, len);
+}
+
+#endif
+
+#endif /* __PIZLONATOR_WAS_HERE__ -> so end of pizlonator wasn't here */
+
+#endif /* !_INSECURE_MEMZERO_H_ */
diff --git a/src/yescrypt/sha256.c b/src/yescrypt/sha256.c
new file mode 100644
index 000000000000..78c215ff2684
--- /dev/null
+++ b/src/yescrypt/sha256.c
@@ -0,0 +1,646 @@
+/*-
+ * Copyright 2005-2016 Colin Percival
+ * Copyright 2016-2018 Alexander Peslyak
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <assert.h>
+#include <stdint.h>
+#include <string.h>
+
+#include "insecure_memzero.h"
+#include "sysendian.h"
+
+#include "sha256.h"
+
+#ifdef __ICC
+/* Miscompile with icc 14.0.0 (at least), so don't use restrict there */
+#define restrict
+#elif __STDC_VERSION__ >= 199901L
+/* Have restrict */
+#elif defined(__GNUC__)
+#define restrict __restrict
+#else
+#define restrict
+#endif
+
+/*
+ * Encode a length len*2 vector of (uint32_t) into a length len*8 vector of
+ * (uint8_t) in big-endian form.
+ */
+static void
+be32enc_vect(uint8_t * dst, const uint32_t * src, size_t len)
+{
+
+	/* Encode vector, two words at a time. */
+	do {
+		be32enc(&dst[0], src[0]);
+		be32enc(&dst[4], src[1]);
+		src += 2;
+		dst += 8;
+	} while (--len);
+}
+
+/*
+ * Decode a big-endian length len*8 vector of (uint8_t) into a length
+ * len*2 vector of (uint32_t).
+ */
+static void
+be32dec_vect(uint32_t * dst, const uint8_t * src, size_t len)
+{
+
+	/* Decode vector, two words at a time. */
+	do {
+		dst[0] = be32dec(&src[0]);
+		dst[1] = be32dec(&src[4]);
+		src += 8;
+		dst += 2;
+	} while (--len);
+}
+
+/* SHA256 round constants. */
+static const uint32_t Krnd[64] = {
+	0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
+	0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
+	0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
+	0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
+	0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
+	0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
+	0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
+	0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
+	0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
+	0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
+	0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
+	0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
+	0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
+	0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
+	0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
+	0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
+};
+
+/* Elementary functions used by SHA256 */
+#define Ch(x, y, z)	((x & (y ^ z)) ^ z)
+#define Maj(x, y, z)	((x & (y | z)) | (y & z))
+#define SHR(x, n)	(x >> n)
+#define ROTR(x, n)	((x >> n) | (x << (32 - n)))
+#define S0(x)		(ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22))
+#define S1(x)		(ROTR(x, 6) ^ ROTR(x, 11) ^ ROTR(x, 25))
+#define s0(x)		(ROTR(x, 7) ^ ROTR(x, 18) ^ SHR(x, 3))
+#define s1(x)		(ROTR(x, 17) ^ ROTR(x, 19) ^ SHR(x, 10))
+
+/* SHA256 round function */
+#define RND(a, b, c, d, e, f, g, h, k)			\
+	h += S1(e) + Ch(e, f, g) + k;			\
+	d += h;						\
+	h += S0(a) + Maj(a, b, c);
+
+/* Adjusted round function for rotating state */
+#define RNDr(S, W, i, ii)			\
+	RND(S[(64 - i) % 8], S[(65 - i) % 8],	\
+	    S[(66 - i) % 8], S[(67 - i) % 8],	\
+	    S[(68 - i) % 8], S[(69 - i) % 8],	\
+	    S[(70 - i) % 8], S[(71 - i) % 8],	\
+	    W[i + ii] + Krnd[i + ii])
+
+/* Message schedule computation */
+#define MSCH(W, ii, i)				\
+	W[i + ii + 16] = s1(W[i + ii + 14]) + W[i + ii + 9] + s0(W[i + ii + 1]) + W[i + ii]
+
+/*
+ * SHA256 block compression function.  The 256-bit state is transformed via
+ * the 512-bit input block to produce a new state.
+ */
+static void
+SHA256_Transform(uint32_t state[static restrict 8],
+    const uint8_t block[static restrict 64],
+    uint32_t W[static restrict 64], uint32_t S[static restrict 8])
+{
+	int i;
+
+	/* 1. Prepare the first part of the message schedule W. */
+	be32dec_vect(W, block, 8);
+
+	/* 2. Initialize working variables. */
+	memcpy(S, state, 32);
+
+	/* 3. Mix. */
+	for (i = 0; i < 64; i += 16) {
+		RNDr(S, W, 0, i);
+		RNDr(S, W, 1, i);
+		RNDr(S, W, 2, i);
+		RNDr(S, W, 3, i);
+		RNDr(S, W, 4, i);
+		RNDr(S, W, 5, i);
+		RNDr(S, W, 6, i);
+		RNDr(S, W, 7, i);
+		RNDr(S, W, 8, i);
+		RNDr(S, W, 9, i);
+		RNDr(S, W, 10, i);
+		RNDr(S, W, 11, i);
+		RNDr(S, W, 12, i);
+		RNDr(S, W, 13, i);
+		RNDr(S, W, 14, i);
+		RNDr(S, W, 15, i);
+
+		if (i == 48)
+			break;
+		MSCH(W, 0, i);
+		MSCH(W, 1, i);
+		MSCH(W, 2, i);
+		MSCH(W, 3, i);
+		MSCH(W, 4, i);
+		MSCH(W, 5, i);
+		MSCH(W, 6, i);
+		MSCH(W, 7, i);
+		MSCH(W, 8, i);
+		MSCH(W, 9, i);
+		MSCH(W, 10, i);
+		MSCH(W, 11, i);
+		MSCH(W, 12, i);
+		MSCH(W, 13, i);
+		MSCH(W, 14, i);
+		MSCH(W, 15, i);
+	}
+
+	/* 4. Mix local working variables into global state. */
+	state[0] += S[0];
+	state[1] += S[1];
+	state[2] += S[2];
+	state[3] += S[3];
+	state[4] += S[4];
+	state[5] += S[5];
+	state[6] += S[6];
+	state[7] += S[7];
+}
+
+static const uint8_t PAD[64] = {
+	0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
+/* Add padding and terminating bit-count. */
+static void
+SHA256_Pad(SHA256_CTX * ctx, uint32_t tmp32[static restrict 72])
+{
+	size_t r;
+
+	/* Figure out how many bytes we have buffered. */
+	r = (ctx->count >> 3) & 0x3f;
+
+	/* Pad to 56 mod 64, transforming if we finish a block en route. */
+	if (r < 56) {
+		/* Pad to 56 mod 64. */
+		memcpy(&ctx->buf[r], PAD, 56 - r);
+	} else {
+		/* Finish the current block and mix. */
+		memcpy(&ctx->buf[r], PAD, 64 - r);
+		SHA256_Transform(ctx->state, ctx->buf, &tmp32[0], &tmp32[64]);
+
+		/* The start of the final block is all zeroes. */
+		memset(&ctx->buf[0], 0, 56);
+	}
+
+	/* Add the terminating bit-count. */
+	be64enc(&ctx->buf[56], ctx->count);
+
+	/* Mix in the final block. */
+	SHA256_Transform(ctx->state, ctx->buf, &tmp32[0], &tmp32[64]);
+}
+
+/* Magic initialization constants. */
+static const uint32_t initial_state[8] = {
+	0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,
+	0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19
+};
+
+/**
+ * SHA256_Init(ctx):
+ * Initialize the SHA256 context ${ctx}.
+ */
+hidden void
+SHA256_Init(SHA256_CTX * ctx)
+{
+
+	/* Zero bits processed so far. */
+	ctx->count = 0;
+
+	/* Initialize state. */
+	memcpy(ctx->state, initial_state, sizeof(initial_state));
+}
+
+/**
+ * SHA256_Update(ctx, in, len):
+ * Input ${len} bytes from ${in} into the SHA256 context ${ctx}.
+ */
+static void
+_SHA256_Update(SHA256_CTX * ctx, const void * in, size_t len,
+    uint32_t tmp32[static restrict 72])
+{
+	uint32_t r;
+	const uint8_t * src = in;
+
+	/* Return immediately if we have nothing to do. */
+	if (len == 0)
+		return;
+
+	/* Number of bytes left in the buffer from previous updates. */
+	r = (ctx->count >> 3) & 0x3f;
+
+	/* Update number of bits. */
+	ctx->count += (uint64_t)(len) << 3;
+
+	/* Handle the case where we don't need to perform any transforms. */
+	if (len < 64 - r) {
+		memcpy(&ctx->buf[r], src, len);
+		return;
+	}
+
+	/* Finish the current block. */
+	memcpy(&ctx->buf[r], src, 64 - r);
+	SHA256_Transform(ctx->state, ctx->buf, &tmp32[0], &tmp32[64]);
+	src += 64 - r;
+	len -= 64 - r;
+
+	/* Perform complete blocks. */
+	while (len >= 64) {
+		SHA256_Transform(ctx->state, src, &tmp32[0], &tmp32[64]);
+		src += 64;
+		len -= 64;
+	}
+
+	/* Copy left over data into buffer. */
+	memcpy(ctx->buf, src, len);
+}
+
+/* Wrapper function for intermediate-values sanitization. */
+hidden void
+SHA256_Update(SHA256_CTX * ctx, const void * in, size_t len)
+{
+	uint32_t tmp32[72];
+
+	/* Call the real function. */
+	_SHA256_Update(ctx, in, len, tmp32);
+
+	/* Clean the stack. */
+	insecure_memzero(tmp32, 288);
+}
+
+/**
+ * SHA256_Final(digest, ctx):
+ * Output the SHA256 hash of the data input to the context ${ctx} into the
+ * buffer ${digest}.
+ */
+static void
+_SHA256_Final(uint8_t digest[32], SHA256_CTX * ctx,
+    uint32_t tmp32[static restrict 72])
+{
+
+	/* Add padding. */
+	SHA256_Pad(ctx, tmp32);
+
+	/* Write the hash. */
+	be32enc_vect(digest, ctx->state, 4);
+}
+
+/* Wrapper function for intermediate-values sanitization. */
+hidden void
+SHA256_Final(uint8_t digest[32], SHA256_CTX * ctx)
+{
+	uint32_t tmp32[72];
+
+	/* Call the real function. */
+	_SHA256_Final(digest, ctx, tmp32);
+
+	/* Clear the context state. */
+	insecure_memzero(ctx, sizeof(SHA256_CTX));
+
+	/* Clean the stack. */
+	insecure_memzero(tmp32, 288);
+}
+
+/**
+ * SHA256_Buf(in, len, digest):
+ * Compute the SHA256 hash of ${len} bytes from ${in} and write it to ${digest}.
+ */
+hidden void
+SHA256_Buf(const void * in, size_t len, uint8_t digest[32])
+{
+	SHA256_CTX ctx;
+	uint32_t tmp32[72];
+
+	SHA256_Init(&ctx);
+	_SHA256_Update(&ctx, in, len, tmp32);
+	_SHA256_Final(digest, &ctx, tmp32);
+
+	/* Clean the stack. */
+	insecure_memzero(&ctx, sizeof(SHA256_CTX));
+	insecure_memzero(tmp32, 288);
+}
+
+/**
+ * HMAC_SHA256_Init(ctx, K, Klen):
+ * Initialize the HMAC-SHA256 context ${ctx} with ${Klen} bytes of key from
+ * ${K}.
+ */
+static void
+_HMAC_SHA256_Init(HMAC_SHA256_CTX * ctx, const void * _K, size_t Klen,
+    uint32_t tmp32[static restrict 72], uint8_t pad[static restrict 64],
+    uint8_t khash[static restrict 32])
+{
+	const uint8_t * K = _K;
+	size_t i;
+
+	/* If Klen > 64, the key is really SHA256(K). */
+	if (Klen > 64) {
+		SHA256_Init(&ctx->ictx);
+		_SHA256_Update(&ctx->ictx, K, Klen, tmp32);
+		_SHA256_Final(khash, &ctx->ictx, tmp32);
+		K = khash;
+		Klen = 32;
+	}
+
+	/* Inner SHA256 operation is SHA256(K xor [block of 0x36] || data). */
+	SHA256_Init(&ctx->ictx);
+	memset(pad, 0x36, 64);
+	for (i = 0; i < Klen; i++)
+		pad[i] ^= K[i];
+	_SHA256_Update(&ctx->ictx, pad, 64, tmp32);
+
+	/* Outer SHA256 operation is SHA256(K xor [block of 0x5c] || hash). */
+	SHA256_Init(&ctx->octx);
+	memset(pad, 0x5c, 64);
+	for (i = 0; i < Klen; i++)
+		pad[i] ^= K[i];
+	_SHA256_Update(&ctx->octx, pad, 64, tmp32);
+}
+
+/* Wrapper function for intermediate-values sanitization. */
+hidden void
+HMAC_SHA256_Init(HMAC_SHA256_CTX * ctx, const void * _K, size_t Klen)
+{
+	uint32_t tmp32[72];
+	uint8_t pad[64];
+	uint8_t khash[32];
+
+	/* Call the real function. */
+	_HMAC_SHA256_Init(ctx, _K, Klen, tmp32, pad, khash);
+
+	/* Clean the stack. */
+	insecure_memzero(tmp32, 288);
+	insecure_memzero(khash, 32);
+	insecure_memzero(pad, 64);
+}
+
+/**
+ * HMAC_SHA256_Update(ctx, in, len):
+ * Input ${len} bytes from ${in} into the HMAC-SHA256 context ${ctx}.
+ */
+static void
+_HMAC_SHA256_Update(HMAC_SHA256_CTX * ctx, const void * in, size_t len,
+    uint32_t tmp32[static restrict 72])
+{
+
+	/* Feed data to the inner SHA256 operation. */
+	_SHA256_Update(&ctx->ictx, in, len, tmp32);
+}
+
+/* Wrapper function for intermediate-values sanitization. */
+hidden void
+HMAC_SHA256_Update(HMAC_SHA256_CTX * ctx, const void * in, size_t len)
+{
+	uint32_t tmp32[72];
+
+	/* Call the real function. */
+	_HMAC_SHA256_Update(ctx, in, len, tmp32);
+
+	/* Clean the stack. */
+	insecure_memzero(tmp32, 288);
+}
+
+/**
+ * HMAC_SHA256_Final(digest, ctx):
+ * Output the HMAC-SHA256 of the data input to the context ${ctx} into the
+ * buffer ${digest}.
+ */
+static void
+_HMAC_SHA256_Final(uint8_t digest[32], HMAC_SHA256_CTX * ctx,
+    uint32_t tmp32[static restrict 72], uint8_t ihash[static restrict 32])
+{
+
+	/* Finish the inner SHA256 operation. */
+	_SHA256_Final(ihash, &ctx->ictx, tmp32);
+
+	/* Feed the inner hash to the outer SHA256 operation. */
+	_SHA256_Update(&ctx->octx, ihash, 32, tmp32);
+
+	/* Finish the outer SHA256 operation. */
+	_SHA256_Final(digest, &ctx->octx, tmp32);
+}
+
+/* Wrapper function for intermediate-values sanitization. */
+hidden void
+HMAC_SHA256_Final(uint8_t digest[32], HMAC_SHA256_CTX * ctx)
+{
+	uint32_t tmp32[72];
+	uint8_t ihash[32];
+
+	/* Call the real function. */
+	_HMAC_SHA256_Final(digest, ctx, tmp32, ihash);
+
+	/* Clean the stack. */
+	insecure_memzero(tmp32, 288);
+	insecure_memzero(ihash, 32);
+}
+
+/**
+ * HMAC_SHA256_Buf(K, Klen, in, len, digest):
+ * Compute the HMAC-SHA256 of ${len} bytes from ${in} using the key ${K} of
+ * length ${Klen}, and write the result to ${digest}.
+ */
+hidden void
+HMAC_SHA256_Buf(const void * K, size_t Klen, const void * in, size_t len,
+    uint8_t digest[32])
+{
+	HMAC_SHA256_CTX ctx;
+	uint32_t tmp32[72];
+	uint8_t tmp8[96];
+
+	_HMAC_SHA256_Init(&ctx, K, Klen, tmp32, &tmp8[0], &tmp8[64]);
+	_HMAC_SHA256_Update(&ctx, in, len, tmp32);
+	_HMAC_SHA256_Final(digest, &ctx, tmp32, &tmp8[0]);
+
+	/* Clean the stack. */
+	insecure_memzero(&ctx, sizeof(HMAC_SHA256_CTX));
+	insecure_memzero(tmp32, 288);
+	insecure_memzero(tmp8, 96);
+}
+
+/* Add padding and terminating bit-count, but don't invoke Transform yet. */
+static int
+SHA256_Pad_Almost(SHA256_CTX * ctx, uint8_t len[static restrict 8],
+    uint32_t tmp32[static restrict 72])
+{
+	uint32_t r;
+
+	r = (ctx->count >> 3) & 0x3f;
+	if (r >= 56)
+		return -1;
+
+	/*
+	 * Convert length to a vector of bytes -- we do this now rather
+	 * than later because the length will change after we pad.
+	 */
+	be64enc(len, ctx->count);
+
+	/* Add 1--56 bytes so that the resulting length is 56 mod 64. */
+	_SHA256_Update(ctx, PAD, 56 - r, tmp32);
+
+	/* Add the terminating bit-count. */
+	ctx->buf[63] = len[7];
+	_SHA256_Update(ctx, len, 7, tmp32);
+
+	return 0;
+}
+
+/**
+ * PBKDF2_SHA256(passwd, passwdlen, salt, saltlen, c, buf, dkLen):
+ * Compute PBKDF2(passwd, salt, c, dkLen) using HMAC-SHA256 as the PRF, and
+ * write the output to buf.  The value dkLen must be at most 32 * (2^32 - 1).
+ */
+hidden void
+PBKDF2_SHA256(const uint8_t * passwd, size_t passwdlen, const uint8_t * salt,
+    size_t saltlen, uint64_t c, uint8_t * buf, size_t dkLen)
+{
+	HMAC_SHA256_CTX Phctx, PShctx, hctx;
+	uint32_t tmp32[72];
+	union {
+		uint8_t tmp8[96];
+		uint32_t state[8];
+	} u;
+	size_t i;
+	uint8_t ivec[4];
+	uint8_t U[32];
+	uint8_t T[32];
+	uint64_t j;
+	int k;
+	size_t clen;
+
+	/* Sanity-check. */
+	assert(dkLen <= 32 * (size_t)(UINT32_MAX));
+
+	if (c == 1 && (dkLen & 31) == 0 && (saltlen & 63) <= 51) {
+		uint32_t oldcount;
+		uint8_t * ivecp;
+
+		/* Compute HMAC state after processing P and S. */
+		_HMAC_SHA256_Init(&hctx, passwd, passwdlen,
+		    tmp32, &u.tmp8[0], &u.tmp8[64]);
+		_HMAC_SHA256_Update(&hctx, salt, saltlen, tmp32);
+
+		/* Prepare ictx padding. */
+		oldcount = hctx.ictx.count & (0x3f << 3);
+		_HMAC_SHA256_Update(&hctx, "\0\0\0", 4, tmp32);
+		if ((hctx.ictx.count & (0x3f << 3)) < oldcount ||
+		    SHA256_Pad_Almost(&hctx.ictx, u.tmp8, tmp32))
+			goto generic; /* Can't happen due to saltlen check */
+		ivecp = hctx.ictx.buf + (oldcount >> 3);
+
+		/* Prepare octx padding. */
+		hctx.octx.count += 32 << 3;
+		SHA256_Pad_Almost(&hctx.octx, u.tmp8, tmp32);
+
+		/* Iterate through the blocks. */
+		for (i = 0; i * 32 < dkLen; i++) {
+			/* Generate INT(i + 1). */
+			be32enc(ivecp, (uint32_t)(i + 1));
+
+			/* Compute U_1 = PRF(P, S || INT(i)). */
+			memcpy(u.state, hctx.ictx.state, sizeof(u.state));
+			SHA256_Transform(u.state, hctx.ictx.buf,
+			    &tmp32[0], &tmp32[64]);
+			be32enc_vect(hctx.octx.buf, u.state, 4);
+			memcpy(u.state, hctx.octx.state, sizeof(u.state));
+			SHA256_Transform(u.state, hctx.octx.buf,
+			    &tmp32[0], &tmp32[64]);
+			be32enc_vect(&buf[i * 32], u.state, 4);
+		}
+
+		goto cleanup;
+	}
+
+generic:
+	/* Compute HMAC state after processing P. */
+	_HMAC_SHA256_Init(&Phctx, passwd, passwdlen,
+	    tmp32, &u.tmp8[0], &u.tmp8[64]);
+
+	/* Compute HMAC state after processing P and S. */
+	memcpy(&PShctx, &Phctx, sizeof(HMAC_SHA256_CTX));
+	_HMAC_SHA256_Update(&PShctx, salt, saltlen, tmp32);
+
+	/* Iterate through the blocks. */
+	for (i = 0; i * 32 < dkLen; i++) {
+		/* Generate INT(i + 1). */
+		be32enc(ivec, (uint32_t)(i + 1));
+
+		/* Compute U_1 = PRF(P, S || INT(i)). */
+		memcpy(&hctx, &PShctx, sizeof(HMAC_SHA256_CTX));
+		_HMAC_SHA256_Update(&hctx, ivec, 4, tmp32);
+		_HMAC_SHA256_Final(T, &hctx, tmp32, u.tmp8);
+
+		if (c > 1) {
+			/* T_i = U_1 ... */
+			memcpy(U, T, 32);
+
+			for (j = 2; j <= c; j++) {
+				/* Compute U_j. */
+				memcpy(&hctx, &Phctx, sizeof(HMAC_SHA256_CTX));
+				_HMAC_SHA256_Update(&hctx, U, 32, tmp32);
+				_HMAC_SHA256_Final(U, &hctx, tmp32, u.tmp8);
+
+				/* ... xor U_j ... */
+				for (k = 0; k < 32; k++)
+					T[k] ^= U[k];
+			}
+		}
+
+		/* Copy as many bytes as necessary into buf. */
+		clen = dkLen - i * 32;
+		if (clen > 32)
+			clen = 32;
+		memcpy(&buf[i * 32], T, clen);
+	}
+
+	/* Clean the stack. */
+	insecure_memzero(&Phctx, sizeof(HMAC_SHA256_CTX));
+	insecure_memzero(&PShctx, sizeof(HMAC_SHA256_CTX));
+	insecure_memzero(U, 32);
+	insecure_memzero(T, 32);
+
+cleanup:
+	insecure_memzero(&hctx, sizeof(HMAC_SHA256_CTX));
+	insecure_memzero(tmp32, 288);
+	insecure_memzero(&u, sizeof(u));
+}
diff --git a/src/yescrypt/sha256.h b/src/yescrypt/sha256.h
new file mode 100644
index 000000000000..b1d4257b0bd5
--- /dev/null
+++ b/src/yescrypt/sha256.h
@@ -0,0 +1,129 @@
+/*-
+ * Copyright 2005-2016 Colin Percival
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _SHA256_H_
+#define _SHA256_H_
+
+#include <stddef.h>
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Use #defines in order to avoid namespace collisions with anyone else's
+ * SHA256 code (e.g., the code in OpenSSL).
+ */
+#define SHA256_Init libcperciva_SHA256_Init
+#define SHA256_Update libcperciva_SHA256_Update
+#define SHA256_Final libcperciva_SHA256_Final
+#define SHA256_Buf libcperciva_SHA256_Buf
+#define SHA256_CTX libcperciva_SHA256_CTX
+#define HMAC_SHA256_Init libcperciva_HMAC_SHA256_Init
+#define HMAC_SHA256_Update libcperciva_HMAC_SHA256_Update
+#define HMAC_SHA256_Final libcperciva_HMAC_SHA256_Final
+#define HMAC_SHA256_Buf libcperciva_HMAC_SHA256_Buf
+#define HMAC_SHA256_CTX libcperciva_HMAC_SHA256_CTX
+
+/* Context structure for SHA256 operations. */
+typedef struct {
+	uint32_t state[8];
+	uint64_t count;
+	uint8_t buf[64];
+} SHA256_CTX;
+
+/**
+ * SHA256_Init(ctx):
+ * Initialize the SHA256 context ${ctx}.
+ */
+hidden void SHA256_Init(SHA256_CTX *);
+
+/**
+ * SHA256_Update(ctx, in, len):
+ * Input ${len} bytes from ${in} into the SHA256 context ${ctx}.
+ */
+hidden void SHA256_Update(SHA256_CTX *, const void *, size_t);
+
+/**
+ * SHA256_Final(digest, ctx):
+ * Output the SHA256 hash of the data input to the context ${ctx} into the
+ * buffer ${digest}.
+ */
+hidden void SHA256_Final(uint8_t[32], SHA256_CTX *);
+
+/**
+ * SHA256_Buf(in, len, digest):
+ * Compute the SHA256 hash of ${len} bytes from ${in} and write it to ${digest}.
+ */
+hidden void SHA256_Buf(const void *, size_t, uint8_t[32]);
+
+/* Context structure for HMAC-SHA256 operations. */
+typedef struct {
+	SHA256_CTX ictx;
+	SHA256_CTX octx;
+} HMAC_SHA256_CTX;
+
+/**
+ * HMAC_SHA256_Init(ctx, K, Klen):
+ * Initialize the HMAC-SHA256 context ${ctx} with ${Klen} bytes of key from
+ * ${K}.
+ */
+hidden void HMAC_SHA256_Init(HMAC_SHA256_CTX *, const void *, size_t);
+
+/**
+ * HMAC_SHA256_Update(ctx, in, len):
+ * Input ${len} bytes from ${in} into the HMAC-SHA256 context ${ctx}.
+ */
+hidden void HMAC_SHA256_Update(HMAC_SHA256_CTX *, const void *, size_t);
+
+/**
+ * HMAC_SHA256_Final(digest, ctx):
+ * Output the HMAC-SHA256 of the data input to the context ${ctx} into the
+ * buffer ${digest}.
+ */
+hidden void HMAC_SHA256_Final(uint8_t[32], HMAC_SHA256_CTX *);
+
+/**
+ * HMAC_SHA256_Buf(K, Klen, in, len, digest):
+ * Compute the HMAC-SHA256 of ${len} bytes from ${in} using the key ${K} of
+ * length ${Klen}, and write the result to ${digest}.
+ */
+hidden void HMAC_SHA256_Buf(const void *, size_t, const void *, size_t, uint8_t[32]);
+
+/**
+ * PBKDF2_SHA256(passwd, passwdlen, salt, saltlen, c, buf, dkLen):
+ * Compute PBKDF2(passwd, salt, c, dkLen) using HMAC-SHA256 as the PRF, and
+ * write the output to buf.  The value dkLen must be at most 32 * (2^32 - 1).
+ */
+hidden void PBKDF2_SHA256(const uint8_t *, size_t, const uint8_t *, size_t,
+    uint64_t, uint8_t *, size_t);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_SHA256_H_ */
diff --git a/src/yescrypt/sysendian.h b/src/yescrypt/sysendian.h
new file mode 100644
index 000000000000..c51730d1cd5d
--- /dev/null
+++ b/src/yescrypt/sysendian.h
@@ -0,0 +1,122 @@
+/*-
+ * Copyright 2007-2014 Colin Percival
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _SYSENDIAN_H_
+#define _SYSENDIAN_H_
+
+#include <stdint.h>
+
+/* Avoid namespace collisions with BSD <sys/endian.h>. */
+#define be32dec libcperciva_be32dec
+#define be32enc libcperciva_be32enc
+#define be64enc libcperciva_be64enc
+#define le32dec libcperciva_le32dec
+#define le32enc libcperciva_le32enc
+#define le64dec libcperciva_le64dec
+#define le64enc libcperciva_le64enc
+
+static inline uint32_t
+be32dec(const void * pp)
+{
+	const uint8_t * p = (uint8_t const *)pp;
+
+	return ((uint32_t)(p[3]) + ((uint32_t)(p[2]) << 8) +
+	    ((uint32_t)(p[1]) << 16) + ((uint32_t)(p[0]) << 24));
+}
+
+static inline void
+be32enc(void * pp, uint32_t x)
+{
+	uint8_t * p = (uint8_t *)pp;
+
+	p[3] = x & 0xff;
+	p[2] = (x >> 8) & 0xff;
+	p[1] = (x >> 16) & 0xff;
+	p[0] = (x >> 24) & 0xff;
+}
+
+static inline void
+be64enc(void * pp, uint64_t x)
+{
+	uint8_t * p = (uint8_t *)pp;
+
+	p[7] = x & 0xff;
+	p[6] = (x >> 8) & 0xff;
+	p[5] = (x >> 16) & 0xff;
+	p[4] = (x >> 24) & 0xff;
+	p[3] = (x >> 32) & 0xff;
+	p[2] = (x >> 40) & 0xff;
+	p[1] = (x >> 48) & 0xff;
+	p[0] = (x >> 56) & 0xff;
+}
+
+static inline uint32_t
+le32dec(const void * pp)
+{
+	const uint8_t * p = (uint8_t const *)pp;
+
+	return ((uint32_t)(p[0]) + ((uint32_t)(p[1]) << 8) +
+	    ((uint32_t)(p[2]) << 16) + ((uint32_t)(p[3]) << 24));
+}
+
+static inline void
+le32enc(void * pp, uint32_t x)
+{
+	uint8_t * p = (uint8_t *)pp;
+
+	p[0] = x & 0xff;
+	p[1] = (x >> 8) & 0xff;
+	p[2] = (x >> 16) & 0xff;
+	p[3] = (x >> 24) & 0xff;
+}
+
+static inline uint64_t
+le64dec(const void * pp)
+{
+	const uint8_t * p = (uint8_t const *)pp;
+
+	return ((uint64_t)(p[0]) + ((uint64_t)(p[1]) << 8) +
+	    ((uint64_t)(p[2]) << 16) + ((uint64_t)(p[3]) << 24) +
+	    ((uint64_t)(p[4]) << 32) + ((uint64_t)(p[5]) << 40) +
+	    ((uint64_t)(p[6]) << 48) + ((uint64_t)(p[7]) << 56));
+}
+
+static inline void
+le64enc(void * pp, uint64_t x)
+{
+	uint8_t * p = (uint8_t *)pp;
+
+	p[0] = x & 0xff;
+	p[1] = (x >> 8) & 0xff;
+	p[2] = (x >> 16) & 0xff;
+	p[3] = (x >> 24) & 0xff;
+	p[4] = (x >> 32) & 0xff;
+	p[5] = (x >> 40) & 0xff;
+	p[6] = (x >> 48) & 0xff;
+	p[7] = (x >> 56) & 0xff;
+}
+
+#endif /* !_SYSENDIAN_H_ */
diff --git a/src/yescrypt/yescrypt-common.c b/src/yescrypt/yescrypt-common.c
new file mode 100644
index 000000000000..e636c17f13ce
--- /dev/null
+++ b/src/yescrypt/yescrypt-common.c
@@ -0,0 +1,705 @@
+/*-
+ * Copyright 2013-2018 Alexander Peslyak
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <stdint.h>
+#include <string.h>
+
+#include "insecure_memzero.h"
+#include "sha256.h"
+
+#define YESCRYPT_INTERNAL
+#include "yescrypt.h"
+
+#define BYTES2CHARS(bytes) ((((bytes) * 8) + 5) / 6)
+
+#define HASH_SIZE sizeof(yescrypt_binary_t) /* bytes */
+#define HASH_LEN BYTES2CHARS(HASH_SIZE) /* base-64 chars */
+
+/*
+ * "$y$", up to 8 params of up to 6 chars each, '$', salt
+ * Alternatively, but that's smaller:
+ * "$7$", 3 params encoded as 1+5+5 chars, salt
+ */
+#define PREFIX_LEN (3 + 8 * 6 + 1 + BYTES2CHARS(32))
+
+static const char * const itoa64 =
+	"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
+
+static const uint8_t atoi64_partial[77] = {
+	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
+	64, 64, 64, 64, 64, 64, 64,
+	12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
+	25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37,
+	64, 64, 64, 64, 64, 64,
+	38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
+	51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63
+};
+
+static uint8_t *encode64_uint32(uint8_t *dst, size_t dstlen,
+    uint32_t src, uint32_t min)
+{
+	uint32_t start = 0, end = 47, chars = 1, bits = 0;
+
+	if (src < min)
+		return NULL;
+	src -= min;
+
+	do {
+		uint32_t count = (end + 1 - start) << bits;
+		if (src < count)
+			break;
+		if (start >= 63)
+			return NULL;
+		start = end + 1;
+		end = start + (62 - end) / 2;
+		src -= count;
+		chars++;
+		bits += 6;
+	} while (1);
+
+	if (dstlen <= chars) /* require room for a NUL terminator */
+		return NULL;
+
+	*dst++ = itoa64[start + (src >> bits)];
+
+	while (--chars) {
+		bits -= 6;
+		*dst++ = itoa64[(src >> bits) & 0x3f];
+	}
+
+	*dst = 0; /* NUL terminate just in case */
+
+	return dst;
+}
+
+static inline uint32_t atoi64(uint8_t src)
+{
+	if (src >= '.' && src <= 'z')
+		return atoi64_partial[src - '.'];
+
+	return 64;
+}
+
+static const uint8_t *decode64_uint32(uint32_t *dst,
+    const uint8_t *src, uint32_t min)
+{
+	uint32_t start = 0, end = 47, chars = 1, bits = 0;
+	uint32_t c;
+
+	c = atoi64(*src++);
+	if (c > 63)
+		goto fail;
+
+	*dst = min;
+	while (c > end) {
+		*dst += (end + 1 - start) << bits;
+		start = end + 1;
+		end = start + (62 - end) / 2;
+		chars++;
+		bits += 6;
+	}
+
+	*dst += (c - start) << bits;
+
+	while (--chars) {
+		c = atoi64(*src++);
+		if (c > 63)
+			goto fail;
+		bits -= 6;
+		*dst += c << bits;
+	}
+
+	return src;
+
+fail:
+	*dst = 0;
+	return NULL;
+}
+
+static uint8_t *encode64_uint32_fixed(uint8_t *dst, size_t dstlen,
+    uint32_t src, uint32_t srcbits)
+{
+	uint32_t bits;
+
+	for (bits = 0; bits < srcbits; bits += 6) {
+		if (dstlen < 2)
+			return NULL;
+		*dst++ = itoa64[src & 0x3f];
+		dstlen--;
+		src >>= 6;
+	}
+
+	if (src || dstlen < 1)
+		return NULL;
+
+	*dst = 0; /* NUL terminate just in case */
+
+	return dst;
+}
+
+static uint8_t *encode64(uint8_t *dst, size_t dstlen,
+    const uint8_t *src, size_t srclen)
+{
+	size_t i;
+
+	for (i = 0; i < srclen; ) {
+		uint8_t *dnext;
+		uint32_t value = 0, bits = 0;
+		do {
+			value |= (uint32_t)src[i++] << bits;
+			bits += 8;
+		} while (bits < 24 && i < srclen);
+		dnext = encode64_uint32_fixed(dst, dstlen, value, bits);
+		if (!dnext)
+			return NULL;
+		dstlen -= dnext - dst;
+		dst = dnext;
+	}
+
+	if (dstlen < 1)
+		return NULL;
+
+	*dst = 0; /* NUL terminate just in case */
+
+	return dst;
+}
+
+static const uint8_t *decode64_uint32_fixed(uint32_t *dst, uint32_t dstbits,
+    const uint8_t *src)
+{
+	uint32_t bits;
+
+	*dst = 0;
+	for (bits = 0; bits < dstbits; bits += 6) {
+		uint32_t c = atoi64(*src++);
+		if (c > 63) {
+			*dst = 0;
+			return NULL;
+		}
+		*dst |= c << bits;
+	}
+
+	return src;
+}
+
+static const uint8_t *decode64(uint8_t *dst, size_t *dstlen,
+    const uint8_t *src, size_t srclen)
+{
+	size_t dstpos = 0;
+
+	while (dstpos <= *dstlen && srclen) {
+		uint32_t value = 0, bits = 0;
+		while (srclen--) {
+			uint32_t c = atoi64(*src);
+			if (c > 63) {
+				srclen = 0;
+				break;
+			}
+			src++;
+			value |= c << bits;
+			bits += 6;
+			if (bits >= 24)
+				break;
+		}
+		if (!bits)
+			break;
+		if (bits < 12) /* must have at least one full byte */
+			goto fail;
+		while (dstpos++ < *dstlen) {
+			*dst++ = value;
+			value >>= 8;
+			bits -= 8;
+			if (bits < 8) { /* 2 or 4 */
+				if (value) /* must be 0 */
+					goto fail;
+				bits = 0;
+				break;
+			}
+		}
+		if (bits)
+			goto fail;
+	}
+
+	if (!srclen && dstpos <= *dstlen) {
+		*dstlen = dstpos;
+		return src;
+	}
+
+fail:
+	*dstlen = 0;
+	return NULL;
+}
+
+typedef enum { ENC = 1, DEC = -1 } encrypt_dir_t;
+
+static void memxor(unsigned char *dst, unsigned char *src, size_t size)
+{
+	while (size--)
+		*dst++ ^= *src++;
+}
+
+static void encrypt(unsigned char *data, size_t datalen,
+    const yescrypt_binary_t *key, encrypt_dir_t dir)
+{
+	SHA256_CTX ctx;
+	unsigned char f[32 + 4];
+	size_t halflen, which;
+	unsigned char mask, round, target;
+
+	if (!datalen)
+		return;
+	if (datalen > 64)
+		datalen = 64;
+
+	halflen = datalen >> 1;
+
+	which = 0; /* offset to half we are working on (0 or halflen) */
+	mask = 0x0f; /* current half's extra nibble mask if datalen is odd */
+
+	round = 0;
+	target = 5; /* 6 rounds due to Jacques Patarin's CRYPTO 2004 paper */
+
+	if (dir == DEC) {
+		which = halflen; /* even round count, so swap the halves */
+		mask ^= 0xff;
+
+		round = target;
+		target = 0;
+	}
+
+	f[32] = 0;
+	f[33] = sizeof(*key);
+	f[34] = datalen;
+
+	do {
+		SHA256_Init(&ctx);
+		f[35] = round;
+		SHA256_Update(&ctx, &f[32], 4);
+		SHA256_Update(&ctx, key, sizeof(*key));
+		SHA256_Update(&ctx, &data[which], halflen);
+		if (datalen & 1) {
+			f[0] = data[datalen - 1] & mask;
+			SHA256_Update(&ctx, f, 1);
+		}
+		SHA256_Final(f, &ctx);
+		which ^= halflen;
+		memxor(&data[which], f, halflen);
+		if (datalen & 1) {
+			mask ^= 0xff;
+			data[datalen - 1] ^= f[halflen] & mask;
+		}
+		if (round == target)
+			break;
+		round += dir;
+	} while (1);
+
+	/* ctx is presumably zeroized by SHA256_Final() */
+	insecure_memzero(f, sizeof(f));
+}
+
+hidden uint8_t *yescrypt_r(const yescrypt_shared_t *shared, yescrypt_local_t *local,
+    const uint8_t *passwd, size_t passwdlen,
+    const uint8_t *setting,
+    const yescrypt_binary_t *key,
+    uint8_t *buf, size_t buflen)
+{
+	unsigned char saltbin[64], hashbin[32];
+	const uint8_t *src, *saltstr, *salt;
+	uint8_t *dst;
+	size_t need, prefixlen, saltstrlen, saltlen;
+	yescrypt_params_t params = { .p = 1 };
+
+	if (setting[0] != '$' ||
+	    (setting[1] != '7' && setting[1] != 'y') ||
+	    setting[2] != '$')
+		return NULL;
+	src = setting + 3;
+
+	if (setting[1] == '7') {
+		uint32_t N_log2 = atoi64(*src++);
+		if (N_log2 < 1 || N_log2 > 63)
+			return NULL;
+		params.N = (uint64_t)1 << N_log2;
+
+		src = decode64_uint32_fixed(&params.r, 30, src);
+		if (!src)
+			return NULL;
+
+		src = decode64_uint32_fixed(&params.p, 30, src);
+		if (!src)
+			return NULL;
+
+		if (key)
+			return NULL;
+	} else {
+		uint32_t flavor, N_log2;
+
+		src = decode64_uint32(&flavor, src, 0);
+		if (!src)
+			return NULL;
+
+		if (flavor < YESCRYPT_RW) {
+			params.flags = flavor;
+		} else if (flavor <= YESCRYPT_RW + (YESCRYPT_RW_FLAVOR_MASK >> 2)) {
+			params.flags = YESCRYPT_RW + ((flavor - YESCRYPT_RW) << 2);
+		} else {
+			return NULL;
+		}
+
+		src = decode64_uint32(&N_log2, src, 1);
+		if (!src || N_log2 > 63)
+			return NULL;
+		params.N = (uint64_t)1 << N_log2;
+
+		src = decode64_uint32(&params.r, src, 1);
+		if (!src)
+			return NULL;
+
+		if (*src != '$') {
+			uint32_t have;
+
+			src = decode64_uint32(&have, src, 1);
+			if (!src)
+				return NULL;
+
+			if (have & 1) {
+				src = decode64_uint32(&params.p, src, 2);
+				if (!src)
+					return NULL;
+			}
+
+			if (have & 2) {
+				src = decode64_uint32(&params.t, src, 1);
+				if (!src)
+					return NULL;
+			}
+
+			if (have & 4) {
+				src = decode64_uint32(&params.g, src, 1);
+				if (!src)
+					return NULL;
+			}
+
+			if (have & 8) {
+				uint32_t NROM_log2;
+				src = decode64_uint32(&NROM_log2, src, 1);
+				if (!src || NROM_log2 > 63)
+					return NULL;
+				params.NROM = (uint64_t)1 << NROM_log2;
+			}
+		}
+
+		if (*src++ != '$')
+			return NULL;
+	}
+
+	prefixlen = src - setting;
+
+	saltstr = src;
+	src = (uint8_t *)strrchr((char *)saltstr, '$');
+	if (src)
+		saltstrlen = src - saltstr;
+	else
+		saltstrlen = strlen((char *)saltstr);
+
+	if (setting[1] == '7') {
+		salt = saltstr;
+		saltlen = saltstrlen;
+	} else {
+		const uint8_t *saltend;
+
+		saltlen = sizeof(saltbin);
+		saltend = decode64(saltbin, &saltlen, saltstr, saltstrlen);
+
+		if (!saltend || (size_t)(saltend - saltstr) != saltstrlen)
+			goto fail;
+
+		salt = saltbin;
+
+		if (key)
+			encrypt(saltbin, saltlen, key, ENC);
+	}
+
+	need = prefixlen + saltstrlen + 1 + HASH_LEN + 1;
+	if (need > buflen || need < saltstrlen)
+		goto fail;
+
+	if (yescrypt_kdf(shared, local, passwd, passwdlen, salt, saltlen,
+	    &params, hashbin, sizeof(hashbin)))
+		goto fail;
+
+	if (key) {
+		insecure_memzero(saltbin, sizeof(saltbin));
+		encrypt(hashbin, sizeof(hashbin), key, ENC);
+	}
+
+	dst = buf;
+	memcpy(dst, setting, prefixlen + saltstrlen);
+	dst += prefixlen + saltstrlen;
+	*dst++ = '$';
+
+	dst = encode64(dst, buflen - (dst - buf), hashbin, sizeof(hashbin));
+	insecure_memzero(hashbin, sizeof(hashbin));
+	if (!dst || dst >= buf + buflen)
+		return NULL;
+
+	*dst = 0; /* NUL termination */
+
+	return buf;
+
+fail:
+	insecure_memzero(saltbin, sizeof(saltbin));
+	insecure_memzero(hashbin, sizeof(hashbin));
+	return NULL;
+}
+
+hidden uint8_t *yescrypt(const uint8_t *passwd, const uint8_t *setting)
+{
+	/* prefix, '$', hash, NUL */
+	//static uint8_t buf[PREFIX_LEN + 1 + HASH_LEN + 1];
+        size_t buf_size = PREFIX_LEN + 1 + HASH_LEN + 1;
+	uint8_t* buf = zgc_alloc(buf_size);
+	yescrypt_local_t local;
+	uint8_t *retval;
+
+	if (yescrypt_init_local(&local))
+		return NULL;
+	retval = yescrypt_r(NULL, &local,
+	    passwd, strlen((char *)passwd), setting, NULL, buf, buf_size);
+	if (yescrypt_free_local(&local))
+		return NULL;
+	return retval;
+}
+
+hidden uint8_t *yescrypt_reencrypt(uint8_t *hash,
+    const yescrypt_binary_t *from_key,
+    const yescrypt_binary_t *to_key)
+{
+	uint8_t *retval = NULL, *saltstart, *hashstart;
+	const uint8_t *hashend;
+	unsigned char saltbin[64], hashbin[32];
+	size_t saltstrlen, saltlen, hashlen;
+
+	if (strncmp((char *)hash, "$y$", 3))
+		return NULL;
+
+	saltstart = NULL;
+	hashstart = (uint8_t *)strrchr((char *)hash, '$');
+	if (hashstart) {
+		if (hashstart > (uint8_t *)hash) {
+			saltstart = hashstart - 1;
+			while (*saltstart != '$' && saltstart > hash)
+				saltstart--;
+			if (*saltstart == '$')
+				saltstart++;
+		}
+		hashstart++;
+	} else {
+		hashstart = hash;
+	}
+	saltstrlen = saltstart ? (hashstart - 1 - saltstart) : 0;
+	if (saltstrlen > BYTES2CHARS(64) ||
+	    strlen((char *)hashstart) != HASH_LEN)
+		return NULL;
+
+	if (saltstrlen) {
+		const uint8_t *saltend;
+		saltlen = sizeof(saltbin);
+		saltend = decode64(saltbin, &saltlen, saltstart, saltstrlen);
+		if (!saltend || *saltend != '$' || saltlen < 1 || saltlen > 64)
+			goto out;
+
+		if (from_key)
+			encrypt(saltbin, saltlen, from_key, ENC);
+		if (to_key)
+			encrypt(saltbin, saltlen, to_key, DEC);
+	}
+
+	hashlen = sizeof(hashbin);
+	hashend = decode64(hashbin, &hashlen, hashstart, HASH_LEN);
+	if (!hashend || *hashend || hashlen != sizeof(hashbin))
+		goto out;
+
+	if (from_key)
+		encrypt(hashbin, hashlen, from_key, DEC);
+	if (to_key)
+		encrypt(hashbin, hashlen, to_key, ENC);
+
+	if (saltstrlen) {
+		if (!encode64(saltstart, saltstrlen + 1, saltbin, saltlen))
+			goto out; /* can't happen */
+		*(saltstart + saltstrlen) = '$';
+	}
+
+	if (!encode64(hashstart, HASH_LEN + 1, hashbin, hashlen))
+		goto out; /* can't happen */
+
+	retval = hash;
+
+out:
+	insecure_memzero(saltbin, sizeof(saltbin));
+	insecure_memzero(hashbin, sizeof(hashbin));
+
+	return retval;
+}
+
+static uint32_t N2log2(uint64_t N)
+{
+	uint32_t N_log2;
+
+	if (N < 2)
+		return 0;
+
+	N_log2 = 2;
+	while (N >> N_log2 != 0)
+		N_log2++;
+	N_log2--;
+
+	if (N >> N_log2 != 1)
+		return 0;
+
+	return N_log2;
+}
+
+hidden uint8_t *yescrypt_encode_params_r(const yescrypt_params_t *params,
+    const uint8_t *src, size_t srclen,
+    uint8_t *buf, size_t buflen)
+{
+	uint32_t flavor, N_log2, NROM_log2, have;
+	uint8_t *dst;
+
+	if (srclen > SIZE_MAX / 16)
+		return NULL;
+
+	if (params->flags < YESCRYPT_RW) {
+		flavor = params->flags;
+	} else if ((params->flags & YESCRYPT_MODE_MASK) == YESCRYPT_RW &&
+	    params->flags <= (YESCRYPT_RW | YESCRYPT_RW_FLAVOR_MASK)) {
+		flavor = YESCRYPT_RW + (params->flags >> 2);
+	} else {
+		return NULL;
+	}
+
+	N_log2 = N2log2(params->N);
+	if (!N_log2)
+		return NULL;
+
+	NROM_log2 = N2log2(params->NROM);
+	if (params->NROM && !NROM_log2)
+		return NULL;
+
+	if ((uint64_t)params->r * (uint64_t)params->p >= (1U << 30))
+		return NULL;
+
+	dst = buf;
+	*dst++ = '$';
+	*dst++ = 'y';
+	*dst++ = '$';
+
+	dst = encode64_uint32(dst, buflen - (dst - buf), flavor, 0);
+	if (!dst)
+		return NULL;
+
+	dst = encode64_uint32(dst, buflen - (dst - buf), N_log2, 1);
+	if (!dst)
+		return NULL;
+
+	dst = encode64_uint32(dst, buflen - (dst - buf), params->r, 1);
+	if (!dst)
+		return NULL;
+
+	have = 0;
+	if (params->p != 1)
+		have |= 1;
+	if (params->t)
+		have |= 2;
+	if (params->g)
+		have |= 4;
+	if (NROM_log2)
+		have |= 8;
+
+	if (have) {
+		dst = encode64_uint32(dst, buflen - (dst - buf), have, 1);
+		if (!dst)
+			return NULL;
+	}
+
+	if (params->p != 1) {
+		dst = encode64_uint32(dst, buflen - (dst - buf), params->p, 2);
+		if (!dst)
+			return NULL;
+	}
+
+	if (params->t) {
+		dst = encode64_uint32(dst, buflen - (dst - buf), params->t, 1);
+		if (!dst)
+			return NULL;
+	}
+
+	if (params->g) {
+		dst = encode64_uint32(dst, buflen - (dst - buf), params->g, 1);
+		if (!dst)
+			return NULL;
+	}
+
+	if (NROM_log2) {
+		dst = encode64_uint32(dst, buflen - (dst - buf), NROM_log2, 1);
+		if (!dst)
+			return NULL;
+	}
+
+	if (dst >= buf + buflen)
+		return NULL;
+
+	*dst++ = '$';
+
+	dst = encode64(dst, buflen - (dst - buf), src, srclen);
+	if (!dst || dst >= buf + buflen)
+		return NULL;
+
+	*dst = 0; /* NUL termination */
+
+	return buf;
+}
+
+hidden uint8_t *yescrypt_encode_params(const yescrypt_params_t *params,
+    const uint8_t *src, size_t srclen)
+{
+	/* prefix, NUL */
+	static uint8_t buf[PREFIX_LEN + 1];
+	return yescrypt_encode_params_r(params, src, srclen, buf, sizeof(buf));
+}
+
+hidden int crypto_scrypt(const uint8_t *passwd, size_t passwdlen,
+    const uint8_t *salt, size_t saltlen, uint64_t N, uint32_t r, uint32_t p,
+    uint8_t *buf, size_t buflen)
+{
+	yescrypt_local_t local;
+	yescrypt_params_t params = { .flags = 0, .N = N, .r = r, .p = p };
+	int retval;
+
+	if (yescrypt_init_local(&local))
+		return -1;
+	retval = yescrypt_kdf(NULL, &local,
+	    passwd, passwdlen, salt, saltlen, &params, buf, buflen);
+	if (yescrypt_free_local(&local))
+		return -1;
+	return retval;
+}
diff --git a/src/yescrypt/yescrypt-opt.c b/src/yescrypt/yescrypt-opt.c
new file mode 100644
index 000000000000..e38e8f183f60
--- /dev/null
+++ b/src/yescrypt/yescrypt-opt.c
@@ -0,0 +1,1526 @@
+/*-
+ * Copyright 2009 Colin Percival
+ * Copyright 2012-2018 Alexander Peslyak
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * This file was originally written by Colin Percival as part of the Tarsnap
+ * online backup system.
+ */
+
+#undef __SSE2__
+#undef __SSE__
+
+/*
+ * AVX and especially XOP speed up Salsa20 a lot, but this mostly matters for
+ * classic scrypt and for YESCRYPT_WORM (which use 8 rounds of Salsa20 per
+ * sub-block), and much less so for YESCRYPT_RW (which uses 2 rounds of Salsa20
+ * per block except during pwxform S-box initialization).
+ */
+#ifdef __XOP__
+#warning "Note: XOP is enabled.  That's great."
+#elif defined(__AVX__)
+#warning "Note: AVX is enabled, which is great for classic scrypt and YESCRYPT_WORM, but is sometimes slightly slower than plain SSE2 for YESCRYPT_RW"
+#elif defined(__SSE2__)
+#warning "Note: AVX and XOP are not enabled, which is great for YESCRYPT_RW, but they would substantially improve performance at classic scrypt and YESCRYPT_WORM"
+#elif defined(__x86_64__) || defined(__i386__)
+#warning "SSE2 not enabled.  Expect poor performance."
+#else
+#warning "Note: building generic code for non-x86.  That's OK."
+#endif
+
+/*
+ * The SSE4 code version has fewer instructions than the generic SSE2 version,
+ * but all of the instructions are SIMD, thereby wasting the scalar execution
+ * units.  Thus, the generic SSE2 version below actually runs faster on some
+ * CPUs due to its balanced mix of SIMD and scalar instructions.
+ */
+#undef USE_SSE4_FOR_32BIT
+
+#ifdef __SSE2__
+/*
+ * GCC before 4.9 would by default unnecessarily use store/load (without
+ * SSE4.1) or (V)PEXTR (with SSE4.1 or AVX) instead of simply (V)MOV.
+ * This was tracked as GCC bug 54349.
+ * "-mtune=corei7" works around this, but is only supported for GCC 4.6+.
+ * We use inline asm for pre-4.6 GCC, further down this file.
+ */
+#if __GNUC__ == 4 && __GNUC_MINOR__ >= 6 && __GNUC_MINOR__ < 9 && \
+    !defined(__clang__) && !defined(__ICC)
+#pragma GCC target ("tune=corei7")
+#endif
+#include <emmintrin.h>
+#ifdef __XOP__
+#include <x86intrin.h>
+#endif
+#elif defined(__SSE__)
+#include <xmmintrin.h>
+#endif
+
+#include <errno.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "insecure_memzero.h"
+#include "sha256.h"
+#include "sysendian.h"
+
+#define YESCRYPT_INTERNAL
+#include "yescrypt.h"
+
+#include "yescrypt-platform.h"
+
+#if __STDC_VERSION__ >= 199901L
+/* Have restrict */
+#elif defined(__GNUC__)
+#define restrict __restrict
+#else
+#define restrict
+#endif
+
+#ifdef __GNUC__
+#define unlikely(exp) __builtin_expect(exp, 0)
+#else
+#define unlikely(exp) (exp)
+#endif
+
+#ifdef __SSE__
+#define PREFETCH(x, hint) _mm_prefetch((const char *)(x), (hint));
+#else
+#undef PREFETCH
+#endif
+
+typedef union {
+	uint32_t w[16];
+	uint64_t d[8];
+#ifdef __SSE2__
+	__m128i q[4];
+#endif
+} salsa20_blk_t;
+
+static inline void salsa20_simd_shuffle(const salsa20_blk_t *Bin,
+    salsa20_blk_t *Bout)
+{
+#define COMBINE(out, in1, in2) \
+	Bout->d[out] = Bin->w[in1 * 2] | ((uint64_t)Bin->w[in2 * 2 + 1] << 32);
+	COMBINE(0, 0, 2)
+	COMBINE(1, 5, 7)
+	COMBINE(2, 2, 4)
+	COMBINE(3, 7, 1)
+	COMBINE(4, 4, 6)
+	COMBINE(5, 1, 3)
+	COMBINE(6, 6, 0)
+	COMBINE(7, 3, 5)
+#undef COMBINE
+}
+
+static inline void salsa20_simd_unshuffle(const salsa20_blk_t *Bin,
+    salsa20_blk_t *Bout)
+{
+#define UNCOMBINE(out, in1, in2) \
+	Bout->w[out * 2] = Bin->d[in1]; \
+	Bout->w[out * 2 + 1] = Bin->d[in2] >> 32;
+	UNCOMBINE(0, 0, 6)
+	UNCOMBINE(1, 5, 3)
+	UNCOMBINE(2, 2, 0)
+	UNCOMBINE(3, 7, 5)
+	UNCOMBINE(4, 4, 2)
+	UNCOMBINE(5, 1, 7)
+	UNCOMBINE(6, 6, 4)
+	UNCOMBINE(7, 3, 1)
+#undef UNCOMBINE
+}
+
+#ifdef __SSE2__
+#define DECL_X \
+	__m128i X0, X1, X2, X3;
+#define DECL_Y \
+	__m128i Y0, Y1, Y2, Y3;
+#define READ_X(in) \
+	X0 = (in).q[0]; X1 = (in).q[1]; X2 = (in).q[2]; X3 = (in).q[3];
+#define WRITE_X(out) \
+	(out).q[0] = X0; (out).q[1] = X1; (out).q[2] = X2; (out).q[3] = X3;
+
+#ifdef __XOP__
+#define ARX(out, in1, in2, s) \
+	out = _mm_xor_si128(out, _mm_roti_epi32(_mm_add_epi32(in1, in2), s));
+#else
+#define ARX(out, in1, in2, s) { \
+	__m128i tmp = _mm_add_epi32(in1, in2); \
+	out = _mm_xor_si128(out, _mm_slli_epi32(tmp, s)); \
+	out = _mm_xor_si128(out, _mm_srli_epi32(tmp, 32 - s)); \
+}
+#endif
+
+#define SALSA20_2ROUNDS \
+	/* Operate on "columns" */ \
+	ARX(X1, X0, X3, 7) \
+	ARX(X2, X1, X0, 9) \
+	ARX(X3, X2, X1, 13) \
+	ARX(X0, X3, X2, 18) \
+	/* Rearrange data */ \
+	X1 = _mm_shuffle_epi32(X1, 0x93); \
+	X2 = _mm_shuffle_epi32(X2, 0x4E); \
+	X3 = _mm_shuffle_epi32(X3, 0x39); \
+	/* Operate on "rows" */ \
+	ARX(X3, X0, X1, 7) \
+	ARX(X2, X3, X0, 9) \
+	ARX(X1, X2, X3, 13) \
+	ARX(X0, X1, X2, 18) \
+	/* Rearrange data */ \
+	X1 = _mm_shuffle_epi32(X1, 0x39); \
+	X2 = _mm_shuffle_epi32(X2, 0x4E); \
+	X3 = _mm_shuffle_epi32(X3, 0x93);
+
+/**
+ * Apply the Salsa20 core to the block provided in (X0 ... X3).
+ */
+#define SALSA20_wrapper(out, rounds) { \
+	__m128i Z0 = X0, Z1 = X1, Z2 = X2, Z3 = X3; \
+	rounds \
+	(out).q[0] = X0 = _mm_add_epi32(X0, Z0); \
+	(out).q[1] = X1 = _mm_add_epi32(X1, Z1); \
+	(out).q[2] = X2 = _mm_add_epi32(X2, Z2); \
+	(out).q[3] = X3 = _mm_add_epi32(X3, Z3); \
+}
+
+/**
+ * Apply the Salsa20/2 core to the block provided in X.
+ */
+#define SALSA20_2(out) \
+	SALSA20_wrapper(out, SALSA20_2ROUNDS)
+
+#define SALSA20_8ROUNDS \
+	SALSA20_2ROUNDS SALSA20_2ROUNDS SALSA20_2ROUNDS SALSA20_2ROUNDS
+
+#define XOR_X(in) \
+	X0 = _mm_xor_si128(X0, (in).q[0]); \
+	X1 = _mm_xor_si128(X1, (in).q[1]); \
+	X2 = _mm_xor_si128(X2, (in).q[2]); \
+	X3 = _mm_xor_si128(X3, (in).q[3]);
+
+#define XOR_X_2(in1, in2) \
+	X0 = _mm_xor_si128((in1).q[0], (in2).q[0]); \
+	X1 = _mm_xor_si128((in1).q[1], (in2).q[1]); \
+	X2 = _mm_xor_si128((in1).q[2], (in2).q[2]); \
+	X3 = _mm_xor_si128((in1).q[3], (in2).q[3]);
+
+#define XOR_X_WRITE_XOR_Y_2(out, in) \
+	(out).q[0] = Y0 = _mm_xor_si128((out).q[0], (in).q[0]); \
+	(out).q[1] = Y1 = _mm_xor_si128((out).q[1], (in).q[1]); \
+	(out).q[2] = Y2 = _mm_xor_si128((out).q[2], (in).q[2]); \
+	(out).q[3] = Y3 = _mm_xor_si128((out).q[3], (in).q[3]); \
+	X0 = _mm_xor_si128(X0, Y0); \
+	X1 = _mm_xor_si128(X1, Y1); \
+	X2 = _mm_xor_si128(X2, Y2); \
+	X3 = _mm_xor_si128(X3, Y3);
+
+/**
+ * Apply the Salsa20/8 core to the block provided in X ^ in.
+ */
+#define SALSA20_8_XOR_MEM(in, out) \
+	XOR_X(in) \
+	SALSA20_wrapper(out, SALSA20_8ROUNDS)
+
+#define INTEGERIFY _mm_cvtsi128_si32(X0)
+
+#else /* !defined(__SSE2__) */
+
+#define DECL_X \
+	salsa20_blk_t X;
+#define DECL_Y \
+	salsa20_blk_t Y;
+
+#define COPY(out, in) \
+	(out).d[0] = (in).d[0]; \
+	(out).d[1] = (in).d[1]; \
+	(out).d[2] = (in).d[2]; \
+	(out).d[3] = (in).d[3]; \
+	(out).d[4] = (in).d[4]; \
+	(out).d[5] = (in).d[5]; \
+	(out).d[6] = (in).d[6]; \
+	(out).d[7] = (in).d[7];
+
+#define READ_X(in) COPY(X, in)
+#define WRITE_X(out) COPY(out, X)
+
+/**
+ * salsa20(B):
+ * Apply the Salsa20 core to the provided block.
+ */
+static inline void salsa20(salsa20_blk_t *restrict B,
+    salsa20_blk_t *restrict Bout, uint32_t doublerounds)
+{
+	salsa20_blk_t X;
+#define x X.w
+
+	salsa20_simd_unshuffle(B, &X);
+
+	do {
+#define R(a,b) (((a) << (b)) | ((a) >> (32 - (b))))
+		/* Operate on columns */
+		x[ 4] ^= R(x[ 0]+x[12], 7);  x[ 8] ^= R(x[ 4]+x[ 0], 9);
+		x[12] ^= R(x[ 8]+x[ 4],13);  x[ 0] ^= R(x[12]+x[ 8],18);
+
+		x[ 9] ^= R(x[ 5]+x[ 1], 7);  x[13] ^= R(x[ 9]+x[ 5], 9);
+		x[ 1] ^= R(x[13]+x[ 9],13);  x[ 5] ^= R(x[ 1]+x[13],18);
+
+		x[14] ^= R(x[10]+x[ 6], 7);  x[ 2] ^= R(x[14]+x[10], 9);
+		x[ 6] ^= R(x[ 2]+x[14],13);  x[10] ^= R(x[ 6]+x[ 2],18);
+
+		x[ 3] ^= R(x[15]+x[11], 7);  x[ 7] ^= R(x[ 3]+x[15], 9);
+		x[11] ^= R(x[ 7]+x[ 3],13);  x[15] ^= R(x[11]+x[ 7],18);
+
+		/* Operate on rows */
+		x[ 1] ^= R(x[ 0]+x[ 3], 7);  x[ 2] ^= R(x[ 1]+x[ 0], 9);
+		x[ 3] ^= R(x[ 2]+x[ 1],13);  x[ 0] ^= R(x[ 3]+x[ 2],18);
+
+		x[ 6] ^= R(x[ 5]+x[ 4], 7);  x[ 7] ^= R(x[ 6]+x[ 5], 9);
+		x[ 4] ^= R(x[ 7]+x[ 6],13);  x[ 5] ^= R(x[ 4]+x[ 7],18);
+
+		x[11] ^= R(x[10]+x[ 9], 7);  x[ 8] ^= R(x[11]+x[10], 9);
+		x[ 9] ^= R(x[ 8]+x[11],13);  x[10] ^= R(x[ 9]+x[ 8],18);
+
+		x[12] ^= R(x[15]+x[14], 7);  x[13] ^= R(x[12]+x[15], 9);
+		x[14] ^= R(x[13]+x[12],13);  x[15] ^= R(x[14]+x[13],18);
+#undef R
+	} while (--doublerounds);
+#undef x
+
+	{
+		uint32_t i;
+		salsa20_simd_shuffle(&X, Bout);
+		for (i = 0; i < 16; i += 4) {
+			B->w[i] = Bout->w[i] += B->w[i];
+			B->w[i + 1] = Bout->w[i + 1] += B->w[i + 1];
+			B->w[i + 2] = Bout->w[i + 2] += B->w[i + 2];
+			B->w[i + 3] = Bout->w[i + 3] += B->w[i + 3];
+		}
+	}
+
+#if 0
+	/* Too expensive */
+	insecure_memzero(&X, sizeof(X));
+#endif
+}
+
+/**
+ * Apply the Salsa20/2 core to the block provided in X.
+ */
+#define SALSA20_2(out) \
+	salsa20(&X, &out, 1);
+
+#define XOR(out, in1, in2) \
+	(out).d[0] = (in1).d[0] ^ (in2).d[0]; \
+	(out).d[1] = (in1).d[1] ^ (in2).d[1]; \
+	(out).d[2] = (in1).d[2] ^ (in2).d[2]; \
+	(out).d[3] = (in1).d[3] ^ (in2).d[3]; \
+	(out).d[4] = (in1).d[4] ^ (in2).d[4]; \
+	(out).d[5] = (in1).d[5] ^ (in2).d[5]; \
+	(out).d[6] = (in1).d[6] ^ (in2).d[6]; \
+	(out).d[7] = (in1).d[7] ^ (in2).d[7];
+
+#define XOR_X(in) XOR(X, X, in)
+#define XOR_X_2(in1, in2) XOR(X, in1, in2)
+#define XOR_X_WRITE_XOR_Y_2(out, in) \
+	XOR(Y, out, in) \
+	COPY(out, Y) \
+	XOR(X, X, Y)
+
+/**
+ * Apply the Salsa20/8 core to the block provided in X ^ in.
+ */
+#define SALSA20_8_XOR_MEM(in, out) \
+	XOR_X(in); \
+	salsa20(&X, &out, 4);
+
+#define INTEGERIFY (uint32_t)X.d[0]
+#endif
+
+/**
+ * blockmix_salsa8(Bin, Bout, r):
+ * Compute Bout = BlockMix_{salsa20/8, r}(Bin).  The input Bin must be 128r
+ * bytes in length; the output Bout must also be the same size.
+ */
+static void blockmix_salsa8(const salsa20_blk_t *restrict Bin,
+    salsa20_blk_t *restrict Bout, size_t r)
+{
+	size_t i;
+	DECL_X
+
+	READ_X(Bin[r * 2 - 1])
+	for (i = 0; i < r; i++) {
+		SALSA20_8_XOR_MEM(Bin[i * 2], Bout[i])
+		SALSA20_8_XOR_MEM(Bin[i * 2 + 1], Bout[r + i])
+	}
+}
+
+static uint32_t blockmix_salsa8_xor(const salsa20_blk_t *restrict Bin1,
+    const salsa20_blk_t *restrict Bin2, salsa20_blk_t *restrict Bout,
+    size_t r)
+{
+	size_t i;
+	DECL_X
+
+#ifdef PREFETCH
+	PREFETCH(&Bin2[r * 2 - 1], _MM_HINT_T0)
+	for (i = 0; i < r - 1; i++) {
+		PREFETCH(&Bin2[i * 2], _MM_HINT_T0)
+		PREFETCH(&Bin2[i * 2 + 1], _MM_HINT_T0)
+	}
+	PREFETCH(&Bin2[i * 2], _MM_HINT_T0)
+#endif
+
+	XOR_X_2(Bin1[r * 2 - 1], Bin2[r * 2 - 1])
+	for (i = 0; i < r; i++) {
+		XOR_X(Bin1[i * 2])
+		SALSA20_8_XOR_MEM(Bin2[i * 2], Bout[i])
+		XOR_X(Bin1[i * 2 + 1])
+		SALSA20_8_XOR_MEM(Bin2[i * 2 + 1], Bout[r + i])
+	}
+
+	return INTEGERIFY;
+}
+
+/* This is tunable */
+#define Swidth 8
+
+/* Not tunable in this implementation, hard-coded in a few places */
+#define PWXsimple 2
+#define PWXgather 4
+
+/* Derived values.  Not tunable except via Swidth above. */
+#define PWXbytes (PWXgather * PWXsimple * 8)
+#define Sbytes (3 * (1 << Swidth) * PWXsimple * 8)
+#define Smask (((1 << Swidth) - 1) * PWXsimple * 8)
+#define Smask2 (((uint64_t)Smask << 32) | Smask)
+
+#define DECL_SMASK2REG /* empty */
+#define FORCE_REGALLOC_3 /* empty */
+#define MAYBE_MEMORY_BARRIER /* empty */
+
+#ifdef __SSE2__
+/*
+ * (V)PSRLDQ and (V)PSHUFD have higher throughput than (V)PSRLQ on some CPUs
+ * starting with Sandy Bridge.  Additionally, PSHUFD uses separate source and
+ * destination registers, whereas the shifts would require an extra move
+ * instruction for our code when building without AVX.  Unfortunately, PSHUFD
+ * is much slower on Conroe (4 cycles latency vs. 1 cycle latency for PSRLQ)
+ * and somewhat slower on some non-Intel CPUs (luckily not including AMD
+ * Bulldozer and Piledriver).
+ */
+#ifdef __AVX__
+#define HI32(X) \
+	_mm_srli_si128((X), 4)
+#elif 1 /* As an option, check for __SSE4_1__ here not to hurt Conroe */
+#define HI32(X) \
+	_mm_shuffle_epi32((X), _MM_SHUFFLE(2,3,0,1))
+#else
+#define HI32(X) \
+	_mm_srli_epi64((X), 32)
+#endif
+
+#if defined(__x86_64__) && \
+    __GNUC__ == 4 && __GNUC_MINOR__ < 6 && !defined(__ICC)
+#ifdef __AVX__
+#define MOVQ "vmovq"
+#else
+/* "movq" would be more correct, but "movd" is supported by older binutils
+ * due to an error in AMD's spec for x86-64. */
+#define MOVQ "movd"
+#endif
+#define EXTRACT64(X) ({ \
+	uint64_t result; \
+	__asm__(MOVQ " %1, %0" : "=r" (result) : "x" (X)); \
+	result; \
+})
+#elif defined(__x86_64__) && !defined(_MSC_VER) && !defined(__OPEN64__)
+/* MSVC and Open64 had bugs */
+#define EXTRACT64(X) _mm_cvtsi128_si64(X)
+#elif defined(__x86_64__) && defined(__SSE4_1__)
+/* No known bugs for this intrinsic */
+#include <smmintrin.h>
+#define EXTRACT64(X) _mm_extract_epi64((X), 0)
+#elif defined(USE_SSE4_FOR_32BIT) && defined(__SSE4_1__)
+/* 32-bit */
+#include <smmintrin.h>
+#if 0
+/* This is currently unused by the code below, which instead uses these two
+ * intrinsics explicitly when (!defined(__x86_64__) && defined(__SSE4_1__)) */
+#define EXTRACT64(X) \
+	((uint64_t)(uint32_t)_mm_cvtsi128_si32(X) | \
+	((uint64_t)(uint32_t)_mm_extract_epi32((X), 1) << 32))
+#endif
+#else
+/* 32-bit or compilers with known past bugs in _mm_cvtsi128_si64() */
+#define EXTRACT64(X) \
+	((uint64_t)(uint32_t)_mm_cvtsi128_si32(X) | \
+	((uint64_t)(uint32_t)_mm_cvtsi128_si32(HI32(X)) << 32))
+#endif
+
+#if defined(__x86_64__) && (defined(__AVX__) || !defined(__GNUC__))
+/* 64-bit with AVX */
+/* Force use of 64-bit AND instead of two 32-bit ANDs */
+#undef DECL_SMASK2REG
+#if defined(__GNUC__) && !defined(__ICC)
+#define DECL_SMASK2REG uint64_t Smask2reg = Smask2;
+/* Force use of lower-numbered registers to reduce number of prefixes, relying
+ * on out-of-order execution and register renaming. */
+#define FORCE_REGALLOC_1 \
+	__asm__("" : "=a" (x), "+d" (Smask2reg), "+S" (S0), "+D" (S1));
+#define FORCE_REGALLOC_2 \
+	__asm__("" : : "c" (lo));
+#else
+static volatile uint64_t Smask2var = Smask2;
+#define DECL_SMASK2REG uint64_t Smask2reg = Smask2var;
+#define FORCE_REGALLOC_1 /* empty */
+#define FORCE_REGALLOC_2 /* empty */
+#endif
+#define PWXFORM_SIMD(X) { \
+	uint64_t x; \
+	FORCE_REGALLOC_1 \
+	uint32_t lo = x = EXTRACT64(X) & Smask2reg; \
+	FORCE_REGALLOC_2 \
+	uint32_t hi = x >> 32; \
+	X = _mm_mul_epu32(HI32(X), X); \
+	X = _mm_add_epi64(X, *(__m128i *)(S0 + lo)); \
+	X = _mm_xor_si128(X, *(__m128i *)(S1 + hi)); \
+}
+#elif defined(__x86_64__)
+/* 64-bit without AVX.  This relies on out-of-order execution and register
+ * renaming.  It may actually be fastest on CPUs with AVX(2) as well - e.g.,
+ * it runs great on Haswell. */
+#warning "Note: using x86-64 inline assembly for YESCRYPT_RW.  That's great."
+/* We need a compiler memory barrier between sub-blocks to ensure that none of
+ * the writes into what was S2 during processing of the previous sub-block are
+ * postponed until after a read from S0 or S1 in the inline asm code below. */
+#undef MAYBE_MEMORY_BARRIER
+#define MAYBE_MEMORY_BARRIER \
+	__asm__("" : : : "memory");
+#ifdef __ILP32__ /* x32 */
+#define REGISTER_PREFIX "e"
+#else
+#define REGISTER_PREFIX "r"
+#endif
+#define PWXFORM_SIMD(X) { \
+	__m128i H; \
+	__asm__( \
+	    "movd %0, %%rax\n\t" \
+	    "pshufd $0xb1, %0, %1\n\t" \
+	    "andq %2, %%rax\n\t" \
+	    "pmuludq %1, %0\n\t" \
+	    "movl %%eax, %%ecx\n\t" \
+	    "shrq $0x20, %%rax\n\t" \
+	    "paddq (%3,%%" REGISTER_PREFIX "cx), %0\n\t" \
+	    "pxor (%4,%%" REGISTER_PREFIX "ax), %0\n\t" \
+	    : "+x" (X), "=x" (H) \
+	    : "d" (Smask2), "S" (S0), "D" (S1) \
+	    : "cc", "ax", "cx"); \
+}
+#elif defined(USE_SSE4_FOR_32BIT) && defined(__SSE4_1__)
+/* 32-bit with SSE4.1 */
+#define PWXFORM_SIMD(X) { \
+	__m128i x = _mm_and_si128(X, _mm_set1_epi64x(Smask2)); \
+	__m128i s0 = *(__m128i *)(S0 + (uint32_t)_mm_cvtsi128_si32(x)); \
+	__m128i s1 = *(__m128i *)(S1 + (uint32_t)_mm_extract_epi32(x, 1)); \
+	X = _mm_mul_epu32(HI32(X), X); \
+	X = _mm_add_epi64(X, s0); \
+	X = _mm_xor_si128(X, s1); \
+}
+#else
+/* 32-bit without SSE4.1 */
+#define PWXFORM_SIMD(X) { \
+	uint64_t x = EXTRACT64(X) & Smask2; \
+	__m128i s0 = *(__m128i *)(S0 + (uint32_t)x); \
+	__m128i s1 = *(__m128i *)(S1 + (x >> 32)); \
+	X = _mm_mul_epu32(HI32(X), X); \
+	X = _mm_add_epi64(X, s0); \
+	X = _mm_xor_si128(X, s1); \
+}
+#endif
+
+#define PWXFORM_ROUND \
+	PWXFORM_SIMD(X0) \
+	PWXFORM_SIMD(X1) \
+	PWXFORM_SIMD(X2) \
+	PWXFORM_SIMD(X3)
+
+#if defined(__x86_64__) && defined(__GNUC__) && !defined(__ICC)
+#undef FORCE_REGALLOC_3
+#define FORCE_REGALLOC_3 __asm__("" : : "b" (Sw));
+#endif
+
+#else /* !defined(__SSE2__) */
+
+#define PWXFORM_SIMD(x0, x1) { \
+	uint64_t x = x0 & Smask2; \
+	uint64_t *p0 = (uint64_t *)(S0 + (uint32_t)x); \
+	uint64_t *p1 = (uint64_t *)(S1 + (x >> 32)); \
+	x0 = ((x0 >> 32) * (uint32_t)x0 + p0[0]) ^ p1[0]; \
+	x1 = ((x1 >> 32) * (uint32_t)x1 + p0[1]) ^ p1[1]; \
+}
+
+#define PWXFORM_ROUND \
+	PWXFORM_SIMD(X.d[0], X.d[1]) \
+	PWXFORM_SIMD(X.d[2], X.d[3]) \
+	PWXFORM_SIMD(X.d[4], X.d[5]) \
+	PWXFORM_SIMD(X.d[6], X.d[7])
+#endif
+
+/*
+ * This offset helps address the 256-byte write block via the single-byte
+ * displacements encodable in x86(-64) instructions.  It is needed because the
+ * displacements are signed.  Without it, we'd get 4-byte displacements for
+ * half of the writes.  Setting it to 0x80 instead of 0x7c would avoid needing
+ * a displacement for one of the writes, but then the LEA instruction would
+ * need a 4-byte displacement.
+ */
+#define PWXFORM_WRITE_OFFSET 0x7c
+
+#define PWXFORM_WRITE \
+	WRITE_X(*(salsa20_blk_t *)(Sw - PWXFORM_WRITE_OFFSET)) \
+	Sw += 64;
+
+#define PWXFORM { \
+	uint8_t *Sw = S2 + w + PWXFORM_WRITE_OFFSET; \
+	FORCE_REGALLOC_3 \
+	MAYBE_MEMORY_BARRIER \
+	PWXFORM_ROUND \
+	PWXFORM_ROUND PWXFORM_WRITE \
+	PWXFORM_ROUND PWXFORM_WRITE \
+	PWXFORM_ROUND PWXFORM_WRITE \
+	PWXFORM_ROUND PWXFORM_WRITE \
+	PWXFORM_ROUND \
+	w = (w + 64 * 4) & Smask2; \
+	{ \
+		uint8_t *Stmp = S2; \
+		S2 = S1; \
+		S1 = S0; \
+		S0 = Stmp; \
+	} \
+}
+
+typedef struct {
+	uint8_t *S0, *S1, *S2;
+	size_t w;
+} pwxform_ctx_t;
+
+#define Salloc (Sbytes + ((sizeof(pwxform_ctx_t) + 63) & ~63U))
+
+/**
+ * blockmix_pwxform(Bin, Bout, r, S):
+ * Compute Bout = BlockMix_pwxform{salsa20/2, r, S}(Bin).  The input Bin must
+ * be 128r bytes in length; the output Bout must also be the same size.
+ */
+static void blockmix(const salsa20_blk_t *restrict Bin,
+    salsa20_blk_t *restrict Bout, size_t r, pwxform_ctx_t *restrict ctx)
+{
+	uint8_t *S0 = ctx->S0, *S1 = ctx->S1, *S2 = ctx->S2;
+	size_t w = ctx->w;
+	size_t i;
+	DECL_X
+
+	/* Convert count of 128-byte blocks to max index of 64-byte block */
+	r = r * 2 - 1;
+
+	READ_X(Bin[r])
+
+	DECL_SMASK2REG
+
+	i = 0;
+	do {
+		XOR_X(Bin[i])
+		PWXFORM
+		if (unlikely(i >= r))
+			break;
+		WRITE_X(Bout[i])
+		i++;
+	} while (1);
+
+	ctx->S0 = S0; ctx->S1 = S1; ctx->S2 = S2;
+	ctx->w = w;
+
+	SALSA20_2(Bout[i])
+}
+
+static uint32_t blockmix_xor(const salsa20_blk_t *Bin1,
+    const salsa20_blk_t *restrict Bin2, salsa20_blk_t *Bout,
+    size_t r, int Bin2_in_ROM, pwxform_ctx_t *restrict ctx)
+{
+	uint8_t *S0 = ctx->S0, *S1 = ctx->S1, *S2 = ctx->S2;
+	size_t w = ctx->w;
+	size_t i;
+	DECL_X
+
+	/* Convert count of 128-byte blocks to max index of 64-byte block */
+	r = r * 2 - 1;
+
+#ifdef PREFETCH
+	if (Bin2_in_ROM) {
+		PREFETCH(&Bin2[r], _MM_HINT_NTA)
+		for (i = 0; i < r; i++) {
+			PREFETCH(&Bin2[i], _MM_HINT_NTA)
+		}
+	} else {
+		PREFETCH(&Bin2[r], _MM_HINT_T0)
+		for (i = 0; i < r; i++) {
+			PREFETCH(&Bin2[i], _MM_HINT_T0)
+		}
+	}
+#else
+	(void)Bin2_in_ROM; /* unused */
+#endif
+
+	XOR_X_2(Bin1[r], Bin2[r])
+
+	DECL_SMASK2REG
+
+	i = 0;
+	r--;
+	do {
+		XOR_X(Bin1[i])
+		XOR_X(Bin2[i])
+		PWXFORM
+		WRITE_X(Bout[i])
+
+		XOR_X(Bin1[i + 1])
+		XOR_X(Bin2[i + 1])
+		PWXFORM
+
+		if (unlikely(i >= r))
+			break;
+
+		WRITE_X(Bout[i + 1])
+
+		i += 2;
+	} while (1);
+	i++;
+
+	ctx->S0 = S0; ctx->S1 = S1; ctx->S2 = S2;
+	ctx->w = w;
+
+	SALSA20_2(Bout[i])
+
+	return INTEGERIFY;
+}
+
+static uint32_t blockmix_xor_save(salsa20_blk_t *restrict Bin1out,
+    salsa20_blk_t *restrict Bin2,
+    size_t r, pwxform_ctx_t *restrict ctx)
+{
+	uint8_t *S0 = ctx->S0, *S1 = ctx->S1, *S2 = ctx->S2;
+	size_t w = ctx->w;
+	size_t i;
+	DECL_X
+	DECL_Y
+
+	/* Convert count of 128-byte blocks to max index of 64-byte block */
+	r = r * 2 - 1;
+
+#ifdef PREFETCH
+	PREFETCH(&Bin2[r], _MM_HINT_T0)
+	for (i = 0; i < r; i++) {
+		PREFETCH(&Bin2[i], _MM_HINT_T0)
+	}
+#endif
+
+	XOR_X_2(Bin1out[r], Bin2[r])
+
+	DECL_SMASK2REG
+
+	i = 0;
+	r--;
+	do {
+		XOR_X_WRITE_XOR_Y_2(Bin2[i], Bin1out[i])
+		PWXFORM
+		WRITE_X(Bin1out[i])
+
+		XOR_X_WRITE_XOR_Y_2(Bin2[i + 1], Bin1out[i + 1])
+		PWXFORM
+
+		if (unlikely(i >= r))
+			break;
+
+		WRITE_X(Bin1out[i + 1])
+
+		i += 2;
+	} while (1);
+	i++;
+
+	ctx->S0 = S0; ctx->S1 = S1; ctx->S2 = S2;
+	ctx->w = w;
+
+	SALSA20_2(Bin1out[i])
+
+	return INTEGERIFY;
+}
+
+/**
+ * integerify(B, r):
+ * Return the result of parsing B_{2r-1} as a little-endian integer.
+ */
+static inline uint32_t integerify(const salsa20_blk_t *B, size_t r)
+{
+/*
+ * Our 64-bit words are in host byte order, which is why we don't just read
+ * w[0] here (would be wrong on big-endian).  Also, our 32-bit words are
+ * SIMD-shuffled (so the next 32 bits would be part of d[6]), but currently
+ * this does not matter as we only care about the least significant 32 bits.
+ */
+	return (uint32_t)B[2 * r - 1].d[0];
+}
+
+/**
+ * smix1(B, r, N, flags, V, NROM, VROM, XY, ctx):
+ * Compute first loop of B = SMix_r(B, N).  The input B must be 128r bytes in
+ * length; the temporary storage V must be 128rN bytes in length; the temporary
+ * storage XY must be 128r+64 bytes in length.  N must be even and at least 4.
+ * The array V must be aligned to a multiple of 64 bytes, and arrays B and XY
+ * to a multiple of at least 16 bytes.
+ */
+static void smix1(uint8_t *B, size_t r, uint32_t N, yescrypt_flags_t flags,
+    salsa20_blk_t *V, uint32_t NROM, const salsa20_blk_t *VROM,
+    salsa20_blk_t *XY, pwxform_ctx_t *ctx)
+{
+	size_t s = 2 * r;
+	salsa20_blk_t *X = V, *Y = &V[s];
+	uint32_t i, j;
+
+	for (i = 0; i < 2 * r; i++) {
+		const salsa20_blk_t *src = (salsa20_blk_t *)&B[i * 64];
+		salsa20_blk_t *tmp = Y;
+		salsa20_blk_t *dst = &X[i];
+		size_t k;
+		for (k = 0; k < 16; k++)
+			tmp->w[k] = le32dec(&src->w[k]);
+		salsa20_simd_shuffle(tmp, dst);
+	}
+
+	if (VROM) {
+		uint32_t n;
+		const salsa20_blk_t *V_j;
+
+		V_j = &VROM[(NROM - 1) * s];
+		j = blockmix_xor(X, V_j, Y, r, 1, ctx) & (NROM - 1);
+		V_j = &VROM[j * s];
+		X = Y + s;
+		j = blockmix_xor(Y, V_j, X, r, 1, ctx);
+
+		for (n = 2; n < N; n <<= 1) {
+			uint32_t m = (n < N / 2) ? n : (N - 1 - n);
+			for (i = 1; i < m; i += 2) {
+				j &= n - 1;
+				j += i - 1;
+				V_j = &V[j * s];
+				Y = X + s;
+				j = blockmix_xor(X, V_j, Y, r, 0, ctx) & (NROM - 1);
+				V_j = &VROM[j * s];
+				X = Y + s;
+				j = blockmix_xor(Y, V_j, X, r, 1, ctx);
+			}
+		}
+		n >>= 1;
+
+		j &= n - 1;
+		j += N - 2 - n;
+		V_j = &V[j * s];
+		Y = X + s;
+		j = blockmix_xor(X, V_j, Y, r, 0, ctx) & (NROM - 1);
+		V_j = &VROM[j * s];
+		blockmix_xor(Y, V_j, XY, r, 1, ctx);
+	} else if (flags & YESCRYPT_RW) {
+		uint32_t n;
+		salsa20_blk_t *V_j;
+
+		blockmix(X, Y, r, ctx);
+		X = Y + s;
+		blockmix(Y, X, r, ctx);
+		j = integerify(X, r);
+
+		for (n = 2; n < N; n <<= 1) {
+			uint32_t m = (n < N / 2) ? n : (N - 1 - n);
+			for (i = 1; i < m; i += 2) {
+				Y = X + s;
+				j &= n - 1;
+				j += i - 1;
+				V_j = &V[j * s];
+				j = blockmix_xor(X, V_j, Y, r, 0, ctx);
+				j &= n - 1;
+				j += i;
+				V_j = &V[j * s];
+				X = Y + s;
+				j = blockmix_xor(Y, V_j, X, r, 0, ctx);
+			}
+		}
+		n >>= 1;
+
+		j &= n - 1;
+		j += N - 2 - n;
+		V_j = &V[j * s];
+		Y = X + s;
+		j = blockmix_xor(X, V_j, Y, r, 0, ctx);
+		j &= n - 1;
+		j += N - 1 - n;
+		V_j = &V[j * s];
+		blockmix_xor(Y, V_j, XY, r, 0, ctx);
+	} else {
+		N -= 2;
+		do {
+			blockmix_salsa8(X, Y, r);
+			X = Y + s;
+			blockmix_salsa8(Y, X, r);
+			Y = X + s;
+		} while ((N -= 2));
+
+		blockmix_salsa8(X, Y, r);
+		blockmix_salsa8(Y, XY, r);
+	}
+
+	for (i = 0; i < 2 * r; i++) {
+		const salsa20_blk_t *src = &XY[i];
+		salsa20_blk_t *tmp = &XY[s];
+		salsa20_blk_t *dst = (salsa20_blk_t *)&B[i * 64];
+		size_t k;
+		for (k = 0; k < 16; k++)
+			le32enc(&tmp->w[k], src->w[k]);
+		salsa20_simd_unshuffle(tmp, dst);
+	}
+}
+
+/**
+ * smix2(B, r, N, Nloop, flags, V, NROM, VROM, XY, ctx):
+ * Compute second loop of B = SMix_r(B, N).  The input B must be 128r bytes in
+ * length; the temporary storage V must be 128rN bytes in length; the temporary
+ * storage XY must be 256r bytes in length.  N must be a power of 2 and at
+ * least 2.  Nloop must be even.  The array V must be aligned to a multiple of
+ * 64 bytes, and arrays B and XY to a multiple of at least 16 bytes.
+ */
+static void smix2(uint8_t *B, size_t r, uint32_t N, uint64_t Nloop,
+    yescrypt_flags_t flags, salsa20_blk_t *V, uint32_t NROM,
+    const salsa20_blk_t *VROM, salsa20_blk_t *XY, pwxform_ctx_t *ctx)
+{
+	size_t s = 2 * r;
+	salsa20_blk_t *X = XY, *Y = &XY[s];
+	uint32_t i, j;
+
+	if (Nloop == 0)
+		return;
+
+	for (i = 0; i < 2 * r; i++) {
+		const salsa20_blk_t *src = (salsa20_blk_t *)&B[i * 64];
+		salsa20_blk_t *tmp = Y;
+		salsa20_blk_t *dst = &X[i];
+		size_t k;
+		for (k = 0; k < 16; k++)
+			tmp->w[k] = le32dec(&src->w[k]);
+		salsa20_simd_shuffle(tmp, dst);
+	}
+
+	j = integerify(X, r) & (N - 1);
+
+/*
+ * Normally, VROM implies YESCRYPT_RW, but we check for these separately
+ * because our SMix resets YESCRYPT_RW for the smix2() calls operating on the
+ * entire V when p > 1.
+ */
+	if (VROM && (flags & YESCRYPT_RW)) {
+		do {
+			salsa20_blk_t *V_j = &V[j * s];
+			const salsa20_blk_t *VROM_j;
+			j = blockmix_xor_save(X, V_j, r, ctx) & (NROM - 1);
+			VROM_j = &VROM[j * s];
+			j = blockmix_xor(X, VROM_j, X, r, 1, ctx) & (N - 1);
+		} while (Nloop -= 2);
+	} else if (VROM) {
+		do {
+			const salsa20_blk_t *V_j = &V[j * s];
+			j = blockmix_xor(X, V_j, X, r, 0, ctx) & (NROM - 1);
+			V_j = &VROM[j * s];
+			j = blockmix_xor(X, V_j, X, r, 1, ctx) & (N - 1);
+		} while (Nloop -= 2);
+	} else if (flags & YESCRYPT_RW) {
+		do {
+			salsa20_blk_t *V_j = &V[j * s];
+			j = blockmix_xor_save(X, V_j, r, ctx) & (N - 1);
+			V_j = &V[j * s];
+			j = blockmix_xor_save(X, V_j, r, ctx) & (N - 1);
+		} while (Nloop -= 2);
+	} else if (ctx) {
+		do {
+			const salsa20_blk_t *V_j = &V[j * s];
+			j = blockmix_xor(X, V_j, X, r, 0, ctx) & (N - 1);
+			V_j = &V[j * s];
+			j = blockmix_xor(X, V_j, X, r, 0, ctx) & (N - 1);
+		} while (Nloop -= 2);
+	} else {
+		do {
+			const salsa20_blk_t *V_j = &V[j * s];
+			j = blockmix_salsa8_xor(X, V_j, Y, r) & (N - 1);
+			V_j = &V[j * s];
+			j = blockmix_salsa8_xor(Y, V_j, X, r) & (N - 1);
+		} while (Nloop -= 2);
+	}
+
+	for (i = 0; i < 2 * r; i++) {
+		const salsa20_blk_t *src = &X[i];
+		salsa20_blk_t *tmp = Y;
+		salsa20_blk_t *dst = (salsa20_blk_t *)&B[i * 64];
+		size_t k;
+		for (k = 0; k < 16; k++)
+			le32enc(&tmp->w[k], src->w[k]);
+		salsa20_simd_unshuffle(tmp, dst);
+	}
+}
+
+/**
+ * p2floor(x):
+ * Largest power of 2 not greater than argument.
+ */
+static uint64_t p2floor(uint64_t x)
+{
+	uint64_t y;
+	while ((y = x & (x - 1)))
+		x = y;
+	return x;
+}
+
+/**
+ * smix(B, r, N, p, t, flags, V, NROM, VROM, XY, S, passwd):
+ * Compute B = SMix_r(B, N).  The input B must be 128rp bytes in length; the
+ * temporary storage V must be 128rN bytes in length; the temporary storage
+ * XY must be 256r or 256rp bytes in length (the larger size is required with
+ * OpenMP-enabled builds).  N must be a power of 2 and at least 4.  The array V
+ * must be aligned to a multiple of 64 bytes, and arrays B and XY to a multiple
+ * of at least 16 bytes (aligning them to 64 bytes as well saves cache lines
+ * and helps avoid false sharing in OpenMP-enabled builds when p > 1, but it
+ * might also result in cache bank conflicts).
+ */
+static void smix(uint8_t *B, size_t r, uint32_t N, uint32_t p, uint32_t t,
+    yescrypt_flags_t flags,
+    salsa20_blk_t *V, uint32_t NROM, const salsa20_blk_t *VROM,
+    salsa20_blk_t *XY, uint8_t *S, uint8_t *passwd)
+{
+	size_t s = 2 * r;
+	uint32_t Nchunk;
+	uint64_t Nloop_all, Nloop_rw;
+	uint32_t i;
+
+	Nchunk = N / p;
+	Nloop_all = Nchunk;
+	if (flags & YESCRYPT_RW) {
+		if (t <= 1) {
+			if (t)
+				Nloop_all *= 2; /* 2/3 */
+			Nloop_all = (Nloop_all + 2) / 3; /* 1/3, round up */
+		} else {
+			Nloop_all *= t - 1;
+		}
+	} else if (t) {
+		if (t == 1)
+			Nloop_all += (Nloop_all + 1) / 2; /* 1.5, round up */
+		Nloop_all *= t;
+	}
+
+	Nloop_rw = 0;
+	if (flags & YESCRYPT_INIT_SHARED)
+		Nloop_rw = Nloop_all;
+	else if (flags & YESCRYPT_RW)
+		Nloop_rw = Nloop_all / p;
+
+	Nchunk &= ~(uint32_t)1; /* round down to even */
+	Nloop_all++; Nloop_all &= ~(uint64_t)1; /* round up to even */
+	Nloop_rw++; Nloop_rw &= ~(uint64_t)1; /* round up to even */
+
+#ifdef _OPENMP
+#pragma omp parallel if (p > 1) default(none) private(i) shared(B, r, N, p, flags, V, NROM, VROM, XY, S, passwd, s, Nchunk, Nloop_all, Nloop_rw)
+	{
+#pragma omp for
+#endif
+	for (i = 0; i < p; i++) {
+		uint32_t Vchunk = i * Nchunk;
+		uint32_t Np = (i < p - 1) ? Nchunk : (N - Vchunk);
+		uint8_t *Bp = &B[128 * r * i];
+		salsa20_blk_t *Vp = &V[Vchunk * s];
+#ifdef _OPENMP
+		salsa20_blk_t *XYp = &XY[i * (2 * s)];
+#else
+		salsa20_blk_t *XYp = XY;
+#endif
+		pwxform_ctx_t *ctx_i = NULL;
+		if (flags & YESCRYPT_RW) {
+			uint8_t *Si = S + i * Salloc;
+			smix1(Bp, 1, Sbytes / 128, 0 /* no flags */,
+			    (salsa20_blk_t *)Si, 0, NULL, XYp, NULL);
+                        ctx_i = zgc_alloc(sizeof(pwxform_ctx_t));
+			//ctx_i = (pwxform_ctx_t *)(Si + Sbytes);
+			ctx_i->S2 = Si;
+			ctx_i->S1 = Si + Sbytes / 3;
+			ctx_i->S0 = Si + Sbytes / 3 * 2;
+			ctx_i->w = 0;
+			if (i == 0)
+				HMAC_SHA256_Buf(Bp + (128 * r - 64), 64,
+				    passwd, 32, passwd);
+		}
+		smix1(Bp, r, Np, flags, Vp, NROM, VROM, XYp, ctx_i);
+		smix2(Bp, r, p2floor(Np), Nloop_rw, flags, Vp,
+		    NROM, VROM, XYp, ctx_i);
+	}
+
+	if (Nloop_all > Nloop_rw) {
+#ifdef _OPENMP
+#pragma omp for
+#endif
+		for (i = 0; i < p; i++) {
+			uint8_t *Bp = &B[128 * r * i];
+#ifdef _OPENMP
+			salsa20_blk_t *XYp = &XY[i * (2 * s)];
+#else
+			salsa20_blk_t *XYp = XY;
+#endif
+			pwxform_ctx_t *ctx_i = NULL;
+			if (flags & YESCRYPT_RW) {
+				uint8_t *Si = S + i * Salloc;
+				ctx_i = (pwxform_ctx_t *)(Si + Sbytes);
+			}
+			smix2(Bp, r, N, Nloop_all - Nloop_rw,
+			    flags & ~YESCRYPT_RW, V, NROM, VROM, XYp, ctx_i);
+		}
+	}
+#ifdef _OPENMP
+	}
+#endif
+}
+
+/**
+ * yescrypt_kdf_body(shared, local, passwd, passwdlen, salt, saltlen,
+ *     flags, N, r, p, t, NROM, buf, buflen):
+ * Compute scrypt(passwd[0 .. passwdlen - 1], salt[0 .. saltlen - 1], N, r,
+ * p, buflen), or a revision of scrypt as requested by flags and shared, and
+ * write the result into buf.
+ *
+ * shared and flags may request special modes as described in yescrypt.h.
+ *
+ * local is the thread-local data structure, allowing to preserve and reuse a
+ * memory allocation across calls, thereby reducing its overhead.
+ *
+ * t controls computation time while not affecting peak memory usage.
+ *
+ * Return 0 on success; or -1 on error.
+ *
+ * This optimized implementation currently limits N to the range from 4 to
+ * 2^31, but other implementations might not.
+ */
+static int yescrypt_kdf_body(const yescrypt_shared_t *shared,
+    yescrypt_local_t *local,
+    const uint8_t *passwd, size_t passwdlen,
+    const uint8_t *salt, size_t saltlen,
+    yescrypt_flags_t flags, uint64_t N, uint32_t r, uint32_t p, uint32_t t,
+    uint64_t NROM,
+    uint8_t *buf, size_t buflen)
+{
+	yescrypt_region_t tmp;
+	const salsa20_blk_t *VROM;
+	size_t B_size, V_size, XY_size, need;
+	uint8_t *B, *S;
+	salsa20_blk_t *V, *XY;
+	uint8_t sha256[32];
+	uint8_t dk[sizeof(sha256)], *dkp = buf;
+
+	/* Sanity-check parameters */
+	switch (flags & YESCRYPT_MODE_MASK) {
+	case 0: /* classic scrypt - can't have anything non-standard */
+		if (flags || t || NROM)
+			goto out_EINVAL;
+		break;
+	case YESCRYPT_WORM:
+		if (flags != YESCRYPT_WORM || NROM)
+			goto out_EINVAL;
+		break;
+	case YESCRYPT_RW:
+		if (flags != (flags & YESCRYPT_KNOWN_FLAGS))
+			goto out_EINVAL;
+#if PWXsimple == 2 && PWXgather == 4 && Sbytes == 12288
+		if ((flags & YESCRYPT_RW_FLAVOR_MASK) ==
+		    (YESCRYPT_ROUNDS_6 | YESCRYPT_GATHER_4 |
+		    YESCRYPT_SIMPLE_2 | YESCRYPT_SBOX_12K))
+			break;
+#else
+#error "Unsupported pwxform settings"
+#endif
+		/* FALLTHRU */
+	default:
+		goto out_EINVAL;
+	}
+#if SIZE_MAX > UINT32_MAX
+	if (buflen > (((uint64_t)1 << 32) - 1) * 32)
+		goto out_EINVAL;
+#endif
+	if ((uint64_t)r * (uint64_t)p >= 1 << 30)
+		goto out_EINVAL;
+	if (N > UINT32_MAX)
+		goto out_EINVAL;
+	if ((N & (N - 1)) != 0 || N <= 3 || r < 1 || p < 1)
+		goto out_EINVAL;
+	if (r > SIZE_MAX / 256 / p ||
+	    N > SIZE_MAX / 128 / r)
+		goto out_EINVAL;
+	if (flags & YESCRYPT_RW) {
+		if (N / p <= 3 || p > SIZE_MAX / Salloc)
+			goto out_EINVAL;
+	}
+#ifdef _OPENMP
+	else if (N > SIZE_MAX / 128 / (r * p)) {
+		goto out_EINVAL;
+	}
+#endif
+
+	VROM = NULL;
+	if (shared) {
+		uint64_t expected_size = (size_t)128 * r * NROM;
+		if ((NROM & (NROM - 1)) != 0 ||
+		    NROM <= 1 || NROM > UINT32_MAX ||
+		    shared->aligned_size < expected_size)
+			goto out_EINVAL;
+		if (!(flags & YESCRYPT_INIT_SHARED)) {
+			uint64_t *tag = (uint64_t *)
+			    ((uint8_t *)shared->aligned + expected_size - 48);
+			if (tag[0] != YESCRYPT_ROM_TAG1 || tag[1] != YESCRYPT_ROM_TAG2)
+				goto out_EINVAL;
+		}
+		VROM = shared->aligned;
+	} else {
+		if (NROM)
+			goto out_EINVAL;
+	}
+
+	/* Allocate memory */
+	V = NULL;
+	V_size = (size_t)128 * r * N;
+#ifdef _OPENMP
+	if (!(flags & YESCRYPT_RW))
+		V_size *= p;
+#endif
+	need = V_size;
+	if (flags & YESCRYPT_INIT_SHARED) {
+		if (local->aligned_size < need) {
+			if (local->base || local->aligned ||
+			    local->base_size || local->aligned_size)
+				goto out_EINVAL;
+			if (!alloc_region(local, need))
+				return -1;
+		}
+		if (flags & YESCRYPT_ALLOC_ONLY)
+			return -2; /* expected "failure" */
+		V = (salsa20_blk_t *)local->aligned;
+		need = 0;
+	}
+	B_size = (size_t)128 * r * p;
+	need += B_size;
+	if (need < B_size)
+		goto out_EINVAL;
+	XY_size = (size_t)256 * r;
+#ifdef _OPENMP
+	XY_size *= p;
+#endif
+	need += XY_size;
+	if (need < XY_size)
+		goto out_EINVAL;
+	if (flags & YESCRYPT_RW) {
+		size_t S_size = (size_t)Salloc * p;
+		need += S_size;
+		if (need < S_size)
+			goto out_EINVAL;
+	}
+	if (flags & YESCRYPT_INIT_SHARED) {
+		if (!alloc_region(&tmp, need))
+			return -1;
+		B = (uint8_t *)tmp.aligned;
+		XY = (salsa20_blk_t *)((uint8_t *)B + B_size);
+	} else {
+		init_region(&tmp);
+		if (local->aligned_size < need) {
+			if (free_region(local))
+				return -1;
+			if (!alloc_region(local, need))
+				return -1;
+		}
+		if (flags & YESCRYPT_ALLOC_ONLY)
+			return -3; /* expected "failure" */
+		B = (uint8_t *)local->aligned;
+		V = (salsa20_blk_t *)((uint8_t *)B + B_size);
+		XY = (salsa20_blk_t *)((uint8_t *)V + V_size);
+	}
+	S = NULL;
+	if (flags & YESCRYPT_RW)
+		S = (uint8_t *)XY + XY_size;
+
+	if (flags) {
+		HMAC_SHA256_Buf("yescrypt-prehash",
+		    (flags & YESCRYPT_PREHASH) ? 16 : 8,
+		    passwd, passwdlen, sha256);
+		passwd = sha256;
+		passwdlen = sizeof(sha256);
+	}
+
+	PBKDF2_SHA256(passwd, passwdlen, salt, saltlen, 1, B, B_size);
+
+	if (flags)
+		memcpy(sha256, B, sizeof(sha256));
+
+	if (p == 1 || (flags & YESCRYPT_RW)) {
+		smix(B, r, N, p, t, flags, V, NROM, VROM, XY, S, sha256);
+	} else {
+		uint32_t i;
+#ifdef _OPENMP
+#pragma omp parallel for default(none) private(i) shared(B, r, N, p, t, flags, V, NROM, VROM, XY, S)
+#endif
+		for (i = 0; i < p; i++) {
+#ifdef _OPENMP
+			smix(&B[(size_t)128 * r * i], r, N, 1, t, flags,
+			    &V[(size_t)2 * r * i * N],
+			    NROM, VROM,
+			    &XY[(size_t)4 * r * i], NULL, NULL);
+#else
+			smix(&B[(size_t)128 * r * i], r, N, 1, t, flags, V,
+			    NROM, VROM, XY, NULL, NULL);
+#endif
+		}
+	}
+
+	dkp = buf;
+	if (flags && buflen < sizeof(dk)) {
+		PBKDF2_SHA256(passwd, passwdlen, B, B_size, 1, dk, sizeof(dk));
+		dkp = dk;
+	}
+
+	PBKDF2_SHA256(passwd, passwdlen, B, B_size, 1, buf, buflen);
+
+	/*
+	 * Except when computing classic scrypt, allow all computation so far
+	 * to be performed on the client.  The final steps below match those of
+	 * SCRAM (RFC 5802), so that an extension of SCRAM (with the steps so
+	 * far in place of SCRAM's use of PBKDF2 and with SHA-256 in place of
+	 * SCRAM's use of SHA-1) would be usable with yescrypt hashes.
+	 */
+	if (flags && !(flags & YESCRYPT_PREHASH)) {
+		/* Compute ClientKey */
+		HMAC_SHA256_Buf(dkp, sizeof(dk), "Client Key", 10, sha256);
+		/* Compute StoredKey */
+		{
+			size_t clen = buflen;
+			if (clen > sizeof(dk))
+				clen = sizeof(dk);
+			SHA256_Buf(sha256, sizeof(sha256), dk);
+			memcpy(buf, dk, clen);
+		}
+	}
+
+	if (flags) {
+		insecure_memzero(sha256, sizeof(sha256));
+		insecure_memzero(dk, sizeof(dk));
+	}
+
+	if (free_region(&tmp)) {
+		insecure_memzero(buf, buflen); /* must preserve errno */
+		return -1;
+	}
+
+	/* Success! */
+	return 0;
+
+out_EINVAL:
+	errno = EINVAL;
+	return -1;
+}
+
+/**
+ * yescrypt_kdf(shared, local, passwd, passwdlen, salt, saltlen, params,
+ *     buf, buflen):
+ * Compute scrypt or its revision as requested by the parameters.  The inputs
+ * to this function are the same as those for yescrypt_kdf_body() above, with
+ * the addition of g, which controls hash upgrades (0 for no upgrades so far).
+ */
+hidden int yescrypt_kdf(const yescrypt_shared_t *shared, yescrypt_local_t *local,
+    const uint8_t *passwd, size_t passwdlen,
+    const uint8_t *salt, size_t saltlen,
+    const yescrypt_params_t *params,
+    uint8_t *buf, size_t buflen)
+{
+	yescrypt_flags_t flags = params->flags;
+	uint64_t N = params->N;
+	uint32_t r = params->r;
+	uint32_t p = params->p;
+	uint32_t t = params->t;
+	uint32_t g = params->g;
+	uint64_t NROM = params->NROM;
+	uint8_t dk[32];
+	int retval;
+
+	/* Support for hash upgrades has been temporarily removed */
+	if (g) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	if ((flags & (YESCRYPT_RW | YESCRYPT_INIT_SHARED)) == YESCRYPT_RW &&
+	    p >= 1 && N / p >= 0x100 && N / p * r >= 0x20000) {
+		if (yescrypt_kdf_body(shared, local,
+		    passwd, passwdlen, salt, saltlen,
+		    flags | YESCRYPT_ALLOC_ONLY, N, r, p, t, NROM,
+		    buf, buflen) != -3) {
+			errno = EINVAL;
+			return -1;
+		}
+		if ((retval = yescrypt_kdf_body(shared, local,
+		    passwd, passwdlen, salt, saltlen,
+		    flags | YESCRYPT_PREHASH, N >> 6, r, p, 0, NROM,
+		    dk, sizeof(dk))))
+			return retval;
+		passwd = dk;
+		passwdlen = sizeof(dk);
+	}
+
+	retval = yescrypt_kdf_body(shared, local,
+	    passwd, passwdlen, salt, saltlen,
+	    flags, N, r, p, t, NROM, buf, buflen);
+#ifndef SKIP_MEMZERO
+	if (passwd == dk)
+		insecure_memzero(dk, sizeof(dk));
+#endif
+	return retval;
+}
+
+hidden int yescrypt_init_shared(yescrypt_shared_t *shared,
+    const uint8_t *seed, size_t seedlen,
+    const yescrypt_params_t *params)
+{
+	yescrypt_params_t subparams;
+	yescrypt_shared_t half1, half2;
+	uint8_t salt[32];
+	uint64_t *tag;
+
+	subparams = *params;
+	subparams.flags |= YESCRYPT_INIT_SHARED;
+	subparams.N = params->NROM;
+	subparams.NROM = 0;
+
+	if (!(params->flags & YESCRYPT_RW) || params->N || params->g)
+		return -1;
+
+	if (params->flags & YESCRYPT_SHARED_PREALLOCATED) {
+		if (!shared->aligned || !shared->aligned_size)
+			return -1;
+
+/* Overwrite a possible old ROM tag before we overwrite the rest */
+		tag = (uint64_t *)
+		    ((uint8_t *)shared->aligned + shared->aligned_size - 48);
+		memset(tag, 0, 48);
+	} else {
+		init_region(shared);
+
+		subparams.flags |= YESCRYPT_ALLOC_ONLY;
+		if (yescrypt_kdf(NULL, shared, NULL, 0, NULL, 0, &subparams,
+		    NULL, 0) != -2 || !shared->aligned)
+			return -1;
+		subparams.flags -= YESCRYPT_ALLOC_ONLY;
+	}
+
+	subparams.N /= 2;
+
+	half1 = *shared;
+	half1.aligned_size /= 2;
+	half2 = half1;
+	half2.aligned = (uint8_t *)half2.aligned + half1.aligned_size;
+
+	if (yescrypt_kdf(NULL, &half1,
+	    seed, seedlen, (const uint8_t *)"yescrypt-ROMhash", 16, &subparams,
+	    salt, sizeof(salt)))
+		goto fail;
+
+	subparams.NROM = subparams.N;
+
+	if (yescrypt_kdf(&half1, &half2,
+	    seed, seedlen, salt, sizeof(salt), &subparams, salt, sizeof(salt)))
+		goto fail;
+
+	if (yescrypt_kdf(&half2, &half1,
+	    seed, seedlen, salt, sizeof(salt), &subparams, salt, sizeof(salt)))
+		goto fail;
+
+	tag = (uint64_t *)
+	    ((uint8_t *)shared->aligned + shared->aligned_size - 48);
+	tag[0] = YESCRYPT_ROM_TAG1;
+	tag[1] = YESCRYPT_ROM_TAG2;
+	tag[2] = le64dec(salt);
+	tag[3] = le64dec(salt + 8);
+	tag[4] = le64dec(salt + 16);
+	tag[5] = le64dec(salt + 24);
+
+	insecure_memzero(salt, sizeof(salt));
+	return 0;
+
+fail:
+	insecure_memzero(salt, sizeof(salt));
+	if (!(params->flags & YESCRYPT_SHARED_PREALLOCATED))
+		free_region(shared);
+	return -1;
+}
+
+hidden yescrypt_binary_t *yescrypt_digest_shared(yescrypt_shared_t *shared)
+{
+	static yescrypt_binary_t digest;
+	uint64_t *tag;
+
+	if (shared->aligned_size < 48)
+		return NULL;
+
+	tag = (uint64_t *)
+	    ((uint8_t *)shared->aligned + shared->aligned_size - 48);
+
+	if (tag[0] != YESCRYPT_ROM_TAG1 || tag[1] != YESCRYPT_ROM_TAG2)
+		return NULL;
+
+	le64enc(digest.uc, tag[2]);
+	le64enc(digest.uc + 8, tag[3]);
+	le64enc(digest.uc + 16, tag[4]);
+	le64enc(digest.uc + 24, tag[5]);
+
+	return &digest;
+}
+
+hidden int yescrypt_free_shared(yescrypt_shared_t *shared)
+{
+	return free_region(shared);
+}
+
+hidden int yescrypt_init_local(yescrypt_local_t *local)
+{
+	init_region(local);
+	return 0;
+}
+
+hidden int yescrypt_free_local(yescrypt_local_t *local)
+{
+	return free_region(local);
+}
diff --git a/src/yescrypt/yescrypt-platform.h b/src/yescrypt/yescrypt-platform.h
new file mode 100644
index 000000000000..0db4c1fa843f
--- /dev/null
+++ b/src/yescrypt/yescrypt-platform.h
@@ -0,0 +1,107 @@
+/*-
+ * Copyright 2013-2018 Alexander Peslyak
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifdef __unix__
+#include <sys/mman.h>
+#endif
+
+#define HUGEPAGE_THRESHOLD		(32 * 1024 * 1024)
+
+#ifdef __x86_64__
+#define HUGEPAGE_SIZE			(2 * 1024 * 1024)
+#else
+#undef HUGEPAGE_SIZE
+#endif
+
+static void *alloc_region(yescrypt_region_t *region, size_t size)
+{
+	size_t base_size = size;
+	uint8_t *base, *aligned;
+#ifdef MAP_ANON
+	int flags =
+#ifdef MAP_NOCORE
+	    MAP_NOCORE |
+#endif
+	    MAP_ANON | MAP_PRIVATE;
+#if defined(MAP_HUGETLB) && defined(HUGEPAGE_SIZE)
+	size_t new_size = size;
+	const size_t hugepage_mask = (size_t)HUGEPAGE_SIZE - 1;
+	if (size >= HUGEPAGE_THRESHOLD && size + hugepage_mask >= size) {
+		flags |= MAP_HUGETLB;
+/*
+ * Linux's munmap() fails on MAP_HUGETLB mappings if size is not a multiple of
+ * huge page size, so let's round up to huge page size here.
+ */
+		new_size = size + hugepage_mask;
+		new_size &= ~hugepage_mask;
+	}
+	base = mmap(NULL, new_size, PROT_READ | PROT_WRITE, flags, -1, 0);
+	if (base != MAP_FAILED) {
+		base_size = new_size;
+	} else if (flags & MAP_HUGETLB) {
+		flags &= ~MAP_HUGETLB;
+		base = mmap(NULL, size, PROT_READ | PROT_WRITE, flags, -1, 0);
+	}
+
+#else
+	base = mmap(NULL, size, PROT_READ | PROT_WRITE, flags, -1, 0);
+#endif
+	if (base == MAP_FAILED)
+		base = NULL;
+	aligned = base;
+#elif defined(HAVE_POSIX_MEMALIGN)
+	if ((errno = posix_memalign((void **)&base, 64, size)) != 0)
+		base = NULL;
+	aligned = base;
+#else
+	base = aligned = NULL;
+	if (size + 63 < size) {
+		errno = ENOMEM;
+	} else if ((base = malloc(size + 63)) != NULL) {
+		aligned = base + 63;
+		aligned -= (uintptr_t)aligned & 63;
+	}
+#endif
+	region->base = base;
+	region->aligned = aligned;
+	region->base_size = base ? base_size : 0;
+	region->aligned_size = base ? size : 0;
+	return aligned;
+}
+
+static inline void init_region(yescrypt_region_t *region)
+{
+	region->base = region->aligned = NULL;
+	region->base_size = region->aligned_size = 0;
+}
+
+static int free_region(yescrypt_region_t *region)
+{
+	if (region->base) {
+#ifdef MAP_ANON
+		if (munmap(region->base, region->base_size))
+			return -1;
+#else
+		free(region->base);
+#endif
+	}
+	init_region(region);
+	return 0;
+}
