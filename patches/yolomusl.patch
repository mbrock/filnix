diff --git a/Makefile b/Makefile
index e8cc443675ef..0c8569065298 100644
--- a/Makefile
+++ b/Makefile
@@ -48,7 +48,7 @@ CFLAGS_C99FSE = -std=c99 -ffreestanding -nostdinc
 
 CFLAGS_ALL = $(CFLAGS_C99FSE)
 CFLAGS_ALL += -D_XOPEN_SOURCE=700 -I$(srcdir)/arch/$(ARCH) -I$(srcdir)/arch/generic -Iobj/src/internal -I$(srcdir)/src/include -I$(srcdir)/src/internal -Iobj/include -I$(srcdir)/include
-CFLAGS_ALL += $(CPPFLAGS) $(CFLAGS_AUTO) $(CFLAGS)
+CFLAGS_ALL += -g $(CPPFLAGS) $(CFLAGS_AUTO) $(CFLAGS)
 
 LDFLAGS_ALL = $(LDFLAGS_AUTO) $(LDFLAGS)
 
@@ -64,16 +64,16 @@ ALL_INCLUDES = $(sort $(INCLUDES:$(srcdir)/%=%) $(GENH:obj/%=%) $(ARCH_INCLUDES:
 EMPTY_LIB_NAMES = m rt pthread crypt util xnet resolv dl
 EMPTY_LIBS = $(EMPTY_LIB_NAMES:%=lib/lib%.a)
 CRT_LIBS = $(addprefix lib/,$(notdir $(CRT_OBJS)))
-STATIC_LIBS = lib/libc.a
-SHARED_LIBS = lib/libc.so
+STATIC_LIBS = lib/libyoloc.a
+SHARED_LIBS = lib/libyoloc.so
 TOOL_LIBS = lib/musl-gcc.specs
-ALL_LIBS = $(CRT_LIBS) $(STATIC_LIBS) $(SHARED_LIBS) $(EMPTY_LIBS) $(TOOL_LIBS)
+ALL_LIBS = $(CRT_LIBS) $(STATIC_LIBS) $(SHARED_LIBS) $(TOOL_LIBS)
 ALL_TOOLS = obj/musl-gcc
 
 WRAPCC_GCC = gcc
 WRAPCC_CLANG = clang
 
-LDSO_PATHNAME = $(syslibdir)/ld-musl-$(ARCH)$(SUBARCH).so.1
+LDSO_PATHNAME = $(syslibdir)/ld-yolo-$(ARCH)$(SUBARCH).so
 
 -include config.mak
 -include $(srcdir)/arch/$(ARCH)/arch.mak
@@ -158,11 +158,11 @@ obj/%.lo: $(srcdir)/%.S
 obj/%.lo: $(srcdir)/%.c $(GENH) $(IMPH)
 	$(CC_CMD)
 
-lib/libc.so: $(LOBJS) $(LDSO_OBJS)
+lib/libyoloc.so: $(LOBJS) $(LDSO_OBJS)
 	$(CC) $(CFLAGS_ALL) $(LDFLAGS_ALL) -nostdlib -shared \
 	-Wl,-e,_dlstart -o $@ $(LOBJS) $(LDSO_OBJS) $(LIBCC)
 
-lib/libc.a: $(AOBJS)
+lib/libyoloc.a: $(AOBJS)
 	rm -f $@
 	$(AR) rc $@ $(AOBJS)
 	$(RANLIB) $@
@@ -209,8 +209,8 @@ $(DESTDIR)$(includedir)/bits/%: obj/include/bits/%
 $(DESTDIR)$(includedir)/%: $(srcdir)/include/%
 	$(INSTALL) -D -m 644 $< $@
 
-$(DESTDIR)$(LDSO_PATHNAME): $(DESTDIR)$(libdir)/libc.so
-	$(INSTALL) -D -l $(libdir)/libc.so $@ || true
+$(DESTDIR)$(LDSO_PATHNAME): $(DESTDIR)$(libdir)/libyoloc.so
+	$(INSTALL) -D -l $(libdir)/libyoloc.so $@
 
 install-libs: $(ALL_LIBS:lib/%=$(DESTDIR)$(libdir)/%) $(if $(SHARED_LIBS),$(DESTDIR)$(LDSO_PATHNAME),)
 
diff --git a/include/elf.h b/include/elf.h
index 72d17c3ad64d..07127b4f7c6b 100644
--- a/include/elf.h
+++ b/include/elf.h
@@ -1058,6 +1058,8 @@ typedef struct {
 
 #define AT_MINSIGSTKSZ		51
 
+#define AT_MAX_KEY              51
+
 
 typedef struct {
   Elf32_Word n_namesz;
diff --git a/include/futex_calls.h b/include/futex_calls.h
new file mode 100644
index 000000000000..8557879b6a44
--- /dev/null
+++ b/include/futex_calls.h
@@ -0,0 +1,18 @@
+#ifndef _FUTEX_CALLS_H_
+#define _FUTEX_CALLS_H_
+
+#define __NEED_struct_timespec
+
+#include <bits/alltypes.h>
+
+void yolo_futex_wake(volatile int *addr, int cnt, int priv);
+void yolo_futex_wait(volatile int *addr, int val, int priv);
+
+/* These return the errno as a negative value. */
+int yolo_futex_timedwait(volatile int *addr, int val, int clock_id, const struct timespec *timeout, int priv);
+int yolo_futex_unlock_pi(volatile int *addr, int priv);
+int yolo_futex_lock_pi(volatile int *addr, int priv, const struct timespec *timeout);
+int yolo_futex_requeue(volatile int *addr, int priv, int wake_count, int requeue_count, volatile int *addr2);
+
+#endif /* _FUTEX_CALLS_H_ */
+
diff --git a/include/signal.h b/include/signal.h
index c347f8610a3f..f741bd05d794 100644
--- a/include/signal.h
+++ b/include/signal.h
@@ -212,9 +212,13 @@ int __libc_current_sigrtmax(void);
 
 int kill(pid_t, int);
 
+extern int libc_internal_signals[];
+extern unsigned num_libc_internal_signals;
+
 int sigemptyset(sigset_t *);
 int sigfillset(sigset_t *);
 int sigaddset(sigset_t *, int);
+int sigdelsetyolo(sigset_t *, int);
 int sigdelset(sigset_t *, int);
 int sigismember(const sigset_t *, int);
 
diff --git a/ldso/dynlink.c b/ldso/dynlink.c
index 324aa85919f0..d06cfd66e83e 100644
--- a/ldso/dynlink.c
+++ b/ldso/dynlink.c
@@ -1072,7 +1072,7 @@ static struct dso *load_library(const char *name, struct dso *needed_by)
 	/* Catch and block attempts to reload the implementation itself */
 	if (name[0]=='l' && name[1]=='i' && name[2]=='b') {
 		static const char reserved[] =
-			"c.pthread.rt.m.dl.util.xnet.";
+			"yoloc.";
 		const char *rp, *next;
 		for (rp=reserved; *rp; rp=next) {
 			next = strchr(rp, '.') + 1;
diff --git a/src/internal/pthread_impl.h b/src/internal/pthread_impl.h
index de2b9d8b477e..0ad052716502 100644
--- a/src/internal/pthread_impl.h
+++ b/src/internal/pthread_impl.h
@@ -194,7 +194,7 @@ extern hidden volatile int __abort_lock[1];
 extern hidden unsigned __default_stacksize;
 extern hidden unsigned __default_guardsize;
 
-#define DEFAULT_STACK_SIZE 131072
+#define DEFAULT_STACK_SIZE 8388608
 #define DEFAULT_GUARD_SIZE 8192
 
 #define DEFAULT_STACK_MAX (8<<20)
diff --git a/src/legacy/utmpx.c b/src/legacy/utmpx.c
index 7aa65da335b5..81b93353c9a2 100644
--- a/src/legacy/utmpx.c
+++ b/src/legacy/utmpx.c
@@ -13,21 +13,25 @@ void setutxent(void)
 
 struct utmpx *getutxent(void)
 {
+	errno = ENOTSUP;
 	return NULL;
 }
 
 struct utmpx *getutxid(const struct utmpx *ut)
 {
+	errno = ENOTSUP;
 	return NULL;
 }
 
 struct utmpx *getutxline(const struct utmpx *ut)
 {
+	errno = ENOTSUP;
 	return NULL;
 }
 
 struct utmpx *pututxline(const struct utmpx *ut)
 {
+	errno = ENOTSUP;
 	return NULL;
 }
 
diff --git a/src/signal/libc_internal_signals.c b/src/signal/libc_internal_signals.c
new file mode 100644
index 000000000000..36140e704d61
--- /dev/null
+++ b/src/signal/libc_internal_signals.c
@@ -0,0 +1,9 @@
+#include "pthread_impl.h"
+
+int libc_internal_signals[] = {
+    SIGTIMER,
+    SIGCANCEL,
+    SIGSYNCCALL
+};
+
+unsigned num_libc_internal_signals = 3;
diff --git a/src/signal/sigdelset.c b/src/signal/sigdelset.c
index ce69280e0cbf..1a86aa6003ac 100644
--- a/src/signal/sigdelset.c
+++ b/src/signal/sigdelset.c
@@ -1,13 +1,23 @@
 #include <signal.h>
 #include <errno.h>
 
-int sigdelset(sigset_t *set, int sig)
+int sigdelsetyolo(sigset_t *set, int sig)
 {
 	unsigned s = sig-1;
-	if (s >= _NSIG-1 || sig-32U < 3) {
+	if (s >= _NSIG-1) {
 		errno = EINVAL;
 		return -1;
 	}
 	set->__bits[s/8/sizeof *set->__bits] &=~(1UL<<(s&8*sizeof *set->__bits-1));
 	return 0;
 }
+
+int sigdelset(sigset_t *set, int sig)
+{
+	unsigned s = sig-1;
+	if (sig-32U < 3) {
+		errno = EINVAL;
+		return -1;
+	}
+	return sigdelsetyolo(set, sig);
+}
diff --git a/src/thread/futex_calls.c b/src/thread/futex_calls.c
new file mode 100644
index 000000000000..255dc0273b07
--- /dev/null
+++ b/src/thread/futex_calls.c
@@ -0,0 +1,55 @@
+#include "pthread_impl.h"
+
+void yolo_futex_wake(volatile int *addr, int cnt, int priv)
+{
+	__wake(addr, cnt, priv);
+}
+
+void yolo_futex_wait(volatile int *addr, int val, int priv)
+{
+	__futexwait(addr, val, priv);
+}
+
+int yolo_futex_timedwait(volatile int *addr, int val, int clock_id, const struct timespec *timeout, int priv)
+{
+	return __timedwait(addr, val, clock_id, timeout, priv);
+}
+
+int yolo_futex_unlock_pi(volatile int *addr, int priv)
+{
+	if (priv) priv = FUTEX_PRIVATE;
+	return __syscall(SYS_futex, addr, FUTEX_UNLOCK_PI|priv);
+}
+
+#define IS32BIT(x) !((x)+0x80000000ULL>>32)
+#define CLAMP(x) (int)(IS32BIT(x) ? (x) : 0x7fffffffU+((0ULL+(x))>>63))
+
+static int __futex4(volatile void *addr, int op, int val, const struct timespec *to)
+{
+#ifdef SYS_futex_time64
+	time_t s = to ? to->tv_sec : 0;
+	long ns = to ? to->tv_nsec : 0;
+	int r = -ENOSYS;
+	if (SYS_futex == SYS_futex_time64 || !IS32BIT(s))
+		r = __syscall(SYS_futex_time64, addr, op, val,
+			to ? ((long long[]){s, ns}) : 0);
+	if (SYS_futex == SYS_futex_time64 || r!=-ENOSYS) return r;
+	to = to ? (void *)(long[]){CLAMP(s), ns} : 0;
+#endif
+	return __syscall(SYS_futex, addr, op, val, to);
+}
+
+int yolo_futex_lock_pi(volatile int *addr, int priv, const struct timespec *timeout)
+{
+	if (priv) priv = FUTEX_PRIVATE;
+	return __futex4(addr, FUTEX_LOCK_PI|priv, 0, timeout);
+}
+
+void yolo_futex_requeue(volatile int *addr, int priv, int wake_count, int requeue_count, volatile int *addr2)
+{
+	if (priv) priv = FUTEX_PRIVATE;
+	__syscall(SYS_futex, addr, FUTEX_REQUEUE|priv, wake_count, requeue_count, addr2) != -ENOSYS
+		|| __syscall(SYS_futex, addr, FUTEX_REQUEUE, wake_count, requeue_count, addr2);
+}
+
+
diff --git a/src/thread/pthread_cond_timedwait.c b/src/thread/pthread_cond_timedwait.c
index 6b761455c47f..4aa84d3a2a88 100644
--- a/src/thread/pthread_cond_timedwait.c
+++ b/src/thread/pthread_cond_timedwait.c
@@ -1,4 +1,5 @@
 #include "pthread_impl.h"
+#include <futex_calls.h>
 
 /*
  * struct waiter
@@ -49,8 +50,7 @@ static inline void unlock_requeue(volatile int *l, volatile int *r, int w)
 {
 	a_store(l, 0);
 	if (w) __wake(l, 1, 1);
-	else __syscall(SYS_futex, l, FUTEX_REQUEUE|FUTEX_PRIVATE, 0, 1, r) != -ENOSYS
-		|| __syscall(SYS_futex, l, FUTEX_REQUEUE, 0, 1, r);
+	else yolo_futex_requeue(l, 1, 0, 1, r);
 }
 
 enum {
diff --git a/src/thread/pthread_mutex_timedlock.c b/src/thread/pthread_mutex_timedlock.c
index 9279fc54308a..cf34dc843164 100644
--- a/src/thread/pthread_mutex_timedlock.c
+++ b/src/thread/pthread_mutex_timedlock.c
@@ -1,22 +1,5 @@
 #include "pthread_impl.h"
-
-#define IS32BIT(x) !((x)+0x80000000ULL>>32)
-#define CLAMP(x) (int)(IS32BIT(x) ? (x) : 0x7fffffffU+((0ULL+(x))>>63))
-
-static int __futex4(volatile void *addr, int op, int val, const struct timespec *to)
-{
-#ifdef SYS_futex_time64
-	time_t s = to ? to->tv_sec : 0;
-	long ns = to ? to->tv_nsec : 0;
-	int r = -ENOSYS;
-	if (SYS_futex == SYS_futex_time64 || !IS32BIT(s))
-		r = __syscall(SYS_futex_time64, addr, op, val,
-			to ? ((long long[]){s, ns}) : 0);
-	if (SYS_futex == SYS_futex_time64 || r!=-ENOSYS) return r;
-	to = to ? (void *)(long[]){CLAMP(s), ns} : 0;
-#endif
-	return __syscall(SYS_futex, addr, op, val, to);
-}
+#include "futex_calls.h"
 
 static int pthread_mutex_timedlock_pi(pthread_mutex_t *restrict m, const struct timespec *restrict at)
 {
@@ -27,7 +10,7 @@ static int pthread_mutex_timedlock_pi(pthread_mutex_t *restrict m, const struct
 
 	if (!priv) self->robust_list.pending = &m->_m_next;
 
-	do e = -__futex4(&m->_m_lock, FUTEX_LOCK_PI|priv, 0, at);
+	do e = -yolo_futex_lock_pi(&m->_m_lock, priv, at);
 	while (e==EINTR);
 	if (e) self->robust_list.pending = 0;
 
