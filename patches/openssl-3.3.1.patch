diff --git a/Configurations/shared-info.pl b/Configurations/shared-info.pl
index caf6f901261f..8b2e06e8b3a9 100644
--- a/Configurations/shared-info.pl
+++ b/Configurations/shared-info.pl
@@ -31,7 +31,7 @@ my %shared_info;
     'linux-shared' => sub {
         return {
             %{$shared_info{'gnu-shared'}},
-            shared_defflag    => '-Wl,--version-script=',
+            shared_defflag    => '--version-script=',
             dso_ldflags       =>
                 (grep /(?:^|\s)-fsanitize/,
                  @{$config{CFLAGS}}, @{$config{cflags}})
@@ -43,7 +43,7 @@ my %shared_info;
     'bsd-gcc-nodef-shared' => sub { 
         return {
             %{$shared_info{'gnu-shared'}},
-            shared_defflags     => '-Wl,--version-script=',
+            shared_defflags     => '--version-script=',
         };
     },
     'darwin-shared' => {
diff --git a/crypto/aes/aes_asm_forward.c b/crypto/aes/aes_asm_forward.c
new file mode 100644
index 000000000000..3434a5238aa0
--- /dev/null
+++ b/crypto/aes/aes_asm_forward.c
@@ -0,0 +1,54 @@
+#include "internal/deprecated.h"
+
+#include <assert.h>
+
+#include <stdlib.h>
+#include <openssl/crypto.h>
+#include <openssl/aes.h>
+#include "aes_local.h"
+#include <stdfil.h>
+
+int AES_set_encrypt_key(const unsigned char *userKey, const int bits,
+                        AES_KEY *key)
+{
+    zcheck_readonly(userKey, zchecked_add(bits, 7) / 8);
+    zcheck(key, sizeof(AES_KEY));
+    return zunsafe_buf_call(bits, "AES_set_encrypt_key", userKey, bits, key);
+}
+
+int AES_set_decrypt_key(const unsigned char *userKey, const int bits,
+                        AES_KEY *key)
+{
+    zcheck_readonly(userKey, zchecked_add(bits, 7) / 8);
+    zcheck(key, sizeof(AES_KEY));
+    return zunsafe_buf_call(bits, "AES_set_decrypt_key", userKey, bits, key);
+}
+
+void AES_encrypt(const unsigned char *in, unsigned char *out,
+                 const AES_KEY *key)
+{
+    zcheck_readonly(in, 16);
+    zcheck(out, 16);
+    zcheck_readonly(key, sizeof(AES_KEY));
+    zunsafe_fast_call("AES_encrypt", in, out, key);
+}
+
+void AES_decrypt(const unsigned char *in, unsigned char *out,
+                 const AES_KEY *key)
+{
+    zcheck_readonly(in, 16);
+    zcheck(out, 16);
+    zcheck_readonly(key, sizeof(AES_KEY));
+    zunsafe_fast_call("AES_decrypt", in, out, key);
+}
+
+void AES_cbc_encrypt(const unsigned char *in, unsigned char *out,
+                     size_t length, const AES_KEY *key,
+                     unsigned char *ivp, const int enc)
+{
+    zcheck_readonly(in, length);
+    zcheck(out, length);
+    zcheck_readonly(key, sizeof(AES_KEY));
+    zcheck(ivp, 16);
+    zunsafe_buf_call(length, "AES_cbc_encrypt", in, out, length, key, ivp, enc);
+}
diff --git a/crypto/aes/aesni_asm_forward.c b/crypto/aes/aesni_asm_forward.c
new file mode 100644
index 000000000000..2b7bfb79240c
--- /dev/null
+++ b/crypto/aes/aesni_asm_forward.c
@@ -0,0 +1,181 @@
+#include "internal/deprecated.h"
+
+#include <assert.h>
+
+#include <stdlib.h>
+#include <openssl/crypto.h>
+#include <openssl/aes.h>
+#include "crypto/modes.h"
+#include "crypto/aes_platform.h"
+#include <stdfil.h>
+
+int aesni_set_encrypt_key(const unsigned char *userKey, int bits,
+                          AES_KEY *key)
+{
+    zcheck_readonly(userKey, zchecked_add(bits, 7) / 8);
+    zcheck(key, sizeof(AES_KEY));
+    return zunsafe_buf_call(bits, "aesni_set_encrypt_key", userKey, bits, key);
+}
+
+int aesni_set_decrypt_key(const unsigned char *userKey, int bits,
+                          AES_KEY *key)
+{
+    zcheck_readonly(userKey, zchecked_add(bits, 7) / 8);
+    zcheck(key, sizeof(AES_KEY));
+    return zunsafe_buf_call(bits, "aesni_set_decrypt_key", userKey, bits, key);
+}
+
+void aesni_encrypt(const unsigned char *in, unsigned char *out,
+                   const AES_KEY *key)
+{
+    zcheck_readonly(in, 16);
+    zcheck(out, 16);
+    zcheck_readonly(key, sizeof(AES_KEY));
+    zunsafe_fast_call("aesni_encrypt", in, out, key);
+}
+
+void aesni_decrypt(const unsigned char *in, unsigned char *out,
+                   const AES_KEY *key)
+{
+    zcheck_readonly(in, 16);
+    zcheck(out, 16);
+    zcheck_readonly(key, sizeof(AES_KEY));
+    zunsafe_fast_call("aesni_decrypt", in, out, key);
+}
+
+void aesni_ecb_encrypt(const unsigned char *in,
+                       unsigned char *out,
+                       size_t length, const AES_KEY *key, int enc)
+{
+    zcheck_readonly(in, length);
+    zcheck(out, length);
+    zcheck_readonly(key, sizeof(AES_KEY));
+    zunsafe_buf_call(length, "aesni_ecb_encrypt", in, out, length, key, enc);
+}
+
+void aesni_cbc_encrypt(const unsigned char *in,
+                       unsigned char *out,
+                       size_t length,
+                       const AES_KEY *key, unsigned char *ivec, int enc)
+{
+    zcheck_readonly(in, length);
+    zcheck(out, length);
+    zcheck_readonly(key, sizeof(AES_KEY));
+    zcheck(ivec, 16);
+    zunsafe_buf_call(length, "aesni_cbc_encrypt", in, out, length, key, ivec, enc);
+}
+
+#  ifndef OPENSSL_NO_OCB
+static size_t l_size(size_t blocks, size_t start_block_num)
+{
+    size_t blocks_processed = start_block_num - 1;
+    size_t all_num_blocks = zchecked_add(blocks, blocks_processed);
+    size_t result = 0;
+    while (all_num_blocks >>= 1)
+        result = zchecked_add(result, 1);
+    return result;
+}
+
+void aesni_ocb_encrypt(const unsigned char *in, unsigned char *out,
+                       size_t blocks, const void *key,
+                       size_t start_block_num,
+                       unsigned char offset_i[16],
+                       const unsigned char L_[][16],
+                       unsigned char checksum[16])
+{
+    zcheck_readonly(in, zchecked_mul(blocks, 16));
+    zcheck(out, zchecked_mul(blocks, 16));
+    zcheck_readonly(key, sizeof(AES_KEY));
+    zcheck(offset_i, 16);
+    zcheck_readonly(L_, zchecked_mul(16, l_size(blocks, start_block_num)));
+    zcheck(checksum, 16);
+    zunsafe_buf_call(blocks, "aesni_ocb_encrypt", in, out, blocks, key, start_block_num, offset_i, L_, checksum);
+}
+
+void aesni_ocb_decrypt(const unsigned char *in, unsigned char *out,
+                       size_t blocks, const void *key,
+                       size_t start_block_num,
+                       unsigned char offset_i[16],
+                       const unsigned char L_[][16],
+                       unsigned char checksum[16])
+{
+    zcheck_readonly(in, zchecked_mul(blocks, 16));
+    zcheck(out, zchecked_mul(blocks, 16));
+    zcheck_readonly(key, sizeof(AES_KEY));
+    zcheck(offset_i, 16);
+    zcheck_readonly(L_, zchecked_mul(16, l_size(blocks, start_block_num)));
+    zcheck(checksum, 16);
+    zunsafe_buf_call(blocks, "aesni_ocb_decrypt", in, out, blocks, key, start_block_num, offset_i, L_, checksum);
+}
+#  endif /* OPENSSL_NO_OCB */
+
+void aesni_ctr32_encrypt_blocks(const unsigned char *in,
+                                unsigned char *out,
+                                size_t blocks,
+                                const void *key, const unsigned char *ivec)
+{
+    zcheck_readonly(in, zchecked_mul(blocks, 16));
+    zcheck(out, zchecked_mul(blocks, 16));
+    zcheck_readonly(key, sizeof(AES_KEY));
+    zcheck_readonly(ivec, 16);
+    zunsafe_buf_call(blocks, "aesni_ctr32_encrypt_blocks", in, out, blocks, key, ivec);
+}
+
+void aesni_xts_encrypt(const unsigned char *in,
+                       unsigned char *out,
+                       size_t length,
+                       const AES_KEY *key1, const AES_KEY *key2,
+                       const unsigned char iv[16])
+{
+    zcheck_readonly(in, length);
+    zcheck(out, length);
+    zcheck_readonly(key1, sizeof(AES_KEY));
+    zcheck_readonly(key2, sizeof(AES_KEY));
+    zcheck_readonly(iv, 16);
+    zunsafe_buf_call(length, "aesni_xts_encrypt", in, out, length, key1, key2, iv);
+}
+
+void aesni_xts_decrypt(const unsigned char *in,
+                       unsigned char *out,
+                       size_t length,
+                       const AES_KEY *key1, const AES_KEY *key2,
+                       const unsigned char iv[16])
+{
+    zcheck_readonly(in, length);
+    zcheck(out, length);
+    zcheck_readonly(key1, sizeof(AES_KEY));
+    zcheck_readonly(key2, sizeof(AES_KEY));
+    zcheck_readonly(iv, 16);
+    zunsafe_buf_call(length, "aesni_xts_decrypt", in, out, length, key1, key2, iv);
+}
+
+void aesni_ccm64_encrypt_blocks(const unsigned char *in,
+                                unsigned char *out,
+                                size_t blocks,
+                                const void *key,
+                                const unsigned char ivec[16],
+                                unsigned char cmac[16])
+{
+    zcheck_readonly(in, zchecked_mul(blocks, 16));
+    zcheck(out, zchecked_mul(blocks, 16));
+    zcheck_readonly(key, sizeof(AES_KEY));
+    zcheck_readonly(ivec, 16);
+    zcheck(cmac, 16);
+    zunsafe_buf_call(blocks, "aesni_ccm64_encrypt_blocks", in, out, blocks, key, ivec, cmac);
+}
+
+void aesni_ccm64_decrypt_blocks(const unsigned char *in,
+                                unsigned char *out,
+                                size_t blocks,
+                                const void *key,
+                                const unsigned char ivec[16],
+                                unsigned char cmac[16])
+{
+    zcheck_readonly(in, zchecked_mul(blocks, 16));
+    zcheck(out, zchecked_mul(blocks, 16));
+    zcheck_readonly(key, sizeof(AES_KEY));
+    zcheck_readonly(ivec, 16);
+    zcheck(cmac, 16);
+    zunsafe_buf_call(blocks, "aesni_ccm64_decrypt_blocks", in, out, blocks, key, ivec, cmac);
+}
+
diff --git a/crypto/aes/aesni_mb_asm_forward.c b/crypto/aes/aesni_mb_asm_forward.c
new file mode 100644
index 000000000000..002a0439984a
--- /dev/null
+++ b/crypto/aes/aesni_mb_asm_forward.c
@@ -0,0 +1,34 @@
+#include "internal/deprecated.h"
+
+#include <assert.h>
+
+#include <stdlib.h>
+#include <openssl/crypto.h>
+#include <openssl/aes.h>
+#include "crypto/modes.h"
+#include "crypto/aes_platform.h"
+#include <stdfil.h>
+
+typedef struct {
+    const unsigned char *inp;
+    unsigned char *out;
+    int blocks;
+    u64 iv[2];
+} CIPH_DESC;
+
+void aesni_multi_cbc_encrypt(CIPH_DESC *desc, void *key, int n4x)
+{
+    ZSAFETY_CHECK(n4x == 1 || n4x == 2);
+    unsigned n = n4x * 4;
+    zcheck(desc, zchecked_mul(sizeof(CIPH_DESC), n));
+    unsigned i;
+    unsigned total = 0;
+    for (i = n; i--;) {
+        zcheck_readonly(desc[i].inp, zchecked_mul(desc[i].blocks, 16));
+        zcheck(desc[i].out, zchecked_mul(desc[i].blocks, 16));
+        total += zchecked_mul(desc[i].blocks, 16);
+    }
+    zcheck(key, sizeof(AES_KEY));
+    zunsafe_buf_call(total, "aesni_multi_cbc_encrypt", desc, key, n4x);
+}
+
diff --git a/crypto/aes/aesni_sha1_asm_forward.c b/crypto/aes/aesni_sha1_asm_forward.c
new file mode 100644
index 000000000000..76d09c1186d4
--- /dev/null
+++ b/crypto/aes/aesni_sha1_asm_forward.c
@@ -0,0 +1,41 @@
+#include "internal/deprecated.h"
+
+#include <assert.h>
+
+#include <stdlib.h>
+#include <openssl/crypto.h>
+#include <openssl/aes.h>
+#include <openssl/sha.h>
+#include "crypto/modes.h"
+#include "crypto/aes_platform.h"
+#include <stdfil.h>
+
+void aesni_cbc_sha1_enc(const void *inp, void *out, size_t blocks,
+                        const AES_KEY *key, unsigned char iv[16],
+                        SHA_CTX *ctx, const void *in0)
+{
+    zcheck_readonly(inp, zchecked_mul(blocks, 64));
+    zcheck(out, zchecked_mul(blocks, 64));
+    zcheck_readonly(key, sizeof(AES_KEY));
+    zcheck(iv, 16);
+    zcheck(ctx, sizeof(SHA_CTX));
+    zcheck_readonly(in0, zchecked_mul(blocks, 64));
+    zunsafe_call("aesni_cbc_sha1_enc", inp, out, blocks, key, iv, ctx, in0);
+}
+
+/* The stitched decrypt thing seems to be implemented but disabled. */
+#if 0
+void aesni256_cbc_sha1_dec(const void *inp, void *out, size_t blocks,
+                           const AES_KEY *key, unsigned char iv[16],
+                           SHA_CTX *ctx, const void *in0)
+{
+    zcheck_readonly(inp, zchecked_mul(blocks, 64));
+    zcheck(out, zchecked_mul(blocks, 64));
+    zcheck_readonly(key, sizeof(AES_KEY));
+    zcheck(iv, 16);
+    zcheck(ctx, sizeof(SHA_CTX));
+    zcheck_readonly(in0, zchecked_mul(blocks, 64));
+    zunsafe_call("aesni256_cbc_sha1_dec", inp, out, blocks, key, iv, ctx, in0);
+}
+#endif
+
diff --git a/crypto/aes/aesni_sha256_asm_forward.c b/crypto/aes/aesni_sha256_asm_forward.c
new file mode 100644
index 000000000000..4c606d8d8a5d
--- /dev/null
+++ b/crypto/aes/aesni_sha256_asm_forward.c
@@ -0,0 +1,29 @@
+#include "internal/deprecated.h"
+
+#include <assert.h>
+
+#include <stdlib.h>
+#include <openssl/crypto.h>
+#include <openssl/aes.h>
+#include <openssl/sha.h>
+#include "crypto/modes.h"
+#include "crypto/aes_platform.h"
+#include <stdfil.h>
+
+int aesni_cbc_sha256_enc(const void *inp, void *out, size_t blocks,
+                         const AES_KEY *key, unsigned char iv[16],
+                         SHA256_CTX *ctx, const void *in0)
+{
+    zcheck_readonly(inp, zchecked_mul(blocks, 64));
+    zcheck(out, zchecked_mul(blocks, 64));
+    if (key)
+        zcheck_readonly(key, sizeof(AES_KEY));
+    if (iv)
+        zcheck(iv, 16);
+    if (ctx)
+        zcheck(ctx, sizeof(SHA_CTX));
+    zcheck_readonly(in0, zchecked_mul(blocks, 64));
+    return zunsafe_call("aesni_cbc_sha256_enc", inp, out, blocks, key, iv, ctx, in0);
+}
+
+
diff --git a/crypto/aes/bsaes_asm_forward.c b/crypto/aes/bsaes_asm_forward.c
new file mode 100644
index 000000000000..67d383cad833
--- /dev/null
+++ b/crypto/aes/bsaes_asm_forward.c
@@ -0,0 +1,58 @@
+#include "internal/deprecated.h"
+
+#include <assert.h>
+
+#include <stdlib.h>
+#include <openssl/crypto.h>
+#include <openssl/aes.h>
+#include "crypto/modes.h"
+#include "crypto/aes_platform.h"
+#include <stdfil.h>
+
+void ossl_bsaes_cbc_encrypt(const unsigned char *in, unsigned char *out,
+                            size_t length, const AES_KEY *key,
+                            unsigned char ivec[16], int enc)
+{
+    zcheck_readonly(in, length);
+    zcheck(out, length);
+    zcheck_readonly(key, sizeof(AES_KEY));
+    zcheck(ivec, 16);
+    zunsafe_buf_call(length, "ossl_bsaes_cbc_encrypt", in, out, length, key, ivec, enc);
+}
+
+void ossl_bsaes_ctr32_encrypt_blocks(const unsigned char *in,
+                                     unsigned char *out, size_t len,
+                                     const AES_KEY *key,
+                                     const unsigned char ivec[16])
+{
+    zcheck_readonly(in, zchecked_mul(len, 16));
+    zcheck(out, zchecked_mul(len, 16));
+    zcheck_readonly(key, sizeof(AES_KEY));
+    zcheck_readonly(ivec, 16);
+    zunsafe_buf_call(len, "ossl_bsaes_ctr32_encrypt_blocks", in, out, len, key, ivec);
+}
+
+void ossl_bsaes_xts_encrypt(const unsigned char *inp, unsigned char *out,
+                            size_t len, const AES_KEY *key1,
+                            const AES_KEY *key2, const unsigned char iv[16])
+{
+    zcheck_readonly(inp, len);
+    zcheck(out, len);
+    zcheck_readonly(key1, sizeof(AES_KEY));
+    zcheck_readonly(key2, sizeof(AES_KEY));
+    zcheck_readonly(iv, 16);
+    zunsafe_buf_call(len, "ossl_bsaes_xts_encrypt", inp, out, len, key1, key2, iv);
+}
+
+void ossl_bsaes_xts_decrypt(const unsigned char *inp, unsigned char *out,
+                            size_t len, const AES_KEY *key1,
+                            const AES_KEY *key2, const unsigned char iv[16])
+{
+    zcheck_readonly(inp, len);
+    zcheck(out, len);
+    zcheck_readonly(key1, sizeof(AES_KEY));
+    zcheck_readonly(key2, sizeof(AES_KEY));
+    zcheck_readonly(iv, 16);
+    zunsafe_buf_call(len, "ossl_bsaes_xts_decrypt", inp, out, len, key1, key2, iv);
+}
+
diff --git a/crypto/aes/build.info b/crypto/aes/build.info
index 2dc16a2b2ef9..fc9b43d5215d 100644
--- a/crypto/aes/build.info
+++ b/crypto/aes/build.info
@@ -8,8 +8,11 @@ IF[{- !$disabled{asm} -}]
   $AESDEF_x86_sse2=VPAES_ASM OPENSSL_IA32_SSE2
 
   $AESASM_x86_64=\
-        aes-x86_64.s vpaes-x86_64.s bsaes-x86_64.s aesni-x86_64.s \
-        aesni-sha1-x86_64.s aesni-sha256-x86_64.s aesni-mb-x86_64.s
+        aes_asm_forward.c aes-x86_64.s vpaes_asm_forward.c vpaes-x86_64.s \
+        bsaes_asm_forward.c bsaes-x86_64.s aesni_asm_forward.c aesni-x86_64.s \
+        aesni_sha1_asm_forward.c aesni-sha1-x86_64.s \
+        aesni_sha256_asm_forward.c aesni-sha256-x86_64.s \
+        aesni_mb_asm_forward.c aesni-mb-x86_64.s
   $AESDEF_x86_64=AES_ASM VPAES_ASM BSAES_ASM
 
   $AESASM_ia64=aes_core.c aes_cbc.c aes-ia64.s
diff --git a/crypto/aes/vpaes_asm_forward.c b/crypto/aes/vpaes_asm_forward.c
new file mode 100644
index 000000000000..c8d788b7c875
--- /dev/null
+++ b/crypto/aes/vpaes_asm_forward.c
@@ -0,0 +1,55 @@
+#include "internal/deprecated.h"
+
+#include <assert.h>
+
+#include <stdlib.h>
+#include <openssl/crypto.h>
+#include <openssl/aes.h>
+#include "crypto/modes.h"
+#include "crypto/aes_platform.h"
+#include <stdfil.h>
+
+int vpaes_set_encrypt_key(const unsigned char *userKey, const int bits,
+                          AES_KEY *key)
+{
+    zcheck_readonly(userKey, zchecked_add(bits, 7) / 8);
+    zcheck(key, sizeof(AES_KEY));
+    return zunsafe_buf_call(bits, "vpaes_set_encrypt_key", userKey, bits, key);
+}
+
+int vpaes_set_decrypt_key(const unsigned char *userKey, const int bits,
+                          AES_KEY *key)
+{
+    zcheck_readonly(userKey, zchecked_add(bits, 7) / 8);
+    zcheck(key, sizeof(AES_KEY));
+    return zunsafe_buf_call(bits, "vpaes_set_decrypt_key", userKey, bits, key);
+}
+
+void vpaes_encrypt(const unsigned char *in, unsigned char *out,
+                   const AES_KEY *key)
+{
+    zcheck_readonly(in, 16);
+    zcheck(out, 16);
+    zcheck_readonly(key, sizeof(AES_KEY));
+    zunsafe_fast_call("vpaes_encrypt", in, out, key);
+}
+
+void vpaes_decrypt(const unsigned char *in, unsigned char *out,
+                   const AES_KEY *key)
+{
+    zcheck_readonly(in, 16);
+    zcheck(out, 16);
+    zcheck_readonly(key, sizeof(AES_KEY));
+    zunsafe_fast_call("vpaes_decrypt", in, out, key);
+}
+
+void vpaes_cbc_encrypt(const unsigned char *in, unsigned char *out,
+                       size_t length, const AES_KEY *key,
+                       unsigned char *ivp, const int enc)
+{
+    zcheck_readonly(in, length);
+    zcheck(out, length);
+    zcheck_readonly(key, sizeof(AES_KEY));
+    zcheck(ivp, 16);
+    zunsafe_buf_call(length, "vpaes_cbc_encrypt", in, out, length, key, ivp, enc);
+}
diff --git a/crypto/bn/bn_asm.c b/crypto/bn/bn_asm.c
index c39907a7dfd3..c7700bb9e97b 100644
--- a/crypto/bn/bn_asm.c
+++ b/crypto/bn/bn_asm.c
@@ -11,6 +11,7 @@
 #include <openssl/crypto.h>
 #include "internal/cryptlib.h"
 #include "bn_local.h"
+#include <stdfil.h>
 
 #if defined(BN_LLONG) || defined(BN_UMULT_HIGH)
 
@@ -1040,3 +1041,16 @@ int bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,
 # endif
 
 #endif                          /* !BN_MUL_COMBA */
+
+#ifndef OPENSSL_NO_ASM
+int bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,
+                const BN_ULONG *np, const BN_ULONG *n0, int num)
+{
+    zcheck(rp, zchecked_mul(num, sizeof(BN_ULONG)));
+    zcheck_readonly(ap, zchecked_mul(num, sizeof(BN_ULONG)));
+    zcheck_readonly(bp, zchecked_mul(num, sizeof(BN_ULONG)));
+    zcheck_readonly(np, zchecked_mul(num, sizeof(BN_ULONG)));
+    zcheck_readonly(n0, sizeof(BN_ULONG));
+    return zunsafe_buf_call(num, "bn_mul_mont", rp, ap, bp, np, n0, num);
+}
+#endif
diff --git a/crypto/bn/bn_div.c b/crypto/bn/bn_div.c
index ff66baa48f22..51643b9b6e9b 100644
--- a/crypto/bn/bn_div.c
+++ b/crypto/bn/bn_div.c
@@ -159,7 +159,7 @@ static int bn_left_align(BIGNUM *num)
 }
 
 # if !defined(OPENSSL_NO_ASM) && !defined(OPENSSL_NO_INLINE_ASM) \
-    && !defined(PEDANTIC) && !defined(BN_DIV3W)
+    && !defined(PEDANTIC) && !defined(BN_DIV3W) && !defined(__FILC__)
 #  if defined(__GNUC__) && __GNUC__>=2
 #   if defined(__i386) || defined (__i386__)
    /*-
diff --git a/crypto/bn/build.info b/crypto/bn/build.info
index 2f30681b3b26..e3f6f44119c0 100644
--- a/crypto/bn/build.info
+++ b/crypto/bn/build.info
@@ -22,15 +22,18 @@ IF[{- !$disabled{asm} -}]
   $BNDEF_x86=OPENSSL_BN_ASM_PART_WORDS OPENSSL_BN_ASM_MONT OPENSSL_BN_ASM_GF2m
   $BNDEF_x86_sse2=OPENSSL_IA32_SSE2
 
-  $BNASM_x86_64=\
-          x86_64-mont.s x86_64-mont5.s x86_64-gf2m.s rsaz_exp.c rsaz-x86_64.s \
-          rsaz-avx2.s rsaz_exp_x2.c rsaz-2k-avx512.s rsaz-3k-avx512.s rsaz-4k-avx512.s
-  IF[{- $config{target} !~ /^VC/ -}]
-    $BNASM_x86_64=asm/x86_64-gcc.c $BNASM_x86_64
-  ELSE
-    $BNASM_x86_64=bn_asm.c $BNASM_x86_64
-  ENDIF
-  $BNDEF_x86_64=OPENSSL_BN_ASM_MONT OPENSSL_BN_ASM_MONT5 OPENSSL_BN_ASM_GF2m
+  # Only enable the bare minimum of assembly support needed to get to constant time crypto.
+  $BNASM_x86_64=bn_asm.c x86_64-mont.s x86_64-mont5.s
+  $BNDEF_x86_64=OPENSSL_BN_ASM_MONT
+  # $BNASM_x86_64=\
+  #         x86_64-mont.s x86_64-mont5.s x86_64-gf2m.s rsaz_exp.c rsaz-x86_64.s \
+  #         rsaz-avx2.s rsaz_exp_x2.c rsaz-2k-avx512.s rsaz-3k-avx512.s rsaz-4k-avx512.s
+  # IF[{- $config{target} !~ /^VC/ -}]
+  #   $BNASM_x86_64=asm/x86_64-gcc.c $BNASM_x86_64
+  # ELSE
+  #   $BNASM_x86_64=bn_asm.c $BNASM_x86_64
+  # ENDIF
+  # $BNDEF_x86_64=OPENSSL_BN_ASM_MONT OPENSSL_BN_ASM_MONT5 OPENSSL_BN_ASM_GF2m
   $BNDEF_x86_64_sse2=OPENSSL_IA32_SSE2
 
   IF[{- $config{target} !~ /^VC/ -}]
diff --git a/crypto/bn/rsaz_exp.h b/crypto/bn/rsaz_exp.h
index 45dc9cc197d0..4b127444d9b0 100644
--- a/crypto/bn/rsaz_exp.h
+++ b/crypto/bn/rsaz_exp.h
@@ -16,7 +16,9 @@
 # define OSSL_CRYPTO_BN_RSAZ_EXP_H
 
 # undef RSAZ_ENABLED
-# if defined(OPENSSL_BN_ASM_MONT) && \
+/* FIXME: No reason why we can't enable these for Fil-C at some point. My understanding is that these
+   code paths are just an optimization and they're not meant to be anything but that. */
+# if !defined(__FILC__) && defined(OPENSSL_BN_ASM_MONT) &&  \
         (defined(__x86_64) || defined(__x86_64__) || \
          defined(_M_AMD64) || defined(_M_X64))
 #  define RSAZ_ENABLED
diff --git a/crypto/camellia/build.info b/crypto/camellia/build.info
index f13cd8c958be..c38ee92f6a56 100644
--- a/crypto/camellia/build.info
+++ b/crypto/camellia/build.info
@@ -3,7 +3,7 @@ LIBS=../../libcrypto
 $CMLLASM=camellia.c cmll_misc.c cmll_cbc.c
 IF[{- !$disabled{asm} -}]
   $CMLLASM_x86=cmll-x86.S
-  $CMLLASM_x86_64=cmll-x86_64.s cmll_misc.c
+  $CMLLASM_x86_64=camellia_asm_forward.c cmll-x86_64.s cmll_misc.c
   $CMLLASM_sparcv9=camellia.c cmll_misc.c cmll_cbc.c cmllt4-sparcv9.S
 
   # Now that we have defined all the arch specific variables, use the
diff --git a/crypto/camellia/camellia_asm_forward.c b/crypto/camellia/camellia_asm_forward.c
new file mode 100644
index 000000000000..adc7ce51bb2f
--- /dev/null
+++ b/crypto/camellia/camellia_asm_forward.c
@@ -0,0 +1,67 @@
+#include "internal/deprecated.h"
+
+#include <openssl/camellia.h>
+#include "cmll_local.h"
+#include <string.h>
+#include <stdlib.h>
+
+#include <stdfil.h>
+
+int Camellia_Ekeygen(int keyBitLength, const u8* rawKey, KEY_TABLE_TYPE k)
+{
+    ZSAFETY_CHECK(keyBitLength == 128 || keyBitLength == 192 || keyBitLength == 256);
+    zcheck_readonly(rawKey, (keyBitLength + 7) / 8);
+    zcheck(k, sizeof(KEY_TABLE_TYPE));
+    return zunsafe_fast_call("Camellia_Ekeygen", keyBitLength, rawKey, k);
+}
+
+void Camellia_EncryptBlock_Rounds(int grandRounds, const u8 plaintext[],
+                                  const KEY_TABLE_TYPE keyTable,
+                                  u8 ciphertext[])
+{
+    zcheck_readonly(plaintext, 16);
+    zcheck_readonly(keyTable, sizeof(KEY_TABLE_TYPE));
+    zcheck(ciphertext, 16);
+    zunsafe_fast_call("Camellia_EncryptBlock_Rounds", grandRounds, plaintext, keyTable, ciphertext);
+}
+
+void Camellia_EncryptBlock(int keyBitLength, const u8 plaintext[],
+                           const KEY_TABLE_TYPE keyTable, u8 ciphertext[])
+{
+    ZSAFETY_CHECK(keyBitLength == 128 || keyBitLength == 192 || keyBitLength == 256);
+    zcheck_readonly(plaintext, 16);
+    zcheck_readonly(keyTable, sizeof(KEY_TABLE_TYPE));
+    zcheck(ciphertext, 16);
+    zunsafe_fast_call("Camellia_EncryptBlock", keyBitLength, plaintext, keyTable, ciphertext);
+}
+
+void Camellia_DecryptBlock_Rounds(int grandRounds, const u8 ciphertext[],
+                                  const KEY_TABLE_TYPE keyTable,
+                                  u8 plaintext[])
+{
+    zcheck_readonly(ciphertext, 16);
+    zcheck_readonly(keyTable, sizeof(KEY_TABLE_TYPE));
+    zcheck(plaintext, 16);
+    zunsafe_fast_call("Camellia_DecryptBlock_Rounds", grandRounds, ciphertext, keyTable, plaintext);
+}
+
+void Camellia_DecryptBlock(int keyBitLength, const u8 ciphertext[],
+                           const KEY_TABLE_TYPE keyTable, u8 plaintext[])
+{
+    ZSAFETY_CHECK(keyBitLength == 128 || keyBitLength == 192 || keyBitLength == 256);
+    zcheck_readonly(ciphertext, 16);
+    zcheck_readonly(keyTable, sizeof(KEY_TABLE_TYPE));
+    zcheck(plaintext, 16);
+    zunsafe_fast_call("Camellia_DecryptBlock", keyBitLength, ciphertext, keyTable, plaintext);
+}
+
+void Camellia_cbc_encrypt(const unsigned char *in, unsigned char *out,
+                          size_t len, const CAMELLIA_KEY *key,
+                          unsigned char *ivec, const int enc)
+{
+    zcheck_readonly(in, len);
+    zcheck(out, len);
+    zcheck_readonly(key, sizeof(CAMELLIA_KEY));
+    zcheck(ivec, 16);
+    zunsafe_buf_call(len, "Camellia_cbc_encrypt", in, out, len, key, ivec, enc);
+}
diff --git a/crypto/chacha/build.info b/crypto/chacha/build.info
index c1352c9b62de..3180893af64d 100644
--- a/crypto/chacha/build.info
+++ b/crypto/chacha/build.info
@@ -3,7 +3,7 @@ LIBS=../../libcrypto
 $CHACHAASM=chacha_enc.c
 IF[{- !$disabled{asm} -}]
   $CHACHAASM_x86=chacha-x86.S
-  $CHACHAASM_x86_64=chacha-x86_64.s
+  $CHACHAASM_x86_64=chacha_asm_forward.c chacha-x86_64.s
 
   $CHACHAASM_ia64=chacha-ia64.s
 
diff --git a/crypto/chacha/chacha_asm_forward.c b/crypto/chacha/chacha_asm_forward.c
new file mode 100644
index 000000000000..5bcdeb244d80
--- /dev/null
+++ b/crypto/chacha/chacha_asm_forward.c
@@ -0,0 +1,16 @@
+#include <string.h>
+
+#include "internal/endian.h"
+#include "crypto/chacha.h"
+#include "crypto/ctype.h"
+#include <stdfil.h>
+
+void ChaCha20_ctr32(unsigned char *out, const unsigned char *inp, size_t len,
+                    const unsigned int key[8], const unsigned int counter[4])
+{
+    zcheck(out, len);
+    zcheck_readonly(inp, len);
+    zcheck_readonly(key, 8 * sizeof(unsigned int));
+    zcheck_readonly(counter, 4 * sizeof(unsigned int));
+    zunsafe_buf_call(len, "ChaCha20_ctr32", out, inp, len, key, counter);
+}
diff --git a/crypto/cpuid.c b/crypto/cpuid.c
index 51cbe5ea090e..c47a418283b1 100644
--- a/crypto/cpuid.c
+++ b/crypto/cpuid.c
@@ -9,6 +9,7 @@
 
 #include "internal/e_os.h"
 #include "crypto/cryptlib.h"
+#include <stdfil.h>
 
 #if     defined(__i386)   || defined(__i386__)   || defined(_M_IX86) || \
         defined(__x86_64) || defined(__x86_64__) || \
@@ -92,10 +93,18 @@ static variant_char *ossl_strchr(const variant_char *str, char srch)
 #  define OPENSSL_CPUID_SETUP
 typedef uint64_t IA32CAP;
 
+unsigned int OPENSSL_ia32cap_P[4];
+asm(".filc_unsafe_export OPENSSL_ia32cap_P");
+
+static IA32CAP OPENSSL_ia32_cpuid(unsigned int *ptr)
+{
+    zcheck(ptr, sizeof(unsigned int) * 4);
+    return zunsafe_fast_call("OPENSSL_ia32_cpuid", ptr);
+}
+
 void OPENSSL_cpuid_setup(void)
 {
     static int trigger = 0;
-    IA32CAP OPENSSL_ia32_cpuid(unsigned int *);
     IA32CAP vec;
     const variant_char *env;
 
@@ -155,6 +164,39 @@ void OPENSSL_cpuid_setup(void)
     OPENSSL_ia32cap_P[0] = (unsigned int)vec | (1 << 10);
     OPENSSL_ia32cap_P[1] = (unsigned int)(vec >> 32);
 }
+static void init(void) __attribute__((constructor));
+static void init(void)
+{
+    OPENSSL_cpuid_setup();
+}
+
+void OPENSSL_cleanse(void *ptr, size_t len)
+{
+    zmemset(ptr, 0, len);
+}
+
+int CRYPTO_memcmp(const void *a, const void *b, size_t len)
+{
+    zcheck_readonly(a, len);
+    zcheck_readonly(b, len);
+    return zunsafe_buf_call(len, "CRYPTO_memcmp", a, b, len);
+}
+
+uint32_t OPENSSL_rdtsc(void)
+{
+    return zunsafe_fast_call("OPENSSL_rdtsc");
+}
+
+size_t OPENSSL_ia32_rdseed_bytes(unsigned char *buf, size_t len)
+{
+    zcheck(buf, len);
+    return zunsafe_buf_call(len, "OPENSSL_ia32_rdseed_bytes", buf, len);
+}
+size_t OPENSSL_ia32_rdrand_bytes(unsigned char *buf, size_t len)
+{
+    zcheck(buf, len);
+    return zunsafe_buf_call(len, "OPENSSL_ia32_rdrand_bytes", buf, len);
+}
 # else
 unsigned int OPENSSL_ia32cap_P[4];
 # endif
diff --git a/crypto/des/des_local.h b/crypto/des/des_local.h
index d43f2c87374d..69b890a2ecfc 100644
--- a/crypto/des/des_local.h
+++ b/crypto/des/des_local.h
@@ -85,7 +85,7 @@
 #  define ROTATE(a,n)     (_lrotr(a,n))
 # elif defined(__ICC)
 #  define ROTATE(a,n)     (_rotr(a,n))
-# elif defined(__GNUC__) && __GNUC__>=2 && !defined(__STRICT_ANSI__) && !defined(OPENSSL_NO_ASM) && !defined(OPENSSL_NO_INLINE_ASM) && !defined(PEDANTIC)
+# elif defined(__GNUC__) && __GNUC__>=2 && !defined(__STRICT_ANSI__) && !defined(OPENSSL_NO_ASM) && !defined(OPENSSL_NO_INLINE_ASM) && !defined(PEDANTIC) && !defined(__FILC__)
 #  if defined(__i386) || defined(__i386__) || defined(__x86_64) || defined(__x86_64__)
 #   define ROTATE(a,n)   ({ register unsigned int ret;   \
                                 asm ("rorl %1,%0"       \
diff --git a/crypto/ec/asm/ecp_nistz256-x86_64.pl b/crypto/ec/asm/ecp_nistz256-x86_64.pl
index 430b14c86d8d..44cca451aec6 100755
--- a/crypto/ec/asm/ecp_nistz256-x86_64.pl
+++ b/crypto/ec/asm/ecp_nistz256-x86_64.pl
@@ -4706,35 +4706,35 @@ $code.=<<___ if ($addx);
 ___
 }
 
-########################################################################
-# Convert ecp_nistz256_table.c to layout expected by ecp_nistz_gather_w7
-#
-open TABLE,"<ecp_nistz256_table.c"		or
-open TABLE,"<${dir}../ecp_nistz256_table.c"	or
-die "failed to open ecp_nistz256_table.c:",$!;
-
-use integer;
-
-foreach(<TABLE>) {
-	s/TOBN\(\s*(0x[0-9a-f]+),\s*(0x[0-9a-f]+)\s*\)/push @arr,hex($2),hex($1)/geo;
-}
-close TABLE;
-
-die "insane number of elements" if ($#arr != 64*16*37-1);
-
-print <<___;
-.text
-.globl	ecp_nistz256_precomputed
-.type	ecp_nistz256_precomputed,\@object
-.align	4096
-ecp_nistz256_precomputed:
-___
-while (@line=splice(@arr,0,16)) {
-	print ".long\t",join(',',map { sprintf "0x%08x",$_} @line),"\n";
-}
-print <<___;
-.size	ecp_nistz256_precomputed,.-ecp_nistz256_precomputed
-___
+# ########################################################################
+# # Convert ecp_nistz256_table.c to layout expected by ecp_nistz_gather_w7
+# #
+# open TABLE,"<ecp_nistz256_table.c"		or
+# open TABLE,"<${dir}../ecp_nistz256_table.c"	or
+# die "failed to open ecp_nistz256_table.c:",$!;
+# 
+# use integer;
+# 
+# foreach(<TABLE>) {
+# 	s/TOBN\(\s*(0x[0-9a-f]+),\s*(0x[0-9a-f]+)\s*\)/push @arr,hex($2),hex($1)/geo;
+# }
+# close TABLE;
+# 
+# die "insane number of elements" if ($#arr != 64*16*37-1);
+# 
+# print <<___;
+# .text
+# .globl	ecp_nistz256_precomputed
+# .type	ecp_nistz256_precomputed,\@object
+# .align	4096
+# ecp_nistz256_precomputed:
+# ___
+# while (@line=splice(@arr,0,16)) {
+# 	print ".long\t",join(',',map { sprintf "0x%08x",$_} @line),"\n";
+# }
+# print <<___;
+# .size	ecp_nistz256_precomputed,.-ecp_nistz256_precomputed
+# ___
 
 $code =~ s/\`([^\`]*)\`/eval $1/gem;
 print $code;
diff --git a/crypto/ec/build.info b/crypto/ec/build.info
index dbe69578ef52..a6143918a364 100644
--- a/crypto/ec/build.info
+++ b/crypto/ec/build.info
@@ -3,7 +3,7 @@ IF[{- !$disabled{asm} -}]
   $ECASM_x86=ecp_nistz256.c ecp_nistz256-x86.S
   $ECDEF_x86=ECP_NISTZ256_ASM
 
-  $ECASM_x86_64=ecp_nistz256.c ecp_nistz256-x86_64.s
+  $ECASM_x86_64=ecp_nistz256.c ecp_nistz256_table.c ecp_nistz256-x86_64.s
   $ECDEF_x86_64=ECP_NISTZ256_ASM
   IF[{- !$disabled{'ecx'} -}]
     $ECASM_x86_64=$ECASM_x86_64 x25519-x86_64.s
diff --git a/crypto/ec/curve25519.c b/crypto/ec/curve25519.c
index cae2ac101dba..4085c65c445b 100644
--- a/crypto/ec/curve25519.c
+++ b/crypto/ec/curve25519.c
@@ -20,6 +20,7 @@
 #include <openssl/sha.h>
 
 #include "internal/numbers.h"
+#include <stdfil.h>
 
 #if defined(X25519_ASM) && (defined(__x86_64) || defined(__x86_64__) || \
                             defined(_M_AMD64) || defined(_M_X64))
@@ -28,7 +29,10 @@
 
 typedef uint64_t fe64[4];
 
-int x25519_fe64_eligible(void);
+static int x25519_fe64_eligible(void)
+{
+    return zunsafe_fast_call("x25519_fe64_eligible");
+}
 
 /*
  * Following subroutines perform corresponding operations modulo
@@ -39,12 +43,45 @@ int x25519_fe64_eligible(void);
  *
  * There are no reference C implementations for these.
  */
-void x25519_fe64_mul(fe64 h, const fe64 f, const fe64 g);
-void x25519_fe64_sqr(fe64 h, const fe64 f);
-void x25519_fe64_mul121666(fe64 h, fe64 f);
-void x25519_fe64_add(fe64 h, const fe64 f, const fe64 g);
-void x25519_fe64_sub(fe64 h, const fe64 f, const fe64 g);
-void x25519_fe64_tobytes(uint8_t *s, const fe64 f);
+static void x25519_fe64_mul(fe64 h, const fe64 f, const fe64 g)
+{
+    zcheck(h, sizeof(fe64));
+    zcheck_readonly(f, sizeof(fe64));
+    zcheck_readonly(g, sizeof(fe64));
+    zunsafe_fast_call("x25519_fe64_mul", h, f, g);
+}
+static void x25519_fe64_sqr(fe64 h, const fe64 f)
+{
+    zcheck(h, sizeof(fe64));
+    zcheck_readonly(f, sizeof(fe64));
+    zunsafe_fast_call("x25519_fe64_sqr", h, f);
+}
+static void x25519_fe64_mul121666(fe64 h, fe64 f)
+{
+    zcheck(h, sizeof(fe64));
+    zcheck(f, sizeof(fe64));
+    zunsafe_fast_call("x25519_fe64_mul121666", h, f);
+}
+static void x25519_fe64_add(fe64 h, const fe64 f, const fe64 g)
+{
+    zcheck(h, sizeof(fe64));
+    zcheck_readonly(f, sizeof(fe64));
+    zcheck_readonly(g, sizeof(fe64));
+    zunsafe_fast_call("x25519_fe64_add", h, f, g);
+}
+static void x25519_fe64_sub(fe64 h, const fe64 f, const fe64 g)
+{
+    zcheck(h, sizeof(fe64));
+    zcheck_readonly(f, sizeof(fe64));
+    zcheck_readonly(g, sizeof(fe64));
+    zunsafe_fast_call("x25519_fe64_sub", h, f, g);
+}
+static void x25519_fe64_tobytes(uint8_t *s, const fe64 f)
+{
+    zcheck(s, sizeof(fe64));
+    zcheck_readonly(f, sizeof(fe64));
+    zunsafe_fast_call("x25519_fe64_tobytes", s, f);
+}
 # define fe64_mul x25519_fe64_mul
 # define fe64_sqr x25519_fe64_sqr
 # define fe64_mul121666 x25519_fe64_mul121666
@@ -387,9 +424,25 @@ static void fe51_tobytes(uint8_t *s, const fe51 h)
 }
 
 # if defined(X25519_ASM)
-void x25519_fe51_mul(fe51 h, const fe51 f, const fe51 g);
-void x25519_fe51_sqr(fe51 h, const fe51 f);
-void x25519_fe51_mul121666(fe51 h, fe51 f);
+static void x25519_fe51_mul(fe51 h, const fe51 f, const fe51 g)
+{
+    zcheck(h, sizeof(fe51));
+    zcheck_readonly(f, sizeof(fe51));
+    zcheck_readonly(g, sizeof(fe51));
+    zunsafe_fast_call("x25519_fe51_mul", h, f, g);
+}
+static void x25519_fe51_sqr(fe51 h, const fe51 f)
+{
+    zcheck(h, sizeof(fe51));
+    zcheck_readonly(f, sizeof(fe51));
+    zunsafe_fast_call("x25519_fe51_sqr", h, f);
+}
+static void x25519_fe51_mul121666(fe51 h, fe51 f)
+{
+    zcheck(h, sizeof(fe51));
+    zcheck(f, sizeof(fe51));
+    zunsafe_fast_call("x25519_fe51_mul121666", h, f);
+}
 #  define fe51_mul x25519_fe51_mul
 #  define fe51_sq  x25519_fe51_sqr
 #  define fe51_mul121666 x25519_fe51_mul121666
diff --git a/crypto/ec/ecp_nistz256.c b/crypto/ec/ecp_nistz256.c
index 5760639a2ee2..a6a3222799d2 100644
--- a/crypto/ec/ecp_nistz256.c
+++ b/crypto/ec/ecp_nistz256.c
@@ -30,6 +30,7 @@
 #include "crypto/bn.h"
 #include "ec_local.h"
 #include "internal/refcount.h"
+#include <stdfil.h>
 
 #if BN_BITS2 != 64
 # define TOBN(hi,lo)    lo,hi
@@ -39,6 +40,7 @@
 
 #define ALIGNPTR(p,N)   ((unsigned char *)p+N-(size_t)p%N)
 #define P256_LIMBS      (256/BN_BITS2)
+#define P256_BYTES      (256/8)
 
 typedef unsigned short u16;
 
@@ -87,47 +89,120 @@ struct nistz256_pre_comp_st {
  * in all cases so far...
  */
 /* Modular add: res = a+b mod P   */
-void ecp_nistz256_add(BN_ULONG res[P256_LIMBS],
-                      const BN_ULONG a[P256_LIMBS],
-                      const BN_ULONG b[P256_LIMBS]);
+static void ecp_nistz256_add(BN_ULONG res[P256_LIMBS],
+                             const BN_ULONG a[P256_LIMBS],
+                             const BN_ULONG b[P256_LIMBS])
+{
+    zcheck(res, P256_BYTES);
+    zcheck_readonly(a, P256_BYTES);
+    zcheck_readonly(b, P256_BYTES);
+    zunsafe_fast_call("ecp_nistz256_add", res, a, b);
+}
 /* Modular mul by 2: res = 2*a mod P */
-void ecp_nistz256_mul_by_2(BN_ULONG res[P256_LIMBS],
-                           const BN_ULONG a[P256_LIMBS]);
+static void ecp_nistz256_mul_by_2(BN_ULONG res[P256_LIMBS],
+                                  const BN_ULONG a[P256_LIMBS])
+{
+    zcheck(res, P256_BYTES);
+    zcheck_readonly(a, P256_BYTES);
+    zunsafe_fast_call("ecp_nistz256_mul_by_2", res, a);
+}
 /* Modular mul by 3: res = 3*a mod P */
-void ecp_nistz256_mul_by_3(BN_ULONG res[P256_LIMBS],
-                           const BN_ULONG a[P256_LIMBS]);
+static void ecp_nistz256_mul_by_3(BN_ULONG res[P256_LIMBS],
+                                  const BN_ULONG a[P256_LIMBS])
+{
+    zcheck(res, P256_BYTES);
+    zcheck_readonly(a, P256_BYTES);
+    zunsafe_fast_call("ecp_nistz256_mul_by_3", res, a);
+}
 
 /* Modular div by 2: res = a/2 mod P */
-void ecp_nistz256_div_by_2(BN_ULONG res[P256_LIMBS],
-                           const BN_ULONG a[P256_LIMBS]);
+static void ecp_nistz256_div_by_2(BN_ULONG res[P256_LIMBS],
+                                  const BN_ULONG a[P256_LIMBS])
+{
+    zcheck(res, P256_BYTES);
+    zcheck_readonly(a, P256_BYTES);
+    zunsafe_fast_call("ecp_nistz256_div_by_2", res, a);
+}
 /* Modular sub: res = a-b mod P   */
-void ecp_nistz256_sub(BN_ULONG res[P256_LIMBS],
-                      const BN_ULONG a[P256_LIMBS],
-                      const BN_ULONG b[P256_LIMBS]);
+static void ecp_nistz256_sub(BN_ULONG res[P256_LIMBS],
+                             const BN_ULONG a[P256_LIMBS],
+                             const BN_ULONG b[P256_LIMBS])
+{
+    zcheck(res, P256_BYTES);
+    zcheck_readonly(a, P256_BYTES);
+    zcheck_readonly(b, P256_BYTES);
+    zunsafe_fast_call("ecp_nistz256_sub", res, a, b);
+}
 /* Modular neg: res = -a mod P    */
-void ecp_nistz256_neg(BN_ULONG res[P256_LIMBS], const BN_ULONG a[P256_LIMBS]);
+static void ecp_nistz256_neg(BN_ULONG res[P256_LIMBS], const BN_ULONG a[P256_LIMBS])
+{
+    zcheck(res, P256_BYTES);
+    zcheck_readonly(a, P256_BYTES);
+    zunsafe_fast_call("ecp_nistz256_neg", res, a);
+}
 /* Montgomery mul: res = a*b*2^-256 mod P */
-void ecp_nistz256_mul_mont(BN_ULONG res[P256_LIMBS],
-                           const BN_ULONG a[P256_LIMBS],
-                           const BN_ULONG b[P256_LIMBS]);
+static void ecp_nistz256_mul_mont(BN_ULONG res[P256_LIMBS],
+                                  const BN_ULONG a[P256_LIMBS],
+                                  const BN_ULONG b[P256_LIMBS])
+{
+    zcheck(res, P256_BYTES);
+    zcheck_readonly(a, P256_BYTES);
+    zcheck_readonly(b, P256_BYTES);
+    zunsafe_fast_call("ecp_nistz256_mul_mont", res, a, b);
+}
 /* Montgomery sqr: res = a*a*2^-256 mod P */
-void ecp_nistz256_sqr_mont(BN_ULONG res[P256_LIMBS],
-                           const BN_ULONG a[P256_LIMBS]);
+static void ecp_nistz256_sqr_mont(BN_ULONG res[P256_LIMBS],
+                                  const BN_ULONG a[P256_LIMBS])
+{
+    zcheck(res, P256_BYTES);
+    zcheck_readonly(a, P256_BYTES);
+    zunsafe_fast_call("ecp_nistz256_sqr_mont", res, a);
+}
 /* Convert a number from Montgomery domain, by multiplying with 1 */
-void ecp_nistz256_from_mont(BN_ULONG res[P256_LIMBS],
-                            const BN_ULONG in[P256_LIMBS]);
+static void ecp_nistz256_from_mont(BN_ULONG res[P256_LIMBS],
+                                   const BN_ULONG in[P256_LIMBS])
+{
+    zcheck(res, P256_BYTES);
+    zcheck_readonly(in, P256_BYTES);
+    zunsafe_fast_call("ecp_nistz256_from_mont", res, in);
+}
 /* Convert a number to Montgomery domain, by multiplying with 2^512 mod P*/
-void ecp_nistz256_to_mont(BN_ULONG res[P256_LIMBS],
-                          const BN_ULONG in[P256_LIMBS]);
+static void ecp_nistz256_to_mont(BN_ULONG res[P256_LIMBS],
+                                 const BN_ULONG in[P256_LIMBS])
+{
+    zcheck(res, P256_BYTES);
+    zcheck_readonly(in, P256_BYTES);
+    zunsafe_fast_call("ecp_nistz256_to_mont", res, in);
+}
 /* Functions that perform constant time access to the precomputed tables */
-void ecp_nistz256_scatter_w5(P256_POINT *val,
-                             const P256_POINT *in_t, int idx);
-void ecp_nistz256_gather_w5(P256_POINT *val,
-                            const P256_POINT *in_t, int idx);
-void ecp_nistz256_scatter_w7(P256_POINT_AFFINE *val,
-                             const P256_POINT_AFFINE *in_t, int idx);
-void ecp_nistz256_gather_w7(P256_POINT_AFFINE *val,
-                            const P256_POINT_AFFINE *in_t, int idx);
+static void ecp_nistz256_scatter_w5(P256_POINT *val,
+                                    const P256_POINT *in_t, int idx)
+{
+    zcheck_readonly(in_t, sizeof(P256_POINT));
+    zcheck(val + idx - 1, sizeof(P256_POINT));
+    zunsafe_fast_call("ecp_nistz256_scatter_w5", val, in_t, idx);
+}
+static void ecp_nistz256_gather_w5(P256_POINT *val,
+                                   const P256_POINT *in_t, int idx)
+{
+    zcheck_readonly(in_t, zchecked_mul(sizeof(P256_POINT), 16));
+    zcheck(val, sizeof(P256_POINT));
+    zunsafe_fast_call("ecp_nistz256_gather_w5", val, in_t, idx);
+}
+static void ecp_nistz256_scatter_w7(P256_POINT_AFFINE *val,
+                                    const P256_POINT_AFFINE *in_t, int idx)
+{
+    zcheck_readonly(in_t, sizeof(P256_POINT_AFFINE));
+    zcheck(val + idx, sizeof(P256_POINT_AFFINE));
+    zunsafe_fast_call("ecp_nistz256_scatter_w7", val, in_t, idx);
+}
+static void ecp_nistz256_gather_w7(P256_POINT_AFFINE *val,
+                                   const P256_POINT_AFFINE *in_t, int idx)
+{
+    zcheck_readonly(in_t, zchecked_mul(sizeof(P256_POINT_AFFINE), 64));
+    zcheck(val, sizeof(P256_POINT_AFFINE));
+    zunsafe_fast_call("ecp_nistz256_gather_w7", val, in_t, idx);
+}
 
 /* One converted into the Montgomery domain */
 static const BN_ULONG ONE[P256_LIMBS] = {
@@ -246,12 +321,29 @@ static BN_ULONG is_one(const BIGNUM *z)
  * ecp_nistz256 module is ECP_NISTZ256_ASM.)
  */
 #ifndef ECP_NISTZ256_REFERENCE_IMPLEMENTATION
-void ecp_nistz256_point_double(P256_POINT *r, const P256_POINT *a);
-void ecp_nistz256_point_add(P256_POINT *r,
-                            const P256_POINT *a, const P256_POINT *b);
-void ecp_nistz256_point_add_affine(P256_POINT *r,
-                                   const P256_POINT *a,
-                                   const P256_POINT_AFFINE *b);
+static void ecp_nistz256_point_double(P256_POINT *r, const P256_POINT *a)
+{
+    zcheck(r, sizeof(P256_POINT));
+    zcheck_readonly(a, sizeof(P256_POINT));
+    zunsafe_fast_call("ecp_nistz256_point_double", r, a);
+}
+static void ecp_nistz256_point_add(P256_POINT *r,
+                                   const P256_POINT *a, const P256_POINT *b)
+{
+    zcheck(r, sizeof(P256_POINT));
+    zcheck_readonly(a, sizeof(P256_POINT));
+    zcheck_readonly(b, sizeof(P256_POINT));
+    zunsafe_fast_call("ecp_nistz256_point_add", r, a, b);
+}
+static void ecp_nistz256_point_add_affine(P256_POINT *r,
+                                          const P256_POINT *a,
+                                          const P256_POINT_AFFINE *b)
+{
+    zcheck(r, sizeof(P256_POINT));
+    zcheck_readonly(a, sizeof(P256_POINT));
+    zcheck_readonly(b, sizeof(P256_POINT_AFFINE));
+    zunsafe_fast_call("ecp_nistz256_point_add_affine", r, a, b);
+}
 #else
 /* Point double: r = 2*a */
 static void ecp_nistz256_point_double(P256_POINT *r, const P256_POINT *a)
@@ -1269,12 +1361,23 @@ static int ecp_nistz256_window_have_precompute_mult(const EC_GROUP *group)
 /*
  * Montgomery mul modulo Order(P): res = a*b*2^-256 mod Order(P)
  */
-void ecp_nistz256_ord_mul_mont(BN_ULONG res[P256_LIMBS],
-                               const BN_ULONG a[P256_LIMBS],
-                               const BN_ULONG b[P256_LIMBS]);
-void ecp_nistz256_ord_sqr_mont(BN_ULONG res[P256_LIMBS],
-                               const BN_ULONG a[P256_LIMBS],
-                               BN_ULONG rep);
+static void ecp_nistz256_ord_mul_mont(BN_ULONG res[P256_LIMBS],
+                                      const BN_ULONG a[P256_LIMBS],
+                                      const BN_ULONG b[P256_LIMBS])
+{
+    zcheck(res, P256_BYTES);
+    zcheck_readonly(a, P256_BYTES);
+    zcheck_readonly(b, P256_BYTES);
+    zunsafe_fast_call("ecp_nistz256_ord_mul_mont", res, a, b);
+}
+static void ecp_nistz256_ord_sqr_mont(BN_ULONG res[P256_LIMBS],
+                                      const BN_ULONG a[P256_LIMBS],
+                                      BN_ULONG rep)
+{
+    zcheck(res, P256_BYTES);
+    zcheck_readonly(a, P256_BYTES);
+    zunsafe_fast_call("ecp_nistz256_ord_sqr_mont", res, a, rep);
+}
 
 static int ecp_nistz256_inv_mod_ord(const EC_GROUP *group, BIGNUM *r,
                                     const BIGNUM *x, BN_CTX *ctx)
diff --git a/crypto/ec/ecp_nistz256_table.c b/crypto/ec/ecp_nistz256_table.c
index 71430d4b8142..0351fe68ceef 100644
--- a/crypto/ec/ecp_nistz256_table.c
+++ b/crypto/ec/ecp_nistz256_table.c
@@ -21,16 +21,16 @@
  * appears to lead to invalid ELF files being produced.
  */
 
+#define TOBN(hi,lo) (((unsigned long)hi<<32)|(unsigned long)lo)
+
 #if defined(__GNUC__)
-__attribute((aligned(4096)))
+__attribute__((aligned(4096)))
 #elif defined(_MSC_VER)
 __declspec(align(4096))
 #elif defined(__SUNPRO_C)
 # pragma align 4096(ecp_nistz256_precomputed)
 #endif
-static const BN_ULONG ecp_nistz256_precomputed[37][64 *
-                                                   sizeof(P256_POINT_AFFINE) /
-                                                   sizeof(BN_ULONG)] = {
+const unsigned long ecp_nistz256_precomputed[37][64 * 8] = {
     {TOBN(0x79e730d4, 0x18a9143c), TOBN(0x75ba95fc, 0x5fedb601),
      TOBN(0x79fb732b, 0x77622510), TOBN(0x18905f76, 0xa53755c6),
      TOBN(0xddf25357, 0xce95560a), TOBN(0x8b4ab8e4, 0xba19e45c),
diff --git a/crypto/evp/e_aes_cbc_hmac_sha1.c b/crypto/evp/e_aes_cbc_hmac_sha1.c
index 8843c8ae119f..f0eb6580bba0 100644
--- a/crypto/evp/e_aes_cbc_hmac_sha1.c
+++ b/crypto/evp/e_aes_cbc_hmac_sha1.c
@@ -27,6 +27,7 @@
 #include "crypto/evp.h"
 #include "internal/constant_time.h"
 #include "evp_local.h"
+#include <stdfil.h>
 
 typedef struct {
     AES_KEY ks;
@@ -99,7 +100,12 @@ static int aesni_cbc_hmac_sha1_init_key(EVP_CIPHER_CTX *ctx,
 #  define aes_off 0
 # endif
 
-void sha1_block_data_order(void *c, const void *p, size_t len);
+void sha1_block_data_order(void *c, const void *p, size_t len)
+{
+    zcheck(c, sizeof(SHA_CTX));
+    zcheck_readonly(p, zchecked_mul(len, SHA_CBLOCK));
+    zunsafe_buf_call(zchecked_mul(len, SHA_CBLOCK), "sha1_block_data_order", c, p, len);
+}
 
 static void sha1_update(SHA_CTX *c, const void *data, size_t len)
 {
@@ -147,7 +153,20 @@ typedef struct {
     int blocks;
 } HASH_DESC;
 
-void sha1_multi_block(SHA1_MB_CTX *, const HASH_DESC *, int);
+void sha1_multi_block(SHA1_MB_CTX *ctx, const HASH_DESC *inp, int n4x)
+{
+    zcheck(ctx, sizeof(SHA1_MB_CTX));
+    ZSAFETY_CHECK(n4x == 1 || n4x == 2);
+    unsigned len = n4x * 4;
+    zcheck_readonly(inp, zchecked_mul(len, sizeof(HASH_DESC)));
+    unsigned i;
+    unsigned total = 0;
+    for (i = len; i--;) {
+        zcheck_readonly(inp[i].ptr, zchecked_mul(inp[i].blocks, 64));
+        total += zchecked_mul(inp[i].blocks, 64);
+    }
+    zunsafe_buf_call(total, "sha1_multi_block", ctx, inp, n4x);
+}
 
 typedef struct {
     const unsigned char *inp;
diff --git a/crypto/evp/e_aes_cbc_hmac_sha256.c b/crypto/evp/e_aes_cbc_hmac_sha256.c
index 3a5f757dbff3..a7727851db66 100644
--- a/crypto/evp/e_aes_cbc_hmac_sha256.c
+++ b/crypto/evp/e_aes_cbc_hmac_sha256.c
@@ -27,6 +27,7 @@
 #include "internal/constant_time.h"
 #include "crypto/evp.h"
 #include "evp_local.h"
+#include <stdfil.h>
 
 typedef struct {
     AES_KEY ks;
@@ -141,7 +142,20 @@ typedef struct {
     int blocks;
 } HASH_DESC;
 
-void sha256_multi_block(SHA256_MB_CTX *, const HASH_DESC *, int);
+void sha256_multi_block(SHA256_MB_CTX *ctx, const HASH_DESC *inp, int n4x)
+{
+    zcheck(ctx, sizeof(SHA256_MB_CTX));
+    ZSAFETY_CHECK(n4x == 1 || n4x == 2);
+    unsigned len = n4x * 4;
+    zcheck_readonly(inp, zchecked_mul(len, sizeof(HASH_DESC)));
+    unsigned i;
+    unsigned total = 0;
+    for (i = len; i--;) {
+        zcheck_readonly(inp[i].ptr, zchecked_mul(inp[i].blocks, 64));
+        total += zchecked_mul(inp[i].blocks, 64);
+    }
+    zunsafe_buf_call(total, "sha256_multi_block", ctx, inp, n4x);
+}
 
 typedef struct {
     const unsigned char *inp;
diff --git a/crypto/evp/e_chacha20_poly1305.c b/crypto/evp/e_chacha20_poly1305.c
index 731c1a1dc70c..de6324902469 100644
--- a/crypto/evp/e_chacha20_poly1305.c
+++ b/crypto/evp/e_chacha20_poly1305.c
@@ -18,6 +18,7 @@
 # include "crypto/evp.h"
 # include "evp_local.h"
 # include "crypto/chacha.h"
+# include <stdfil.h>
 
 typedef struct {
     union {
@@ -204,8 +205,20 @@ static int chacha20_poly1305_init_key(EVP_CIPHER_CTX *ctx,
 #   if defined(POLY1305_ASM) && (defined(__x86_64) || defined(__x86_64__) || \
                                  defined(_M_AMD64) || defined(_M_X64))
 #    define XOR128_HELPERS
-void *xor128_encrypt_n_pad(void *out, const void *inp, void *otp, size_t len);
-void *xor128_decrypt_n_pad(void *out, const void *inp, void *otp, size_t len);
+void *xor128_encrypt_n_pad(void *out, const void *inp, void *otp, size_t len)
+{
+    zcheck(out, len);
+    zcheck_readonly(inp, len);
+    zcheck(otp, (len + 15) & -16);
+    return zmkptr(otp, zunsafe_buf_call(len, "xor128_encrypt_n_pad", out, inp, otp, len));
+}
+void *xor128_decrypt_n_pad(void *out, const void *inp, void *otp, size_t len)
+{
+    zcheck(out, len);
+    zcheck_readonly(inp, len);
+    zcheck(otp, (len + 15) & -16);
+    return zmkptr(otp, zunsafe_buf_call(len, "xor128_decrypt_n_pad", out, inp, otp, len));
+}
 static const unsigned char zero[4 * CHACHA_BLK_SIZE] = { 0 };
 #   else
 static const unsigned char zero[2 * CHACHA_BLK_SIZE] = { 0 };
diff --git a/crypto/md5/md5_dgst.c b/crypto/md5/md5_dgst.c
index 913b1ea5cad6..f0c41741417d 100644
--- a/crypto/md5/md5_dgst.c
+++ b/crypto/md5/md5_dgst.c
@@ -16,6 +16,7 @@
 #include <stdio.h>
 #include "md5_local.h"
 #include <openssl/opensslv.h>
+#include <stdfil.h>
 
 /*
  * Implemented from RFC1321 The MD5 Message-Digest Algorithm
@@ -167,4 +168,11 @@ void md5_block_data_order(MD5_CTX *c, const void *data_, size_t num)
         D = c->D += D;
     }
 }
+#else
+void md5_block_data_order(MD5_CTX *c, const void *data_, size_t num)
+{
+    zcheck(c, sizeof(MD5_CTX));
+    zcheck_readonly(data_, zchecked_mul(num, MD5_CBLOCK));
+    zunsafe_buf_call(num, "ossl_md5_block_asm_data_order", c, data_, num);
+}
 #endif
diff --git a/crypto/mem_sec.c b/crypto/mem_sec.c
index 269c7dcb6d41..a9ad53f854b1 100644
--- a/crypto/mem_sec.c
+++ b/crypto/mem_sec.c
@@ -87,6 +87,8 @@ VirtualLock(
 # define MAP_ANON MAP_ANONYMOUS
 #endif
 
+#include <stdfil.h>
+
 #ifndef OPENSSL_NO_SECURE_MEMORY
 static size_t secure_mem_used;
 
@@ -107,6 +109,7 @@ static int sh_allocated(const char *ptr);
 
 int CRYPTO_secure_malloc_init(size_t size, size_t minsize)
 {
+    zerror("Cannot do secure malloc in Fil-C");
 #ifndef OPENSSL_NO_SECURE_MEMORY
     int ret = 0;
 
diff --git a/crypto/modes/aesni_gcm_asm_forward.c b/crypto/modes/aesni_gcm_asm_forward.c
new file mode 100644
index 000000000000..80f280fe6e9a
--- /dev/null
+++ b/crypto/modes/aesni_gcm_asm_forward.c
@@ -0,0 +1,34 @@
+#include "internal/deprecated.h"
+
+#include <assert.h>
+
+#include <stdlib.h>
+#include <openssl/crypto.h>
+#include <openssl/aes.h>
+#include "crypto/modes.h"
+#include "crypto/aes_platform.h"
+#include <stdfil.h>
+#include <stddef.h>
+
+size_t aesni_gcm_encrypt(const unsigned char *in, unsigned char *out, size_t len,
+                         const void *key, unsigned char ivec[16], u64 *Xi)
+{
+    zcheck_readonly(in, len);
+    zcheck(out, len);
+    zcheck_readonly(key, sizeof(AES_KEY));
+    zcheck(ivec, 16);
+    zcheck(Xi, sizeof(GCM128_CONTEXT) - offsetof(GCM128_CONTEXT, Xi));
+    return zunsafe_buf_call(len, "aesni_gcm_encrypt", in, out, len, key, ivec, Xi);
+}
+
+size_t aesni_gcm_decrypt(const unsigned char *in, unsigned char *out, size_t len,
+                         const void *key, unsigned char ivec[16], u64 *Xi)
+{
+    zcheck_readonly(in, len);
+    zcheck(out, len);
+    zcheck_readonly(key, sizeof(AES_KEY));
+    zcheck(ivec, 16);
+    zcheck(Xi, sizeof(GCM128_CONTEXT) - offsetof(GCM128_CONTEXT, Xi));
+    return zunsafe_buf_call(len, "aesni_gcm_decrypt", in, out, len, key, ivec, Xi);
+}
+
diff --git a/crypto/modes/build.info b/crypto/modes/build.info
index 52d2df19c6d9..a9de2a547d02 100644
--- a/crypto/modes/build.info
+++ b/crypto/modes/build.info
@@ -4,7 +4,7 @@ $MODESASM=
 IF[{- !$disabled{asm} -}]
   $MODESASM_x86=ghash-x86.S
   $MODESDEF_x86=GHASH_ASM
-  $MODESASM_x86_64=ghash-x86_64.s aesni-gcm-x86_64.s aes-gcm-avx512.s
+  $MODESASM_x86_64=ghash-x86_64.s aesni_gcm_asm_forward.c aesni-gcm-x86_64.s aes-gcm-avx512.s
   $MODESDEF_x86_64=GHASH_ASM
 
   # ghash-ia64.s doesn't work on VMS
diff --git a/crypto/modes/gcm128.c b/crypto/modes/gcm128.c
index f8901ed07c53..1a64b1bb8f68 100644
--- a/crypto/modes/gcm128.c
+++ b/crypto/modes/gcm128.c
@@ -12,6 +12,7 @@
 #include "internal/cryptlib.h"
 #include "internal/endian.h"
 #include "crypto/modes.h"
+#include <stdfil.h>
 
 #if defined(__GNUC__) && !defined(STRICT_ALIGNMENT)
 typedef size_t size_t_aX __attribute((__aligned__(1)));
@@ -320,9 +321,21 @@ static void gcm_ghash_4bit(u64 Xi[2], const u128 Htable[16],
 }
 #  endif
 # else
-void gcm_gmult_4bit(u64 Xi[2], const u128 Htable[16]);
-void gcm_ghash_4bit(u64 Xi[2], const u128 Htable[16], const u8 *inp,
-                    size_t len);
+static void gcm_gmult_4bit(u64 Xi[2], const u128 Htable[16])
+{
+    zcheck(Xi, sizeof(u64) * 2);
+    zcheck_readonly(Htable, sizeof(u128) * 16);
+    zunsafe_fast_call("gcm_gmult_4bit", Xi, Htable);
+}
+
+static void gcm_ghash_4bit(u64 Xi[2], const u128 Htable[16], const u8 *inp,
+                           size_t len)
+{
+    zcheck(Xi, sizeof(u64) * 2);
+    zcheck_readonly(Htable, sizeof(u128) * 16);
+    zcheck_readonly(inp, len);
+    zunsafe_buf_call(len, "gcm_ghash_4bit", Xi, Htable, inp, len);
+}
 # endif
 
 # define GCM_MUL(ctx)      ctx->funcs.gmult(ctx->Xi.u,ctx->Htable)
@@ -343,20 +356,56 @@ void gcm_ghash_4bit(u64 Xi[2], const u128 Htable[16], const u8 *inp,
          defined(_M_IX86)       || defined(_M_AMD64)    || defined(_M_X64))
 #  define GHASH_ASM_X86_OR_64
 
-void gcm_init_clmul(u128 Htable[16], const u64 Xi[2]);
-void gcm_gmult_clmul(u64 Xi[2], const u128 Htable[16]);
-void gcm_ghash_clmul(u64 Xi[2], const u128 Htable[16], const u8 *inp,
-                     size_t len);
+static void gcm_init_clmul(u128 Htable[16], const u64 Xi[2])
+{
+    zcheck(Htable, sizeof(u128) * 16);
+    zcheck_readonly(Xi, sizeof(u64) * 2);
+    zunsafe_fast_call("gcm_init_clmul", Htable, Xi);
+}
+
+static void gcm_gmult_clmul(u64 Xi[2], const u128 Htable[16])
+{
+    zcheck(Xi, sizeof(u64) * 2);
+    zcheck_readonly(Htable, sizeof(u128) * 16);
+    zunsafe_fast_call("gcm_gmult_clmul", Xi, Htable);
+}
+
+static void gcm_ghash_clmul(u64 Xi[2], const u128 Htable[16], const u8 *inp,
+                            size_t len)
+{
+    zcheck(Xi, sizeof(u64) * 2);
+    zcheck_readonly(Htable, sizeof(u128) * 16);
+    zcheck_readonly(inp, len);
+    zunsafe_buf_call(len, "gcm_ghash_clmul", Xi, Htable, inp, len);
+}
 
 #  if defined(__i386) || defined(__i386__) || defined(_M_IX86)
 #   define gcm_init_avx   gcm_init_clmul
 #   define gcm_gmult_avx  gcm_gmult_clmul
 #   define gcm_ghash_avx  gcm_ghash_clmul
 #  else
-void gcm_init_avx(u128 Htable[16], const u64 Xi[2]);
-void gcm_gmult_avx(u64 Xi[2], const u128 Htable[16]);
+static void gcm_init_avx(u128 Htable[16], const u64 Xi[2])
+{
+    zcheck(Htable, sizeof(u128) * 16);
+    zcheck_readonly(Xi, sizeof(u64) * 2);
+    zunsafe_fast_call("gcm_init_avx", Htable, Xi);
+}
+
+static void gcm_gmult_avx(u64 Xi[2], const u128 Htable[16])
+{
+    zcheck(Xi, sizeof(u64) * 2);
+    zcheck_readonly(Htable, sizeof(u128) * 16);
+    zunsafe_fast_call("gcm_gmult_avx", Xi, Htable);
+}
+
 void gcm_ghash_avx(u64 Xi[2], const u128 Htable[16], const u8 *inp,
-                   size_t len);
+                          size_t len)
+{
+    zcheck(Xi, sizeof(u64) * 2);
+    zcheck_readonly(Htable, sizeof(u128) * 16);
+    zcheck_readonly(inp, len);
+    zunsafe_buf_call(len, "gcm_ghash_avx", Xi, Htable, inp, len);
+}
 #  endif
 
 #  if   defined(__i386) || defined(__i386__) || defined(_M_IX86)
diff --git a/crypto/poly1305/asm/poly1305-x86_64.pl b/crypto/poly1305/asm/poly1305-x86_64.pl
index 4cddca1c514c..696af7c1c08e 100755
--- a/crypto/poly1305/asm/poly1305-x86_64.pl
+++ b/crypto/poly1305/asm/poly1305-x86_64.pl
@@ -95,6 +95,11 @@ if (!$avx && `$ENV{CC} -v 2>&1` =~ /((?:clang|LLVM) version|.*based on LLVM) ([0
 	$avx = ($2>=3.0) + ($2>3.0);
 }
 
+# FIXME: We should re-enable the avx codepaths. They are disabled because this code makes it
+# necessary for user code to make indirect function calls into yololand, which Fil-C currently
+# doesn't support.
+$avx = 0;
+
 open OUT,"| \"$^X\" \"$xlate\" $flavour \"$output\""
     or die "can't call $xlate: $!";
 *STDOUT=*OUT;
diff --git a/crypto/poly1305/poly1305.c b/crypto/poly1305/poly1305.c
index b3bf2b117bbf..200cf73b4a6a 100644
--- a/crypto/poly1305/poly1305.c
+++ b/crypto/poly1305/poly1305.c
@@ -12,6 +12,7 @@
 #include <openssl/crypto.h>
 
 #include "crypto/poly1305.h"
+#include <stdfil.h>
 
 size_t Poly1305_ctx_size(void)
 {
@@ -423,11 +424,28 @@ static void poly1305_emit(void *ctx, unsigned char mac[16],
 }
 # endif
 #else
-int poly1305_init(void *ctx, const unsigned char key[16], void *func);
-void poly1305_blocks(void *ctx, const unsigned char *inp, size_t len,
-                     unsigned int padbit);
-void poly1305_emit(void *ctx, unsigned char mac[16],
-                   const unsigned int nonce[4]);
+static int poly1305_init(void *ctx, const unsigned char key[16], void *func)
+{
+    zcheck(ctx, sizeof(poly1305_opaque));
+    zcheck_readonly(key, 16);
+    zcheck(func, sizeof(void*) * 2);
+    return zunsafe_fast_call("poly1305_init", ctx, key, func);
+}
+static void poly1305_blocks(void *ctx, const unsigned char *inp, size_t len,
+                            unsigned int padbit)
+{
+    zcheck(ctx, sizeof(poly1305_opaque));
+    zcheck_readonly(inp, len);
+    zunsafe_buf_call(len, "poly1305_blocks", ctx, inp, len, padbit);
+}
+static void poly1305_emit(void *ctx, unsigned char mac[16],
+                          const unsigned int nonce[4])
+{
+    zcheck(ctx, sizeof(poly1305_opaque));
+    zcheck(mac, 16);
+    zcheck_readonly(nonce, sizeof(unsigned) * 4);
+    zunsafe_fast_call("poly1305_emit", ctx, mac, nonce);
+}
 #endif
 
 void Poly1305_Init(POLY1305 *ctx, const unsigned char key[32])
@@ -456,26 +474,8 @@ void Poly1305_Init(POLY1305 *ctx, const unsigned char key[32])
 
 }
 
-#ifdef POLY1305_ASM
-/*
- * This "eclipses" poly1305_blocks and poly1305_emit, but it's
- * conscious choice imposed by -Wshadow compiler warnings.
- */
-# define poly1305_blocks (*poly1305_blocks_p)
-# define poly1305_emit   (*poly1305_emit_p)
-#endif
-
 void Poly1305_Update(POLY1305 *ctx, const unsigned char *inp, size_t len)
 {
-#ifdef POLY1305_ASM
-    /*
-     * As documented, poly1305_blocks is never called with input
-     * longer than single block and padbit argument set to 0. This
-     * property is fluently used in assembly modules to optimize
-     * padbit handling on loop boundary.
-     */
-    poly1305_blocks_f poly1305_blocks_p = ctx->func.blocks;
-#endif
     size_t rem, num;
 
     if ((num = ctx->num)) {
@@ -509,10 +509,6 @@ void Poly1305_Update(POLY1305 *ctx, const unsigned char *inp, size_t len)
 
 void Poly1305_Final(POLY1305 *ctx, unsigned char mac[16])
 {
-#ifdef POLY1305_ASM
-    poly1305_blocks_f poly1305_blocks_p = ctx->func.blocks;
-    poly1305_emit_f poly1305_emit_p = ctx->func.emit;
-#endif
     size_t num;
 
     if ((num = ctx->num)) {
diff --git a/crypto/rc4/build.info b/crypto/rc4/build.info
index c9c81f87dabf..5a245e100337 100644
--- a/crypto/rc4/build.info
+++ b/crypto/rc4/build.info
@@ -3,7 +3,7 @@ LIBS=../../libcrypto
 $RC4ASM=rc4_enc.c rc4_skey.c
 IF[{- !$disabled{asm} -}]
   $RC4ASM_x86=rc4-586.S
-  $RC4ASM_x86_64=rc4-x86_64.s rc4-md5-x86_64.s
+  $RC4ASM_x86_64=rc4-x86_64.s rc4_md5_asm_forward.c rc4-md5-x86_64.s
   $RC4ASM_s390x=rc4-s390x.s
   $RC4ASM_parisc11=rc4-parisc.s
   $RC4ASM_parisc20_64=$RC4ASM_parisc11
@@ -12,7 +12,7 @@ IF[{- !$disabled{asm} -}]
   # Now that we have defined all the arch specific variables, use the
   # appropriate one, and define the appropriate macros
   IF[$RC4ASM_{- $target{asm_arch} -}]
-    $RC4ASM=$RC4ASM_{- $target{asm_arch} -}
+    $RC4ASM=rc4_asm_forward.c $RC4ASM_{- $target{asm_arch} -}
     $RC4DEF=RC4_ASM
   ENDIF
 ENDIF
diff --git a/crypto/rc4/rc4_asm_forward.c b/crypto/rc4/rc4_asm_forward.c
new file mode 100644
index 000000000000..11b07a84d397
--- /dev/null
+++ b/crypto/rc4/rc4_asm_forward.c
@@ -0,0 +1,22 @@
+#include "internal/deprecated.h"
+
+#include <openssl/rc4.h>
+#include "rc4_local.h"
+#include <openssl/opensslv.h>
+#include <stdfil.h>
+
+void RC4_set_key(RC4_KEY *key, int len, const unsigned char *data)
+{
+    zcheck(key, sizeof(RC4_KEY));
+    zcheck_readonly(data, len);
+    zunsafe_buf_call(len, "RC4_set_key", key, len, data);
+}
+
+void RC4(RC4_KEY *key, size_t len, const unsigned char *indata,
+         unsigned char *outdata)
+{
+    zcheck(key, sizeof(RC4_KEY));
+    zcheck_readonly(indata, len);
+    zcheck(outdata, len);
+    zunsafe_buf_call(len, "RC4", key, len, indata, outdata);
+}
diff --git a/crypto/rc4/rc4_md5_asm_forward.c b/crypto/rc4/rc4_md5_asm_forward.c
new file mode 100644
index 000000000000..e7a9b0ca9ae4
--- /dev/null
+++ b/crypto/rc4/rc4_md5_asm_forward.c
@@ -0,0 +1,19 @@
+#include "internal/deprecated.h"
+
+#include <openssl/rc4.h>
+#include <openssl/md5.h>
+#include "rc4_local.h"
+#include <openssl/opensslv.h>
+#include <stdfil.h>
+
+void rc4_md5_enc(RC4_KEY *key, const void *in0, void *out,
+                 MD5_CTX *ctx, const void *inp, size_t blocks)
+{
+    zcheck(key, sizeof(RC4_KEY));
+    zcheck(ctx, sizeof(MD5_CTX));
+    zcheck_readonly(in0, zchecked_mul(blocks, MD5_CBLOCK));
+    zcheck(out, zchecked_mul(blocks, MD5_CBLOCK));
+    zcheck_readonly(inp, zchecked_mul(blocks, MD5_CBLOCK));
+    zunsafe_call("rc4_md5_enc", key, in0, out, ctx, inp, blocks);
+}
+
diff --git a/crypto/sha/build.info b/crypto/sha/build.info
index 9a3d44f6eaa4..0051d64682ba 100644
--- a/crypto/sha/build.info
+++ b/crypto/sha/build.info
@@ -72,7 +72,7 @@ IF[{- !$disabled{asm} -}]
   # Now that we have defined all the arch specific variables, use the
   # appropriate one, and define the appropriate macros
   IF[$KECCAK1600ASM_{- $target{asm_arch} -}]
-    $KECCAK1600ASM=$KECCAK1600ASM_{- $target{asm_arch} -}
+    $KECCAK1600ASM=keccak1600_asm_forward.c $KECCAK1600ASM_{- $target{asm_arch} -}
     $KECCAK1600DEF=KECCAK1600_ASM
   ENDIF
 ENDIF
diff --git a/crypto/sha/keccak1600_asm_forward.c b/crypto/sha/keccak1600_asm_forward.c
new file mode 100644
index 000000000000..03a2837a40c8
--- /dev/null
+++ b/crypto/sha/keccak1600_asm_forward.c
@@ -0,0 +1,25 @@
+#include <openssl/e_os2.h>
+#include <string.h>
+#include <assert.h>
+#include <stdfil.h>
+
+size_t SHA3_absorb(uint64_t A[5][5], const unsigned char *inp, size_t len,
+                   size_t r)
+{
+    ZSAFETY_CHECK(r < (25 * sizeof(A[0][0])));
+    ZSAFETY_CHECK((r % 8) == 0);
+    zcheck(A, 25 * sizeof(A[0][0]));
+    zcheck_readonly(inp, len);
+    return zunsafe_buf_call(len, "SHA3_absorb", A, inp, len, r);
+}
+
+void SHA3_squeeze(uint64_t A[5][5], unsigned char *out, size_t len, size_t r, int next)
+{
+    ZSAFETY_CHECK(r < (25 * sizeof(A[0][0])));
+    ZSAFETY_CHECK((r % 8) == 0);
+    zcheck(A, 25 * sizeof(A[0][0]));
+    zcheck(out, len);
+    zunsafe_buf_call(len, "SHA3_squeeze", A, out, len, r, next);
+}
+
+
diff --git a/crypto/sha/sha256.c b/crypto/sha/sha256.c
index 6ef218e86e3d..66776e6bfbf1 100644
--- a/crypto/sha/sha256.c
+++ b/crypto/sha/sha256.c
@@ -23,6 +23,7 @@
 #include <openssl/opensslv.h>
 #include "internal/endian.h"
 #include "crypto/sha.h"
+#include <stdfil.h>
 
 int SHA224_Init(SHA256_CTX *c)
 {
@@ -123,6 +124,15 @@ void sha256_block_data_order_c(SHA256_CTX *ctx, const void *in, size_t num);
 #endif /* SHA256_ASM */
 void sha256_block_data_order(SHA256_CTX *ctx, const void *in, size_t num);
 
+#ifdef SHA256_ASM
+void sha256_block_data_order(SHA256_CTX *ctx, const void *in, size_t num)
+{
+    zcheck(ctx, sizeof(SHA256_CTX));
+    zcheck_readonly(in, zchecked_mul(num, SHA256_CBLOCK));
+    zunsafe_buf_call(zchecked_mul(num, SHA256_CBLOCK), "sha256_block_data_order", ctx, in, num);
+}
+#endif
+
 #include "crypto/md32_common.h"
 
 #if !defined(SHA256_ASM) || defined(INCLUDE_C_SHA256)
diff --git a/crypto/sha/sha512.c b/crypto/sha/sha512.c
index bc547d7cdc26..2fffef10cd0e 100644
--- a/crypto/sha/sha512.c
+++ b/crypto/sha/sha512.c
@@ -58,6 +58,7 @@
 
 #include "internal/cryptlib.h"
 #include "crypto/sha.h"
+#include <stdfil.h>
 
 #if defined(__i386) || defined(__i386__) || defined(_M_IX86) || \
     defined(__x86_64) || defined(_M_AMD64) || defined(_M_X64) || \
@@ -156,6 +157,15 @@ void sha512_block_data_order_c(SHA512_CTX *ctx, const void *in, size_t num);
 #endif
 void sha512_block_data_order(SHA512_CTX *ctx, const void *in, size_t num);
 
+#ifdef SHA512_ASM
+void sha512_block_data_order(SHA512_CTX *ctx, const void *in, size_t num)
+{
+    zcheck(ctx, sizeof(SHA512_CTX));
+    zcheck_readonly(in, zchecked_mul(num, SHA512_CBLOCK));
+    zunsafe_buf_call(zchecked_mul(num, SHA512_CBLOCK), "sha512_block_data_order", ctx, in, num);
+}
+#endif
+
 int SHA512_Final(unsigned char *md, SHA512_CTX *c)
 {
     unsigned char *p = (unsigned char *)c->u.p;
diff --git a/crypto/whrlpool/build.info b/crypto/whrlpool/build.info
index c7dbecb4fd79..8eb4320bdf8d 100644
--- a/crypto/whrlpool/build.info
+++ b/crypto/whrlpool/build.info
@@ -6,7 +6,7 @@ IF[{- !$disabled{asm} -}]
     $WPASM_x86=wp_block.c wp-mmx.S
     $WPDEF_x86=WHIRLPOOL_ASM
   ENDIF
-  $WPASM_x86_64=wp-x86_64.s
+  $WPASM_x86_64=wp_asm_forward.c wp-x86_64.s
   $WPDEF_x86_64=WHIRLPOOL_ASM
 
   # Now that we have defined all the arch specific variables, use the
diff --git a/crypto/whrlpool/wp_asm_forward.c b/crypto/whrlpool/wp_asm_forward.c
new file mode 100644
index 000000000000..d319b2ac4de9
--- /dev/null
+++ b/crypto/whrlpool/wp_asm_forward.c
@@ -0,0 +1,14 @@
+#include "internal/deprecated.h"
+
+#include "internal/cryptlib.h"
+#include "wp_local.h"
+#include <string.h>
+
+#include <stdfil.h>
+
+void whirlpool_block(WHIRLPOOL_CTX *ctx, const void *inp, size_t n)
+{
+    zcheck(ctx, sizeof(WHIRLPOOL_CTX));
+    zcheck_readonly(inp, zchecked_mul(n, WHIRLPOOL_BBLOCK / 8));
+    zunsafe_buf_call(zchecked_mul(n, WHIRLPOOL_BBLOCK / 8), "whirlpool_block", ctx, inp, n);
+}
diff --git a/crypto/x86_64cpuid.pl b/crypto/x86_64cpuid.pl
index 53685ec26390..f03071fabf35 100644
--- a/crypto/x86_64cpuid.pl
+++ b/crypto/x86_64cpuid.pl
@@ -27,14 +27,6 @@ open OUT,"| \"$^X\" \"$xlate\" $flavour \"$output\""
 				 ("%rdi","%rsi","%rdx","%rcx");	# Unix order
 
 print<<___;
-.extern		OPENSSL_cpuid_setup
-.hidden		OPENSSL_cpuid_setup
-.section	.init
-	call	OPENSSL_cpuid_setup
-
-.hidden	OPENSSL_ia32cap_P
-.comm	OPENSSL_ia32cap_P,16,4
-
 .text
 
 .globl	OPENSSL_atomic_add
@@ -237,44 +229,6 @@ OPENSSL_ia32_cpuid:
 .cfi_endproc
 .size	OPENSSL_ia32_cpuid,.-OPENSSL_ia32_cpuid
 
-.globl  OPENSSL_cleanse
-.type   OPENSSL_cleanse,\@abi-omnipotent
-.align  16
-OPENSSL_cleanse:
-.cfi_startproc
-	endbranch
-	xor	%rax,%rax
-	cmp	\$15,$arg2
-	jae	.Lot
-	cmp	\$0,$arg2
-	je	.Lret
-.Little:
-	mov	%al,($arg1)
-	sub	\$1,$arg2
-	lea	1($arg1),$arg1
-	jnz	.Little
-.Lret:
-	ret
-.align	16
-.Lot:
-	test	\$7,$arg1
-	jz	.Laligned
-	mov	%al,($arg1)
-	lea	-1($arg2),$arg2
-	lea	1($arg1),$arg1
-	jmp	.Lot
-.Laligned:
-	mov	%rax,($arg1)
-	lea	-8($arg2),$arg2
-	test	\$-8,$arg2
-	lea	8($arg1),$arg1
-	jnz	.Laligned
-	cmp	\$0,$arg2
-	jne	.Little
-	ret
-.cfi_endproc
-.size	OPENSSL_cleanse,.-OPENSSL_cleanse
-
 .globl  CRYPTO_memcmp
 .type   CRYPTO_memcmp,\@abi-omnipotent
 .align  16
diff --git a/engines/e_padlock.c b/engines/e_padlock.c
index 7e0cfc21fc9b..e2a0aea74110 100644
--- a/engines/e_padlock.c
+++ b/engines/e_padlock.c
@@ -24,6 +24,7 @@
 #include <openssl/rand.h>
 #include <openssl/err.h>
 #include <openssl/modes.h>
+#include <stdfil.h>
 
 #ifndef OPENSSL_NO_PADLOCKENG
 
@@ -214,27 +215,83 @@ struct padlock_cipher_data {
 };
 
 /* Interface to assembler module */
-unsigned int padlock_capability(void);
-void padlock_key_bswap(AES_KEY *key);
-void padlock_verify_context(struct padlock_cipher_data *ctx);
-void padlock_reload_key(void);
-void padlock_aes_block(void *out, const void *inp,
-                       struct padlock_cipher_data *ctx);
-int padlock_ecb_encrypt(void *out, const void *inp,
-                        struct padlock_cipher_data *ctx, size_t len);
-int padlock_cbc_encrypt(void *out, const void *inp,
-                        struct padlock_cipher_data *ctx, size_t len);
-int padlock_cfb_encrypt(void *out, const void *inp,
-                        struct padlock_cipher_data *ctx, size_t len);
-int padlock_ofb_encrypt(void *out, const void *inp,
-                        struct padlock_cipher_data *ctx, size_t len);
-int padlock_ctr32_encrypt(void *out, const void *inp,
-                          struct padlock_cipher_data *ctx, size_t len);
-int padlock_xstore(void *out, int edx);
-void padlock_sha1_oneshot(void *ctx, const void *inp, size_t len);
-void padlock_sha1(void *ctx, const void *inp, size_t len);
-void padlock_sha256_oneshot(void *ctx, const void *inp, size_t len);
-void padlock_sha256(void *ctx, const void *inp, size_t len);
+static unsigned int padlock_capability(void)
+{
+    return zunsafe_fast_call("padlock_capability");
+}
+
+static void padlock_key_bswap(AES_KEY *key)
+{
+    zcheck(key, sizeof(AES_KEY));
+    zunsafe_fast_call("padlock_key_bswap", key);
+}
+
+static void padlock_reload_key(void)
+{
+    zunsafe_fast_call("padlock_reload_key");
+}
+
+static void padlock_aes_block(void *out, const void *inp,
+                              struct padlock_cipher_data *ctx)
+{
+    zcheck(out, AES_BLOCK_SIZE);
+    zcheck_readonly(inp, AES_BLOCK_SIZE);
+    zcheck(ctx, sizeof(struct padlock_cipher_data));
+    zunsafe_fast_call("padlock_aes_block", out, inp, ctx);
+}
+
+static int padlock_ecb_encrypt(void *out, const void *inp,
+                               struct padlock_cipher_data *ctx, size_t len)
+{
+    zcheck(out, len);
+    zcheck_readonly(inp, len);
+    zcheck(ctx, sizeof(struct padlock_cipher_data));
+    return zunsafe_buf_call(len, "padlock_ecb_encrypt", out, inp, ctx, len);
+}
+
+static int padlock_cbc_encrypt(void *out, const void *inp,
+                               struct padlock_cipher_data *ctx, size_t len)
+{
+    zcheck(out, len);
+    zcheck_readonly(inp, len);
+    zcheck(ctx, sizeof(struct padlock_cipher_data));
+    return zunsafe_buf_call(len, "padlock_cbc_encrypt", out, inp, ctx, len);
+}
+
+static int padlock_cfb_encrypt(void *out, const void *inp,
+                               struct padlock_cipher_data *ctx, size_t len)
+{
+    zcheck(out, len);
+    zcheck_readonly(inp, len);
+    zcheck(ctx, sizeof(struct padlock_cipher_data));
+    return zunsafe_buf_call(len, "padlock_cfb_encrypt", out, inp, ctx, len);
+}
+
+static int padlock_ofb_encrypt(void *out, const void *inp,
+                               struct padlock_cipher_data *ctx, size_t len)
+{
+    zcheck(out, len);
+    zcheck_readonly(inp, len);
+    zcheck(ctx, sizeof(struct padlock_cipher_data));
+    return zunsafe_buf_call(len, "padlock_ofb_encrypt", out, inp, ctx, len);
+}
+
+static int padlock_ctr32_encrypt(void *out, const void *inp,
+                                 struct padlock_cipher_data *ctx, size_t len)
+{
+    zcheck(out, len);
+    zcheck_readonly(inp, len);
+    zcheck(ctx, sizeof(struct padlock_cipher_data));
+    return zunsafe_buf_call(len, "padlock_ctr32_encrypt", out, inp, ctx, len);
+}
+
+static int padlock_xstore(void *out, int edx)
+{
+    zcheck(out, 8); /* Really, the xstore might be requested to store only 4 bytes and out may point
+                       at an int. But we don't have to be so precise since an int in Fil-C is really
+                       16 bytes. */
+    return zunsafe_fast_call("padlock_xstore", out, edx);
+}
 
 /*
  * Load supported features of the CPU to see if the PadLock is available.
diff --git a/include/crypto/md32_common.h b/include/crypto/md32_common.h
index 46214f3237cc..ade29b59e778 100644
--- a/include/crypto/md32_common.h
+++ b/include/crypto/md32_common.h
@@ -101,7 +101,7 @@
 
 #ifndef PEDANTIC
 # if defined(__GNUC__) && __GNUC__>=2 && \
-     !defined(OPENSSL_NO_ASM) && !defined(OPENSSL_NO_INLINE_ASM)
+    !defined(OPENSSL_NO_ASM) && !defined(OPENSSL_NO_INLINE_ASM) && !defined(__FILC__)
 #  if defined(__riscv_zbb) || defined(__riscv_zbkb)
 #   if __riscv_xlen == 64
 #   undef ROTATE
diff --git a/include/crypto/modes.h b/include/crypto/modes.h
index d03ca83d00f2..8461e24092ff 100644
--- a/include/crypto/modes.h
+++ b/include/crypto/modes.h
@@ -38,7 +38,7 @@ typedef unsigned char u8;
 # endif
 #endif
 
-#if !defined(PEDANTIC) && !defined(OPENSSL_NO_ASM) && !defined(OPENSSL_NO_INLINE_ASM)
+#if !defined(PEDANTIC) && !defined(OPENSSL_NO_ASM) && !defined(OPENSSL_NO_INLINE_ASM) && !defined(__FILC__)
 # if defined(__GNUC__) && __GNUC__>=2
 #  if defined(__x86_64) || defined(__x86_64__)
 #   define BSWAP8(x) ({ u64 ret_=(x);                   \
diff --git a/include/crypto/poly1305.h b/include/crypto/poly1305.h
index ba54f3bdcbe1..a4b92a12ff0f 100644
--- a/include/crypto/poly1305.h
+++ b/include/crypto/poly1305.h
@@ -24,11 +24,12 @@ typedef void (*poly1305_blocks_f) (void *ctx, const unsigned char *inp,
 typedef void (*poly1305_emit_f) (void *ctx, unsigned char mac[16],
                                  const unsigned int nonce[4]);
 
+typedef double poly1305_opaque[24]; /* large enough to hold internal state, declared
+                                     * 'double' to ensure at least 64-bit invariant
+                                     * alignment across all platforms and
+                                     * configurations */
 struct poly1305_context {
-    double opaque[24];  /* large enough to hold internal state, declared
-                         * 'double' to ensure at least 64-bit invariant
-                         * alignment across all platforms and
-                         * configurations */
+    poly1305_opaque opaque;
     unsigned int nonce[4];
     unsigned char data[POLY1305_BLOCK_SIZE];
     size_t num;
diff --git a/providers/implementations/ciphers/cipher_aes_gcm_hw.c b/providers/implementations/ciphers/cipher_aes_gcm_hw.c
index 207a16bc70e7..3ad5d6311a90 100644
--- a/providers/implementations/ciphers/cipher_aes_gcm_hw.c
+++ b/providers/implementations/ciphers/cipher_aes_gcm_hw.c
@@ -16,6 +16,7 @@
 #include "internal/deprecated.h"
 
 #include "cipher_aes_gcm.h"
+#include <stdfil.h>
 
 static int aes_gcm_initkey(PROV_GCM_CTX *ctx, const unsigned char *key,
                                    size_t keylen)
@@ -26,6 +27,7 @@ static int aes_gcm_initkey(PROV_GCM_CTX *ctx, const unsigned char *key,
 # ifdef HWAES_CAPABLE
     if (HWAES_CAPABLE) {
 #  ifdef HWAES_ctr32_encrypt_blocks
+
         GCM_HW_SET_KEY_CTR_FN(ks, HWAES_set_encrypt_key, HWAES_encrypt,
                               HWAES_ctr32_encrypt_blocks);
 #  else
diff --git a/providers/implementations/ciphers/cipher_aes_gcm_hw_vaes_avx512.inc b/providers/implementations/ciphers/cipher_aes_gcm_hw_vaes_avx512.inc
index c892c0754e8d..900dfed08d8d 100644
--- a/providers/implementations/ciphers/cipher_aes_gcm_hw_vaes_avx512.inc
+++ b/providers/implementations/ciphers/cipher_aes_gcm_hw_vaes_avx512.inc
@@ -19,27 +19,69 @@
 # define VAES_GCM_ENABLED
 
 /* Returns non-zero when AVX512F + VAES + VPCLMULDQD combination is available */
-int ossl_vaes_vpclmulqdq_capable(void);
+static int ossl_vaes_vpclmulqdq_capable(void)
+{
+    return zunsafe_fast_call("ossl_vaes_vpclmulqdq_capable");
+}
 
 # define OSSL_AES_GCM_UPDATE(direction)                                 \
+    static                                                              \
     void ossl_aes_gcm_ ## direction ## _avx512(const void *ks,          \
                                                void *gcm128ctx,         \
                                                unsigned int *pblocklen, \
                                                const unsigned char *in, \
                                                size_t len,              \
-                                               unsigned char *out);
+                                               unsigned char *out)      \
+    {                                                                   \
+        zcheck_readonly(ks, sizeof(AES_KEY));                           \
+        zcheck(gcm128ctx, sizeof(GCM128_CONTEXT));                      \
+        zcheck(pblocklen, sizeof(unsigned int));                        \
+        zcheck_readonly(in, len);                                       \
+        zcheck(out, len);                                               \
+        zunsafe_buf_call(                                               \
+            len, "ossl_aes_gcm_" #direction "_avx512",                  \
+            ks, gcm128ctx, pblocklen, in, len, out);                    \
+    }
 
 OSSL_AES_GCM_UPDATE(encrypt)
 OSSL_AES_GCM_UPDATE(decrypt)
 
-void ossl_aes_gcm_init_avx512(const void *ks, void *gcm128ctx);
-void ossl_aes_gcm_setiv_avx512(const void *ks, void *gcm128ctx,
-                               const unsigned char *iv, size_t ivlen);
-void ossl_aes_gcm_update_aad_avx512(void *gcm128ctx, const unsigned char *aad,
-                                    size_t aadlen);
-void ossl_aes_gcm_finalize_avx512(void *gcm128ctx, unsigned int pblocklen);
+static void ossl_aes_gcm_init_avx512(const void *ks, void *gcm128ctx)
+{
+    zcheck_readonly(ks, sizeof(AES_KEY));
+    zcheck(gcm128ctx, sizeof(GCM128_CONTEXT));
+    zunsafe_fast_call("ossl_aes_gcm_init_avx512", ks, gcm128ctx);
+}
+
+static void ossl_aes_gcm_setiv_avx512(const void *ks, void *gcm128ctx,
+                                      const unsigned char *iv, size_t ivlen)
+{
+    zcheck_readonly(ks, sizeof(AES_KEY));
+    zcheck(gcm128ctx, sizeof(GCM128_CONTEXT));
+    zcheck_readonly(iv, ivlen);
+    zunsafe_buf_call(ivlen, "ossl_aes_gcm_setiv_avx512", ks, gcm128ctx, iv, ivlen);
+}
+
+static void ossl_aes_gcm_update_aad_avx512(void *gcm128ctx, const unsigned char *aad,
+                                           size_t aadlen)
+{
+    zcheck(gcm128ctx, sizeof(GCM128_CONTEXT));
+    zcheck_readonly(aad, aadlen);
+    zunsafe_buf_call(aadlen, "ossl_aes_gcm_update_aad_avx512", gcm128ctx, aad, aadlen);
+}
+
+static void ossl_aes_gcm_finalize_avx512(void *gcm128ctx, unsigned int pblocklen)
+{
+    zcheck(gcm128ctx, sizeof(GCM128_CONTEXT));
+    zunsafe_fast_call("ossl_aes_gcm_finalize_avx512", gcm128ctx, pblocklen);
+}
 
-void ossl_gcm_gmult_avx512(u64 Xi[2], const void *gcm128ctx);
+static void ossl_gcm_gmult_avx512(u64 Xi[2], const void *gcm128ctx)
+{
+    zcheck(Xi, sizeof(u64) * 2);
+    zcheck_readonly(gcm128ctx, sizeof(GCM128_CONTEXT));
+    zunsafe_fast_call("ossl_gcm_gmult_avx512", Xi, gcm128ctx);
+}
 
 static int vaes_gcm_setkey(PROV_GCM_CTX *ctx, const unsigned char *key,
                            size_t keylen)
diff --git a/providers/implementations/rands/seeding/rand_cpu_x86.c b/providers/implementations/rands/seeding/rand_cpu_x86.c
index 0e062fa45aa2..b961b8fd2e64 100644
--- a/providers/implementations/rands/seeding/rand_cpu_x86.c
+++ b/providers/implementations/rands/seeding/rand_cpu_x86.c
@@ -11,6 +11,7 @@
 #include <openssl/opensslconf.h>
 #include "crypto/rand_pool.h"
 #include "prov/seeding.h"
+#include <stdfil.h>
 
 #ifdef OPENSSL_RAND_SEED_RDCPU
 # if defined(OPENSSL_SYS_TANDEM) && defined(_TNS_X_TARGET)
diff --git a/test/recipes/01-test_symbol_presence.t b/test/recipes/01-test_symbol_presence.t
deleted file mode 100644
index 222b1886aec0..000000000000
--- a/test/recipes/01-test_symbol_presence.t
+++ /dev/null
@@ -1,242 +0,0 @@
-#! /usr/bin/env perl
-# -*- mode: Perl -*-
-# Copyright 2016-2023 The OpenSSL Project Authors. All Rights Reserved.
-#
-# Licensed under the Apache License 2.0 (the "License").  You may not use
-# this file except in compliance with the License.  You can obtain a copy
-# in the file LICENSE in the source distribution or at
-# https://www.openssl.org/source/license.html
-
-use strict;
-use File::Spec::Functions qw(devnull);
-use IPC::Cmd;
-use OpenSSL::Test qw(:DEFAULT srctop_file srctop_dir bldtop_dir bldtop_file);
-use OpenSSL::Test::Utils;
-
-BEGIN {
-    setup("test_symbol_presence");
-}
-
-use lib srctop_dir('Configurations');
-use lib bldtop_dir('.');
-use platform;
-
-plan skip_all => "Test is disabled on NonStop" if config('target') =~ m|^nonstop|;
-# MacOS arranges symbol names differently
-plan skip_all => "Test is disabled on MacOS" if config('target') =~ m|^darwin|;
-plan skip_all => "This is unsupported on platforms that don't have 'nm'"
-    unless IPC::Cmd::can_run('nm');
-
-note
-    "NOTE: developer test!  It's possible that it won't run on your\n",
-    "platform, and that's perfectly fine.  This is mainly for developers\n",
-    "on Unix to check that our shared libraries are consistent with the\n",
-    "ordinals (util/*.num in the source tree), and that our static libraries\n",
-    "don't share symbols, something that should be a good enough check for\n",
-    "the other platforms as well.\n";
-
-my %stlibname;
-my %shlibname;
-my %stlibpath;
-my %shlibpath;
-my %defpath;
-foreach (qw(crypto ssl)) {
-    $stlibname{$_} = platform->staticlib("lib$_");
-    $stlibpath{$_} = bldtop_file($stlibname{$_});
-    $shlibname{$_} = platform->sharedlib("lib$_") unless disabled('shared');
-    $shlibpath{$_} = bldtop_file($shlibname{$_})  unless disabled('shared');
-}
-
-my $testcount
-    =  1                        # Check for static library symbols duplicates
-    ;
-$testcount
-    += (scalar keys %shlibpath) # Check for missing symbols in shared lib
-    unless disabled('shared');
-
-plan tests => $testcount;
-
-######################################################################
-# Collect symbols
-# [3 tests per library]
-
-my %stsymbols;                  # Static library symbols
-my %shsymbols;                  # Shared library symbols
-my %defsymbols;                 # Symbols taken from ordinals
-foreach (sort keys %stlibname) {
-    my $stlib_cmd = "nm -Pg $stlibpath{$_} 2> /dev/null";
-    my $shlib_cmd = "nm -DPg $shlibpath{$_} 2> /dev/null";
-    my @stlib_lines;
-    my @shlib_lines;
-    *OSTDERR = *STDERR;
-    *OSTDOUT = *STDOUT;
-    open STDERR, ">", devnull();
-    open STDOUT, ">", devnull();
-    @stlib_lines = map { s|\R$||; $_ } `$stlib_cmd`;
-    if ($? != 0) {
-        note "running '$stlib_cmd' => $?";
-        @stlib_lines = ();
-    }
-    unless (disabled('shared')) {
-        @shlib_lines = map { s|\R$||; $_ } `$shlib_cmd`;
-        if ($? != 0) {
-            note "running '$shlib_cmd' => $?";
-            @shlib_lines = ();
-        }
-    }
-    close STDERR;
-    close STDOUT;
-    *STDERR = *OSTDERR;
-    *STDOUT = *OSTDOUT;
-
-    my $bldtop = bldtop_dir();
-    my @def_lines;
-    unless (disabled('shared')) {
-        indir $bldtop => sub {
-            my $mkdefpath = srctop_file("util", "mkdef.pl");
-            my $def_path = srctop_file("util", "lib$_.num");
-            my $def_cmd = "$^X $mkdefpath --ordinals $def_path --name $_ --OS linux 2> /dev/null";
-            @def_lines = map { s|\R$||; $_ } `$def_cmd`;
-            if ($? != 0) {
-                note "running 'cd $bldtop; $def_cmd' => $?";
-                @def_lines = ();
-            }
-        }, create => 0, cleanup => 0;
-    }
-
-    note "Number of lines in \@stlib_lines before massaging: ", scalar @stlib_lines;
-    unless (disabled('shared')) {
-        note "Number of lines in \@shlib_lines before massaging: ", scalar @shlib_lines;
-        note "Number of lines in \@def_lines before massaging: ", scalar @def_lines;
-    }
-
-    # Massage the nm output to only contain defined symbols
-    my @arrays = ( \@stlib_lines );
-    push @arrays, \@shlib_lines unless disabled('shared');
-    foreach (@arrays) {
-        my %commons;
-        foreach (@$_) {
-            if (m|^(.*) C .*|) {
-                $commons{$1}++;
-            }
-        }
-        foreach (sort keys %commons) {
-            note "Common symbol: $_";
-        }
-
-        @$_ =
-            sort
-            ( map {
-                  # Drop the first space and everything following it
-                  s| .*||;
-                  # Drop OpenSSL dynamic version information if there is any
-                  s|\@\@.+$||;
-                  # Return the result
-                  $_
-              }
-              # Drop any symbol starting with a double underscore, they
-              # are reserved for the compiler / system ABI and are none
-              # of our business
-              grep !m|^__|,
-              # Only look at external definitions
-              grep m|.* [BDST] .*|,
-              @$_ ),
-            keys %commons;
-    }
-
-    # Massage the mkdef.pl output to only contain global symbols
-    # The output we got is in Unix .map format, which has a global
-    # and a local section.  We're only interested in the global
-    # section.
-    my $in_global = 0;
-    unless (disabled('shared')) {
-        @def_lines =
-            sort
-            map { s|;||; s|\s+||g; $_ }
-            grep { $in_global = 1 if m|global:|;
-                   $in_global = 0 if m|local:|;
-                   $in_global = 0 if m|\}|;
-                   $in_global && m|;|; } @def_lines;
-    }
-
-    note "Number of lines in \@stlib_lines after massaging: ", scalar @stlib_lines;
-    unless (disabled('shared')) {
-
-        note "Number of lines in \@shlib_lines after massaging: ", scalar @shlib_lines;
-        note "Number of lines in \@def_lines after massaging: ", scalar @def_lines;
-    }
-
-    $stsymbols{$_} = [ @stlib_lines ];
-    unless (disabled('shared')) {
-        $shsymbols{$_} = [ @shlib_lines ];
-        $defsymbols{$_} = [ @def_lines ];
-    }
-}
-
-######################################################################
-# Check that there are no duplicate symbols in all our static libraries
-# combined
-# [1 test]
-
-my %symbols;
-foreach (sort keys %stlibname) {
-    foreach (@{$stsymbols{$_}}) {
-        $symbols{$_}++;
-    }
-}
-my @duplicates = sort grep { $symbols{$_} > 1 } keys %symbols;
-if (@duplicates) {
-    note "Duplicates:";
-    note join('\n', @duplicates);
-}
-ok(scalar @duplicates == 0, "checking no duplicate symbols in static libraries");
-
-######################################################################
-# Check that the exported symbols in our shared libraries are consistent
-# with our ordinals files.
-# [1 test per library]
-
-unless (disabled('shared')) {
-    foreach (sort keys %stlibname) {
-        # Maintain lists of symbols that are missing in the shared library,
-        # or that are extra.
-        my @missing = ();
-        my @extra = ();
-
-        my @sh_symbols = ( @{$shsymbols{$_}} );
-        my @def_symbols = ( @{$defsymbols{$_}} );
-
-        while (scalar @sh_symbols || scalar @def_symbols) {
-            my $sh_first = $sh_symbols[0];
-            my $def_first = $def_symbols[0];
-
-            if (!defined($sh_first)) {
-                push @missing, shift @def_symbols;
-            } elsif (!defined($def_first)) {
-                push @extra, shift @sh_symbols;
-            } elsif ($sh_first gt $def_first) {
-                push @missing, shift @def_symbols;
-            } elsif ($sh_first lt $def_first) {
-                push @extra, shift @sh_symbols;
-            } else {
-                shift @def_symbols;
-                shift @sh_symbols;
-            }
-        }
-
-        if (scalar @missing) {
-            note "The following symbols are missing in $_:";
-            foreach (@missing) {
-                note "  $_";
-            }
-        }
-        if (scalar @extra) {
-            note "The following symbols are extra in $_:";
-            foreach (@extra) {
-                note "  $_";
-            }
-        }
-        ok(scalar @missing == 0,
-           "check that there are no missing symbols in $_");
-    }
-}
diff --git a/test/recipes/04-test_param_build.t b/test/recipes/04-test_param_build.t
deleted file mode 100644
index b9846c5204f6..000000000000
--- a/test/recipes/04-test_param_build.t
+++ /dev/null
@@ -1,15 +0,0 @@
-#! /usr/bin/env perl
-# Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
-#
-# Licensed under the Apache License 2.0 (the "License").  You may not use
-# this file except in compliance with the License.  You can obtain a copy
-# in the file LICENSE in the source distribution or at
-# https://www.openssl.org/source/license.html
-
-use strict;
-use OpenSSL::Test;
-use OpenSSL::Test::Simple;
-
-setup("test_param_build");
-
-simple_test("test_param_build", "param_build_test");
diff --git a/test/recipes/30-test_afalg.t b/test/recipes/30-test_afalg.t
deleted file mode 100644
index 572a847511a8..000000000000
--- a/test/recipes/30-test_afalg.t
+++ /dev/null
@@ -1,21 +0,0 @@
-#! /usr/bin/env perl
-# Copyright 2015-2020 The OpenSSL Project Authors. All Rights Reserved.
-#
-# Licensed under the Apache License 2.0 (the "License").  You may not use
-# this file except in compliance with the License.  You can obtain a copy
-# in the file LICENSE in the source distribution or at
-# https://www.openssl.org/source/license.html
-
-use strict;
-use OpenSSL::Test qw/:DEFAULT/;
-use OpenSSL::Test::Utils;
-
-my $test_name = "test_afalg";
-setup($test_name);
-
-plan skip_all => "$test_name not supported for this build"
-    if disabled("afalgeng");
-
-plan tests => 1;
-
-ok(run(test(["afalgtest"])), "running afalgtest");
diff --git a/test/recipes/90-test_secmem.t b/test/recipes/90-test_secmem.t
deleted file mode 100644
index 764391b42ad6..000000000000
--- a/test/recipes/90-test_secmem.t
+++ /dev/null
@@ -1,12 +0,0 @@
-#! /usr/bin/env perl
-# Copyright 2015-2016 The OpenSSL Project Authors. All Rights Reserved.
-#
-# Licensed under the Apache License 2.0 (the "License").  You may not use
-# this file except in compliance with the License.  You can obtain a copy
-# in the file LICENSE in the source distribution or at
-# https://www.openssl.org/source/license.html
-
-
-use OpenSSL::Test::Simple;
-
-simple_test("test_secmem", "secmemtest");
diff --git a/test/recipes/90-test_shlibload.t b/test/recipes/90-test_shlibload.t
deleted file mode 100644
index 67afff607e04..000000000000
--- a/test/recipes/90-test_shlibload.t
+++ /dev/null
@@ -1,75 +0,0 @@
-#! /usr/bin/env perl
-# Copyright 2016-2024 The OpenSSL Project Authors. All Rights Reserved.
-#
-# Licensed under the Apache License 2.0 (the "License").  You may not use
-# this file except in compliance with the License.  You can obtain a copy
-# in the file LICENSE in the source distribution or at
-# https://www.openssl.org/source/license.html
-
-use OpenSSL::Test qw/:DEFAULT srctop_dir bldtop_dir/;
-use OpenSSL::Test::Utils;
-
-#Load configdata.pm
-
-BEGIN {
-    setup("test_shlibload");
-}
-use lib srctop_dir('Configurations');
-use lib bldtop_dir('.');
-use platform;
-
-plan skip_all => "Test only supported in a shared build" if disabled("shared");
-plan skip_all => "Test is disabled on AIX" if config('target') =~ m|^aix|;
-plan skip_all => "Test is disabled on NonStop" if config('target') =~ m|^nonstop|;
-plan skip_all => "Test only supported in a dso build" if disabled("dso");
-plan skip_all => "Test is disabled in an address sanitizer build" unless disabled("asan");
-plan skip_all => "Test is disabled in no-atexit build" if disabled("atexit");
-
-plan tests => 10;
-
-my $libcrypto = platform->sharedlib('libcrypto');
-my $libssl = platform->sharedlib('libssl');
-my $atexit_outfile;
-
-$atexit_outfile = 'atexit-cryptofirst.txt';
-1 while unlink $atexit_outfile;
-ok(run(test(["shlibloadtest", "-crypto_first", $libcrypto, $libssl, $atexit_outfile])),
-   "running shlibloadtest -crypto_first $atexit_outfile");
-ok(check_atexit($atexit_outfile));
-
-$atexit_outfile = 'atexit-sslfirst.txt';
-1 while unlink $atexit_outfile;
-ok(run(test(["shlibloadtest", "-ssl_first", $libcrypto, $libssl, $atexit_outfile])),
-   "running shlibloadtest -ssl_first $atexit_outfile");
-ok(check_atexit($atexit_outfile));
-
-$atexit_outfile = 'atexit-justcrypto.txt';
-1 while unlink $atexit_outfile;
-ok(run(test(["shlibloadtest", "-just_crypto", $libcrypto, $libssl, $atexit_outfile])),
-   "running shlibloadtest -just_crypto $atexit_outfile");
-ok(check_atexit($atexit_outfile));
-
-$atexit_outfile = 'atexit-dsoref.txt';
-1 while unlink $atexit_outfile;
-ok(run(test(["shlibloadtest", "-dso_ref", $libcrypto, $libssl, $atexit_outfile])),
-   "running shlibloadtest -dso_ref $atexit_outfile");
-ok(check_atexit($atexit_outfile));
-
-$atexit_outfile = 'atexit-noatexit.txt';
-1 while unlink $atexit_outfile;
-ok(run(test(["shlibloadtest", "-no_atexit", $libcrypto, $libssl, $atexit_outfile])),
-   "running shlibloadtest -no_atexit $atexit_outfile");
-ok(!check_atexit($atexit_outfile));
-
-sub check_atexit {
-    my $filename = shift;
-
-    open my $fh, '<', $filename;
-    return 0 unless defined $fh;
-
-    my $data = <$fh>;
-
-    return 1 if (defined $data && $data =~ m/atexit\(\) run/);
-
-    return 0;
-}
