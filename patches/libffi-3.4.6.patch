diff --git a/Makefile.am b/Makefile.am
index 3de0bea4737d..77b83b30709e 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -119,7 +119,7 @@ endif
 
 if LIBFFI_BUILD_VERSIONED_SHLIB
 if LIBFFI_BUILD_VERSIONED_SHLIB_GNU
-libffi_version_script = -Wl,--version-script,libffi.map
+libffi_version_script = --version-script,libffi.map
 libffi_version_dep = libffi.map
 endif
 if LIBFFI_BUILD_VERSIONED_SHLIB_SUN
diff --git a/configure.host b/configure.host
index 4cc69be4fe29..6da272b8f338 100644
--- a/configure.host
+++ b/configure.host
@@ -331,6 +331,8 @@ case "${TARGET}" in
 	;;
 esac
 
+SOURCES=ffi64.c
+
 # If we failed to configure SOURCES, we can't do anything.
 if test -z "${SOURCES}"; then
   UNSUPPORTED=1
diff --git a/doc/libffi.info b/doc/libffi.info
index 2afb9c7fafb2..67c6b994ba2f 100644
--- a/doc/libffi.info
+++ b/doc/libffi.info
@@ -1,14 +1,13 @@
-This is libffi.info, produced by makeinfo version 7.0.3 from
-libffi.texi.
+This is libffi.info, produced by makeinfo version 6.8 from libffi.texi.
 
 This manual is for libffi, a portable foreign function interface
 library.
 
-   Copyright © 2008–2024 Anthony Green and Red Hat, Inc.
+   Copyright (C) 2008-2024 Anthony Green and Red Hat, Inc.
 
    Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
-“Software”), to deal in the Software without restriction, including
+"Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
@@ -17,7 +16,7 @@ the following conditions:
    The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.
 
-   THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
@@ -39,11 +38,11 @@ libffi
 This manual is for libffi, a portable foreign function interface
 library.
 
-   Copyright © 2008–2024 Anthony Green and Red Hat, Inc.
+   Copyright (C) 2008-2024 Anthony Green and Red Hat, Inc.
 
    Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
-“Software”), to deal in the Software without restriction, including
+"Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
@@ -52,7 +51,7 @@ the following conditions:
    The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.
 
-   THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
@@ -65,7 +64,7 @@ SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * Introduction::                What is libffi?
 * Using libffi::                How to use libffi.
 * Memory Usage::                Where memory for closures comes from.
-* Missing Features::            Things libffi can’t do.
+* Missing Features::            Things libffi can't do.
 * Index::                       Index.
 
 
@@ -76,29 +75,29 @@ File: libffi.info,  Node: Introduction,  Next: Using libffi,  Prev: Top,  Up: To
 
 Compilers for high level languages generate code that follow certain
 conventions.  These conventions are necessary, in part, for separate
-compilation to work.  One such convention is the “calling convention”.
+compilation to work.  One such convention is the "calling convention".
 The calling convention is a set of assumptions made by the compiler
 about where function arguments will be found on entry to a function.  A
 calling convention also specifies where the return value for a function
-is found.  The calling convention is also sometimes called the “ABI” or
-“Application Binary Interface”.
+is found.  The calling convention is also sometimes called the "ABI" or
+"Application Binary Interface".
 
    Some programs may not know at the time of compilation what arguments
 are to be passed to a function.  For instance, an interpreter may be
 told at run-time about the number and types of arguments used to call a
-given function.  ‘libffi’ can be used in such programs to provide a
+given function.  'libffi' can be used in such programs to provide a
 bridge from the interpreter program to compiled code.
 
-   The ‘libffi’ library provides a portable, high level programming
+   The 'libffi' library provides a portable, high level programming
 interface to various calling conventions.  This allows a programmer to
 call any function specified by a call interface description at run time.
 
    FFI stands for Foreign Function Interface.  A foreign function
 interface is the popular name for the interface that allows code written
-in one language to call code written in another language.  The ‘libffi’
+in one language to call code written in another language.  The 'libffi'
 library really only provides the lowest, machine dependent layer of a
 fully featured foreign function interface.  A layer must exist above
-‘libffi’ that handles type conversions for values passed between the two
+'libffi' that handles type conversions for values passed between the two
 languages.
 
 
@@ -123,45 +122,45 @@ File: libffi.info,  Node: The Basics,  Next: Simple Example,  Up: Using libffi
 2.1 The Basics
 ==============
 
-‘libffi’ assumes that you have a pointer to the function you wish to
+'libffi' assumes that you have a pointer to the function you wish to
 call and that you know the number and types of arguments to pass it, as
 well as the return type of the function.
 
-   The first thing you must do is create an ‘ffi_cif’ object that
+   The first thing you must do is create an 'ffi_cif' object that
 matches the signature of the function you wish to call.  This is a
 separate step because it is common to make multiple calls using a single
-‘ffi_cif’.  The “cif” in ‘ffi_cif’ stands for Call InterFace.  To
-prepare a call interface object, use the function ‘ffi_prep_cif’.
+'ffi_cif'.  The "cif" in 'ffi_cif' stands for Call InterFace.  To
+prepare a call interface object, use the function 'ffi_prep_cif'.
 
  -- Function: ffi_status ffi_prep_cif (ffi_cif *CIF, ffi_abi ABI,
           unsigned int NARGS, ffi_type *RTYPE, ffi_type **ARGTYPES)
      This initializes CIF according to the given parameters.
 
-     ABI is the ABI to use; normally ‘FFI_DEFAULT_ABI’ is what you want.
+     ABI is the ABI to use; normally 'FFI_DEFAULT_ABI' is what you want.
      *note Multiple ABIs:: for more information.
 
      NARGS is the number of arguments that this function accepts.
 
-     RTYPE is a pointer to an ‘ffi_type’ structure that describes the
+     RTYPE is a pointer to an 'ffi_type' structure that describes the
      return type of the function.  *Note Types::.
 
-     ARGTYPES is a vector of ‘ffi_type’ pointers.  ARGTYPES must have
+     ARGTYPES is a vector of 'ffi_type' pointers.  ARGTYPES must have
      NARGS elements.  If NARGS is 0, this argument is ignored.
 
-     ‘ffi_prep_cif’ returns a ‘libffi’ status code, of type
-     ‘ffi_status’.  This will be either ‘FFI_OK’ if everything worked
-     properly; ‘FFI_BAD_TYPEDEF’ if one of the ‘ffi_type’ objects is
-     incorrect; or ‘FFI_BAD_ABI’ if the ABI parameter is invalid.
+     'ffi_prep_cif' returns a 'libffi' status code, of type
+     'ffi_status'.  This will be either 'FFI_OK' if everything worked
+     properly; 'FFI_BAD_TYPEDEF' if one of the 'ffi_type' objects is
+     incorrect; or 'FFI_BAD_ABI' if the ABI parameter is invalid.
 
    If the function being called is variadic (varargs) then
-‘ffi_prep_cif_var’ must be used instead of ‘ffi_prep_cif’.
+'ffi_prep_cif_var' must be used instead of 'ffi_prep_cif'.
 
  -- Function: ffi_status ffi_prep_cif_var (ffi_cif *CIF, ffi_abi ABI,
           unsigned int NFIXEDARGS, unsigned int NTOTALARGS, ffi_type
           *RTYPE, ffi_type **ARGTYPES)
      This initializes CIF according to the given parameters for a call
      to a variadic function.  In general its operation is the same as
-     for ‘ffi_prep_cif’ except that:
+     for 'ffi_prep_cif' except that:
 
      NFIXEDARGS is the number of fixed arguments, prior to any variadic
      arguments.  It must be greater than zero.
@@ -169,59 +168,59 @@ prepare a call interface object, use the function ‘ffi_prep_cif’.
      NTOTALARGS the total number of arguments, including variadic and
      fixed arguments.  ARGTYPES must have this many elements.
 
-     ‘ffi_prep_cif_var’ will return ‘FFI_BAD_ARGTYPE’ if any of the
-     variable argument types are ‘ffi_type_float’ (promote to
-     ‘ffi_type_double’ first), or any integer type small than an int
+     'ffi_prep_cif_var' will return 'FFI_BAD_ARGTYPE' if any of the
+     variable argument types are 'ffi_type_float' (promote to
+     'ffi_type_double' first), or any integer type small than an int
      (promote to an int-sized type first).
 
-     Note that, different cif’s must be prepped for calls to the same
+     Note that, different cif's must be prepped for calls to the same
      function when different numbers of arguments are passed.
 
-     Also note that a call to ‘ffi_prep_cif_var’ with
+     Also note that a call to 'ffi_prep_cif_var' with
      NFIXEDARGS=NOTOTALARGS is NOT equivalent to a call to
-     ‘ffi_prep_cif’.
+     'ffi_prep_cif'.
 
-   Note that the resulting ‘ffi_cif’ holds pointers to all the
-‘ffi_type’ objects that were used during initialization.  You must
+   Note that the resulting 'ffi_cif' holds pointers to all the
+'ffi_type' objects that were used during initialization.  You must
 ensure that these type objects have a lifetime at least as long as that
-of the ‘ffi_cif’.
+of the 'ffi_cif'.
 
-   To call a function using an initialized ‘ffi_cif’, use the ‘ffi_call’
+   To call a function using an initialized 'ffi_cif', use the 'ffi_call'
 function:
 
  -- Function: void ffi_call (ffi_cif *CIF, void *FN, void *RVALUE, void
           **AVALUES)
      This calls the function FN according to the description given in
-     CIF.  CIF must have already been prepared using ‘ffi_prep_cif’.
+     CIF.  CIF must have already been prepared using 'ffi_prep_cif'.
 
      RVALUE is a pointer to a chunk of memory that will hold the result
      of the function call.  This must be large enough to hold the
      result, no smaller than the system register size (generally 32 or
-     64 bits), and must be suitably aligned; it is the caller’s
+     64 bits), and must be suitably aligned; it is the caller's
      responsibility to ensure this.  If CIF declares that the function
-     returns ‘void’ (using ‘ffi_type_void’), then RVALUE is ignored.
+     returns 'void' (using 'ffi_type_void'), then RVALUE is ignored.
 
-     In most situations, ‘libffi’ will handle promotion according to the
+     In most situations, 'libffi' will handle promotion according to the
      ABI. However, for historical reasons, there is a special case with
      return values that must be handled by your code.  In particular,
-     for integral (not ‘struct’) types that are narrower than the system
-     register size, the return value will be widened by ‘libffi’.
-     ‘libffi’ provides a type, ‘ffi_arg’, that can be used as the return
+     for integral (not 'struct') types that are narrower than the system
+     register size, the return value will be widened by 'libffi'.
+     'libffi' provides a type, 'ffi_arg', that can be used as the return
      type.  For example, if the CIF was defined with a return type of
-     ‘char’, ‘libffi’ will try to store a full ‘ffi_arg’ into the return
+     'char', 'libffi' will try to store a full 'ffi_arg' into the return
      value.
 
-     AVALUES is a vector of ‘void *’ pointers that point to the memory
+     AVALUES is a vector of 'void *' pointers that point to the memory
      locations holding the argument values for a call.  If CIF declares
      that the function has no arguments (i.e., NARGS was 0), then
      AVALUES is ignored.
 
      Note that while the return value must be register-sized, arguments
      should exactly match their declared type.  For example, if an
-     argument is a ‘short’, then the entry in AVALUES should point to an
-     object declared as ‘short’; but if the return type is ‘short’, then
-     RVALUE should point to an object declared as a larger type –
-     usually ‘ffi_arg’.
+     argument is a 'short', then the entry in AVALUES should point to an
+     object declared as 'short'; but if the return type is 'short', then
+     RVALUE should point to an object declared as a larger type -
+     usually 'ffi_arg'.
 
 
 File: libffi.info,  Node: Simple Example,  Next: Types,  Prev: The Basics,  Up: Using libffi
@@ -229,7 +228,7 @@ File: libffi.info,  Node: Simple Example,  Next: Types,  Prev: The Basics,  Up:
 2.2 Simple Example
 ==================
 
-Here is a trivial example that calls ‘puts’ a few times.
+Here is a trivial example that calls 'puts' a few times.
 
      #include <stdio.h>
      #include <ffi.h>
@@ -286,91 +285,91 @@ File: libffi.info,  Node: Primitive Types,  Next: Structures,  Up: Types
 2.3.1 Primitive Types
 ---------------------
 
-‘Libffi’ provides a number of built-in type descriptors that can be used
+'Libffi' provides a number of built-in type descriptors that can be used
 to describe argument and return types:
 
-‘ffi_type_void’
-     The type ‘void’.  This cannot be used for argument types, only for
+'ffi_type_void'
+     The type 'void'.  This cannot be used for argument types, only for
      return values.
 
-‘ffi_type_uint8’
+'ffi_type_uint8'
      An unsigned, 8-bit integer type.
 
-‘ffi_type_sint8’
+'ffi_type_sint8'
      A signed, 8-bit integer type.
 
-‘ffi_type_uint16’
+'ffi_type_uint16'
      An unsigned, 16-bit integer type.
 
-‘ffi_type_sint16’
+'ffi_type_sint16'
      A signed, 16-bit integer type.
 
-‘ffi_type_uint32’
+'ffi_type_uint32'
      An unsigned, 32-bit integer type.
 
-‘ffi_type_sint32’
+'ffi_type_sint32'
      A signed, 32-bit integer type.
 
-‘ffi_type_uint64’
+'ffi_type_uint64'
      An unsigned, 64-bit integer type.
 
-‘ffi_type_sint64’
+'ffi_type_sint64'
      A signed, 64-bit integer type.
 
-‘ffi_type_float’
-     The C ‘float’ type.
+'ffi_type_float'
+     The C 'float' type.
 
-‘ffi_type_double’
-     The C ‘double’ type.
+'ffi_type_double'
+     The C 'double' type.
 
-‘ffi_type_uchar’
-     The C ‘unsigned char’ type.
+'ffi_type_uchar'
+     The C 'unsigned char' type.
 
-‘ffi_type_schar’
-     The C ‘signed char’ type.  (Note that there is not an exact
-     equivalent to the C ‘char’ type in ‘libffi’; ordinarily you should
-     either use ‘ffi_type_schar’ or ‘ffi_type_uchar’ depending on
-     whether ‘char’ is signed.)
+'ffi_type_schar'
+     The C 'signed char' type.  (Note that there is not an exact
+     equivalent to the C 'char' type in 'libffi'; ordinarily you should
+     either use 'ffi_type_schar' or 'ffi_type_uchar' depending on
+     whether 'char' is signed.)
 
-‘ffi_type_ushort’
-     The C ‘unsigned short’ type.
+'ffi_type_ushort'
+     The C 'unsigned short' type.
 
-‘ffi_type_sshort’
-     The C ‘short’ type.
+'ffi_type_sshort'
+     The C 'short' type.
 
-‘ffi_type_uint’
-     The C ‘unsigned int’ type.
+'ffi_type_uint'
+     The C 'unsigned int' type.
 
-‘ffi_type_sint’
-     The C ‘int’ type.
+'ffi_type_sint'
+     The C 'int' type.
 
-‘ffi_type_ulong’
-     The C ‘unsigned long’ type.
+'ffi_type_ulong'
+     The C 'unsigned long' type.
 
-‘ffi_type_slong’
-     The C ‘long’ type.
+'ffi_type_slong'
+     The C 'long' type.
 
-‘ffi_type_longdouble’
-     On platforms that have a C ‘long double’ type, this is defined.  On
+'ffi_type_longdouble'
+     On platforms that have a C 'long double' type, this is defined.  On
      other platforms, it is not.
 
-‘ffi_type_pointer’
-     A generic ‘void *’ pointer.  You should use this for all pointers,
+'ffi_type_pointer'
+     A generic 'void *' pointer.  You should use this for all pointers,
      regardless of their real type.
 
-‘ffi_type_complex_float’
-     The C ‘_Complex float’ type.
+'ffi_type_complex_float'
+     The C '_Complex float' type.
 
-‘ffi_type_complex_double’
-     The C ‘_Complex double’ type.
+'ffi_type_complex_double'
+     The C '_Complex double' type.
 
-‘ffi_type_complex_longdouble’
-     The C ‘_Complex long double’ type.  On platforms that have a C
-     ‘long double’ type, this is defined.  On other platforms, it is
+'ffi_type_complex_longdouble'
+     The C '_Complex long double' type.  On platforms that have a C
+     'long double' type, this is defined.  On other platforms, it is
      not.
 
-   Each of these is of type ‘ffi_type’, so you must take the address
-when passing to ‘ffi_prep_cif’.
+   Each of these is of type 'ffi_type', so you must take the address
+when passing to 'ffi_prep_cif'.
 
 
 File: libffi.info,  Node: Structures,  Next: Size and Alignment,  Prev: Primitive Types,  Up: Types
@@ -378,30 +377,30 @@ File: libffi.info,  Node: Structures,  Next: Size and Alignment,  Prev: Primitiv
 2.3.2 Structures
 ----------------
 
-‘libffi’ is perfectly happy passing structures back and forth.  You must
-first describe the structure to ‘libffi’ by creating a new ‘ffi_type’
+'libffi' is perfectly happy passing structures back and forth.  You must
+first describe the structure to 'libffi' by creating a new 'ffi_type'
 object for it.
 
  -- Data type: ffi_type
-     The ‘ffi_type’ has the following members:
-     ‘size_t size’
-          This is set by ‘libffi’; you should initialize it to zero.
+     The 'ffi_type' has the following members:
+     'size_t size'
+          This is set by 'libffi'; you should initialize it to zero.
 
-     ‘unsigned short alignment’
-          This is set by ‘libffi’; you should initialize it to zero.
+     'unsigned short alignment'
+          This is set by 'libffi'; you should initialize it to zero.
 
-     ‘unsigned short type’
-          For a structure, this should be set to ‘FFI_TYPE_STRUCT’.
+     'unsigned short type'
+          For a structure, this should be set to 'FFI_TYPE_STRUCT'.
 
-     ‘ffi_type **elements’
-          This is a ‘NULL’-terminated array of pointers to ‘ffi_type’
+     'ffi_type **elements'
+          This is a 'NULL'-terminated array of pointers to 'ffi_type'
           objects.  There is one element per field of the struct.
 
-          Note that ‘libffi’ has no special support for bit-fields.  You
+          Note that 'libffi' has no special support for bit-fields.  You
           must manage these manually.
 
-   The ‘size’ and ‘alignment’ fields will be filled in by ‘ffi_prep_cif’
-or ‘ffi_prep_cif_var’, as needed.
+   The 'size' and 'alignment' fields will be filled in by 'ffi_prep_cif'
+or 'ffi_prep_cif_var', as needed.
 
 
 File: libffi.info,  Node: Size and Alignment,  Next: Arrays Unions Enums,  Prev: Structures,  Up: Types
@@ -409,24 +408,24 @@ File: libffi.info,  Node: Size and Alignment,  Next: Arrays Unions Enums,  Prev:
 2.3.3 Size and Alignment
 ------------------------
 
-‘libffi’ will set the ‘size’ and ‘alignment’ fields of an ‘ffi_type’
+'libffi' will set the 'size' and 'alignment' fields of an 'ffi_type'
 object for you.  It does so using its knowledge of the ABI.
 
    You might expect that you can simply read these fields for a type
-that has been laid out by ‘libffi’.  However, there are some caveats.
+that has been laid out by 'libffi'.  However, there are some caveats.
 
-   • The size or alignment of some of the built-in types may vary
+   * The size or alignment of some of the built-in types may vary
      depending on the chosen ABI.
 
-   • The size and alignment of a new structure type will not be set by
-     ‘libffi’ until it has been passed to ‘ffi_prep_cif’ or
-     ‘ffi_get_struct_offsets’.
+   * The size and alignment of a new structure type will not be set by
+     'libffi' until it has been passed to 'ffi_prep_cif' or
+     'ffi_get_struct_offsets'.
 
-   • A structure type cannot be shared across ABIs.  Instead each ABI
+   * A structure type cannot be shared across ABIs.  Instead each ABI
      needs its own copy of the structure type.
 
    So, before examining these fields, it is safest to pass the
-‘ffi_type’ object to ‘ffi_prep_cif’ or ‘ffi_get_struct_offsets’ first.
+'ffi_type' object to 'ffi_prep_cif' or 'ffi_get_struct_offsets' first.
 This function will do all the needed setup.
 
      ffi_type *desired_type;
@@ -439,7 +438,7 @@ This function will do all the needed setup.
          unsigned short alignment = desired_type->alignment;
        }
 
-   ‘libffi’ also provides a way to get the offsets of the members of a
+   'libffi' also provides a way to get the offsets of the members of a
 structure.
 
  -- Function: ffi_status ffi_get_struct_offsets (ffi_abi abi, ffi_type
@@ -449,15 +448,15 @@ structure.
      layout depends on the ABI.
 
      OFFSETS is an out parameter.  The caller is responsible for
-     providing enough space for all the results to be written – one
-     element per element type in STRUCT_TYPE.  If OFFSETS is ‘NULL’,
+     providing enough space for all the results to be written - one
+     element per element type in STRUCT_TYPE.  If OFFSETS is 'NULL',
      then the type will be laid out but not otherwise modified.  This
-     can be useful for accessing the type’s size or layout, as mentioned
+     can be useful for accessing the type's size or layout, as mentioned
      above.
 
-     This function returns ‘FFI_OK’ on success; ‘FFI_BAD_ABI’ if ABI is
-     invalid; or ‘FFI_BAD_TYPEDEF’ if STRUCT_TYPE is invalid in some
-     way.  Note that only ‘FFI_STRUCT’ types are valid here.
+     This function returns 'FFI_OK' on success; 'FFI_BAD_ABI' if ABI is
+     invalid; or 'FFI_BAD_TYPEDEF' if STRUCT_TYPE is invalid in some
+     way.  Note that only 'FFI_STRUCT' types are valid here.
 
 
 File: libffi.info,  Node: Arrays Unions Enums,  Next: Type Example,  Prev: Size and Alignment,  Up: Types
@@ -468,11 +467,11 @@ File: libffi.info,  Node: Arrays Unions Enums,  Next: Type Example,  Prev: Size
 2.3.4.1 Arrays
 ..............
 
-‘libffi’ does not have direct support for arrays or unions.  However,
+'libffi' does not have direct support for arrays or unions.  However,
 they can be emulated using structures.
 
-   To emulate an array, simply create an ‘ffi_type’ using
-‘FFI_TYPE_STRUCT’ with as many members as there are elements in the
+   To emulate an array, simply create an 'ffi_type' using
+'FFI_TYPE_STRUCT' with as many members as there are elements in the
 array.
 
      ffi_type array_type;
@@ -488,18 +487,18 @@ array.
      array_type.type = FFI_TYPE_STRUCT;
      array_type.elements = elements;
 
-   Note that arrays cannot be passed or returned by value in C –
+   Note that arrays cannot be passed or returned by value in C -
 structure types created like this should only be used to refer to
-members of real ‘FFI_TYPE_STRUCT’ objects.
+members of real 'FFI_TYPE_STRUCT' objects.
 
    However, a phony array type like this will not cause any errors from
-‘libffi’ if you use it as an argument or return type.  This may be
+'libffi' if you use it as an argument or return type.  This may be
 confusing.
 
 2.3.4.2 Unions
 ..............
 
-A union can also be emulated using ‘FFI_TYPE_STRUCT’.  In this case,
+A union can also be emulated using 'FFI_TYPE_STRUCT'.  In this case,
 however, you must make sure that the size and alignment match the real
 requirements of the union.
 
@@ -507,7 +506,7 @@ requirements of the union.
 out.  Then, give the new structure type a single element; the size of
 the largest element; and the largest alignment seen as well.
 
-   This example uses the ‘ffi_prep_cif’ trick to ensure that each
+   This example uses the 'ffi_prep_cif' trick to ensure that each
 element type is laid out.
 
      ffi_abi desired_abi;
@@ -541,11 +540,11 @@ element type is laid out.
 2.3.4.3 Enumerations
 ....................
 
-‘libffi’ does not have any special support for C ‘enum’s.  Although any
-given ‘enum’ is implemented using a specific underlying integral type,
-exactly which type will be used cannot be determined by ‘libffi’ – it
+'libffi' does not have any special support for C 'enum's.  Although any
+given 'enum' is implemented using a specific underlying integral type,
+exactly which type will be used cannot be determined by 'libffi' - it
 may depend on the values in the enumeration or on compiler flags such as
-‘-fshort-enums’.  *Note (gcc)Structures unions enumerations and
+'-fshort-enums'.  *Note (gcc)Structures unions enumerations and
 bit-fields implementation::, for more information about how GCC handles
 enumerations.
 
@@ -555,8 +554,8 @@ File: libffi.info,  Node: Type Example,  Next: Complex,  Prev: Arrays Unions Enu
 2.3.5 Type Example
 ------------------
 
-The following example initializes a ‘ffi_type’ object representing the
-‘tm’ struct from Linux’s ‘time.h’.
+The following example initializes a 'ffi_type' object representing the
+'tm' struct from Linux's 'time.h'.
 
    Here is how the struct is defined:
 
@@ -575,7 +574,7 @@ The following example initializes a ‘ffi_type’ object representing the
          __const char *__tm_zone__;
      };
 
-   Here is the corresponding code to describe this struct to ‘libffi’:
+   Here is the corresponding code to describe this struct to 'libffi':
 
          {
            ffi_type tm_type;
@@ -603,38 +602,38 @@ File: libffi.info,  Node: Complex,  Next: Complex Type Example,  Prev: Type Exam
 2.3.6 Complex Types
 -------------------
 
-‘libffi’ supports the complex types defined by the C99 standard
-(‘_Complex float’, ‘_Complex double’ and ‘_Complex long double’ with the
-built-in type descriptors ‘ffi_type_complex_float’,
-‘ffi_type_complex_double’ and ‘ffi_type_complex_longdouble’.
+'libffi' supports the complex types defined by the C99 standard
+('_Complex float', '_Complex double' and '_Complex long double' with the
+built-in type descriptors 'ffi_type_complex_float',
+'ffi_type_complex_double' and 'ffi_type_complex_longdouble'.
 
-   Custom complex types like ‘_Complex int’ can also be used.  An
-‘ffi_type’ object has to be defined to describe the complex type to
-‘libffi’.
+   Custom complex types like '_Complex int' can also be used.  An
+'ffi_type' object has to be defined to describe the complex type to
+'libffi'.
 
  -- Data type: ffi_type
-     ‘size_t size’
+     'size_t size'
           This must be manually set to the size of the complex type.
 
-     ‘unsigned short alignment’
+     'unsigned short alignment'
           This must be manually set to the alignment of the complex
           type.
 
-     ‘unsigned short type’
-          For a complex type, this must be set to ‘FFI_TYPE_COMPLEX’.
+     'unsigned short type'
+          For a complex type, this must be set to 'FFI_TYPE_COMPLEX'.
 
-     ‘ffi_type **elements’
+     'ffi_type **elements'
 
-          This is a ‘NULL’-terminated array of pointers to ‘ffi_type’
-          objects.  The first element is set to the ‘ffi_type’ of the
-          complex’s base type.  The second element must be set to
-          ‘NULL’.
+          This is a 'NULL'-terminated array of pointers to 'ffi_type'
+          objects.  The first element is set to the 'ffi_type' of the
+          complex's base type.  The second element must be set to
+          'NULL'.
 
    The section *note Complex Type Example:: shows a way to determine the
-‘size’ and ‘alignment’ members in a platform independent way.
+'size' and 'alignment' members in a platform independent way.
 
-   For platforms that have no complex support in ‘libffi’ yet, the
-functions ‘ffi_prep_cif’ and ‘ffi_prep_args’ abort the program if they
+   For platforms that have no complex support in 'libffi' yet, the
+functions 'ffi_prep_cif' and 'ffi_prep_args' abort the program if they
 encounter a complex type.
 
 
@@ -731,9 +730,9 @@ File: libffi.info,  Node: Multiple ABIs,  Next: The Closure API,  Prev: Types,
 =================
 
 A given platform may provide multiple different ABIs at once.  For
-instance, the x86 platform has both ‘stdcall’ and ‘fastcall’ functions.
+instance, the x86 platform has both 'stdcall' and 'fastcall' functions.
 
-   ‘libffi’ provides some support for this.  However, this is
+   'libffi' provides some support for this.  However, this is
 necessarily platform-specific.
 
 
@@ -742,13 +741,13 @@ File: libffi.info,  Node: The Closure API,  Next: Closure Example,  Prev: Multip
 2.5 The Closure API
 ===================
 
-‘libffi’ also provides a way to write a generic function – a function
+'libffi' also provides a way to write a generic function - a function
 that can accept and decode any combination of arguments.  This can be
 useful when writing an interpreter, or to provide wrappers for arbitrary
 functions.
 
-   This facility is called the “closure API”. Closures are not supported
-on all platforms; you can check the ‘FFI_CLOSURES’ define to determine
+   This facility is called the "closure API". Closures are not supported
+on all platforms; you can check the 'FFI_CLOSURES' define to determine
 whether they are supported on the current platform.
 
    Because closures work by assembling a tiny function at runtime, they
@@ -760,28 +759,28 @@ Memory management for closures is handled by a pair of functions:
      pointer to the writable address, and sets *CODE to the
      corresponding executable address.
 
-     SIZE should be sufficient to hold a ‘ffi_closure’ object.
+     SIZE should be sufficient to hold a 'ffi_closure' object.
 
  -- Function: void ffi_closure_free (void *WRITABLE)
-     Free memory allocated using ‘ffi_closure_alloc’.  The argument is
+     Free memory allocated using 'ffi_closure_alloc'.  The argument is
      the writable address that was returned.
 
    Once you have allocated the memory for a closure, you must construct
-a ‘ffi_cif’ describing the function call.  Finally you can prepare the
+a 'ffi_cif' describing the function call.  Finally you can prepare the
 closure function:
 
  -- Function: ffi_status ffi_prep_closure_loc (ffi_closure *CLOSURE,
           ffi_cif *CIF, void (*FUN) (ffi_cif *CIF, void *RET, void
           **ARGS, void *USER_DATA), void *USER_DATA, void *CODELOC)
      Prepare a closure function.  The arguments to
-     ‘ffi_prep_closure_loc’ are:
+     'ffi_prep_closure_loc' are:
 
      CLOSURE
-          The address of a ‘ffi_closure’ object; this is the writable
-          address returned by ‘ffi_closure_alloc’.
+          The address of a 'ffi_closure' object; this is the writable
+          address returned by 'ffi_closure_alloc'.
 
      CIF
-          The ‘ffi_cif’ describing the function parameters.  Note that
+          The 'ffi_cif' describing the function parameters.  Note that
           this object, and the types to which it refers, must be kept
           alive until the closure itself is freed.
 
@@ -790,29 +789,29 @@ closure function:
           closure function.
 
      CODELOC
-          The executable address returned by ‘ffi_closure_alloc’.
+          The executable address returned by 'ffi_closure_alloc'.
 
      FUN
           The function which will be called when the closure is invoked.
           It is called with the arguments:
 
           CIF
-               The ‘ffi_cif’ passed to ‘ffi_prep_closure_loc’.
+               The 'ffi_cif' passed to 'ffi_prep_closure_loc'.
 
           RET
-               A pointer to the memory used for the function’s return
+               A pointer to the memory used for the function's return
                value.
 
-               If the function is declared as returning ‘void’, then
+               If the function is declared as returning 'void', then
                this value is garbage and should not be used.
 
                Otherwise, FUN must fill the object to which this points,
                following the same special promotion behavior as
-               ‘ffi_call’.  That is, in most cases, RET points to an
+               'ffi_call'.  That is, in most cases, RET points to an
                object of exactly the size of the type specified when CIF
                was constructed.  However, integral types narrower than
                the system register size are widened.  In these cases
-               your program may assume that RET points to an ‘ffi_arg’
+               your program may assume that RET points to an 'ffi_arg'
                object.
 
           ARGS
@@ -821,15 +820,15 @@ closure function:
 
           USER_DATA
                The same USER_DATA that was passed to
-               ‘ffi_prep_closure_loc’.
+               'ffi_prep_closure_loc'.
 
-     ‘ffi_prep_closure_loc’ will return ‘FFI_OK’ if everything went ok,
-     and one of the other ‘ffi_status’ values on error.
+     'ffi_prep_closure_loc' will return 'FFI_OK' if everything went ok,
+     and one of the other 'ffi_status' values on error.
 
-     After calling ‘ffi_prep_closure_loc’, you can cast CODELOC to the
+     After calling 'ffi_prep_closure_loc', you can cast CODELOC to the
      appropriate pointer-to-function type.
 
-   You may see old code referring to ‘ffi_prep_closure’.  This function
+   You may see old code referring to 'ffi_prep_closure'.  This function
 is deprecated, as it cannot handle the need for separate writable and
 executable addresses.
 
@@ -839,8 +838,8 @@ File: libffi.info,  Node: Closure Example,  Next: Thread Safety,  Prev: The Clos
 2.6 Closure Example
 ===================
 
-A trivial example that creates a new ‘puts’ by binding ‘fputs’ with
-‘stdout’.
+A trivial example that creates a new 'puts' by binding 'fputs' with
+'stdout'.
 
      #include <stdio.h>
      #include <ffi.h>
@@ -898,21 +897,21 @@ File: libffi.info,  Node: Thread Safety,  Prev: Closure Example,  Up: Using libf
 2.7 Thread Safety
 =================
 
-‘libffi’ is not completely thread-safe.  However, many parts are, and if
+'libffi' is not completely thread-safe.  However, many parts are, and if
 you follow some simple rules, you can use it safely in a multi-threaded
 program.
 
-   • ‘ffi_prep_cif’ may modify the ‘ffi_type’ objects passed to it.  It
+   * 'ffi_prep_cif' may modify the 'ffi_type' objects passed to it.  It
      is best to ensure that only a single thread prepares a given
-     ‘ffi_cif’ at a time.
+     'ffi_cif' at a time.
 
-   • On some platforms, ‘ffi_prep_cif’ may modify the size and alignment
+   * On some platforms, 'ffi_prep_cif' may modify the size and alignment
      of some types, depending on the chosen ABI. On these platforms, if
      you switch between ABIs, you must ensure that there is only one
-     call to ‘ffi_prep_cif’ at a time.
+     call to 'ffi_prep_cif' at a time.
 
      Currently the only affected platform is PowerPC and the only
-     affected type is ‘long double’.
+     affected type is 'long double'.
 
 
 File: libffi.info,  Node: Memory Usage,  Next: Missing Features,  Prev: Using libffi,  Up: Top
@@ -920,36 +919,36 @@ File: libffi.info,  Node: Memory Usage,  Next: Missing Features,  Prev: Using li
 3 Memory Usage
 **************
 
-Note that memory allocated by ‘ffi_closure_alloc’ and freed by
-‘ffi_closure_free’ does not come from the same general pool of memory
-that ‘malloc’ and ‘free’ use.  To accomodate security settings, ‘libffi’
+Note that memory allocated by 'ffi_closure_alloc' and freed by
+'ffi_closure_free' does not come from the same general pool of memory
+that 'malloc' and 'free' use.  To accomodate security settings, 'libffi'
 may aquire memory, for example, by mapping temporary files into multiple
 places in the address space (once to write out the closure, a second to
 execute it).  The search follows this list, using the first that works:
 
-   • A anonymous mapping (i.e.  not file-backed)
+   * A anonymous mapping (i.e.  not file-backed)
 
-   • ‘memfd_create()’, if the kernel supports it.
+   * 'memfd_create()', if the kernel supports it.
 
-   • A file created in the directory referenced by the environment
-     variable ‘LIBFFI_TMPDIR’.
+   * A file created in the directory referenced by the environment
+     variable 'LIBFFI_TMPDIR'.
 
-   • Likewise for the environment variable ‘TMPDIR’.
+   * Likewise for the environment variable 'TMPDIR'.
 
-   • A file created in ‘/tmp’.
+   * A file created in '/tmp'.
 
-   • A file created in ‘/var/tmp’.
+   * A file created in '/var/tmp'.
 
-   • A file created in ‘/dev/shm’.
+   * A file created in '/dev/shm'.
 
-   • A file created in the user’s home directory (‘$HOME’).
+   * A file created in the user's home directory ('$HOME').
 
-   • A file created in any directory listed in ‘/etc/mtab’.
+   * A file created in any directory listed in '/etc/mtab'.
 
-   • A file created in any directory listed in ‘/proc/mounts’.
+   * A file created in any directory listed in '/proc/mounts'.
 
    If security settings prohibit using any of these for closures,
-‘ffi_closure_alloc’ will fail.
+'ffi_closure_alloc' will fail.
 
 
 File: libffi.info,  Node: Missing Features,  Next: Index,  Prev: Memory Usage,  Up: Top
@@ -957,16 +956,16 @@ File: libffi.info,  Node: Missing Features,  Next: Index,  Prev: Memory Usage,
 4 Missing Features
 ******************
 
-‘libffi’ is missing a few features.  We welcome patches to add support
+'libffi' is missing a few features.  We welcome patches to add support
 for these.
 
-   • Variadic closures.
+   * Variadic closures.
 
-   • There is no support for bit fields in structures.
+   * There is no support for bit fields in structures.
 
-   • The “raw” API is undocumented.
+   * The "raw" API is undocumented.
 
-   • The Go API is undocumented.
+   * The Go API is undocumented.
 
 
 File: libffi.info,  Node: Index,  Prev: Missing Features,  Up: Top
@@ -1032,26 +1031,26 @@ Index
 
 
 Tag Table:
-Node: Top1399
-Node: Introduction2933
-Node: Using libffi4593
-Node: The Basics5122
-Node: Simple Example10240
-Node: Types11275
-Node: Primitive Types11786
-Node: Structures14103
-Node: Size and Alignment15214
-Node: Arrays Unions Enums17489
-Node: Type Example20470
-Node: Complex21779
-Node: Complex Type Example23295
-Node: Multiple ABIs26347
-Node: The Closure API26730
-Node: Closure Example30648
-Node: Thread Safety32292
-Node: Memory Usage33125
-Node: Missing Features34402
-Node: Index34783
+Node: Top1388
+Node: Introduction2911
+Node: Using libffi4543
+Node: The Basics5072
+Node: Simple Example10000
+Node: Types11031
+Node: Primitive Types11542
+Node: Structures13663
+Node: Size and Alignment14702
+Node: Arrays Unions Enums16899
+Node: Type Example19828
+Node: Complex21119
+Node: Complex Type Example22537
+Node: Multiple ABIs25589
+Node: The Closure API25960
+Node: Closure Example29786
+Node: Thread Safety31418
+Node: Memory Usage32219
+Node: Missing Features33414
+Node: Index33779
 
 End Tag Table
 
diff --git a/fficonfig.h.in b/fficonfig.h.in
index 2e4aac6623ba..36c12ad20275 100644
--- a/fficonfig.h.in
+++ b/fficonfig.h.in
@@ -65,10 +65,10 @@
 /* Define if you support more than one size of the long double type */
 #undef HAVE_LONG_DOUBLE_VARIANT
 
-/* Define to 1 if you have the `memcpy' function. */
+/* Define to 1 if you have the 'memcpy' function. */
 #undef HAVE_MEMCPY
 
-/* Define to 1 if you have the `memfd_create' function. */
+/* Define to 1 if you have the 'memfd_create' function. */
 #undef HAVE_MEMFD_CREATE
 
 /* Define if your compiler supports pointer authentication. */
@@ -131,16 +131,16 @@
 /* Define to the version of this package. */
 #undef PACKAGE_VERSION
 
-/* The size of `double', as computed by sizeof. */
+/* The size of 'double', as computed by sizeof. */
 #undef SIZEOF_DOUBLE
 
-/* The size of `long double', as computed by sizeof. */
+/* The size of 'long double', as computed by sizeof. */
 #undef SIZEOF_LONG_DOUBLE
 
-/* The size of `size_t', as computed by sizeof. */
+/* The size of 'size_t', as computed by sizeof. */
 #undef SIZEOF_SIZE_T
 
-/* Define to 1 if all of the C90 standard headers exist (not just the ones
+/* Define to 1 if all of the C89 standard headers exist (not just the ones
    required in a freestanding environment). This macro is provided for
    backward compatibility; new code need not use it. */
 #undef STDC_HEADERS
diff --git a/ffitest.c b/ffitest.c
new file mode 100644
index 000000000000..504884c3630f
--- /dev/null
+++ b/ffitest.c
@@ -0,0 +1,34 @@
+#include <stdio.h>
+#include <ffi.h>
+
+int main()
+{
+    ffi_cif cif;
+    ffi_type *args[1];
+    void *values[1];
+    char *s;
+    ffi_arg rc;
+
+    /* Initialize the argument info vectors */
+    args[0] = &ffi_type_pointer;
+    values[0] = &s;
+
+    /* Initialize the cif */
+    if (ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+                     &ffi_type_sint, args) == FFI_OK) 
+    {
+        s = "Hello World!";
+        ffi_call(&cif, puts, &rc, values);
+        /* rc now holds the result of the call to puts */
+
+        /* values holds a pointer to the function's arg, so to
+           call puts() again all we need to do is change the
+           value of s */
+        s = "This is cool!";
+        ffi_call(&cif, puts, &rc, values);
+    }
+
+    return 0;
+}
+
+
diff --git a/ffitest.expected b/ffitest.expected
new file mode 100644
index 000000000000..2648dbba26db
--- /dev/null
+++ b/ffitest.expected
@@ -0,0 +1,2 @@
+Hello World!
+This is cool!
diff --git a/src/closures.c b/src/closures.c
index 67a94a822ca0..3090c4abc42a 100644
--- a/src/closures.c
+++ b/src/closures.c
@@ -38,6 +38,30 @@
 #include <ffi_common.h>
 #include <tramp.h>
 
+#ifdef __FILC__
+
+#include <stdfil.h>
+
+extern void ffi_closure_callback (void);
+
+void *
+ffi_closure_alloc (size_t size, void **code)
+{
+  *code = zclosure_new(ffi_closure_callback, NULL);
+  return *code;
+}
+
+void
+ffi_closure_free (__attribute__((unused)) void *ptr)
+{
+}
+
+int ffi_tramp_is_present(__attribute__((unused)) void *ptr)
+{
+  return 0;
+}
+
+#else /* __FILC__ -> so !__FILC__ */
 #ifdef __NetBSD__
 #include <sys/param.h>
 #endif
@@ -1104,4 +1128,6 @@ ffi_tramp_is_present (__attribute__((unused)) void *ptr)
 #endif /* FFI_CLOSURES */
 
 #endif /* NetBSD with PROT_MPROTECT */
+#endif /* !__FILC__ */
 #endif /* __EMSCRIPTEN__ */
+
diff --git a/src/x86/ffi64.c b/src/x86/ffi64.c
index 6a8e37fc5679..8da593d1bb91 100644
--- a/src/x86/ffi64.c
+++ b/src/x86/ffi64.c
@@ -33,9 +33,14 @@
 #include <stdlib.h>
 #include <stdarg.h>
 #include <stdint.h>
+#include <stdbool.h>
 #include <tramp.h>
 #include "internal64.h"
 
+#ifdef __FILC__
+#include <stdfil.h>
+#endif
+
 #ifdef __x86_64__
 
 #define MAX_GPR_REGS 6
@@ -69,8 +74,16 @@ struct register_args
   UINT64 r10;	/* static chain */
 };
 
+#ifdef __FILC__
+static bool is_filc = true;
+#else
+static bool is_filc = false;
+#endif
+
+#ifndef __FILC__
 extern void ffi_call_unix64 (void *args, unsigned long bytes, unsigned flags,
 			     void *raddr, void (*fnaddr)(void)) FFI_HIDDEN;
+#endif
 
 /* All reference to register classes here is identical to the code in
    gcc/config/i386/i386.c. Do *not* change one without the other.  */
@@ -392,7 +405,7 @@ examine_argument (ffi_type *type, enum x86_64_reg_class classes[MAX_CLASSES],
 
 /* Perform machine dependent cif processing.  */
 
-#ifndef __ILP32__
+#if !defined(__ILP32__) && !defined(__FILC__)
 extern ffi_status
 ffi_prep_cif_machdep_efi64(ffi_cif *cif);
 #endif
@@ -406,12 +419,17 @@ ffi_prep_cif_machdep (ffi_cif *cif)
   size_t bytes, n, rtype_size;
   ffi_type *rtype;
 
-#ifndef __ILP32__
+#ifdef __FILC__
+  if (cif->abi != FFI_FILC)
+    return FFI_BAD_ABI;
+#else
+# ifndef __ILP32__
   if (cif->abi == FFI_EFI64 || cif->abi == FFI_GNUW64)
     return ffi_prep_cif_machdep_efi64(cif);
-#endif
+# endif
   if (cif->abi != FFI_UNIX64)
     return FFI_BAD_ABI;
+#endif
 
   gprcount = ssecount = 0;
 
@@ -530,7 +548,8 @@ ffi_prep_cif_machdep (ffi_cif *cif)
      not, add it's size to the stack byte count.  */
   for (bytes = 0, i = 0, avn = cif->nargs; i < avn; i++)
     {
-      if (examine_argument (cif->arg_types[i], classes, 0, &ngpr, &nsse) == 0
+      if (is_filc
+          || examine_argument (cif->arg_types[i], classes, 0, &ngpr, &nsse) == 0
 	  || gprcount + ngpr > MAX_GPR_REGS
 	  || ssecount + nsse > MAX_SSE_REGS)
 	{
@@ -561,6 +580,57 @@ static void
 ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue,
 	      void **avalue, void *closure)
 {
+#ifdef __FILC__
+  char *stack, *argp;
+  ffi_type **arg_types;
+  int i, avn, flags;
+  size_t bytes;
+  void *rets;
+
+  FFI_ASSERT (cif->abi == FFI_FILC);
+  FFI_ASSERT (closure == NULL);
+
+  flags = cif->flags;
+  bytes = cif->bytes;
+  if (flags & UNIX64_FLAG_RET_IN_MEM)
+    bytes += sizeof (void*);
+
+  stack = alloca (bytes);
+  argp = stack;
+
+  if (flags & UNIX64_FLAG_RET_IN_MEM)
+    {
+      if (rvalue == NULL)
+        rvalue = alloca (cif->rtype->size);
+
+      *(void **) argp = rvalue;
+      argp += sizeof (void*);
+    }
+
+  arg_types = cif->arg_types;
+  avn = cif->nargs;
+
+  for (i = 0; i < avn; ++i)
+    {
+      size_t size = size = arg_types[i]->size;
+      long align = arg_types[i]->alignment;
+
+      if (align < 8)
+        align = 8;
+
+      argp = (void *) FFI_ALIGN (argp, align);
+      memcpy (argp, avalue[i], size);
+
+      argp += size;
+    }
+
+  FFI_ASSERT (argp == stack + cif->bytes);
+
+  rets = zcall (fn, stack);
+
+  if (rvalue != NULL && !(flags & UNIX64_FLAG_RET_IN_MEM))
+    memcpy (rvalue, rets, cif->rtype->size);
+#else
   enum x86_64_reg_class classes[MAX_CLASSES];
   char *stack, *argp;
   ffi_type **arg_types;
@@ -672,9 +742,10 @@ ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue,
 
   ffi_call_unix64 (stack, cif->bytes + sizeof (struct register_args),
 		   flags, rvalue, fn);
+#endif
 }
 
-#ifndef __ILP32__
+#if !defined(__ILP32__) && !defined(__FILC__)
 extern void
 ffi_call_efi64(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue);
 #endif
@@ -682,8 +753,10 @@ ffi_call_efi64(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue);
 void
 ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
 {
+#ifndef __FILC__
   ffi_type **arg_types = cif->arg_types;
   int i, nargs = cif->nargs;
+
   const int max_reg_struct_size = cif->abi == FFI_GNUW64 ? 8 : 16;
 
   /* If we have any large structure arguments, make a copy so we are passing
@@ -706,6 +779,7 @@ ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
       ffi_call_efi64(cif, fn, rvalue, avalue);
       return;
     }
+#endif
 #endif
   ffi_call_int (cif, fn, rvalue, avalue, NULL);
 }
@@ -741,7 +815,7 @@ extern void ffi_closure_unix64_alt(void) FFI_HIDDEN;
 extern void ffi_closure_unix64_sse_alt(void) FFI_HIDDEN;
 #endif
 
-#ifndef __ILP32__
+#if !defined(__ILP32__) && !defined(__FILC__)
 extern ffi_status
 ffi_prep_closure_loc_efi64(ffi_closure* closure,
 			   ffi_cif* cif,
@@ -757,6 +831,9 @@ ffi_prep_closure_loc (ffi_closure* closure,
 		      void *user_data,
 		      void *codeloc)
 {
+#ifdef __FILC__
+  zclosure_set_data (codeloc, closure);
+#else
   static const unsigned char trampoline[24] = {
     /* endbr64 */
     0xf3, 0x0f, 0x1e, 0xfa,
@@ -801,6 +878,7 @@ ffi_prep_closure_loc (ffi_closure* closure,
 
 #if defined(FFI_EXEC_STATIC_TRAMP)
 out:
+#endif
 #endif
   closure->cif = cif;
   closure->fun = fun;
@@ -809,6 +887,57 @@ out:
   return FFI_OK;
 }
 
+#ifdef __FILC__
+void FFI_HIDDEN
+ffi_closure_callback (void)
+{
+  ffi_closure *closure;
+  ffi_cif *cif;
+  void (*fun)(ffi_cif*, void*, void**, void*);
+  char *argp;
+  void *user_data, **avalue, *rvalue;
+  int i, avn, flags;
+  ffi_type **arg_types;
+
+  closure = zcallee_closure_data ();
+  cif = closure->cif;
+  fun = closure->fun;
+  user_data = closure->user_data;
+
+  avn = cif->nargs;
+  flags = cif->flags;
+  arg_types = cif->arg_types;
+
+  argp = zargs ();
+
+  avalue = alloca (avn * sizeof (void *));
+
+  if (flags & UNIX64_FLAG_RET_IN_MEM)
+    {
+      rvalue = *(void **) argp;
+      argp += sizeof (void*);
+    }
+  else
+    rvalue = alloca (cif->rtype->size);
+
+  for (i = 0; i < avn; ++i)
+    {
+      long align = arg_types[i]->alignment;
+
+      if (align < 8)
+        align = 8;
+
+      argp = (void *) FFI_ALIGN (argp, align);
+      avalue[i] = argp;
+      argp += arg_types[i]->size;
+    }
+
+  fun (cif, rvalue, avalue, user_data);
+
+  if (!(flags & UNIX64_FLAG_RET_IN_MEM))
+    zreturn (rvalue);
+}
+#else
 int FFI_HIDDEN
 ffi_closure_unix64_inner(ffi_cif *cif,
 			 void (*fun)(ffi_cif*, void*, void**, void*),
@@ -901,6 +1030,7 @@ ffi_closure_unix64_inner(ffi_cif *cif,
   /* Tell assembly how to perform return type promotions.  */
   return flags;
 }
+#endif
 
 #ifdef FFI_GO_CLOSURES
 
diff --git a/src/x86/ffitarget.h b/src/x86/ffitarget.h
index 5a3399d80982..ac676917b4b6 100644
--- a/src/x86/ffitarget.h
+++ b/src/x86/ffitarget.h
@@ -81,7 +81,13 @@ typedef signed long            ffi_sarg;
 #endif
 
 typedef enum ffi_abi {
-#if defined(X86_WIN64)
+#if defined(__FILC__)
+  FFI_FIRST_ABI = 0,
+  FFI_FILC,
+  FFI_UNIX64 = FFI_FILC,
+  FFI_LAST_ABI,
+  FFI_DEFAULT_ABI = FFI_FILC
+#elif defined(X86_WIN64)
   FFI_FIRST_ABI = 0,
   FFI_WIN64,            /* sizeof(long double) == 8  - microsoft compilers */
   FFI_GNUW64,           /* sizeof(long double) == 16 - GNU compilers */
@@ -130,7 +136,9 @@ typedef enum ffi_abi {
 /* ---- Definitions for closures ----------------------------------------- */
 
 #define FFI_CLOSURES 1
+#ifndef __FILC__
 #define FFI_GO_CLOSURES 1
+#endif
 
 #define FFI_TYPE_SMALL_STRUCT_1B (FFI_TYPE_LAST + 1)
 #define FFI_TYPE_SMALL_STRUCT_2B (FFI_TYPE_LAST + 2)
