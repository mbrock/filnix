# Fil-C Patches

This directory contains patches for building upstream software with Fil-C (memory-safe C/C++).

## Overview

- **Total patches**: 75
- **Total size**: 4.3MB
- **Source**: fil-c commit `594c0b05910`
- **Generated by**: `extract-patch.sh`

## What's in the patches

These patches contain **only** the source code changes needed for Fil-C compatibility:

- Pointer-to-integer conversions using `zptrtable_encode()` / `zptrtable_decode()`
- `#include <stdfil.h>` for Fil-C runtime functions
- Build system adjustments (Makefile.am, CMakeLists.txt)
- Platform-specific fixes

## What's excluded

To keep patches minimal and maintainable, we exclude:

- **Autotools generated files**: `configure`, `Makefile.in`, `aclocal.m4`, `config.h.in`
- **Build helper directories**: `build-aux/*`, `conftools/*`
- **Repository infrastructure**: `.github/*`, `.gitignore`, CI configs
- **Gettext/i18n generated files**: `po/Makefile.in.in`, etc.
- **Fil-C test files**: `fil-tests/*` (Filip's test additions)

## Projects needing no patches

These projects build as-is with Fil-C without any modifications:

```
brotli, busybox, bzip2, check, coreutils, curl, dummy-pam-ecryptfs,
emacs-lisp, gmp, kmod, libidn2, libtasn1, lz4, mg, ncurses,
pcre-8.39, pkgconf, shadow, sudo, util-linux, wg14_signals
```

## Using in Nix

Example package override:

```nix
perl = super.perl.overrideAttrs (old: {
  patches = (old.patches or []) ++ [
    ./patches/perl-5.40.0.patch
  ];
});
```

## Regenerating patches

If you need to update patches from a newer fil-c commit:

```bash
# Requires ~/fil-c-projects checkout
make clean
make -j20
```

This will regenerate all patches from the git history in fil-c-projects.

## Largest patches

The biggest patches are for core libraries with extensive changes:

- `user-glibc-2.40.patch` (718K) - Memory-safe user glibc
- `usermusl.patch` (588K) - Memory-safe musl libc
- `nghttp2-1.62.1.patch` (533K) - HTTP/2 library
- `libuev-2.4.1.patch` (517K) - Event loop library
- `pcre2-10.44.patch` (507K) - Regular expressions

## Common patch patterns

The patches use several patterns to make code Fil-C compatible. Here are real examples from various projects:

### Pattern 1: Pointer tables (Perl, Python)

The most common pattern: using `zptrtable` to convert pointers to integers safely.

**Perl's `builtin.c`** - Storing callback pointers as integers:
```c
+#include <stdfil.h>
+
+static zptrtable* builtin_ptrtable;
+
+static void construct_ptrtable(void) __attribute__((constructor));
+static void construct_ptrtable(void)
+{
+    builtin_ptrtable = zptrtable_new();
+}

 static OP *ck_builtin_const(pTHX_ OP *entersubop, GV *namegv, SV *ckobj)
 {
-    const struct BuiltinFuncDescriptor *builtin = NUM2PTR(..., SvUV(ckobj));
+    const struct BuiltinFuncDescriptor *builtin = zptrtable_decode(builtin_ptrtable, SvUV(ckobj));
```

**Python's `longobject.c`** - Converting C pointers to Python ints:
```c
+#include <stdfil.h>
+
+static zexact_ptrtable* ptrtable;
+
+static void construct_ptrtable(void) __attribute__((constructor));
+static void construct_ptrtable(void)
+{
+    ptrtable = zexact_ptrtable_new();
+}

 PyObject *
 PyLong_FromVoidPtr(void *p)
 {
-    return PyLong_FromUnsignedLong((unsigned long)(uintptr_t)p);
+    return PyLong_FromUnsignedLong((unsigned long)(uintptr_t)zexact_ptrtable_encode(ptrtable, p));
 }

 void *
 PyLong_AsVoidPtr(PyObject *vv)
 {
     long x;
     // ... extract x from Python long ...
-    return (void *)x;
+    return (void *)zexact_ptrtable_decode(ptrtable, x);
 }
```

**Note**: `zptrtable` is for general use, `zexact_ptrtable` preserves exact pointer identity (needed for `==` comparisons).

### Pattern 2: Type adjustments (Git)

Sometimes storing as `void*` and casting on access is simpler than pointer tables.

**Git's `parse-options.h`** - Changing defval storage type:
```c
 struct option {
     // ...
     parse_opt_cb *callback;
-    intptr_t defval;
+    void *defval;  // Store as pointer instead of integer
 };

 #define OPT_SET_INT_F(s, l, v, h, i, f) { \
     // ...
-    .defval = (i), \
+    .defval = (void *)(i),  // Cast to void* when initializing
 }
```

**Git's `parse-options.c`** - Casting back to integer:
```c
 case OPTION_SET_INT:
-    *(int *)opt->value = unset ? 0 : opt->defval;
+    *(int *)opt->value = unset ? 0 : (intptr_t)opt->defval;
```

### Pattern 3: Build system adjustments (Lua)

Some projects just need build flags changed.

**Lua's `makefile`** - Removing problematic flags:
```c
-MYCFLAGS= $(LOCAL) -std=c99 -DLUA_USE_LINUX -DLUA_USE_READLINE
+MYCFLAGS= $(LOCAL) -std=c99 -DLUA_USE_LINUX

-MYLIBS= -ldl -lreadline
+MYLIBS= -ldl

-CFLAGS= -Wall -O2 $(MYCFLAGS)
+CFLAGS= -Wall -O2 -g $(MYCFLAGS)  # Add -g for debugging
```

### Pattern 4: Symbol versioning (xz)

Libraries with symbol versioning need Fil-C-specific directives.

**xz's `common.h`** - Conditional symbol versioning:
```c
+#elif __PIZLONATOR_WAS_HERE__
+    #define LZMA_SYMVER_API(extnamever, type, intname) \
+        __asm__(".filc_symver " #intname "," extnamever); \
+        extern LZMA_API(type) intname
 #else
     #define LZMA_SYMVER_API(extnamever, type, intname) \
         __asm__(".symver " #intname "," extnamever); \
```

**Note**: `__PIZLONATOR_WAS_HERE__` is defined by the Fil-C compiler.

### Pattern 5: Alignment fixes (xz)

Some types need explicit alignment for Fil-C's capability system.

**xz's `file_io.h`** - Adding alignment attribute:
```c
-typedef union {
+typedef union __attribute__((aligned(16))) {
     uint8_t u8[IO_BUFFER_SIZE];
     uint32_t u32[IO_BUFFER_SIZE / sizeof(uint32_t)];
     uint64_t u64[IO_BUFFER_SIZE / sizeof(uint64_t)];
 } io_buf;
```

### Pattern 6: Header inclusion

When a project uses Fil-C runtime functions (like `zptrtable`), it needs to include the header.

**Python's `Python.h`**, **Perl's `perl.h`**, etc:
```c
+#include <stdfil.h>
```

This provides declarations for:
- `zptrtable_new()`, `zptrtable_encode()`, `zptrtable_decode()`
- `zexact_ptrtable_new()`, `zexact_ptrtable_encode()`, `zexact_ptrtable_decode()`
- Other Fil-C runtime functions

**Note**: Projects that don't use pointer tables or other Fil-C features may need no changes at all (like coreutils, busybox, ncurses).
