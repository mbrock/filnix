diff --git a/Makeconfig b/Makeconfig
index 2d4343b60433..e3db25d5fc2e 100644
--- a/Makeconfig
+++ b/Makeconfig
@@ -195,7 +195,7 @@ inst_zonedir = $(install_root)$(zonedir)
 # Where to install the compiled binary locale archive and compiled
 # binary locale files.
 ifndef complocaledir
-complocaledir = $(libdir)/locale
+complocaledir = /lib/locale
 endif
 inst_complocaledir = $(install_root)$(complocaledir)
 
@@ -272,7 +272,7 @@ inst_vardbdir = $(install_root)$(vardbdir)
 # other than there, so the zoneinfo directory contains only universal data,
 # localizing the configuration data elsewhere.
 ifndef localtime-file
-localtime-file = $(sysconfdir)/localtime
+localtime-file = /etc/localtime
 endif
 
 # What to use for leap second specifications in compiling the default
@@ -381,13 +381,13 @@ LDFLAGS.so += $(relro-LDFLAGS)
 LDFLAGS-rtld += $(relro-LDFLAGS)
 
 # Linker options to enable and disable DT_RELR.
-ifeq ($(have-dt-relr),yes)
-dt-relr-ldflag = -Wl,-z,pack-relative-relocs
-no-dt-relr-ldflag = -Wl,-z,nopack-relative-relocs
-else
+#ifeq ($(have-dt-relr),yes)
+#dt-relr-ldflag = -Wl,-z,pack-relative-relocs
+#no-dt-relr-ldflag = -Wl,-z,nopack-relative-relocs
+#else
 dt-relr-ldflag =
 no-dt-relr-ldflag =
-endif
+#endif
 
 ifeq (no,$(build-pie-default))
 pie-default = $(no-pie-ccflag)
@@ -433,15 +433,12 @@ link-extra-libs-tests = $(libsupport)
 ifndef +link-pie
 +link-pie-before-inputs = $(if $($(@F)-no-pie),$(no-pie-ldflag),-pie) \
 	     $(if $($(@F)-no-dt-relr),$(no-dt-relr-ldflag),$(dt-relr-ldflag)) \
-	     -Wl,-O1 -nostdlib -nostartfiles \
+	     -Wl,-O1 -nodefaultlibs -normalcrt \
 	     $(sysdep-LDFLAGS) $(LDFLAGS) $(LDFLAGS-$(@F)) \
 	     $(relro-LDFLAGS) $(hashstyle-LDFLAGS) \
-	     $(firstword $(CRT-$(@F)) $(csu-objpfx)S$(start-installed-name)) \
 	     $(+preinit) $(+prectorS)
 +link-pie-before-libc = -o $@ $(+link-pie-before-inputs) \
-	     $(filter-out $(addprefix $(csu-objpfx),start.o \
-						    S$(start-installed-name))\
-			  $(+preinit) $(link-extra-libs) \
+	     $(filter-out $(+preinit) $(link-extra-libs) \
 			  $(common-objpfx)libc% $(+postinit),$^) \
 	     $(link-extra-libs)
 +link-pie-after-libc = $(+postctorS) $(+postinit)
@@ -463,16 +460,13 @@ endef
 endif
 # Command for statically linking programs with the C library.
 ifndef +link-static
-+link-static-before-inputs = -nostdlib -nostartfiles -static \
++link-static-before-inputs = -nodefaultlibs -normalcrt -static \
 	      $(if $($(@F)-no-pie),$(no-pie-ldflag),$(static-pie-ldflag)) \
 	      $(if $($(@F)-no-dt-relr),$(no-dt-relr-ldflag),$(static-pie-dt-relr-ldflag)) \
 	      $(sysdep-LDFLAGS) $(LDFLAGS) $(LDFLAGS-$(@F))  \
-	      $(firstword $(CRT-$(@F)) $(csu-objpfx)$(real-static-start-installed-name)) \
 	      $(+preinit) $(+prectorT)
 +link-static-before-libc = -o $@ $(+link-static-before-inputs) \
-	      $(filter-out $(addprefix $(csu-objpfx),start.o \
-						     $(start-installed-name))\
-			   $(+preinit) $(link-extra-libs-static) \
+	      $(filter-out $(+preinit) $(link-extra-libs-static) \
 			   $(common-objpfx)libc% $(+postinit),$^) \
 	      $(link-extra-libs-static)
 +link-static-after-libc = $(+postctorT) $(+postinit)
@@ -500,15 +494,12 @@ ifeq (yes,$(build-pie-default))
 +link-tests-after-inputs = $(link-libc-tests) $(+link-pie-after-libc)
 +link-printers-tests = $(+link-pie-printers-tests)
 else  # not build-pie-default
-+link-before-inputs = -nostdlib -nostartfiles $(no-pie-ldflag) \
++link-before-inputs = -nodefaultlibs -normalcrt $(no-pie-ldflag) \
 	      $(sysdep-LDFLAGS) $(LDFLAGS) $(LDFLAGS-$(@F)) \
 	      $(relro-LDFLAGS) $(hashstyle-LDFLAGS) \
-	      $(firstword $(CRT-$(@F)) $(csu-objpfx)$(start-installed-name)) \
 	      $(+preinit) $(+prector)
 +link-before-libc = -o $@ $(+link-before-inputs) \
-	      $(filter-out $(addprefix $(csu-objpfx),start.o \
-						     $(start-installed-name))\
-			   $(+preinit) $(link-extra-libs) \
+	      $(filter-out $(+preinit) $(link-extra-libs) \
 			   $(common-objpfx)libc% $(+postinit),$^) \
 	      $(link-extra-libs)
 +link-after-libc = $(+postctor) $(+postinit)
@@ -540,15 +531,12 @@ endif  # build-shared
 endif  # +link
 
 # Command for linking test programs with crt1.o from glibc 2.0.
-+link-2.0-before-inputs = -nostdlib -nostartfiles $(no-pie-ldflag) \
++link-2.0-before-inputs = -nodefaultlibs -normalcrt $(no-pie-ldflag) \
 	      $(sysdep-LDFLAGS) $(LDFLAGS) $(LDFLAGS-$(@F)) \
 	      $(relro-LDFLAGS) $(hashstyle-LDFLAGS) \
-	      $(firstword $(CRT-$(@F)) $(csu-objpfx)$(start-name-2.0)) \
 	      $(+preinit) $(+prector)
 +link-2.0-before-libc = -o $@ $(+link-2.0-before-inputs) \
-	      $(filter-out $(addprefix $(csu-objpfx),start.o \
-						     $(start-name-2.0))\
-			   $(+preinit) $(link-extra-libs) \
+	      $(filter-out $(+preinit) $(link-extra-libs) \
 			   $(common-objpfx)libc% $(+postinit),$^) \
 	      $(link-extra-libs)
 +link-after-libc = $(+postctor) $(+postinit)
@@ -574,8 +562,8 @@ CFLAGS-printers-tests := -O0 -ggdb3 -DIS_IN_build $(no-fortify-source)
 
 ifeq (yes,$(build-shared))
 # These indicate whether to link using the built ld.so or the installed one.
-installed-rtld-LDFLAGS = -Wl,-dynamic-linker=$(rtlddir)/$(rtld-installed-name)
-built-rtld-LDFLAGS = -Wl,-dynamic-linker=$(elf-objpfx)ld.so
+installed-rtld-LDFLAGS = 
+built-rtld-LDFLAGS = 
 
 ifndef rtld-LDFLAGS
 rtld-LDFLAGS = $(installed-rtld-LDFLAGS)
@@ -620,9 +608,7 @@ link-test-modules-rpath-link =
 endif  # build-hardcoded-path-in-tests
 
 link-libc-between-gnulib = $(common-objpfx)libc.so$(libc.so-version) \
-			   $(common-objpfx)$(patsubst %,$(libtype.oS),c) \
-			   -Wl,--as-needed $(elf-objpfx)ld.so \
-			   -Wl,--no-as-needed
+			   $(common-objpfx)$(patsubst %,$(libtype.oS),c)
 link-libc = $(link-libc-between-gnulib) $(gnulib)
 
 link-libc-tests-after-rpath-link = $(gnulib-tests) $(link-libc-between-gnulib) $(gnulib-tests)
@@ -705,39 +691,39 @@ ifneq ($(have-cc-with-libunwind),yes)
 else
   libunwind = -lunwind
 endif
-libgcc_eh := -Wl,--as-needed -lgcc_s $(libunwind) -Wl,--no-as-needed
+libgcc_eh := 
 gnulib-arch =
-gnulib = -lgcc $(gnulib-arch)
-gnulib-tests := -lgcc $(libgcc_eh)
+gnulib = $(gnulib-arch)
+gnulib-tests := $(libgcc_eh)
 static-gnulib-arch =
 # By default, elf/static-stubs.o, instead of -lgcc_eh, is used to
 # statically link programs.  When --disable-shared is used, we use
 # -lgcc_eh since elf/static-stubs.o isn't sufficient.
 ifeq (yes,$(build-shared))
-static-gnulib = -lgcc $(static-gnulib-arch)
+static-gnulib = $(static-gnulib-arch)
 else
-static-gnulib = -lgcc -lgcc_eh $(static-gnulib-arch)
+static-gnulib = $(static-gnulib-arch)
 endif
-static-gnulib-tests := -lgcc -lgcc_eh $(libunwind)
-libc.so-gnulib := -lgcc
+static-gnulib-tests := $(libunwind)
+libc.so-gnulib := 
 endif
-+preinit = $(addprefix $(csu-objpfx),crti.o)
-+postinit = $(addprefix $(csu-objpfx),crtn.o)
-+prector = `$(CC) $(sysdep-LDFLAGS) --print-file-name=crtbegin.o`
-+postctor = `$(CC) $(sysdep-LDFLAGS) --print-file-name=crtend.o`
++preinit = 
++postinit = 
++prector = 
++postctor = 
 # Variants of the two previous definitions for linking PIE programs.
-+prectorS = `$(CC) $(sysdep-LDFLAGS) --print-file-name=crtbeginS.o`
-+postctorS = `$(CC) $(sysdep-LDFLAGS) --print-file-name=crtendS.o`
++prectorS = 
++postctorS = 
 # Variants of the two previous definitions for statically linking programs.
-static-prector = `$(CC) $(sysdep-LDFLAGS) --print-file-name=crtbeginT.o`
-static-postctor = `$(CC) $(sysdep-LDFLAGS) --print-file-name=crtend.o`
+static-prector = 
+static-postctor = 
 ifeq (yes,$(enable-static-pie))
 # Static PIE must use PIE variants.
-+prectorT = $(if $($(@F)-no-pie),$(static-prector),$(+prectorS))
-+postctorT = $(if $($(@F)-no-pie),$(static-postctor),$(+postctorS))
++prectorT = 
++postctorT = 
 else
-+prectorT = $(static-prector)
-+postctorT =$(static-postctor)
++prectorT = 
++postctorT = 
 endif
 csu-objpfx = $(common-objpfx)csu/
 elf-objpfx = $(common-objpfx)elf/
diff --git a/Makefile b/Makefile
index c84f266ce74f..909132314fdd 100644
--- a/Makefile
+++ b/Makefile
@@ -98,13 +98,6 @@ install: subdir_install
 # Explicit dependency so that `make install-headers' works
 install-headers: install-headers-nosubdir
 
-# Make sure that the dynamic linker is installed before libc.
-$(inst_slibdir)/libc-$(version).so: elf/ldso_install
-
-.PHONY: elf/ldso_install
-elf/ldso_install:
-	$(MAKE) -C $(@D) $(@F)
-
 # Create links for shared libraries using the `ldconfig' program if possible.
 # Ignore the error if we cannot update /etc/ld.so.cache.
 ifeq (no,$(cross-compiling))
diff --git a/Makerules b/Makerules
index 275110dda82f..0c3dc22f6b4b 100644
--- a/Makerules
+++ b/Makerules
@@ -503,7 +503,7 @@ ifeq ($(build-shared),yes)
 map-file = $(firstword $($(@F:.so=-map)) \
 		       $(addprefix $(common-objpfx), \
 				   $(filter $(@F:.so=.map),$(version-maps))))
-load-map-file = $(map-file:%=-Wl,--version-script=%)
+load-map-file = $(map-file:%=--version-script=%)
 endif
 
 # Compiler arguments to use to link a shared object with libc and
@@ -512,7 +512,6 @@ endif
 link-libc-args = -Wl,--start-group \
 		 $(libc-for-link) \
 		 $(common-objpfx)libc_nonshared.a \
-		 -Wl,--as-needed $(elf-objpfx)ld.so -Wl,--no-as-needed \
 		 -Wl,--end-group
 
 # The corresponding shared libc to use.  This may be modified for a
@@ -523,7 +522,7 @@ libc-for-link = $(common-objpfx)libc.so
 # not just commands, they cannot use target-specific variables so need
 # to name both possible libc.so objects.
 link-libc-deps = $(common-objpfx)libc.so $(common-objpfx)linkobj/libc.so \
-		 $(common-objpfx)libc_nonshared.a $(elf-objpfx)ld.so
+		 $(common-objpfx)libc_nonshared.a
 
 # Pattern rule to build a shared object from an archive of PIC objects.
 # This must come after the installation rules so Make doesn't try to
@@ -536,7 +535,7 @@ lib%.so: lib%_pic.a $(+preinit) $(+postinit) $(link-libc-deps)
 	$(call after-link,$@)
 
 define build-shlib-helper
-$(LINK.o) -shared -static-libgcc -Wl,-O1 $(sysdep-LDFLAGS) \
+$(LINK.o) -shared -Wl,-O1 $(sysdep-LDFLAGS) \
 	  $(if $($(@F)-no-z-defs)$(no-z-defs),,-Wl,-z,defs) $(rtld-LDFLAGS) \
 	  $(if $($(@F)-no-dt-relr),$(no-dt-relr-ldflag),$(dt-relr-ldflag)) \
 	  $(extra-B-$(@F:lib%.so=%).so) -B$(csu-objpfx) \
@@ -582,25 +581,21 @@ endef
 build-module-helper-objlist = \
 	$(patsubst %_pic.a,$(whole-archive) %_pic.a $(no-whole-archive),\
 		   $(filter-out %.lds $(map-file) $(+preinit) $(+postinit) \
-				$(elf-objpfx)sofini.os \
 				$(link-libc-deps),$^))
 
 build-module-objlist = $(build-module-helper-objlist) $(LDLIBS-$(@F:%.so=%).so)
 build-shlib-objlist = $(build-module-helper-objlist) \
-		      $(LDLIBS-$(@F:lib%.so=%).so) \
-		      $(filter $(elf-objpfx)sofini.os,$^)
+		      $(LDLIBS-$(@F:lib%.so=%).so)
 
 # Don't try to use -lc when making libc.so itself.
 # Also omits crti.o and crtn.o, which we do not want
 # since we define our own `.init' section specially.
-LDFLAGS-c.so = -nostdlib -nostartfiles
+LDFLAGS-c.so = -nodefaultlibs
 # But we still want to link libc.so against $(libc.so-gnulib).
 LDLIBS-c.so += $(libc.so-gnulib)
-# Give libc.so an entry point and make it directly runnable itself.
-LDFLAGS-c.so += -e __libc_main
 # Pre-link the objects of libc_pic.a for .gnu.glibc-stub.* processing.
 $(common-objpfx)libc_pic.os: $(common-objpfx)libc_pic.a
-	$(LINK.o) -nostdlib -nostartfiles -r -o $@ \
+	$(LINK.o) -nodefaultlibs -r -o $@ \
 	$(LDFLAGS-c_pic.os) $(whole-archive) $^ -o $@
 
 # Generate a list of -R options to excise .gnu.glibc-stub.* sections.
@@ -642,17 +637,11 @@ $(common-objpfx)linkobj/libc.so: link-libc-deps = # empty
 
 # Use our own special initializer and finalizer files for the libc.so
 # libraries.
-$(common-objpfx)libc.so: $(common-objpfx)libc_pic.os$(libc_pic_clean) \
-			 $(elf-objpfx)sofini.os \
-			 $(elf-objpfx)interp.os \
-			 $(elf-objpfx)ld.so
+$(common-objpfx)libc.so: $(common-objpfx)libc_pic.a
 	$(build-shlib)
 	$(call after-link,$@)
 
-$(common-objpfx)linkobj/libc.so: $(common-objpfx)linkobj/libc_pic.a \
-			 $(elf-objpfx)sofini.os \
-			 $(elf-objpfx)interp.os \
-			 $(elf-objpfx)ld.so
+$(common-objpfx)linkobj/libc.so: $(common-objpfx)linkobj/libc_pic.a
 	$(build-shlib)
 	$(call after-link,$@)
 
@@ -992,7 +981,7 @@ install: $(inst_slibdir)/libc.so$(libc.so-version)
 $(common-objpfx)format.lds: $(common-objpfx)config.make \
 			    $(common-objpfx)config.h $(..)Makerules
 	$(LINK.o) -shared -nostdlib -nostartfiles \
-		  -x assembler /dev/null -o $@.so
+		  /dev/null -o $@.so
 	$(OBJDUMP) -f $@.so | sed -n 's/.*file format \(.*\)/OUTPUT_FORMAT(\1)/;T;p' > $@
 	rm -f $@.so
 common-generated += format.lds
@@ -1016,7 +1005,7 @@ $(inst_libdir)/libc.so: $(common-objpfx)format.lds \
 	 cat $<; \
 	 echo 'GROUP ( $(slibdir)/libc.so$(libc.so-version)' \
 	      '$(libdir)/$(patsubst %,$(libtype.oS),$(libprefix)$(libc-name))'\
-	      ' AS_NEEDED (' $(rtlddir)/$(rtld-installed-name) ') )' \
+	      ' )' \
 	) > $@.new
 	mv -f $@.new $@
 
diff --git a/Rules b/Rules
index 9010c5d5b269..32b91c9a94ba 100644
--- a/Rules
+++ b/Rules
@@ -225,7 +225,7 @@ binaries-shared-notests = $(filter-out $(binaries-pie) $(binaries-static), \
 ifneq "$(strip $(binaries-shared-notests))" ""
 $(addprefix $(objpfx),$(binaries-shared-notests)): %: %.o \
   $(sort $(filter $(common-objpfx)lib%,$(link-libc))) \
-  $(addprefix $(csu-objpfx),start.o) $(+preinit) $(+postinit)
+  $(+preinit) $(+postinit)
 	$(+link)
 endif
 
@@ -233,7 +233,7 @@ ifneq "$(strip $(binaries-shared-tests))" ""
 $(addprefix $(objpfx),$(binaries-shared-tests)): %: %.o \
   $(link-extra-libs-tests) \
   $(sort $(filter $(common-objpfx)lib%,$(link-libc))) \
-  $(addprefix $(csu-objpfx),start.o) $(+preinit) $(+postinit)
+  $(+preinit) $(+postinit)
 	$(+link-tests)
 endif
 
@@ -242,7 +242,7 @@ ifneq "$(strip $(binaries-shared-2.0-tests))" ""
 $(addprefix $(objpfx),$(binaries-shared-2.0-tests)): %: %.o \
   $(link-extra-libs-tests) \
   $(sort $(filter $(common-objpfx)lib%,$(link-libc))) \
-  $(addprefix $(csu-objpfx),start.o) $(+preinit) $(+postinit)
+  $(+preinit) $(+postinit)
 	$(+link-2.0-tests)
 endif
 
@@ -251,7 +251,7 @@ $(addprefix $(objpfx),$(binaries-mcheck-tests)): %-mcheck: %.o \
   $(link-extra-libs-tests) \
   $(sort $(filter $(common-objpfx)lib%,$(link-libc))) \
   $(common-objpfx)malloc/libmcheck.a \
-  $(addprefix $(csu-objpfx),start.o) $(+preinit) $(+postinit)
+  $(+preinit) $(+postinit)
 	$(+link-tests)
 endif
 
@@ -259,7 +259,7 @@ ifneq "$(strip $(binaries-malloc-check-tests))" ""
 $(addprefix $(objpfx),$(binaries-malloc-check-tests)): %-malloc-check: %.o \
   $(link-extra-libs-tests) \
   $(sort $(filter $(common-objpfx)lib%,$(link-libc))) \
-  $(addprefix $(csu-objpfx),start.o) $(+preinit) $(+postinit)
+  $(+preinit) $(+postinit)
 	$(+link-tests)
 endif
 
@@ -267,7 +267,7 @@ ifneq "$(strip $(binaries-malloc-hugetlb1-tests))" ""
 $(addprefix $(objpfx),$(binaries-malloc-hugetlb1-tests)): %-malloc-hugetlb1: %.o \
   $(link-extra-libs-tests) \
   $(sort $(filter $(common-objpfx)lib%,$(link-libc))) \
-  $(addprefix $(csu-objpfx),start.o) $(+preinit) $(+postinit)
+  $(+preinit) $(+postinit)
 	$(+link-tests)
 endif
 
@@ -275,7 +275,7 @@ ifneq "$(strip $(binaries-malloc-hugetlb2-tests))" ""
 $(addprefix $(objpfx),$(binaries-malloc-hugetlb2-tests)): %-malloc-hugetlb2: %.o \
   $(link-extra-libs-tests) \
   $(sort $(filter $(common-objpfx)lib%,$(link-libc))) \
-  $(addprefix $(csu-objpfx),start.o) $(+preinit) $(+postinit)
+  $(+preinit) $(+postinit)
 	$(+link-tests)
 endif
 
@@ -283,21 +283,21 @@ ifneq "$(strip $(binaries-pie-tests))" ""
 $(addprefix $(objpfx),$(binaries-pie-tests)): %: %.o \
   $(link-extra-libs-tests) \
   $(sort $(filter $(common-objpfx)lib%,$(link-libc))) \
-  $(addprefix $(csu-objpfx),start.o) $(+preinit) $(+postinit)
+  $(+preinit) $(+postinit)
 	$(+link-pie-tests)
 endif
 
 ifneq "$(strip $(binaries-pie-notests))" ""
 $(addprefix $(objpfx),$(binaries-pie-notests)): %: %.o \
   $(sort $(filter $(common-objpfx)lib%,$(link-libc))) \
-  $(addprefix $(csu-objpfx),start.o) $(+preinit) $(+postinit)
+  $(+preinit) $(+postinit)
 	$(+link-pie)
 endif
 
 ifneq "$(strip $(binaries-static-notests))" ""
 $(addprefix $(objpfx),$(binaries-static-notests)): %: %.o \
   $(sort $(filter $(common-objpfx)lib%,$(link-libc-static))) \
-  $(addprefix $(csu-objpfx),start.o) $(+preinit) $(+postinit)
+  $(+preinit) $(+postinit)
 	$(+link-static)
 endif
 
@@ -305,7 +305,7 @@ ifneq "$(strip $(binaries-static-tests))" ""
 $(addprefix $(objpfx),$(binaries-static-tests)): %: %.o \
   $(link-extra-libs-tests) \
   $(sort $(filter $(common-objpfx)lib%,$(link-libc-static-tests))) \
-  $(addprefix $(csu-objpfx),start.o) $(+preinit) $(+postinit)
+  $(+preinit) $(+postinit)
 	$(+link-static-tests)
 endif
 
@@ -380,7 +380,7 @@ ifneq "$(strip $(tests-printers))" ""
 # Static pattern rule for building the test programs for the pretty printers.
 $(tests-printers-programs): %: %.o $(tests-printers-libs) \
   $(sort $(filter $(common-objpfx)lib%,$(link-libc-static-tests))) \
-  $(addprefix $(csu-objpfx),start.o) $(+preinit) $(+postinit)
+  $(+preinit) $(+postinit)
 	$(+link-printers-tests)
 
 # Add the paths to the generated constants file and test_common_printers.py
diff --git a/bits/dlfcn.h b/bits/dlfcn.h
index dd5bb46a182d..f944f8ce5bd5 100644
--- a/bits/dlfcn.h
+++ b/bits/dlfcn.h
@@ -57,7 +57,7 @@
 __BEGIN_DECLS
 
 /* This function calls the profiling functions.  */
-extern void _dl_mcount_wrapper_check (void *__selfpc) __THROW;
+static inline void _dl_mcount_wrapper_check (void *__selfpc) { }
 
 __END_DECLS
 
diff --git a/catgets/config.h b/catgets/config.h
index ce7887b3512f..dbde3b7b7f24 100644
--- a/catgets/config.h
+++ b/catgets/config.h
@@ -9,6 +9,6 @@
 #endif
 
 
-#include_next <config.h>
+#include <config.h>
 
 #endif
diff --git a/configure.ac b/configure.ac
index 9cbc0bf68f19..ef862e7a7f0a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -562,7 +562,6 @@ AC_CHECK_PROG_VER(BISON, bison, --version,
 AC_CACHE_CHECK([if $CC is sufficient to build libc], libc_cv_compiler_ok, [
 AC_PREPROC_IFELSE([AC_LANG_PROGRAM([[]], [[
 #if !defined __GNUC__ || __GNUC__ < 6 || (__GNUC__ == 6 && __GNUC_MINOR__ < 2)
-#error insufficient compiler
 #endif]])],
 	       [libc_cv_compiler_ok=yes],
 	       [libc_cv_compiler_ok=no])])
@@ -728,9 +727,7 @@ EOF
 libc_cv_gcc_indirect_function=no
 if ${CC-cc} -c conftest.c -o conftest.o 1>&AS_MESSAGE_LOG_FD \
    2>&AS_MESSAGE_LOG_FD ; then
-  if $READELF -s conftest.o | grep IFUNC >/dev/null 2>&AS_MESSAGE_LOG_FD; then
-    libc_cv_gcc_indirect_function=yes
-  fi
+  libc_cv_gcc_indirect_function=yes
 fi
 rm -f conftest*])
 
@@ -1412,9 +1409,9 @@ else
   libc_cv_gcc_builtin_redirection=no
 fi
 rm -f conftest* ])
-if test "$libc_cv_gcc_builtin_redirection" = no; then
-  AC_MSG_ERROR([support for the symbol redirection needed])
-fi
+dnl if test "$libc_cv_gcc_builtin_redirection" = no; then
+dnl   AC_MSG_ERROR([support for the symbol redirection needed])
+dnl fi
 
 dnl Determine how to disable generation of FMA instructions.
 AC_CACHE_CHECK([for compiler option to disable generation of FMA instructions],
diff --git a/csu/Makefile b/csu/Makefile
index 777d6720a70b..10dc2eb0c56b 100644
--- a/csu/Makefile
+++ b/csu/Makefile
@@ -33,29 +33,18 @@ routines = \
   init-first \
   libc-start \
   libc-tls \
-  sysdep \
   version \
   # routines
 aux	 = errno
-elide-routines.os = libc-tls
-csu-dummies = $(filter-out $(start-installed-name),crt1.o Mcrt1.o)
-extra-objs = \
-  $(csu-dummies) \
-  $(start-installed-name) \
-  $(start-name-2.0) \
-  S$(start-installed-name) \
-  g$(start-installed-name) \
-  start.o \
-  # extra-objs
+elide-routines.os = 
+csu-dummies = 
+extra-objs = 
 omit-deps = $(patsubst %.o,%,$(start-installed-name) g$(start-installed-name) \
 			     b$(start-installed-name) $(csu-dummies) \
 			     S$(start-installed-name) \
 			     r$(start-installed-name) \
 			     gr$(start-installed-name))
 install-lib = \
-  $(csu-dummies) \
-  $(start-installed-name) \
-  g$(start-installed-name) \
   # install-lib
 
 # No tests are allowed in the csu/ subdirectory because the startup
@@ -85,54 +74,16 @@ CFLAGS-.os += $(call elide-stack-protector,.os,$(filter-out \
 
 ifeq (yes,$(build-shared))
 extra-objs += \
-  S$(start-installed-name) \
   gmon-start.os \
   # extra-objs
 ifneq ($(start-installed-name),$(static-start-installed-name))
 extra-objs += gmon-start.o
 endif
-install-lib += S$(start-installed-name)
 generated += start.os
 else
 extra-objs += gmon-start.o
 endif
 
-ifeq (yes,$(enable-static-pie))
-extra-objs += \
-  gr$(start-installed-name) \
-  r$(start-installed-name) \
-  # extra-objs
-install-lib += \
-  gr$(start-installed-name) \
-  r$(start-installed-name) \
-  # install-lib
-endif
-
-ifneq ($(start-installed-name),$(static-start-installed-name))
-extra-objs += \
-  $(static-start-installed-name) \
-  g$(static-start-installed-name) \
-  # extra-objs
-omit-deps += $(patsubst %.o,%,$(static-start-installed-name) \
-			     g$(static-start-installed-name))
-install-lib += \
-  $(static-start-installed-name) \
-  g$(static-start-installed-name) \
-  # install-lib
-ifeq (yes,$(enable-static-pie))
-extra-objs += \
-  gr$(static-start-installed-name) \
-  r$(static-start-installed-name) \
-  # extra-objs
-omit-deps += $(patsubst %.o,%,r$(static-start-installed-name) \
-			     gr$(static-start-installed-name))
-install-lib += \
-  gr$(static-start-installed-name) \
-  r$(static-start-installed-name) \
-  # install-lib
-endif
-endif
-
 before-compile += $(objpfx)abi-tag.h
 generated += abi-tag.h
 
@@ -142,10 +93,7 @@ gen-as-const-headers += rtld-sizes.sym
 # These are the special initializer/finalizer files.  They are always the
 # first and last file in the link.  crti.o ... crtn.o define the global
 # "functions" _init and _fini to run the .init and .fini sections.
-crtstuff = \
-  crti \
-  crtn \
-  # crtstuff
+crtstuff = 
 
 install-lib += $(crtstuff:=.o)
 extra-objs += $(crtstuff:=.o)
diff --git a/csu/dso_handle.c b/csu/dso_handle.c
index 2d4dc8c8700b..3b444da03b2b 100644
--- a/csu/dso_handle.c
+++ b/csu/dso_handle.c
@@ -17,5 +17,5 @@
 
 /* We have to define __dso_handle ourselves since we do not use gcc's
    crtbegin files.  */
-const void *const __dso_handle __attribute__ ((__visibility__ ("hidden")))
-  = &__dso_handle;
+//const void *const __dso_handle __attribute__ ((__visibility__ ("hidden")))
+//  = &__dso_handle;
diff --git a/csu/init-first.c b/csu/init-first.c
index a2cb456ccf9a..0ff2327ab44c 100644
--- a/csu/init-first.c
+++ b/csu/init-first.c
@@ -46,28 +46,11 @@ _init_first (int argc, char **argv, char **envp)
 {
 #endif
 
-  /* Make sure we don't initialize twice.  */
-#ifdef SHARED
-  if (__libc_initial)
-    {
-      /* Set the FPU control word to the proper default value if the
-	 kernel would use a different value.  */
-      if (__fpu_control != GLRO(dl_fpu_control))
-	__setfpucw (__fpu_control);
-    }
-#endif
-
   /* Save the command-line arguments.  */
   __libc_argc = argc;
   __libc_argv = argv;
   __environ = envp;
 
-#ifndef SHARED
-  /* First the initialization which normally would be done by the
-     dynamic linker.  */
-  _dl_non_dynamic_init ();
-#endif
-
   __init_misc (argc, argv, envp);
 }
 
diff --git a/csu/libc-start.c b/csu/libc-start.c
index d784de0f0bdd..744908d99d77 100644
--- a/csu/libc-start.c
+++ b/csu/libc-start.c
@@ -36,9 +36,13 @@
 #include <stdbool.h>
 #include <elf-initfini.h>
 #include <shlib-compat.h>
+#include <dlfcn/dlerror.h>
+#include <errno.h>
 
 #include <elf/dl-tunables.h>
 
+#include <pizlonated_runtime.h>
+
 extern void __libc_init_first (int argc, char **argv, char **envp);
 
 #include <tls.h>
@@ -56,51 +60,6 @@ uintptr_t __pointer_chk_guard_local attribute_relro attribute_hidden;
 # endif
 #endif
 
-#ifndef SHARED
-# include <link.h>
-# include <dl-irel.h>
-
-# ifdef ELF_MACHINE_IRELA
-#  define IREL_T	ElfW(Rela)
-#  define IPLT_START	__rela_iplt_start
-#  define IPLT_END	__rela_iplt_end
-#  define IREL		elf_irela
-# elif defined ELF_MACHINE_IREL
-#  define IREL_T	ElfW(Rel)
-#  define IPLT_START	__rel_iplt_start
-#  define IPLT_END	__rel_iplt_end
-#  define IREL		elf_irel
-# endif
-
-static void
-apply_irel (void)
-{
-# ifdef IREL
-  /* We use weak references for these so that we'll still work with a linker
-     that doesn't define them.  Such a linker doesn't support IFUNC at all
-     and so uses won't work, but a statically-linked program that doesn't
-     use any IFUNC symbols won't have a problem.  */
-  extern const IREL_T IPLT_START[] __attribute__ ((weak));
-  extern const IREL_T IPLT_END[] __attribute__ ((weak));
-  for (const IREL_T *ipltent = IPLT_START; ipltent < IPLT_END; ++ipltent)
-    IREL (ipltent);
-# endif
-}
-#endif
-
-
-#ifdef LIBC_START_MAIN
-# ifdef LIBC_START_DISABLE_INLINE
-#  define STATIC static
-# else
-#  define STATIC static inline __attribute__ ((always_inline))
-# endif
-# define DO_DEFINE_LIBC_START_MAIN_VERSION 0
-#else
-# define STATIC
-# define LIBC_START_MAIN __libc_start_main_impl
-# define DO_DEFINE_LIBC_START_MAIN_VERSION 1
-#endif
 
 #ifdef MAIN_AUXVEC_ARG
 /* main gets passed a pointer to the auxiliary.  */
@@ -118,212 +77,66 @@ apply_irel (void)
 /* Obtain the definition of __libc_start_call_main.  */
 #include <libc_start_call_main.h>
 
-#ifdef SHARED
-/* Initialization for dynamic executables.  Find the main executable
-   link map and run its init functions.  */
-static void
-call_init (int argc, char **argv, char **env)
-{
-  /* Obtain the main map of the executable.  */
-  struct link_map *l = GL(dl_ns)[LM_ID_BASE]._ns_loaded;
-
-  /* DT_PREINIT_ARRAY is not processed here.  It is already handled in
-     _dl_init in elf/dl-init.c.  Also see the call_init function in
-     the same file.  */
-
-  if (ELF_INITFINI && l->l_info[DT_INIT] != NULL)
-    DL_CALL_DT_INIT(l, l->l_addr + l->l_info[DT_INIT]->d_un.d_ptr,
-		    argc, argv, env);
-
-  ElfW(Dyn) *init_array = l->l_info[DT_INIT_ARRAY];
-  if (init_array != NULL)
-    {
-      unsigned int jm
-	= l->l_info[DT_INIT_ARRAYSZ]->d_un.d_val / sizeof (ElfW(Addr));
-      ElfW(Addr) *addrs = (void *) (init_array->d_un.d_ptr + l->l_addr);
-      for (unsigned int j = 0; j < jm; ++j)
-	((dl_init_t) addrs[j]) (argc, argv, env);
-    }
-}
-
-#else /* !SHARED */
-
-/* These magic symbols are provided by the linker.  */
-extern void (*__preinit_array_start []) (int, char **, char **)
-  attribute_hidden;
-extern void (*__preinit_array_end []) (int, char **, char **)
-  attribute_hidden;
-extern void (*__init_array_start []) (int, char **, char **)
-  attribute_hidden;
-extern void (*__init_array_end []) (int, char **, char **)
-  attribute_hidden;
-extern void (*__fini_array_start []) (void) attribute_hidden;
-extern void (*__fini_array_end []) (void) attribute_hidden;
+#include <libc-start.h>
 
-# if ELF_INITFINI
-/* These function symbols are provided for the .init/.fini section entry
-   points automagically by the linker.  */
-extern void _init (void);
-extern void _fini (void);
-# endif
+int __libc_start_main (int (*main) (int, char **, char **
+					 MAIN_AUXVEC_DECL),
+                       int argc,
+                       char **argv,
+                       char **ev,
+                       ElfW(auxv_t) *auxvec)
+     __attribute__ ((noreturn));
 
-/* Initialization for static executables.  There is no dynamic
-   segment, so we access the symbols directly.  */
-static void
-call_init (int argc, char **argv, char **envp)
+static void errno_handler(int errno_value)
 {
-  /* For static executables, preinit happens right before init.  */
-  {
-    const size_t size = __preinit_array_end - __preinit_array_start;
-    size_t i;
-    for (i = 0; i < size; i++)
-      (*__preinit_array_start [i]) (argc, argv, envp);
-  }
-
-# if ELF_INITFINI
-  _init ();
-# endif
-
-  const size_t size = __init_array_end - __init_array_start;
-  for (size_t i = 0; i < size; i++)
-      (*__init_array_start [i]) (argc, argv, envp);
+  errno = errno_value;
 }
 
-/* Likewise for the destructor.  */
-static void
-call_fini (void *unused)
+static void dlerror_handler(const char* str)
 {
-  size_t i = __fini_array_end - __fini_array_start;
-  while (i-- > 0)
-    (*__fini_array_start [i]) ();
-
-# if ELF_INITFINI
-  _fini ();
-# endif
+  __libc_dlerror_result_string = (char*)str;
 }
 
-#endif /* !SHARED */
-
-#include <libc-start.h>
-
-STATIC int LIBC_START_MAIN (int (*main) (int, char **, char **
-					 MAIN_AUXVEC_DECL),
-			    int argc,
-			    char **argv,
-#ifdef LIBC_START_MAIN_AUXVEC_ARG
-			    ElfW(auxv_t) *auxvec,
-#endif
-			    __typeof (main) init,
-			    void (*fini) (void),
-			    void (*rtld_fini) (void),
-			    void *stack_end)
-     __attribute__ ((noreturn));
-
-
-/* Note: The init and fini parameters are no longer used.  fini is
-   completely unused, init is still called if not NULL, but the
-   current startup code always passes NULL.  (In the future, it would
-   be possible to use fini to pass a version code if init is NULL, to
-   indicate the link-time glibc without introducing a hard
-   incompatibility for new programs with older glibc versions.)
-
-   For dynamically linked executables, the dynamic segment is used to
-   locate constructors and destructors.  For statically linked
-   executables, the relevant symbols are access directly.  */
-STATIC int
-LIBC_START_MAIN (int (*main) (int, char **, char ** MAIN_AUXVEC_DECL),
-		 int argc, char **argv,
-#ifdef LIBC_START_MAIN_AUXVEC_ARG
-		 ElfW(auxv_t) *auxvec,
-#endif
-		 __typeof (main) init,
-		 void (*fini) (void),
-		 void (*rtld_fini) (void), void *stack_end)
+int
+__libc_start_main (int (*main) (int, char **, char ** MAIN_AUXVEC_DECL),
+                   int argc, char **argv,
+                   char **ev,
+                   ElfW(auxv_t) *auxvec)
 {
-#ifndef SHARED
-  char **ev = &argv[argc + 1];
-
+  zmake_setjmp_save_sigmask(true);
+  
   __environ = ev;
+  GLRO(dl_auxv) = auxvec;
 
-  /* Store the lowest stack address.  This is done in ld.so if this is
-     the code for the DSO.  */
-  __libc_stack_end = stack_end;
-
-# ifdef HAVE_AUX_VECTOR
-  /* First process the auxiliary vector since we need to find the
-     program header to locate an eventually present PT_TLS entry.  */
-#  ifndef LIBC_START_MAIN_AUXVEC_ARG
-  ElfW(auxv_t) *auxvec;
-  {
-    char **evp = ev;
-    while (*evp++ != NULL)
-      ;
-    auxvec = (ElfW(auxv_t) *) evp;
-  }
-#  endif
-  _dl_aux_init (auxvec);
-# endif
-
-  __tunables_init (__environ);
-
-  ARCH_INIT_CPU_FEATURES ();
-
-  /* Do static pie self relocation after tunables and cpu features
-     are setup for ifunc resolvers. Before this point relocations
-     must be avoided.  */
-  _dl_relocate_static_pie ();
-
-  /* Perform IREL{,A} relocations.  */
-  ARCH_SETUP_IREL ();
-
-  /* The stack guard goes into the TCB, so initialize it early.  */
-  ARCH_SETUP_TLS ();
-
-  /* In some architectures, IREL{,A} relocations happen after TLS setup in
-     order to let IFUNC resolvers benefit from TCB information, e.g. powerpc's
-     hwcap and platform fields available in the TCB.  */
-  ARCH_APPLY_IREL ();
-
-  /* Set up the stack checker's canary.  */
-  uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);
-# ifdef THREAD_SET_STACK_GUARD
-  THREAD_SET_STACK_GUARD (stack_chk_guard);
-# else
-  __stack_chk_guard = stack_chk_guard;
-# endif
+  ElfW(auxv_t) *av;
+  for (av = auxvec; av->a_type != AT_NULL; av++)
+    if (av->a_type == AT_SECURE)
+      {
+        __libc_enable_secure = av->a_un.a_val;
+        break;
+      }
 
   /* Initialize libpthread if linked in.  */
   if (__pthread_initialize_minimal != NULL)
     __pthread_initialize_minimal ();
 
-  /* Set up the pointer guard value.  */
-  uintptr_t pointer_chk_guard = _dl_setup_pointer_guard (_dl_random,
-							 stack_chk_guard);
-# ifdef THREAD_SET_POINTER_GUARD
-  THREAD_SET_POINTER_GUARD (pointer_chk_guard);
-# else
-  __pointer_chk_guard_local = pointer_chk_guard;
-# endif
-
-#endif /* !SHARED  */
-
-  /* Register the destructor of the dynamic linker if there is any.  */
-  if (__glibc_likely (rtld_fini != NULL))
-    __cxa_atexit ((void (*) (void *)) rtld_fini, NULL, NULL);
+  ARCH_INIT_CPU_FEATURES ();
 
-#ifndef SHARED
+  ARCH_SETUP_TLS ();
+  
   /* Perform early initialization.  In the shared case, this function
      is called from the dynamic loader as early as possible.  */
   __libc_early_init (true);
 
+  zregister_sys_errno_handler(errno_handler);
+  zregister_sys_dlerror_handler(dlerror_handler);
+
+#ifndef SHARED
   /* Call the initializer of the libc.  This is only needed here if we
      are compiling for the static library in which case we haven't
      run the constructors in `_dl_start_user'.  */
   __libc_init_first (argc, argv, __environ);
 
-  /* Register the destructor of the statically-linked program.  */
-  __cxa_atexit (call_fini, NULL, NULL);
-
   /* Some security at this point.  Prevent starting a SUID binary where
      the standard file descriptors are not opened.  We have to do this
      only for statically linked applications since otherwise the dynamic
@@ -335,60 +148,16 @@ LIBC_START_MAIN (int (*main) (int, char **, char ** MAIN_AUXVEC_DECL),
   /* Call the initializer of the program, if any.  */
 #ifdef SHARED
   if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_IMPCALLS, 0))
-    GLRO(dl_debug_printf) ("\ninitialize program: %s\n\n", argv[0]);
-
-  if (init != NULL)
-    /* This is a legacy program which supplied its own init
-       routine.  */
-    (*init) (argc, argv, __environ MAIN_AUXVEC_PARAM);
-  else
-    /* This is a current program.  Use the dynamic segment to find
-       constructors.  */
-    call_init (argc, argv, __environ);
+    zprintf ("\ninitialize program: %s\n\n", argv[0]);
 
-  /* Auditing checkpoint: we have a new object.  */
-  _dl_audit_preinit (GL(dl_ns)[LM_ID_BASE]._ns_loaded);
+  zrun_deferred_global_ctors();
 
   if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_IMPCALLS))
-    GLRO(dl_debug_printf) ("\ntransferring control: %s\n\n", argv[0]);
+    zprintf ("\ntransferring control: %s\n\n", argv[0]);
 #else /* !SHARED */
-  call_init (argc, argv, __environ);
-
-  _dl_debug_initialize (0, LM_ID_BASE);
+  zrun_deferred_global_ctors();
 #endif
 
   __libc_start_call_main (main, argc, argv MAIN_AUXVEC_PARAM);
 }
 
-/* Starting with glibc 2.34, the init parameter is always NULL.  Older
-   libcs are not prepared to handle that.  The macro
-   DEFINE_LIBC_START_MAIN_VERSION creates GLIBC_2.34 alias, so that
-   newly linked binaries reflect that dependency.  The macros below
-   expect that the exported function is called
-   __libc_start_main_impl.  */
-#ifdef SHARED
-# define DEFINE_LIBC_START_MAIN_VERSION \
-  DEFINE_LIBC_START_MAIN_VERSION_1 \
-  strong_alias (__libc_start_main_impl, __libc_start_main_alias_2)	\
-  versioned_symbol (libc, __libc_start_main_alias_2, __libc_start_main, \
-		    GLIBC_2_34);
-
-# if SHLIB_COMPAT(libc, GLIBC_2_0, GLIBC_2_34)
-#  define DEFINE_LIBC_START_MAIN_VERSION_1 \
-  strong_alias (__libc_start_main_impl, __libc_start_main_alias_1)	\
-  compat_symbol (libc, __libc_start_main_alias_1, __libc_start_main, GLIBC_2_0);
-#  else
-#  define DEFINE_LIBC_START_MAIN_VERSION_1
-# endif
-#else  /* !SHARED */
-/* Enable calling the function under its exported name.  */
-# define DEFINE_LIBC_START_MAIN_VERSION \
-  strong_alias (__libc_start_main_impl, __libc_start_main)
-#endif
-
-/* Only define the version information if LIBC_START_MAIN was not set.
-   If there is a wrapper file, it must expand
-   DEFINE_LIBC_START_MAIN_VERSION on its own.  */
-#if DO_DEFINE_LIBC_START_MAIN_VERSION
-DEFINE_LIBC_START_MAIN_VERSION
-#endif
diff --git a/csu/libc-tls.c b/csu/libc-tls.c
index b7682bdf4330..febd31084084 100644
--- a/csu/libc-tls.c
+++ b/csu/libc-tls.c
@@ -26,194 +26,11 @@
 #include <array_length.h>
 #include <pthreadP.h>
 #include <dl-call_tls_init_tp.h>
-
-#ifdef SHARED
- #error makefile bug, this file is for static only
-#endif
-
-dtv_t _dl_static_dtv[2 + TLS_SLOTINFO_SURPLUS];
-
-
-static struct dtv_slotinfo_list static_slotinfo =
-  {
-   /* Allocate an array of 2 + TLS_SLOTINFO_SURPLUS elements.  */
-   .slotinfo =  { [array_length (_dl_static_dtv) - 1] = { 0 } },
-  };
-
-/* Highest dtv index currently needed.  */
-size_t _dl_tls_max_dtv_idx;
-/* Flag signalling whether there are gaps in the module ID allocation.  */
-bool _dl_tls_dtv_gaps;
-/* Information about the dtv slots.  */
-struct dtv_slotinfo_list *_dl_tls_dtv_slotinfo_list;
-/* Number of modules in the static TLS block.  */
-size_t _dl_tls_static_nelem;
-/* Size of the static TLS block.  */
-size_t _dl_tls_static_size;
-/* Size actually allocated in the static TLS block.  */
-size_t _dl_tls_static_used;
-/* Alignment requirement of the static TLS block.  */
-size_t _dl_tls_static_align;
-/* Size of surplus space in the static TLS area for dynamically
-   loaded modules with IE-model TLS or for TLSDESC optimization.
-   See comments in elf/dl-tls.c where it is initialized.  */
-size_t _dl_tls_static_surplus;
-/* Remaining amount of static TLS that may be used for optimizing
-   dynamic TLS access (e.g. with TLSDESC).  */
-size_t _dl_tls_static_optional;
-
-/* Generation counter for the dtv.  */
-size_t _dl_tls_generation;
-
-
-/* Additional definitions needed by TLS initialization.  */
-#ifdef TLS_INIT_HELPER
-TLS_INIT_HELPER
-#endif
-
-static void
-init_slotinfo (void)
-{
-  /* Create the slotinfo list.  Note that the type of static_slotinfo
-     has effectively a zero-length array, so we cannot use the size of
-     static_slotinfo to determine the array length.  */
-  static_slotinfo.len = array_length (_dl_static_dtv);
-  /* static_slotinfo.next = NULL; -- Already zero.  */
-
-  /* The slotinfo list.  Will be extended by the code doing dynamic
-     linking.  */
-  GL(dl_tls_max_dtv_idx) = 1;
-  GL(dl_tls_dtv_slotinfo_list) = &static_slotinfo;
-}
-
-static void
-init_static_tls (size_t memsz, size_t align)
-{
-  /* That is the size of the TLS memory for this object.  */
-  GL(dl_tls_static_size) = roundup (memsz + GLRO(dl_tls_static_surplus),
-				    TCB_ALIGNMENT);
-#if TLS_TCB_AT_TP
-  GL(dl_tls_static_size) += TLS_TCB_SIZE;
-#endif
-  GL(dl_tls_static_used) = memsz;
-  /* The alignment requirement for the static TLS block.  */
-  GL(dl_tls_static_align) = align;
-  /* Number of elements in the static TLS block.  */
-  GL(dl_tls_static_nelem) = GL(dl_tls_max_dtv_idx);
-}
+#include <stdfil.h>
 
 void
 __libc_setup_tls (void)
 {
-  void *tlsblock;
-  size_t memsz = 0;
-  size_t filesz = 0;
-  void *initimage = NULL;
-  size_t align = 0;
-  size_t max_align = TCB_ALIGNMENT;
-  size_t tcb_offset;
-  const ElfW(Phdr) *phdr;
-
-  struct link_map *main_map = GL(dl_ns)[LM_ID_BASE]._ns_loaded;
-
-  __tls_pre_init_tp ();
-
-  /* Look through the TLS segment if there is any.  */
-  for (phdr = _dl_phdr; phdr < &_dl_phdr[_dl_phnum]; ++phdr)
-    if (phdr->p_type == PT_TLS)
-      {
-	/* Remember the values we need.  */
-	memsz = phdr->p_memsz;
-	filesz = phdr->p_filesz;
-	initimage = (void *) phdr->p_vaddr + main_map->l_addr;
-	align = phdr->p_align;
-	if (phdr->p_align > max_align)
-	  max_align = phdr->p_align;
-	break;
-      }
-
-  /* Calculate the size of the static TLS surplus, with 0 auditors.  */
-  _dl_tls_static_surplus_init (0);
-
-  /* We have to set up the TCB block which also (possibly) contains
-     'errno'.  Therefore we avoid 'malloc' which might touch 'errno'.
-     Instead we use 'sbrk' which would only uses 'errno' if it fails.
-     In this case we are right away out of memory and the user gets
-     what she/he deserves.  */
-#if TLS_TCB_AT_TP
-  /* Align the TCB offset to the maximum alignment, as
-     _dl_allocate_tls_storage (in elf/dl-tls.c) does using __libc_memalign
-     and dl_tls_static_align.  */
-  tcb_offset = roundup (memsz + GLRO(dl_tls_static_surplus), max_align);
-  tlsblock = _dl_early_allocate (tcb_offset + TLS_INIT_TCB_SIZE + max_align);
-  if (tlsblock == NULL)
-    _startup_fatal_tls_error ();
-#elif TLS_DTV_AT_TP
-  tcb_offset = roundup (TLS_INIT_TCB_SIZE, align ?: 1);
-  tlsblock = _dl_early_allocate (tcb_offset + memsz + max_align
-				 + TLS_PRE_TCB_SIZE
-				 + GLRO(dl_tls_static_surplus));
-  if (tlsblock == NULL)
-    _startup_fatal_tls_error ();
-  tlsblock += TLS_PRE_TCB_SIZE;
-#else
-  /* In case a model with a different layout for the TCB and DTV
-     is defined add another #elif here and in the following #ifs.  */
-# error "Either TLS_TCB_AT_TP or TLS_DTV_AT_TP must be defined"
-#endif
-
-  /* Align the TLS block.  */
-  tlsblock = (void *) (((uintptr_t) tlsblock + max_align - 1)
-		       & ~(max_align - 1));
-
-  /* Initialize the dtv.  [0] is the length, [1] the generation counter.  */
-  _dl_static_dtv[0].counter = (sizeof (_dl_static_dtv) / sizeof (_dl_static_dtv[0])) - 2;
-  // _dl_static_dtv[1].counter = 0;		would be needed if not already done
-
-  /* Initialize the TLS block.  */
-#if TLS_TCB_AT_TP
-  _dl_static_dtv[2].pointer.val = ((char *) tlsblock + tcb_offset
-			       - roundup (memsz, align ?: 1));
-  main_map->l_tls_offset = roundup (memsz, align ?: 1);
-#elif TLS_DTV_AT_TP
-  _dl_static_dtv[2].pointer.val = (char *) tlsblock + tcb_offset;
-  main_map->l_tls_offset = tcb_offset;
-#else
-# error "Either TLS_TCB_AT_TP or TLS_DTV_AT_TP must be defined"
-#endif
-  _dl_static_dtv[2].pointer.to_free = NULL;
-  /* sbrk gives us zero'd memory, so we don't need to clear the remainder.  */
-  memcpy (_dl_static_dtv[2].pointer.val, initimage, filesz);
-
-  /* Install the pointer to the dtv.  */
-
-  /* Initialize the thread pointer.  */
-#if TLS_TCB_AT_TP
-  INSTALL_DTV ((char *) tlsblock + tcb_offset, _dl_static_dtv);
-
-  call_tls_init_tp ((char *) tlsblock + tcb_offset);
-#elif TLS_DTV_AT_TP
-  INSTALL_DTV (tlsblock, _dl_static_dtv);
-  call_tls_init_tp (tlsblock);
-#endif
-
-  /* Update the executable's link map with enough information to make
-     the TLS routines happy.  */
-  main_map->l_tls_align = align;
-  main_map->l_tls_blocksize = memsz;
-  main_map->l_tls_initimage = initimage;
-  main_map->l_tls_initimage_size = filesz;
-  main_map->l_tls_modid = 1;
-
-  init_slotinfo ();
-  /* static_slotinfo.slotinfo[1].gen = 0; -- Already zero.  */
-  static_slotinfo.slotinfo[1].map = main_map;
-
-  memsz = roundup (memsz, align ?: 1);
-
-#if TLS_DTV_AT_TP
-  memsz += tcb_offset;
-#endif
-
-  init_static_tls (memsz, MAX (TCB_ALIGNMENT, max_align));
+  void* pd = zgc_alloc (TLS_TCB_SIZE);
+  call_tls_init_tp (pd);  
 }
diff --git a/debug/Makefile b/debug/Makefile
index 3903cc97a370..f6e0ef2ab16b 100644
--- a/debug/Makefile
+++ b/debug/Makefile
@@ -30,7 +30,6 @@ headers	:= execinfo.h
 # build, its _FORTIFY_SOURCE support will be too.
 routines = \
   $(static-only-routines) \
-  ____longjmp_chk \
   asprintf_chk \
   backtrace \
   backtracesyms \
@@ -55,14 +54,9 @@ routines = \
   gethostname_chk \
   gets_chk \
   getwd_chk \
-  longjmp_chk \
   mbsnrtowcs_chk \
   mbsrtowcs_chk \
   mbstowcs_chk \
-  memcpy_chk \
-  memmove_chk \
-  mempcpy_chk \
-  memset_chk \
   noophooks \
   obprintf_chk \
   poll_chk \
@@ -116,7 +110,6 @@ routines = \
   wmemcpy_chk \
   wmemmove_chk \
   wmempcpy_chk \
-  wmemset_chk \
   wprintf_chk \
   # routines
 static-only-routines := stack_chk_fail_local
diff --git a/debug/backtracesyms.c b/debug/backtracesyms.c
index c1f6322981ad..8994deb75e48 100644
--- a/debug/backtracesyms.c
+++ b/debug/backtracesyms.c
@@ -23,6 +23,7 @@
 #include <string.h>
 
 #include <ldsodefs.h>
+#include <stdfil.h>
 
 #if __ELF_NATIVE_CLASS == 32
 # define WORD_WIDTH 8
@@ -35,85 +36,7 @@
 char **
 __backtrace_symbols (void *const *array, int size)
 {
-  Dl_info info[size];
-  int status[size];
-  int cnt;
-  size_t total = 0;
-  char **result;
-
-  /* Fill in the information we can get from `dladdr'.  */
-  for (cnt = 0; cnt < size; ++cnt)
-    {
-      struct link_map *map;
-      status[cnt] = _dl_addr (array[cnt], &info[cnt], &map, NULL);
-      if (status[cnt] && info[cnt].dli_fname && info[cnt].dli_fname[0] != '\0')
-	{
-	  /* We have some info, compute the length of the string which will be
-	     "<file-name>(<sym-name>+offset) [address].  */
-	  total += (strlen (info[cnt].dli_fname ?: "")
-		    + strlen (info[cnt].dli_sname ?: "")
-		    + 3 + WORD_WIDTH + 3 + WORD_WIDTH + 5);
-
-	  /* The load bias is more useful to the user than the load
-	     address.  The use of these addresses is to calculate an
-	     address in the ELF file, so its prelinked bias is not
-	     something we want to subtract out.  */
-	  info[cnt].dli_fbase = (void *) map->l_addr;
-	}
-      else
-	total += 5 + WORD_WIDTH;
-    }
-
-  /* Allocate memory for the result.  */
-  result = (char **) malloc (size * sizeof (char *) + total);
-  if (result != NULL)
-    {
-      char *last = (char *) (result + size);
-
-      for (cnt = 0; cnt < size; ++cnt)
-	{
-	  result[cnt] = last;
-
-	  if (status[cnt]
-	      && info[cnt].dli_fname != NULL && info[cnt].dli_fname[0] != '\0')
-	    {
-	      if (info[cnt].dli_sname == NULL)
-		/* We found no symbol name to use, so describe it as
-		   relative to the file.  */
-		info[cnt].dli_saddr = info[cnt].dli_fbase;
-
-	      if (info[cnt].dli_sname == NULL && info[cnt].dli_saddr == 0)
-		last += 1 + sprintf (last, "%s(%s) [%p]",
-				     info[cnt].dli_fname ?: "",
-				     info[cnt].dli_sname ?: "",
-				     array[cnt]);
-	      else
-		{
-		  char sign;
-		  ptrdiff_t offset;
-		  if (array[cnt] >= (void *) info[cnt].dli_saddr)
-		    {
-		      sign = '+';
-		      offset = array[cnt] - info[cnt].dli_saddr;
-		    }
-		  else
-		    {
-		      sign = '-';
-		      offset = info[cnt].dli_saddr - array[cnt];
-		    }
-
-		  last += 1 + sprintf (last, "%s(%s%c%#tx) [%p]",
-				       info[cnt].dli_fname ?: "",
-				       info[cnt].dli_sname ?: "",
-				       sign, offset, array[cnt]);
-		}
-	    }
-	  else
-	    last += 1 + sprintf (last, "[%p]", array[cnt]);
-	}
-      assert (last <= (char *) result + size * sizeof (char *) + total);
-    }
-
-  return result;
+  zerror ("backtrace_symbols not yet supported.");
+  return NULL;
 }
 weak_alias (__backtrace_symbols, backtrace_symbols)
diff --git a/debug/backtracesymsfd.c b/debug/backtracesymsfd.c
index f68a4830e7c2..9b6aef08e4c3 100644
--- a/debug/backtracesymsfd.c
+++ b/debug/backtracesymsfd.c
@@ -22,6 +22,7 @@
 
 #include <_itoa.h>
 #include <ldsodefs.h>
+#include <stdfil.h>
 
 #if __ELF_NATIVE_CLASS == 32
 # define WORD_WIDTH 8
@@ -34,94 +35,7 @@
 void
 __backtrace_symbols_fd (void *const *array, int size, int fd)
 {
-  struct iovec iov[9];
-  int cnt;
-
-  for (cnt = 0; cnt < size; ++cnt)
-    {
-      char buf[WORD_WIDTH];
-      char buf2[WORD_WIDTH];
-      Dl_info info;
-      struct link_map *map;
-      size_t last = 0;
-
-      if (_dl_addr (array[cnt], &info, &map, NULL)
-	  && info.dli_fname != NULL && info.dli_fname[0] != '\0')
-	{
-	  /* Name of the file.  */
-	  iov[0].iov_base = (void *) info.dli_fname;
-	  iov[0].iov_len = strlen (info.dli_fname);
-	  last = 1;
-
-	  if (info.dli_sname != NULL || map->l_addr != 0)
-	    {
-	      size_t diff;
-
-	      iov[last].iov_base = (void *) "(";
-	      iov[last].iov_len = 1;
-	      ++last;
-
-	      if (info.dli_sname != NULL)
-		{
-		  /* We have a symbol name.  */
-		  iov[last].iov_base = (void *) info.dli_sname;
-		  iov[last].iov_len = strlen (info.dli_sname);
-		  ++last;
-		}
-	      else
-		/* We have no symbol, so describe it as relative to the file.
-		   The load bias is more useful to the user than the load
-		   address.  The use of these addresses is to calculate an
-		   address in the ELF file, so its prelinked bias is not
-		   something we want to subtract out.  */
-		info.dli_saddr = (void *) map->l_addr;
-
-	      if (array[cnt] >= (void *) info.dli_saddr)
-		{
-		  iov[last].iov_base = (void *) "+0x";
-		  diff = array[cnt] - info.dli_saddr;
-		}
-	      else
-		{
-		  iov[last].iov_base = (void *) "-0x";
-		  diff = info.dli_saddr - array[cnt];
-		}
-	      iov[last].iov_len = 3;
-	      ++last;
-
-	      iov[last].iov_base = _itoa_word ((unsigned long int) diff,
-					       &buf2[WORD_WIDTH], 16, 0);
-	      iov[last].iov_len = (&buf2[WORD_WIDTH]
-				   - (char *) iov[last].iov_base);
-	      ++last;
-
-	      iov[last].iov_base = (void *) ") ";
-	      iov[last].iov_len = 2;
-	      ++last;
-	    }
-	  else
-	    {
-	      iov[last].iov_base = (void *) "() ";
-	      iov[last].iov_len = 3;
-	      ++last;
-	    }
-	}
-
-      iov[last].iov_base = (void *) "[0x";
-      iov[last].iov_len = 3;
-      ++last;
-
-      iov[last].iov_base = _itoa_word ((unsigned long int) array[cnt],
-				       &buf[WORD_WIDTH], 16, 0);
-      iov[last].iov_len = &buf[WORD_WIDTH] - (char *) iov[last].iov_base;
-      ++last;
-
-      iov[last].iov_base = (void *) "]\n";
-      iov[last].iov_len = 2;
-      ++last;
-
-      __writev (fd, iov, last);
-    }
+  zprintf ("backtrace_symbols_fd not yet supported.");
 }
 weak_alias (__backtrace_symbols_fd, backtrace_symbols_fd)
 libc_hidden_def (__backtrace_symbols_fd)
diff --git a/dlfcn/dladdr.c b/dlfcn/dladdr.c
index 3b0d8b2ef4cf..5663bb991c41 100644
--- a/dlfcn/dladdr.c
+++ b/dlfcn/dladdr.c
@@ -19,15 +19,13 @@
 #include <dlfcn.h>
 #include <ldsodefs.h>
 #include <shlib-compat.h>
+#include <stdfil.h>
 
 int
 __dladdr (const void *address, Dl_info *info)
 {
-#ifdef SHARED
-  if (GLRO (dl_dlfcn_hook) != NULL)
-    return GLRO (dl_dlfcn_hook)->dladdr (address, info);
-#endif
-  return _dl_addr (address, info, NULL, NULL);
+  zerror ("dladdr not yet supported.");
+  return 0;
 }
 versioned_symbol (libc, __dladdr, dladdr, GLIBC_2_34);
 
diff --git a/dlfcn/dladdr1.c b/dlfcn/dladdr1.c
index 06e284fb9ac0..b0312d02f670 100644
--- a/dlfcn/dladdr1.c
+++ b/dlfcn/dladdr1.c
@@ -19,25 +19,13 @@
 #include <dlfcn.h>
 #include <ldsodefs.h>
 #include <shlib-compat.h>
+#include <stdfil.h>
 
 int
 __dladdr1 (const void *address, Dl_info *info, void **extra, int flags)
 {
-#ifdef SHARED
-  if (GLRO (dl_dlfcn_hook) != NULL)
-    return GLRO (dl_dlfcn_hook)->dladdr1 (address, info, extra, flags);
-#endif
-
-  switch (flags)
-    {
-    default:			/* Make this an error?  */
-    case 0:
-      return _dl_addr (address, info, NULL, NULL);
-    case RTLD_DL_SYMENT:
-      return _dl_addr (address, info, NULL, (const ElfW(Sym) **) extra);
-    case RTLD_DL_LINKMAP:
-      return _dl_addr (address, info, (struct link_map **) extra, NULL);
-    }
+  zerror ("dladdr1 not yet supported.");
+  return 0;
 }
 versioned_symbol (libc, __dladdr1, dladdr1, GLIBC_2_34);
 
diff --git a/dlfcn/dlclose.c b/dlfcn/dlclose.c
index b5bff5587d52..9b7b935d2304 100644
--- a/dlfcn/dlclose.c
+++ b/dlfcn/dlclose.c
@@ -23,12 +23,8 @@
 int
 __dlclose (void *handle)
 {
-#ifdef SHARED
-  if (GLRO (dl_dlfcn_hook) != NULL)
-    return GLRO (dl_dlfcn_hook)->dlclose (handle);
-#endif
-
-  return _dlerror_run (GLRO (dl_close), handle) ? -1 : 0;
+  /* FIXME: We could, and should, implement dlclosing eventually. */
+  return 0;
 }
 versioned_symbol (libc, __dlclose, dlclose, GLIBC_2_34);
 
diff --git a/dlfcn/dlerror.c b/dlfcn/dlerror.c
index 26965af84211..810c5647e369 100644
--- a/dlfcn/dlerror.c
+++ b/dlfcn/dlerror.c
@@ -31,76 +31,9 @@
 char *
 __dlerror (void)
 {
-# ifdef SHARED
-  if (GLRO (dl_dlfcn_hook) != NULL)
-    return GLRO (dl_dlfcn_hook)->dlerror ();
-# endif
-
-  struct dl_action_result *result = __libc_dlerror_result;
-
-  /* No libdl function has been called.  No error is possible.  */
-  if (result == NULL)
-    return NULL;
-
-  /* For an early malloc failure, clear the error flag and return the
-     error message.  This marks the error as delivered.  */
-  if (result == dl_action_result_malloc_failed)
-    {
-      __libc_dlerror_result = NULL;
-      return (char *) "out of memory";
-    }
-
-  /* Placeholder object.  This can be observed in a recursive call,
-     e.g. from an ELF constructor.  */
-  if (result->errstring == NULL)
-    return NULL;
-
-  /* If we have already reported the error, we can free the result and
-     return NULL.  See __libc_dlerror_result_free.  */
-  if (result->returned)
-    {
-      __libc_dlerror_result = NULL;
-      dl_action_result_errstring_free (result);
-      free (result);
-      return NULL;
-    }
-
-  assert (result->errstring != NULL);
-
-  /* Create the combined error message.  */
-  char *buf;
-  int n;
-  if (result->errcode == 0)
-    n = __asprintf (&buf, "%s%s%s",
-		    result->objname,
-		    result->objname[0] == '\0' ? "" : ": ",
-		    _(result->errstring));
-  else
-    {
-      __set_errno (result->errcode);
-      n = __asprintf (&buf, "%s%s%s: %m",
-		      result->objname,
-		      result->objname[0] == '\0' ? "" : ": ",
-		      _(result->errstring));
-      /* Set errno again in case asprintf clobbered it.  */
-      __set_errno (result->errcode);
-    }
-
-  /* Mark the error as delivered.  */
-  result->returned = true;
-
-  if (n >= 0)
-    {
-      /* Replace the error string with the newly allocated one.  */
-      dl_action_result_errstring_free (result);
-      result->errstring = buf;
-      result->errstring_source = dl_action_result_errstring_local;
-      return buf;
-    }
-  else
-    /* We could not create the combined error message, so use the
-       existing string as a fallback.  */
-    return result->errstring;
+  char *result = __libc_dlerror_result_string;
+  __libc_dlerror_result_string = NULL;
+  return result;
 }
 versioned_symbol (libc, __dlerror, dlerror, GLIBC_2_34);
 
@@ -108,91 +41,3 @@ versioned_symbol (libc, __dlerror, dlerror, GLIBC_2_34);
 compat_symbol (libdl, __dlerror, dlerror, GLIBC_2_0);
 #endif
 
-int
-_dlerror_run (void (*operate) (void *), void *args)
-{
-  struct dl_action_result *result = __libc_dlerror_result;
-  if (result != NULL)
-    {
-      if (result == dl_action_result_malloc_failed)
-	{
-	  /* Clear the previous error.  */
-	  __libc_dlerror_result = NULL;
-	  result = NULL;
-	}
-      else
-	{
-	  /* There is an existing object.  Free its error string, but
-	     keep the object.  */
-	  dl_action_result_errstring_free (result);
-	  /* Mark the object as not containing an error.  This ensures
-	     that call to dlerror from, for example, an ELF
-	     constructor will not notice this result object.  */
-	  result->errstring = NULL;
-	}
-    }
-
-  const char *objname;
-  const char *errstring;
-  bool malloced;
-  int errcode = GLRO (dl_catch_error) (&objname, &errstring, &malloced,
-				       operate, args);
-
-  /* ELF constructors or destructors may have indirectly altered the
-     value of __libc_dlerror_result, therefore reload it.  */
-  result = __libc_dlerror_result;
-
-  if (errstring == NULL)
-    {
-      /* There is no error.  We no longer need the result object if it
-	 does not contain an error.  However, a recursive call may
-	 have added an error even if this call did not cause it.  Keep
-	 the other error.  */
-      if (result != NULL && result->errstring == NULL)
-	{
-	  __libc_dlerror_result = NULL;
-	  free (result);
-	}
-      return 0;
-    }
-  else
-    {
-      /* A new error occurred.  Check if a result object has to be
-	 allocated.  */
-      if (result == NULL || result == dl_action_result_malloc_failed)
-	{
-	  /* Allocating storage for the error message after the fact
-	     is not ideal.  But this avoids an infinite recursion in
-	     case malloc itself calls libdl functions (without
-	     triggering errors).  */
-	  result = malloc (sizeof (*result));
-	  if (result == NULL)
-	    {
-	      /* Assume that the dlfcn failure was due to a malloc
-		 failure, too.  */
-	      if (malloced)
-		dl_error_free ((char *) errstring);
-	      __libc_dlerror_result = dl_action_result_malloc_failed;
-	      return 1;
-	    }
-	  __libc_dlerror_result = result;
-	}
-      else
-	/* Deallocate the existing error message from a recursive
-	   call, but reuse the result object.  */
-	dl_action_result_errstring_free (result);
-
-      result->errcode = errcode;
-      result->objname = objname;
-      result->errstring = (char *) errstring;
-      result->returned = false;
-      /* In case of an error, the malloced flag indicates whether the
-	 error string is constant or not.  */
-      if (malloced)
-	result->errstring_source = dl_action_result_errstring_rtld;
-      else
-	result->errstring_source = dl_action_result_errstring_constant;
-
-      return 1;
-    }
-}
diff --git a/dlfcn/dlerror.h b/dlfcn/dlerror.h
index 1f5fed7eea72..f5798f4d1641 100644
--- a/dlfcn/dlerror.h
+++ b/dlfcn/dlerror.h
@@ -25,67 +25,9 @@
 #include <stdint.h>
 #include <stdlib.h>
 
-/* Source of the errstring member in struct dl_action_result, for
-   finding the right deallocation routine.  */
-enum dl_action_result_errstring_source
-  {
-   dl_action_result_errstring_constant, /* String literal, no deallocation.  */
-   dl_action_result_errstring_rtld, /* libc in the primary namespace.  */
-   dl_action_result_errstring_local, /* libc in the current namespace.  */
-  };
-
-struct dl_action_result
-{
-  int errcode;
-  char errstring_source;
-  bool returned;
-  const char *objname;
-  char *errstring;
-};
-
-/* Used to free the errstring member of struct dl_action_result in the
-   dl_action_result_errstring_rtld case.  */
-static inline void
-dl_error_free (void *ptr)
-{
-#ifdef SHARED
-  /* In the shared case, ld.so may use a different malloc than this
-     namespace.  */
-  GLRO (dl_error_free (ptr));
-#else
-  /* Call the implementation directly.  It still has to check for
-     pointers which cannot be freed, so do not call free directly
-     here.  */
-  _dl_error_free (ptr);
-#endif
-}
-
-/* Deallocate RESULT->errstring, leaving *RESULT itself allocated.  */
-static inline void
-dl_action_result_errstring_free (struct dl_action_result *result)
-{
-  switch (result->errstring_source)
-    {
-    case dl_action_result_errstring_constant:
-      break;
-    case dl_action_result_errstring_rtld:
-      dl_error_free (result->errstring);
-      break;
-    case dl_action_result_errstring_local:
-      free (result->errstring);
-      break;
-    }
-}
-
-/* Stand-in for an error result object whose allocation failed.  No
-   precise message can be reported for this, but an error must still
-   be signaled.  */
-static struct dl_action_result *const dl_action_result_malloc_failed
-  __attribute__ ((unused)) = (struct dl_action_result *) (intptr_t) -1;
-
 /* Thread-local variable for storing dlfcn failures for subsequent
    reporting via dlerror.  */
-extern __thread struct dl_action_result *__libc_dlerror_result
+extern __thread char *__libc_dlerror_result_string
   attribute_tls_model_ie;
 
 #endif /* _DLERROR_H */
diff --git a/dlfcn/dlinfo.c b/dlfcn/dlinfo.c
index b0feb9362d58..cb8a1416a948 100644
--- a/dlfcn/dlinfo.c
+++ b/dlfcn/dlinfo.c
@@ -22,88 +22,14 @@
 #include <libintl.h>
 #include <dl-tls.h>
 #include <shlib-compat.h>
-
-struct dlinfo_args
-{
-  void *handle;
-  int request;
-  void *arg;
-
-  /* This is the value that is returned from dlinfo if no error is
-     signaled.  */
-  int result;
-};
-
-static void
-dlinfo_doit (void *argsblock)
-{
-  struct dlinfo_args *const args = argsblock;
-  struct link_map *l = args->handle;
-
-  switch (args->request)
-    {
-    case RTLD_DI_CONFIGADDR:
-    default:
-      args->result = -1;
-      _dl_signal_error (0, NULL, NULL, N_("unsupported dlinfo request"));
-      break;
-
-    case RTLD_DI_LMID:
-      *(Lmid_t *) args->arg = l->l_ns;
-      break;
-
-    case RTLD_DI_LINKMAP:
-      *(struct link_map **) args->arg = l;
-      break;
-
-    case RTLD_DI_SERINFO:
-      _dl_rtld_di_serinfo (l, args->arg, false);
-      break;
-    case RTLD_DI_SERINFOSIZE:
-      _dl_rtld_di_serinfo (l, args->arg, true);
-      break;
-
-    case RTLD_DI_ORIGIN:
-      strcpy (args->arg, l->l_origin);
-      break;
-
-    case RTLD_DI_TLS_MODID:
-      *(size_t *) args->arg = 0;
-      *(size_t *) args->arg = l->l_tls_modid;
-      break;
-
-    case RTLD_DI_TLS_DATA:
-      {
-	void *data = NULL;
-	if (l->l_tls_modid != 0)
-	  data = GLRO(dl_tls_get_addr_soft) (l);
-	*(void **) args->arg = data;
-	break;
-      }
-
-    case RTLD_DI_PHDR:
-      *(const ElfW(Phdr) **) args->arg = l->l_phdr;
-      args->result = l->l_phnum;
-      break;
-    }
-}
-
-static int
-dlinfo_implementation (void *handle, int request, void *arg)
-{
-  struct dlinfo_args args = { handle, request, arg };
-  _dlerror_run (&dlinfo_doit, &args);
-  return args.result;
-}
+#include <stdfil.h>
 
 #ifdef SHARED
 int
 ___dlinfo (void *handle, int request, void *arg)
 {
-  if (GLRO (dl_dlfcn_hook) != NULL)
-    return GLRO (dl_dlfcn_hook)->dlinfo (handle, request, arg);
-  else
-    return dlinfo_implementation (handle, request, arg);
+  zerror ("dlinfo not yet supported.");
+  return -1;
 }
 versioned_symbol (libc, ___dlinfo, dlinfo, GLIBC_2_34);
 
@@ -115,7 +41,8 @@ compat_symbol (libc, ___dlinfo, dlinfo, GLIBC_2_3_3);
 int
 __dlinfo (void *handle, int request, void *arg)
 {
-  return dlinfo_implementation (handle, request, arg);
+  zerror ("dlinfo not yet supported.");
+  return -1;
 }
 weak_alias (__dlinfo, dlinfo)
 #endif
diff --git a/dlfcn/dlmopen.c b/dlfcn/dlmopen.c
index 880866f8edfa..764fe9235946 100644
--- a/dlfcn/dlmopen.c
+++ b/dlfcn/dlmopen.c
@@ -23,67 +23,14 @@
 #include <unistd.h>
 #include <ldsodefs.h>
 #include <shlib-compat.h>
-
-struct dlmopen_args
-{
-  /* Namespace ID.  */
-  Lmid_t nsid;
-  /* The arguments for dlopen_doit.  */
-  const char *file;
-  int mode;
-  /* The return value of dlopen_doit.  */
-  void *new;
-  /* Address of the caller.  */
-  const void *caller;
-};
-
-static void
-dlmopen_doit (void *a)
-{
-  struct dlmopen_args *args = (struct dlmopen_args *) a;
-
-  /* Non-shared code has no support for multiple namespaces.  */
-  if (args->nsid != LM_ID_BASE)
-    {
-# ifdef SHARED
-      /* If trying to open the link map for the main executable the namespace
-	 must be the main one.  */
-      if (args->file == NULL)
-# endif
-	_dl_signal_error (EINVAL, NULL, NULL, N_("invalid namespace"));
-
-      /* It makes no sense to use RTLD_GLOBAL when loading a DSO into
-	 a namespace other than the base namespace.  */
-      if (__glibc_unlikely (args->mode & RTLD_GLOBAL))
-	_dl_signal_error (EINVAL, NULL, NULL, N_("invalid mode"));
-    }
-
-  args->new = GLRO(dl_open) (args->file ?: "", args->mode | __RTLD_DLOPEN,
-			     args->caller,
-			     args->nsid, __libc_argc, __libc_argv, __environ);
-}
-
-static void *
-dlmopen_implementation (Lmid_t nsid, const char *file, int mode,
-			void *dl_caller)
-{
-  struct dlmopen_args args;
-  args.nsid = nsid;
-  args.file = file;
-  args.mode = mode;
-  args.caller = dl_caller;
-
-  return _dlerror_run (dlmopen_doit, &args) ? NULL : args.new;
-}
+#include <stdfil.h>
 
 #ifdef SHARED
 void *
 ___dlmopen (Lmid_t nsid, const char *file, int mode)
 {
-  if (GLRO (dl_dlfcn_hook) != NULL)
-    return GLRO (dl_dlfcn_hook)->dlmopen (nsid, file, mode, RETURN_ADDRESS (0));
-  else
-    return dlmopen_implementation (nsid, file, mode, RETURN_ADDRESS (0));
+  zerror("dlmopen not yet supported.");
+  return NULL;
 }
 versioned_symbol (libc, ___dlmopen, dlmopen, GLIBC_2_34);
 
@@ -95,7 +42,8 @@ compat_symbol (libdl, ___dlmopen, dlmopen, GLIBC_2_3_4);
 void *
 __dlmopen (Lmid_t nsid, const char *file, int mode, void *dl_caller)
 {
-  return dlmopen_implementation (nsid, file, mode, RETURN_ADDRESS (0));
+  zerror("dlmopen not yet supported.");
+  return NULL;
 }
 
 void *
diff --git a/dlfcn/dlopen.c b/dlfcn/dlopen.c
index 3775da3295fa..aa6deefa1cfe 100644
--- a/dlfcn/dlopen.c
+++ b/dlfcn/dlopen.c
@@ -22,63 +22,13 @@
 #include <unistd.h>
 #include <ldsodefs.h>
 #include <shlib-compat.h>
-
-struct dlopen_args
-{
-  /* The arguments for dlopen_doit.  */
-  const char *file;
-  int mode;
-  /* The return value of dlopen_doit.  */
-  void *new;
-  /* Address of the caller.  */
-  const void *caller;
-};
-
-
-/* Non-shared code has no support for multiple namespaces.  */
-#ifdef SHARED
-# define NS __LM_ID_CALLER
-#else
-# define NS LM_ID_BASE
-#endif
-
-
-static void
-dlopen_doit (void *a)
-{
-  struct dlopen_args *args = (struct dlopen_args *) a;
-
-  if (args->mode & ~(RTLD_BINDING_MASK | RTLD_NOLOAD | RTLD_DEEPBIND
-		     | RTLD_GLOBAL | RTLD_LOCAL | RTLD_NODELETE
-		     | __RTLD_SPROF))
-    _dl_signal_error (0, NULL, NULL, _("invalid mode parameter"));
-
-  args->new = GLRO(dl_open) (args->file ?: "", args->mode | __RTLD_DLOPEN,
-			     args->caller,
-			     args->file == NULL ? LM_ID_BASE : NS,
-			     __libc_argc, __libc_argv, __environ);
-}
-
-
-static void *
-dlopen_implementation (const char *file, int mode, void *dl_caller)
-{
-  struct dlopen_args args;
-  args.file = file;
-  args.mode = mode;
-  args.caller = dl_caller;
-
-  return _dlerror_run (dlopen_doit, &args) ? NULL : args.new;
-}
+#include <pizlonated_syscalls.h>
 
 #ifdef SHARED
 void *
 ___dlopen (const char *file, int mode)
 {
-  if (GLRO (dl_dlfcn_hook) != NULL)
-    return GLRO (dl_dlfcn_hook)->dlopen (file, mode, RETURN_ADDRESS (0));
-  else
-    return dlopen_implementation (file, mode, RETURN_ADDRESS (0));
+  return zsys_dlopen (file, mode);
 }
 versioned_symbol (libc, ___dlopen, dlopen, GLIBC_2_34);
 
@@ -86,17 +36,10 @@ versioned_symbol (libc, ___dlopen, dlopen, GLIBC_2_34);
 compat_symbol (libdl, ___dlopen, dlopen, GLIBC_2_1);
 # endif
 #else /* !SHARED */
-/* Also used with _dlfcn_hook.  */
-void *
-__dlopen (const char *file, int mode, void *dl_caller)
-{
-  return dlopen_implementation (file, mode, dl_caller);
-}
-
 void *
 ___dlopen (const char *file, int mode)
 {
-  return __dlopen (file, mode, RETURN_ADDRESS (0));
+  return zsys_dlopen (file, mode);
 }
 weak_alias (___dlopen, dlopen)
 static_link_warning (dlopen)
diff --git a/dlfcn/dlsym.c b/dlfcn/dlsym.c
index 7cb6b426adab..db2f86f19089 100644
--- a/dlfcn/dlsym.c
+++ b/dlfcn/dlsym.c
@@ -20,52 +20,13 @@
 #include <ldsodefs.h>
 #include <shlib-compat.h>
 #include <stddef.h>
-
-struct dlsym_args
-{
-  /* The arguments to dlsym_doit.  */
-  void *handle;
-  const char *name;
-  void *who;
-
-  /* The return value of dlsym_doit.  */
-  void *sym;
-};
-
-static void
-dlsym_doit (void *a)
-{
-  struct dlsym_args *args = (struct dlsym_args *) a;
-
-  args->sym = _dl_sym (args->handle, args->name, args->who);
-}
-
-static void *
-dlsym_implementation (void *handle, const char *name, void *dl_caller)
-{
-  struct dlsym_args args;
-  args.who = dl_caller;
-  args.handle = handle;
-  args.name = name;
-
-  /* Protect against concurrent loads and unloads.  */
-  __rtld_lock_lock_recursive (GL(dl_load_lock));
-
-  void *result = (_dlerror_run (dlsym_doit, &args) ? NULL : args.sym);
-
-  __rtld_lock_unlock_recursive (GL(dl_load_lock));
-
-  return result;
-}
+#include <pizlonated_syscalls.h>
 
 #ifdef SHARED
 void *
 ___dlsym (void *handle, const char *name)
 {
-  if (GLRO (dl_dlfcn_hook) != NULL)
-    return GLRO (dl_dlfcn_hook)->dlsym (handle, name, RETURN_ADDRESS (0));
-  else
-    return dlsym_implementation (handle, name, RETURN_ADDRESS (0));
+  return zsys_dlsym (handle, name);
 }
 versioned_symbol (libc, ___dlsym, dlsym, GLIBC_2_34);
 
@@ -74,17 +35,10 @@ compat_symbol (libdl, ___dlsym, dlsym, GLIBC_2_0);
 # endif
 
 #else /* !SHARED */
-/* Also used with _dlfcn_hook.  */
-void *
-__dlsym (void *handle, const char *name, void *dl_caller)
-{
-  return dlsym_implementation (handle, name, dl_caller);
-}
-
 void *
 ___dlsym (void *handle, const char *name)
 {
-  return __dlsym (handle, name, RETURN_ADDRESS (0));
+  return zsys_dlsym (handle, name);
 }
 weak_alias (___dlsym, dlsym)
 #endif /* !SHARED */
diff --git a/dlfcn/dlvsym.c b/dlfcn/dlvsym.c
index 5413f689d1f3..e2f49b152887 100644
--- a/dlfcn/dlvsym.c
+++ b/dlfcn/dlvsym.c
@@ -20,56 +20,14 @@
 #include <ldsodefs.h>
 #include <shlib-compat.h>
 #include <stddef.h>
-
-struct dlvsym_args
-{
-  /* The arguments to dlvsym_doit.  */
-  void *handle;
-  const char *name;
-  const char *version;
-  void *who;
-
-  /* The return values of dlvsym_doit.  */
-  void *sym;
-};
-
-static void
-dlvsym_doit (void *a)
-{
-  struct dlvsym_args *args = (struct dlvsym_args *) a;
-
-  args->sym = _dl_vsym (args->handle, args->name, args->version, args->who);
-}
-
-static void *
-dlvsym_implementation (void *handle, const char *name, const char *version,
-		       void *dl_caller)
-{
-  struct dlvsym_args args;
-  args.who = dl_caller;
-  args.handle = handle;
-  args.name = name;
-  args.version = version;
-
-  /* Protect against concurrent loads and unloads.  */
-  __rtld_lock_lock_recursive (GL(dl_load_lock));
-
-  void *result = (_dlerror_run (dlvsym_doit, &args) ? NULL : args.sym);
-
-  __rtld_lock_unlock_recursive (GL(dl_load_lock));
-
-  return result;
-}
+#include <stdfil.h>
+#include <pizlonated_syscalls.h>
 
 #ifdef SHARED
 void *
 ___dlvsym (void *handle, const char *name, const char *version)
 {
-  if (GLRO (dl_dlfcn_hook) != NULL)
-    return GLRO (dl_dlfcn_hook)->dlvsym (handle, name, version,
-					 RETURN_ADDRESS (0));
-  else
-    return dlvsym_implementation (handle, name, version, RETURN_ADDRESS (0));
+  return zsys_dlvsym (handle, name, version);
 }
 versioned_symbol (libc, ___dlvsym, dlvsym, GLIBC_2_34);
 
@@ -82,7 +40,7 @@ compat_symbol (libdl, ___dlvsym, dlvsym, GLIBC_2_1);
 void *
 __dlvsym (void *handle, const char *name, const char *version, void *dl_caller)
 {
-  return dlvsym_implementation (handle, name, version, dl_caller);
+  return zsys_dlvsym (handle, name, version);
 }
 
 void *
diff --git a/dlfcn/libc_dlerror_result.c b/dlfcn/libc_dlerror_result.c
index 8351feadf0aa..7442a766219f 100644
--- a/dlfcn/libc_dlerror_result.c
+++ b/dlfcn/libc_dlerror_result.c
@@ -18,22 +18,11 @@
 
 #include <dlerror.h>
 
-/* This pointer is either NULL, dl_action_result_malloc_failed (), or
-   has been allocated using malloc by the namespace that also contains
-   this instance of the thread-local variable.  */
-__thread struct dl_action_result *__libc_dlerror_result attribute_tls_model_ie;
+__thread char *__libc_dlerror_result_string
+  attribute_tls_model_ie;
 
 /* Called during thread shutdown to free resources.  */
 void
 __libc_dlerror_result_free (void)
 {
-  if (__libc_dlerror_result != NULL)
-    {
-      if (__libc_dlerror_result != dl_action_result_malloc_failed)
-        {
-          dl_action_result_errstring_free (__libc_dlerror_result);
-          free (__libc_dlerror_result);
-        }
-      __libc_dlerror_result = NULL;
-    }
 }
diff --git a/elf/Makefile b/elf/Makefile
index dc686c3bffb8..58d0b74f87f6 100644
--- a/elf/Makefile
+++ b/elf/Makefile
@@ -30,3121 +30,13 @@ headers = \
   # headers
 
 routines = \
-  $(all-dl-routines) \
-  dl-addr \
-  dl-addr-obj \
-  dl-early_allocate \
-  dl-find_object \
-  dl-iteratephdr \
   dl-libc \
-  dl-origin \
-  dl-reloc-static-pie \
   dl-support \
-  dl-sym \
   dl-sysdep \
-  enbl-secure \
-  libc-dl-profstub  \
-  libc-dl_find_object \
-  libc_early_init \
-  rtld_static_init \
-  # routines
-
-# The core dynamic linking functions are in libc for the static and
-# profiled libraries.
-dl-routines = \
-  dl-call-libc-early-init \
-  dl-call_fini \
-  dl-catch \
-  dl-close \
-  dl-debug \
-  dl-debug-symbols \
-  dl-deps \
-  dl-exception \
-  dl-execstack \
-  dl-fini \
-  dl-init \
-  dl-load \
-  dl-lookup \
-  dl-lookup-direct \
-  dl-minimal-malloc \
-  dl-misc \
-  dl-object \
-  dl-open \
-  dl-origin \
-  dl-printf \
-  dl-reloc \
-  dl-runtime \
-  dl-scope \
-  dl-setup_hash \
-  dl-sort-maps \
-  dl-thread_gscope_wait \
-  dl-tls \
-  dl-tls_init_tp \
-  dl-trampoline \
   dl-tunables \
-  dl-version \
-  dl-write \
-  # dl-routines
-
-ifeq (yes,$(use-ldconfig))
-dl-routines += dl-cache
-endif
-
-ifeq (yesyes,$(build-shared)$(run-built-tests))
-tests-special += $(objpfx)list-tunables.out
-endif
-
-# Make sure that the compiler does not insert any library calls in tunables
-# code paths.
-ifeq (yes,$(have-loop-to-function))
-CFLAGS-dl-tunables.c += -fno-tree-loop-distribute-patterns
-endif
-
-all-dl-routines = $(dl-routines) $(sysdep-dl-routines)
-# But they are absent from the shared libc, because that code is in ld.so.
-elide-routines.os = \
-  $(all-dl-routines) \
-  dl-early_allocate \
-  dl-exception \
-  dl-origin \
-  dl-reloc-static-pie \
-  dl-support \
-  dl-sysdep \
+  dl-tls_init_tp \
+  libc_early_init \
   enbl-secure \
-  rtld_static_init \
-  thread_gscope_wait \
-  # elide-routines.os
-
-# These object files are only included in the dynamically-linked libc.
-shared-only-routines = \
-  libc-dl-profile \
-  libc-dl-profstub \
-  libc-dl_find_object \
-  # shared-only-routines
-
-# ld.so uses those routines, plus some special stuff for being the program
-# interpreter and operating independent of libc.
-rtld-routines = \
-  $(all-dl-routines) \
-  dl-audit \
-  dl-compat \
-  dl-diagnostics \
-  dl-diagnostics-cpu \
-  dl-diagnostics-kernel \
-  dl-environ \
-  dl-hwcaps \
-  dl-hwcaps-subdirs \
-  dl-hwcaps_split \
-  dl-libc_freeres \
-  dl-minimal \
-  dl-mutex \
-  dl-profile \
-  dl-sysdep \
-  dl-usage \
-  rtld \
-  # rtld-routines
-
-all-rtld-routines = $(rtld-routines) $(sysdep-rtld-routines)
-
-CFLAGS-dl-runtime.c += -fexceptions -fasynchronous-unwind-tables
-CFLAGS-dl-lookup.c += -fexceptions -fasynchronous-unwind-tables
-CFLAGS-dl-iteratephdr.c += $(uses-callbacks)
-
-# Called during static library initialization, so turn stack-protection
-# off for non-shared builds.
-CFLAGS-dl-minimal-malloc.o = $(no-stack-protector)
-CFLAGS-dl-minimal-malloc.op = $(no-stack-protector)
-
-# On targets without __builtin_memset, rtld.c uses a hand-coded loop
-# in _dl_start.  Make sure this isn't turned into a call to regular memset.
-ifeq (yes,$(have-loop-to-function))
-CFLAGS-rtld.c += -fno-tree-loop-distribute-patterns
-endif
-
-# Compile rtld itself without stack protection.
-# Also compile all routines in the static library that are elided from
-# the shared libc because they are in libc.a in the same way.
-
-CFLAGS-.o += $(call elide-stack-protector,.o,$(elide-routines.os))
-CFLAGS-.op += $(call elide-stack-protector,.op,$(elide-routines.os))
-CFLAGS-.os += $(call elide-stack-protector,.os,$(all-rtld-routines))
-
-# Add the requested compiler flags to the early startup code.
-CFLAGS-dl-misc.os += $(rtld-early-cflags)
-CFLAGS-dl-printf.os += $(rtld-early-cflags)
-CFLAGS-dl-setup_hash.os += $(rtld-early-cflags)
-CFLAGS-dl-sysdep.os += $(rtld-early-cflags)
-CFLAGS-dl-tunables.os += $(rtld-early-cflags)
-CFLAGS-dl-write.os += $(rtld-early-cflags)
-CFLAGS-dl-writev.os += $(rtld-early-cflags)
-CFLAGS-rtld.os += $(rtld-early-cflags)
-
-ifeq ($(unwind-find-fde),yes)
-routines += unwind-dw2-fde-glibc
-shared-only-routines += unwind-dw2-fde-glibc
-endif
-
-before-compile  += $(objpfx)trusted-dirs.h
-generated	+= trusted-dirs.h trusted-dirs.st for-renamed/renamed.so
-generated-dirs	+= for-renamed
-
-ifeq ($(build-shared),yes)
-ld-map		= $(common-objpfx)ld.map
-endif
-
-ifeq (yes,$(build-shared))
-extra-objs = \
-  $(all-rtld-routines:%=%.os) \
-  interp.os \
-  sofini.os \
-  # extra-objs
-generated += \
-  dl-allobjs.os \
-  ld.so ldd \
-  librtld.os \
-  # generated
-install-others	= $(inst_rtlddir)/$(rtld-installed-name) $(inst_bindir)/ld.so
-install-bin-script = ldd
-endif
-
-others		= sprof sln
-install-bin	= sprof
-others-static   = sln
-install-rootsbin = sln
-sln-modules	:= static-stubs
-extra-objs	+= $(sln-modules:=.o)
-
-ifeq (yes,$(use-ldconfig))
-ifeq (yes,$(build-shared))
-others-static	+= ldconfig
-others		+= ldconfig
-install-rootsbin += ldconfig
-
-ldconfig-modules := \
-  cache \
-  chroot_canon \
-  readlib \
-  static-stubs \
-  stringtable \
-  xmalloc \
-  xstrdup \
-  # ldconfig-modules
-extra-objs	+= $(ldconfig-modules:=.o)
-others-extras   = $(ldconfig-modules)
-endif
-endif
-
-# To find xmalloc.c and xstrdup.c
-vpath %.c ../locale/programs
-
-ifeq ($(build-shared),yes)
-extra-objs += sotruss-lib.os sotruss-lib.so
-install-others += $(inst_auditdir)/sotruss-lib.so
-install-bin-script += sotruss
-generated += sotruss
-libof-sotruss-lib = extramodules
-LDFLAGS-sotruss-lib.so += $(z-now-$(bind-now))
-$(objpfx)sotruss-lib.so: $(objpfx)sotruss-lib.os
-	$(build-module-asneeded)
-$(objpfx)sotruss-lib.so: $(common-objpfx)libc.so $(objpfx)ld.so \
-	$(common-objpfx)libc_nonshared.a
-
-$(objpfx)sotruss: sotruss.sh $(common-objpfx)config.make
-	sed -e 's%@VERSION@%$(version)%g' \
-	    -e 's%@TEXTDOMAINDIR@%$(localedir)%g' \
-	    -e 's%@PREFIX@%$(prefix)%g' \
-	    -e 's|@PKGVERSION@|$(PKGVERSION)|g' \
-	    -e 's|@REPORT_BUGS_TO@|$(REPORT_BUGS_TO)|g' \
-	    < $< > $@.new
-	chmod 555 $@.new
-	mv -f $@.new $@
-$(inst_auditdir)/sotruss-lib.so: $(objpfx)sotruss-lib.so $(+force)
-	$(do-install-program)
-endif
-
-tests-static-normal := \
-  tst-array1-static \
-  tst-array5-static \
-  tst-dl-iter-static \
-  tst-dst-static \
-  tst-env-setuid-static \
-  tst-getauxval-static \
-  tst-linkall-static \
-  tst-single_threaded-pthread-static \
-  tst-single_threaded-static \
-  tst-tls-allocation-failure-static \
-  tst-tlsalign-extern-static \
-  tst-tlsalign-static \
-  # tests-static-normal
-
-tests-static-internal := \
-  tst-dl-printf-static \
-  tst-dl_find_object-static \
-  tst-env-setuid-tunables \
-  tst-ptrguard1-static \
-  tst-stackguard1-static \
-  tst-tls1-static \
-  tst-tls1-static-non-pie \
-  tst-tunables \
-  tst-tunables-enable_secure \
-  # tests-static-internal
-
-CRT-tst-tls1-static-non-pie := $(csu-objpfx)crt1.o
-tst-tls1-static-non-pie-no-pie = yes
-
-tests-container := \
-  tst-ldconfig-bad-aux-cache \
-  tst-ldconfig-ld_so_conf-update \
-  # tests-container
-
-ifeq (no,$(build-hardcoded-path-in-tests))
-# This is an ld.so.cache test, and RPATH/RUNPATH in the executable
-# interferes with its test objectives.
-tests-container += tst-glibc-hwcaps-prepend-cache
-endif
-
-tests := \
-  tst-array1 \
-  tst-array2 \
-  tst-array3 \
-  tst-array4 \
-  tst-array5 \
-  tst-auxv \
-  tst-decorate-maps \
-  tst-dl-hash \
-  tst-env-setuid \
-  tst-leaks1 \
-  tst-stringtable \
-  tst-tls9 \
-  tst-tunables-enable_secure-env \
-  # tests
-
-tests-internal := \
-  $(tests-static-internal) \
-  tst-tls1 \
-  # tests-internal
-
-tests-static := $(tests-static-normal) $(tests-static-internal)
-
-ifeq (yes,$(build-shared))
-tests-static += \
-  tst-single_threaded-static-dlopen \
-  tst-tls9-static \
-  # tests-static
-
-static-dlopen-environment = \
-  LD_LIBRARY_PATH=$(ld-library-path):$(common-objpfx)dlfcn
-tst-tls9-static-ENV = $(static-dlopen-environment)
-tst-single_threaded-static-dlopen-ENV = $(static-dlopen-environment)
-tst-rootdir-ENV = LD_LIBRARY_PATH=/
-
-tests += \
-  argv0test \
-  constload1 \
-  dblload \
-  dblunload \
-  filter \
-  global \
-  initfirst \
-  lateglobal \
-  loadfail \
-  multiload \
-  next \
-  nodelete \
-  nodelete2 \
-  nodlopen \
-  nodlopen2 \
-  noload \
-  order \
-  order2 \
-  origtest \
-  preloadtest \
-  reldep \
-  reldep2 \
-  reldep3 \
-  reldep4 \
-  reldep5 \
-  reldep6 \
-  reldep7 \
-  reldep8 \
-  resolvfail \
-  restest1 \
-  restest2 \
-  tst-absolute-sym \
-  tst-absolute-zero \
-  tst-addr1 \
-  tst-align \
-  tst-align2 \
-  tst-align3 \
-  tst-audit-tlsdesc \
-  tst-audit-tlsdesc-dlopen \
-  tst-audit1 \
-  tst-audit2 \
-  tst-audit8 \
-  tst-audit9 \
-  tst-audit11 \
-  tst-audit12 \
-  tst-audit13 \
-  tst-audit17 \
-  tst-audit18 \
-  tst-audit19b \
-  tst-audit20 \
-  tst-audit21 \
-  tst-audit22 \
-  tst-audit23 \
-  tst-audit24a \
-  tst-audit24b \
-  tst-audit24c \
-  tst-audit24d \
-  tst-audit25a \
-  tst-audit25b \
-  tst-audit28 \
-  tst-auditmany \
-  tst-auxobj \
-  tst-auxobj-dlopen \
-  tst-big-note \
-  tst-debug1 \
-  tst-deep1 \
-  tst-dl-is_dso \
-  tst-dlclose-lazy \
-  tst-dlmodcount \
-  tst-dlmopen-dlerror \
-  tst-dlmopen-gethostbyname \
-  tst-dlmopen-twice \
-  tst-dlmopen1 \
-  tst-dlmopen3 \
-  tst-dlmopen4 \
-  tst-dlopen-self \
-  tst-dlopen-tlsmodid \
-  tst-dlopen-tlsreinit1 \
-  tst-dlopen-tlsreinit2 \
-  tst-dlopen-tlsreinit3 \
-  tst-dlopen-tlsreinit4 \
-  tst-dlopenfail \
-  tst-dlopenfail-2 \
-  tst-dlopenrpath \
-  tst-dlsym-error \
-  tst-filterobj \
-  tst-filterobj-dlopen \
-  tst-glibc-hwcaps \
-  tst-glibc-hwcaps-mask \
-  tst-glibc-hwcaps-prepend \
-  tst-global1 \
-  tst-global2 \
-  tst-gnu2-tls2 \
-  tst-initfinilazyfail \
-  tst-initorder \
-  tst-initorder2 \
-  tst-latepthread \
-  tst-main1 \
-  tst-next-ver \
-  tst-nodelete-dlclose \
-  tst-nodelete-opened \
-  tst-nodelete2 \
-  tst-nodeps1 \
-  tst-nodeps2 \
-  tst-noload \
-  tst-non-directory-path \
-  tst-null-argv \
-  tst-p_align1 \
-  tst-p_align2 \
-  tst-p_align3 \
-  tst-recursive-tls \
-  tst-relsort1 \
-  tst-ro-dynamic \
-  tst-rtld-run-static \
-  tst-single_threaded \
-  tst-single_threaded-pthread \
-  tst-sonamemove-dlopen \
-  tst-sonamemove-link \
-  tst-thrlock \
-  tst-tls-dlinfo \
-  tst-tls-ie \
-  tst-tls-ie-dlmopen \
-  tst-tls-manydynamic \
-  tst-tls4 \
-  tst-tls5 \
-  tst-tls10 \
-  tst-tls11 \
-  tst-tls12 \
-  tst-tls13 \
-  tst-tls14 \
-  tst-tls15 \
-  tst-tls16 \
-  tst-tls17 \
-  tst-tls18 \
-  tst-tls19 \
-  tst-tls20 \
-  tst-tls21 \
-  tst-tlsalign \
-  tst-tlsalign-extern \
-  tst-tlsgap \
-  tst-unique1 \
-  tst-unique2 \
-  tst-unwind-ctor \
-  tst-unwind-main \
-  unload3 \
-  unload4 \
-  unload5 \
-  unload6 \
-  unload7 \
-  unload8 \
-  valgrind-test \
-  # tests
-tests-cxx = \
-  tst-dlopen-nodelete-reloc \
-  tst-nodelete \
-  tst-unique3 \
-  tst-unique4 \
-  # tests-cxx
-
-tests += $(if $(CXX),$(tests-cxx))
-
-tests-internal += \
-  circleload1 \
-  loadtest \
-  neededtest \
-  neededtest2 \
-  neededtest3 \
-  neededtest4 \
-  tst-audit19a \
-  tst-create_format1 \
-  tst-dl-hwcaps_split \
-  tst-dl_find_object \
-  tst-dl_find_object-threads \
-  tst-dlmopen2 \
-  tst-ptrguard1 \
-  tst-stackguard1 \
-  tst-tls-surplus \
-  tst-tls3 \
-  tst-tls6 \
-  tst-tls7 \
-  tst-tls8 \
-  unload \
-  unload2 \
-  # tests-internal
-
-tests-container += \
-  tst-dlopen-self-container \
-  tst-dlopen-tlsmodid-container \
-  tst-pldd \
-  tst-preload-pthread-libc \
-  tst-rootdir \
-  # tests-container
-
-test-srcs = \
-  tst-pathopt \
-  tst-sprof-basic \
-  # tests-srcs
-
-ifeq (yes,$(have-fpie))
-tests-pie += tst-align3
-endif
-selinux-enabled := $(shell cat /selinux/enforce 2> /dev/null)
-
-ifneq ($(selinux-enabled),1)
-tests-execstack-yes = \
-  tst-execstack \
-  tst-execstack-needed \
-  tst-execstack-prog \
-  # tests-execstack-yes
-endif
-ifeq ($(have-depaudit),yes)
-tests += \
-  tst-audit14 \
-  tst-audit14a \
-  tst-audit15 \
-  tst-audit16 \
-  # tests
-ifeq ($(run-built-tests),yes)
-tests-special += \
-  $(objpfx)tst-audit14-cmp.out \
-  $(objpfx)tst-audit14a-cmp.out \
-  $(objpfx)tst-audit15-cmp.out \
-  $(objpfx)tst-audit16-cmp.out \
-  # tests-special
-endif
-endif
-ifeq ($(have-dt-relr),yes)
-tests += \
-  tst-relr \
-  tst-relr2 \
-  tst-relr3 \
-  tst-relr4 \
-  # tests
-modules-names-dt-relr = \
-  tst-relr-mod2 \
-  tst-relr-mod3a \
-  tst-relr-mod3b \
-  tst-relr-mod4a \
-  tst-relr-mod4b \
-  # modules-names-dt-relr
-modules-names += $(modules-names-dt-relr)
-# These shared libraries have special build rules.
-modules-names-nobuild += $(modules-names-dt-relr)
-ifeq ($(have-fpie),yes)
-tests += \
-  tst-relr-pie \
-  # tests
-tests-pie += \
-  tst-relr-pie \
-  # tests-pie
-tests-special += \
-  $(objpfx)check-tst-relr-pie.out \
-  # tests-special
-endif
-CFLAGS-tst-relr-pie.c += $(pie-ccflag)
-LDFLAGS-tst-relr += -Wl,-z,pack-relative-relocs
-LDFLAGS-tst-relr-pie += -Wl,-z,pack-relative-relocs
-CFLAGS-tst-relr-mod2.c += $(no-stack-protector)
-CFLAGS-tst-relr-mod3a.c += $(no-stack-protector)
-CFLAGS-tst-relr-mod3b.c += $(no-stack-protector)
-CFLAGS-tst-relr-mod4a.c += $(no-stack-protector)
-CFLAGS-tst-relr-mod4b.c += $(no-stack-protector)
-endif
-endif
-
-tests-special += $(objpfx)tst-relro-ldso.out $(objpfx)tst-relro-libc.out
-$(objpfx)tst-relro-ldso.out: tst-relro-symbols.py $(..)/scripts/glibcelf.py \
-  $(objpfx)ld.so
-	$(PYTHON) tst-relro-symbols.py $(objpfx)ld.so \
-	  --required=_rtld_global_ro \
-	  > $@ 2>&1; $(evaluate-test)
-# The optional symbols are present in libc only if the architecture has
-# the GLIBC_2.0 symbol set in libc.
-$(objpfx)tst-relro-libc.out: tst-relro-symbols.py $(..)/scripts/glibcelf.py \
-  $(common-objpfx)libc.so
-	$(PYTHON) tst-relro-symbols.py $(common-objpfx)libc.so \
-	    --required=_IO_file_jumps \
-	    --required=_IO_wfile_jumps \
-	    --required=__io_vtables \
-	  > $@ 2>&1; $(evaluate-test)
-
-ifeq ($(run-built-tests),yes)
-tests-special += $(objpfx)tst-valgrind-smoke.out
-endif
-$(objpfx)tst-valgrind-smoke.out: tst-valgrind-smoke.sh $(objpfx)ld.so $(objpfx)valgrind-test
-	$(SHELL) $< $(objpfx)ld.so  $(rtlddir)/$(rtld-installed-name) '$(test-wrapper-env)' \
-		'$(run-program-env)' '$(rpath-link)' $(objpfx)valgrind-test > $@; $(evaluate-test)
-
-ifeq ($(run-built-tests),yes)
-tests-special += $(objpfx)tst-rtld-does-not-exist.out
-endif
-$(objpfx)tst-rtld-does-not-exist.out: tst-rtld-does-not-exist.sh $(objpfx)ld.so
-	$(SHELL) $< $(objpfx)ld.so > $@; \
-	$(evaluate-test)
-
-tests += $(tests-execstack-$(have-z-execstack))
-ifeq ($(run-built-tests),yes)
-tests-special += \
-  $(objpfx)tst-ldconfig-X.out \
-  $(objpfx)tst-ldconfig-p.out \
-  $(objpfx)tst-ldconfig-soname.out \
-  $(objpfx)tst-rtld-help.out \
-  # tests-special
-ifeq (yes,$(build-shared))
-ifneq ($(PERL),no)
-tests-special += \
-  $(objpfx)noload-mem.out \
-  $(objpfx)tst-leaks1-mem.out \
-  # tests-special
-endif
-endif
-endif
-tlsmod17a-suffixes = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
-tlsmod18a-suffixes = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
-tlsmod17a-modules = $(addprefix tst-tlsmod17a, $(tlsmod17a-suffixes))
-tlsmod18a-modules = $(addprefix tst-tlsmod18a, $(tlsmod17a-suffixes))
-one-hundred = $(foreach x,0 1 2 3 4 5 6 7 8 9, \
-  0$x 1$x 2$x 3$x 4$x 5$x 6$x 7$x 8$x 9$x)
-tst-tls-many-dynamic-modules := \
-  $(foreach n,$(one-hundred),tst-tls-manydynamic$(n)mod)
-tst-tls-many-dynamic-modules-dep-suffixes = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 \
-					    14 15 16 17 18 19
-tst-tls-many-dynamic-modules-dep = \
-  $(foreach n,$(tst-tls-many-dynamic-modules-dep-suffixes),tst-tls-manydynamic$(n)mod-dep)
-tst-tls-many-dynamic-modules-dep-bad-suffixes = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
-tst-tls-many-dynamic-modules-dep-bad = \
-  $(foreach n,$(tst-tls-many-dynamic-modules-dep-bad-suffixes),tst-tls-manydynamic$(n)mod-dep-bad)
-extra-test-objs += \
-  $(tlsmod17a-modules:=.os) \
-  $(tlsmod18a-modules:=.os) \
-  tst-tlsalign-vars.o \
-  # extra-test-objs
-test-extras += \
-  tst-tlsalign-vars \
-  tst-tlsmod17a \
-  tst-tlsmod18a \
-  # test-extras
-modules-names += \
-  circlemod1 \
-  circlemod1a \
-  circlemod2 \
-  circlemod2a \
-  circlemod3 \
-  circlemod3a \
-  constload2 \
-  constload3 \
-  dblloadmod1 \
-  dblloadmod2 \
-  dblloadmod3 \
-  dep1 \
-  dep2 \
-  dep3 \
-  dep4 \
-  failobj \
-  filtmod1 \
-  filtmod2 \
-  firstobj \
-  globalmod1 \
-  libmarkermod1-1 \
-  libmarkermod1-2 \
-  libmarkermod1-3 \
-  libmarkermod2-1 \
-  libmarkermod2-2 \
-  libmarkermod3-1 \
-  libmarkermod3-2 \
-  libmarkermod3-3 \
-  libmarkermod4-1 \
-  libmarkermod4-2 \
-  libmarkermod4-3 \
-  libmarkermod4-4 \
-  libmarkermod5-1 \
-  libmarkermod5-2 \
-  libmarkermod5-3 \
-  libmarkermod5-4 \
-  libmarkermod5-5 \
-  libtracemod1-1 \
-  libtracemod2-1 \
-  libtracemod3-1 \
-  libtracemod4-1 \
-  libtracemod5-1 \
-  ltglobmod1 \
-  ltglobmod2 \
-  neededobj1 \
-  neededobj2 \
-  neededobj3 \
-  neededobj4 \
-  neededobj5 \
-  neededobj6 \
-  nextmod1 \
-  nextmod2 \
-  nextmod3 \
-  nodel2mod1 \
-  nodel2mod2 \
-  nodel2mod3 \
-  nodelmod1 \
-  nodelmod2 \
-  nodelmod3 \
-  nodelmod4 \
-  nodlopenmod \
-  nodlopenmod2 \
-  order2mod1 \
-  order2mod2 \
-  order2mod3 \
-  order2mod4 \
-  pathoptobj \
-  reldep4mod1 \
-  reldep4mod2 \
-  reldep4mod3 \
-  reldep4mod4 \
-  reldep6mod0 \
-  reldep6mod1 \
-  reldep6mod2 \
-  reldep6mod3 \
-  reldep6mod4 \
-  reldep7mod1 \
-  reldep7mod2 \
-  reldep8mod1 \
-  reldep8mod2 \
-  reldep8mod3 \
-  reldep9mod1 \
-  reldep9mod2 \
-  reldep9mod3 \
-  reldepmod1 \
-  reldepmod2 \
-  reldepmod3 \
-  reldepmod4 \
-  reldepmod5 \
-  reldepmod6 \
-  testobj1 \
-  testobj1_1 \
-  testobj2 \
-  testobj3 \
-  testobj4 \
-  testobj5 \
-  testobj6 \
-  tst-absolute-sym-lib \
-  tst-absolute-zero-lib \
-  tst-alignmod \
-  tst-alignmod2 \
-  tst-alignmod3 \
-  tst-array2dep \
-  tst-array5dep \
-  tst-audit-tlsdesc-mod1 \
-  tst-audit-tlsdesc-mod2 \
-  tst-audit11mod1 \
-  tst-audit11mod2 \
-  tst-audit12mod1 \
-  tst-audit12mod2 \
-  tst-audit12mod3 \
-  tst-audit13mod1 \
-  tst-audit18mod \
-  tst-audit19bmod \
-  tst-audit23mod \
-  tst-audit24amod1 \
-  tst-audit24amod2 \
-  tst-audit24bmod1 \
-  tst-audit24bmod2 \
-  tst-audit24dmod1 \
-  tst-audit24dmod2 \
-  tst-audit24dmod3 \
-  tst-audit24dmod4 \
-  tst-audit25mod1 \
-  tst-audit25mod2 \
-  tst-audit25mod3 \
-  tst-audit25mod4 \
-  tst-auditlogmod-1 \
-  tst-auditlogmod-2 \
-  tst-auditlogmod-3 \
-  tst-auditmanymod1 \
-  tst-auditmanymod2 \
-  tst-auditmanymod3 \
-  tst-auditmanymod4 \
-  tst-auditmanymod5 \
-  tst-auditmanymod6 \
-  tst-auditmanymod7 \
-  tst-auditmanymod8 \
-  tst-auditmanymod9 \
-  tst-auditmod-tlsdesc  \
-  tst-auditmod1 \
-  tst-auditmod11 \
-  tst-auditmod12 \
-  tst-auditmod18 \
-  tst-auditmod19a \
-  tst-auditmod19b \
-  tst-auditmod20 \
-  tst-auditmod21a \
-  tst-auditmod21b \
-  tst-auditmod22 \
-  tst-auditmod23 \
-  tst-auditmod24a \
-  tst-auditmod24b \
-  tst-auditmod24c \
-  tst-auditmod24d \
-  tst-auditmod25 \
-  tst-auditmod28 \
-  tst-auditmod9a \
-  tst-auditmod9b \
-  tst-auxvalmod \
-  tst-big-note-lib \
-  tst-deep1mod1 \
-  tst-deep1mod2 \
-  tst-deep1mod3 \
-  tst-dl_find_object-mod1 \
-  tst-dl_find_object-mod2 \
-  tst-dl_find_object-mod3 \
-  tst-dl_find_object-mod4 \
-  tst-dl_find_object-mod5 \
-  tst-dl_find_object-mod6 \
-  tst-dl_find_object-mod7 \
-  tst-dl_find_object-mod8 \
-  tst-dl_find_object-mod9 \
-  tst-dlclose-lazy-mod1 \
-  tst-dlclose-lazy-mod2 \
-  tst-dlmopen-dlerror-mod \
-  tst-dlmopen-gethostbyname-mod \
-  tst-dlmopen-twice-mod1 \
-  tst-dlmopen-twice-mod2 \
-  tst-dlmopen1mod \
-  tst-dlopen-tlsreinitmod1 \
-  tst-dlopen-tlsreinitmod2 \
-  tst-dlopen-tlsreinitmod3 \
-  tst-dlopenfaillinkmod \
-  tst-dlopenfailmod1 \
-  tst-dlopenfailmod2 \
-  tst-dlopenfailmod3 \
-  tst-dlopenfailnodelmod \
-  tst-dlopenrpathmod \
-  tst-filterobj-aux \
-  tst-filterobj-filtee \
-  tst-filterobj-flt \
-  tst-finilazyfailmod \
-  tst-globalmod2 \
-  tst-gnu2-tls2mod0 \
-  tst-gnu2-tls2mod1 \
-  tst-gnu2-tls2mod2 \
-  tst-initlazyfailmod \
-  tst-initorder2a \
-  tst-initorder2b \
-  tst-initorder2c \
-  tst-initorder2d \
-  tst-initordera1 \
-  tst-initordera2 \
-  tst-initordera3 \
-  tst-initordera4 \
-  tst-initorderb1 \
-  tst-initorderb2 \
-  tst-latepthreadmod \
-  tst-ldconfig-ld-mod \
-  tst-ldconfig-soname-lib-with-soname \
-  tst-ldconfig-soname-lib-without-soname \
-  tst-main1mod \
-  tst-nodelete-dlclose-dso \
-  tst-nodelete-dlclose-plugin \
-  tst-nodelete-opened-lib \
-  tst-nodelete2mod \
-  tst-nodeps1-mod \
-  tst-nodeps2-mod \
-  tst-non-directory-mod \
-  tst-null-argv-lib \
-  tst-p_alignmod-base \
-  tst-p_alignmod3 \
-  tst-recursive-tlsmallocmod \
-  tst-recursive-tlsmod0 \
-  tst-recursive-tlsmod1 \
-  tst-recursive-tlsmod2 \
-  tst-recursive-tlsmod3 \
-  tst-recursive-tlsmod4 \
-  tst-recursive-tlsmod5 \
-  tst-recursive-tlsmod6 \
-  tst-recursive-tlsmod7 \
-  tst-recursive-tlsmod8 \
-  tst-recursive-tlsmod9 \
-  tst-recursive-tlsmod10 \
-  tst-recursive-tlsmod11 \
-  tst-recursive-tlsmod12 \
-  tst-recursive-tlsmod13 \
-  tst-recursive-tlsmod14 \
-  tst-recursive-tlsmod15 \
-  tst-relsort1mod1 \
-  tst-relsort1mod2 \
-  tst-ro-dynamic-mod \
-  tst-rootdir-lib \
-  tst-single_threaded-mod1 \
-  tst-single_threaded-mod2 \
-  tst-single_threaded-mod3 \
-  tst-single_threaded-mod4 \
-  tst-sonamemove-linkmod1 \
-  tst-sonamemove-runmod1 \
-  tst-sonamemove-runmod2 \
-  tst-sprof-mod \
-  tst-tls-ie-mod0 \
-  tst-tls-ie-mod1 \
-  tst-tls-ie-mod2 \
-  tst-tls-ie-mod3 \
-  tst-tls-ie-mod4 \
-  tst-tls-ie-mod5 \
-  tst-tls-ie-mod6 \
-  tst-tls19mod1 \
-  tst-tls19mod2 \
-  tst-tls19mod3 \
-  tst-tls20mod-bad \
-  tst-tls21mod \
-  tst-tlsalign-lib \
-  tst-tlsgap-mod0 \
-  tst-tlsgap-mod1 \
-  tst-tlsgap-mod2 \
-  tst-tlsmod1 \
-  tst-tlsmod10 \
-  tst-tlsmod11 \
-  tst-tlsmod12 \
-  tst-tlsmod13 \
-  tst-tlsmod13a \
-  tst-tlsmod14a \
-  tst-tlsmod14b \
-  tst-tlsmod15a \
-  tst-tlsmod15b \
-  tst-tlsmod16a \
-  tst-tlsmod16b \
-  tst-tlsmod17b \
-  tst-tlsmod2 \
-  tst-tlsmod3 \
-  tst-tlsmod4 \
-  tst-tlsmod5 \
-  tst-tlsmod6 \
-  tst-tlsmod7 \
-  tst-tlsmod8 \
-  tst-tlsmod9 \
-  tst-unique1mod1 \
-  tst-unique1mod2 \
-  tst-unique2mod1 \
-  tst-unique2mod2 \
-  tst-unwind-ctor-lib \
-  unload2dep \
-  unload2mod \
-  unload3mod1 \
-  unload3mod2 \
-  unload3mod3 \
-  unload3mod4 \
-  unload4mod1 \
-  unload4mod2 \
-  unload4mod3 \
-  unload4mod4 \
-  unload6mod1 \
-  unload6mod2 \
-  unload6mod3 \
-  unload7mod1 \
-  unload7mod2 \
-  unload8mod1 \
-  unload8mod1x \
-  unload8mod2 \
-  unload8mod3 \
-  unloadmod \
-  vismod1 \
-  vismod2 \
-  vismod3 \
-  # modules-names
-
-modules-names-cxx = \
-  tst-dlopen-nodelete-reloc-mod1 \
-  tst-dlopen-nodelete-reloc-mod2 \
-  tst-dlopen-nodelete-reloc-mod3 \
-  tst-dlopen-nodelete-reloc-mod4 \
-  tst-dlopen-nodelete-reloc-mod5 \
-  tst-dlopen-nodelete-reloc-mod6 \
-  tst-dlopen-nodelete-reloc-mod7 \
-  tst-dlopen-nodelete-reloc-mod8 \
-  tst-dlopen-nodelete-reloc-mod9 \
-  tst-dlopen-nodelete-reloc-mod10 \
-  tst-dlopen-nodelete-reloc-mod11 \
-  tst-dlopen-nodelete-reloc-mod12 \
-  tst-dlopen-nodelete-reloc-mod13 \
-  tst-dlopen-nodelete-reloc-mod14 \
-  tst-dlopen-nodelete-reloc-mod15 \
-  tst-dlopen-nodelete-reloc-mod16 \
-  tst-dlopen-nodelete-reloc-mod17 \
-  tst-nodelete-rtldmod \
-  tst-nodelete-uniquemod \
-  tst-nodelete-zmod \
-  tst-unique3lib \
-  tst-unique3lib2 \
-  tst-unique4lib \
-  # modules-names-cxx
-
-modules-names += \
-  $(if $(CXX),$(modules-names-cxx)) \
-  $(modules-execstack-$(have-z-execstack)) \
-  $(tlsmod17a-modules) \
-  $(tlsmod18a-modules) \
-  $(tst-tls-many-dynamic-modules) \
-  $(tst-tls-many-dynamic-modules-dep) \
-  $(tst-tls-many-dynamic-modules-dep-bad) \
-  # modules-names
-
-# Most modules build with _ISOMAC defined, but those filtered out
-# depend on internal headers.
-modules-names-tests = $(filter-out ifuncmod% tst-tlsmod%,\
-				   $(modules-names))
-
-# For +depfiles in Makerules.
-extra-test-objs += tst-auditmod17.os
-
-ifneq (no,$(have-mtls-descriptor))
-tests += tst-gnu2-tls1
-modules-names += tst-gnu2-tls1mod
-$(objpfx)tst-gnu2-tls1: $(objpfx)tst-gnu2-tls1mod.so
-tst-gnu2-tls1mod.so-no-z-defs = yes
-CFLAGS-tst-gnu2-tls1mod.c += -mtls-dialect=$(have-mtls-descriptor)
-endif # $(have-mtls-descriptor)
-
-ifeq (yes,$(have-protected-data))
-modules-names += tst-protected1moda tst-protected1modb
-tests += tst-protected1a tst-protected1b
-$(objpfx)tst-protected1a: $(addprefix $(objpfx),tst-protected1moda.so tst-protected1modb.so)
-$(objpfx)tst-protected1b: $(addprefix $(objpfx),tst-protected1modb.so tst-protected1moda.so)
-tst-protected1modb.so-no-z-defs = yes
-# These tests fail with GCC versions prior to 5.1 and with some versions
-# of binutils.  See https://sourceware.org/bugzilla/show_bug.cgi?id=17709
-# and https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65248 for details.
-# Perhaps in future we can make these XFAILs conditional on some detection
-# of compiler/linker behavior/version.
-test-xfail-tst-protected1a = yes
-test-xfail-tst-protected1b = yes
-endif
-ifeq (yesyes,$(have-fpie)$(build-shared))
-modules-names += tst-piemod1
-tests += \
-  tst-dlopen-pie \
-  tst-dlopen-self-pie \
-  tst-dlopen-tlsmodid-pie \
-  tst-pie1 \
-  tst-pie2 \
-  # tests
-tests-pie += \
-  tst-dlopen-self-pie \
-  tst-dlopen-tlsmodid-pie \
-  tst-pie1 \
-  tst-pie2 \
-  # tests-pie
-ifeq (yes,$(have-protected-data))
-tests += vismain
-tests-pie += vismain
-CFLAGS-vismain.c += $(PIE-ccflag)
-endif
-endif
-modules-execstack-yes = tst-execstack-mod
-extra-test-objs += $(addsuffix .os,$(strip $(modules-names)))
-
-# filtmod1.so, tst-big-note-lib.so, tst-ro-dynamic-mod.so have special
-# rules.
-modules-names-nobuild += \
-  filtmod1 \
-  tst-audit24bmod1 \
-  tst-audit24bmod2 \
-  tst-big-note-lib \
-  tst-nodeps1-mod \
-  tst-nodeps2-mod \
-  tst-ro-dynamic-mod \
-  # modules-names-nobuild
-
-tests += $(tests-static)
-
-ifeq (yes,$(have-ifunc))
-tests-ifuncstatic := \
-  ifuncmain1picstatic \
-  ifuncmain1static \
-  ifuncmain2picstatic \
-  ifuncmain2static \
-  ifuncmain4picstatic \
-  ifuncmain4static \
-  ifuncmain5picstatic \
-  ifuncmain5static \
-  ifuncmain7picstatic \
-  ifuncmain7static \
-  # tests-ifuncstatic
-ifeq (yes,$(have-gcc-ifunc))
-tests-ifuncstatic += ifuncmain9static ifuncmain9picstatic
-endif
-tests-static += $(tests-ifuncstatic)
-tests-internal += $(tests-ifuncstatic)
-ifeq (yes,$(build-shared))
-tests += \
-  tst-ifunc-fault-bindnow \
-  tst-ifunc-fault-lazy \
-  # tests
-# Note: sysdeps/x86_64/ifuncmain8.c uses ifuncmain8.
-tests-internal += \
-  ifuncmain1pic \
-  ifuncmain1staticpic \
-  ifuncmain1vis \
-  ifuncmain1vispic \
-  ifuncmain2 \
-  ifuncmain2pic \
-  ifuncmain3 \
-  ifuncmain4 \
-  ifuncmain5staticpic \
-  ifuncmain7 \
-  ifuncmain7pic \
-  # tests-internal
-ifeq (no,$(with-lld))
-tests-internal += \
-  ifuncmain1 \
-  ifuncmain5 \
-  ifuncmain5pic \
-  # tests-internal
-endif
-ifeq (yes,$(have-gcc-ifunc))
-tests-internal += \
-  ifuncmain9 \
-  ifuncmain9pic \
-  # tests-internal
-endif
-ifunc-test-modules = \
-  ifuncdep1 \
-  ifuncdep1pic \
-  ifuncdep2 \
-  ifuncdep2pic \
-  ifuncdep5 \
-  ifuncdep5pic \
-  # ifunc-test-modules
-extra-test-objs += $(ifunc-test-modules:=.o)
-test-internal-extras += $(ifunc-test-modules)
-ifeq (yes,$(have-fpie))
-ifunc-pie-tests = \
-  ifuncmain1pie \
-  ifuncmain1staticpie \
-  ifuncmain1vispie \
-  ifuncmain6pie \
-  ifuncmain7pie \
-  # ifunc-pie-tests
-ifeq (yes,$(have-gcc-ifunc))
-ifunc-pie-tests += ifuncmain9pie
-endif
-ifeq (no,$(with-lld))
-ifunc-pie-tests += ifuncmain5pie
-endif
-ifeq (yes,$(have-textrel_ifunc))
-ifunc-pie-tests += tst-ifunc-textrel
-endif
-tests-internal += $(ifunc-pie-tests)
-tests-pie += $(ifunc-pie-tests)
-endif
-modules-names += \
-  ifuncmod1 \
-  ifuncmod3 \
-  ifuncmod6 \
-  # modules-names
-ifeq (no,$(with-lld))
-modules-names += ifuncmod5
-endif
-endif
-endif
-
-ifeq (yes,$(build-shared))
-ifeq ($(run-built-tests),yes)
-tests-special += \
-  $(objpfx)argv0test.out \
-  $(objpfx)tst-non-directory-path.out \
-  $(objpfx)tst-pathopt.out \
-  $(objpfx)tst-rtld-help.out \
-  $(objpfx)tst-rtld-list-diagnostics.out \
-  $(objpfx)tst-rtld-load-self.out \
-  $(objpfx)tst-rtld-preload.out \
-  $(objpfx)tst-sprof-basic.out \
-  # tests-special
-endif
-tests-special += \
-  $(objpfx)check-execstack.out \
-  $(objpfx)check-initfini.out \
-  $(objpfx)check-localplt.out \
-  $(objpfx)check-textrel.out \
-  $(objpfx)check-wx-segment.out \
-  # tests-special
-endif
-
-ifeq ($(run-built-tests),yes)
-tests-special += \
-  $(objpfx)order-cmp.out \
-  $(objpfx)order2-cmp.out \
-  $(objpfx)tst-array1-cmp.out \
-  $(objpfx)tst-array1-static-cmp.out \
-  $(objpfx)tst-array2-cmp.out \
-  $(objpfx)tst-array3-cmp.out \
-  $(objpfx)tst-array4-cmp.out \
-  $(objpfx)tst-array5-cmp.out \
-  $(objpfx)tst-array5-static-cmp.out \
-  $(objpfx)tst-initorder-cmp.out \
-  $(objpfx)tst-initorder2-cmp.out \
-  $(objpfx)tst-trace1.out \
-  $(objpfx)tst-trace2.out \
-  $(objpfx)tst-trace3.out \
-  $(objpfx)tst-trace4.out \
-  $(objpfx)tst-trace5.out \
-  $(objpfx)tst-unused-dep-cmp.out \
-  $(objpfx)tst-unused-dep.out \
-  # tests-special
-endif
-
-ifndef avoid-generated
-# DSO sorting tests:
-# The dso-ordering-test.py script generates testcase source files in $(objpfx),
-# creating a $(objpfx)<testcase-name>-dir for each testcase, and creates a
-# Makefile fragment to be included.
-define include_dsosort_tests
-$(objpfx)$(1).generated-makefile: $(1)
-	$(PYTHON) $(..)scripts/dso-ordering-test.py \
-	--description-file $$< --objpfx $(objpfx) --output-makefile $$@T
-	mv $$@T $$@
--include $(objpfx)$(1).generated-makefile
-endef
-endif
-
-postclean-generated += $(objpfx)/dso-sort-tests-2.generated-makefile \
-		       $(objpfx)/dso-sort-tests-2.generated-makefile
-
-# Generate from each testcase description file
-$(eval $(call include_dsosort_tests,dso-sort-tests-1.def))
-$(eval $(call include_dsosort_tests,dso-sort-tests-2.def))
-
-# BZ15311 is intentionally underlinked.
-LDFLAGS-tst-bz15311-b.so += -Wl,-z,lazy
-LDFLAGS-tst-bz15311-c.so += -Wl,-z,lazy
-LDFLAGS-tst-bz15311-d.so += -Wl,-z,lazy
-
-check-abi: $(objpfx)check-abi-ld.out \
-	   $(objpfx)check-abi-version-libc.out
-tests-special += \
-  $(objpfx)check-abi-ld.out \
-  $(objpfx)check-abi-version-libc.out \
-# tests-special
-update-abi: update-abi-ld
-update-all-abi: update-all-abi-ld
-
-tests-special += $(objpfx)tst-glibcelf.out
-$(objpfx)tst-glibcelf.out: tst-glibcelf.py elf.h $(..)/scripts/glibcelf.py \
-  $(..)/scripts/glibcextract.py
-	PYTHONPATH=$(..)scripts $(PYTHON) tst-glibcelf.py \
-          --cc="$(CC) $(patsubst -DMODULE_NAME=%,-DMODULE_NAME=testsuite,$(CPPFLAGS))" \
-	  < /dev/null > $@ 2>&1; $(evaluate-test)
-
-ifeq ($(run-built-tests),yes)
-tests-special += $(objpfx)tst-tls-allocation-failure-static-patched.out
-endif
-
-# The test requires shared _and_ PIE because the executable
-# unit test driver must be able to link with the shared object
-# that is going to eventually go into an installed DSO.
-ifeq (yesyes,$(have-fpie)$(build-shared))
-tests-internal += tst-_dl_addr_inside_object
-tests-pie += tst-_dl_addr_inside_object
-$(objpfx)tst-_dl_addr_inside_object: $(objpfx)dl-addr-obj.os
-CFLAGS-tst-_dl_addr_inside_object.c += $(PIE-ccflag)
-endif
+  # routines
 
 include ../Rules
-
-ifeq (yes,$(build-shared))
-# Make sure these things are built in the `make lib' pass so they can be used
-# to run programs during the `make others' pass.
-lib-noranlib: $(objpfx)$(rtld-installed-name) \
-	      $(addprefix $(objpfx),$(extra-objs))
-endif
-
-# Command to link into a larger single relocatable object.
-reloc-link = $(LINK.o) -nostdlib -nostartfiles -r
-
-$(objpfx)dl-allobjs.os: $(all-rtld-routines:%=$(objpfx)%.os)
-	$(reloc-link) -o $@ $^
-
-# Link together the dynamic linker into a single relocatable object.
-# First we do a link against libc_pic.a just to get a link map,
-# and discard the object produced by that link.  From the link map
-# we can glean all the libc modules that need to go into the dynamic
-# linker.  Then we do a recursive make that goes into all the subdirs
-# those modules come from and builds special rtld-foo.os versions that
-# are compiled with special flags, and puts these modules into rtld-libc.a
-# for us.  Then we do the real link using rtld-libc.a instead of libc_pic.a.
-
-# These symbols need to be stubbed out during symbol discovery because
-# their implementation is provided differently in rtld, and the symbol
-# discovery mechanism is not compatible with the libc implementation
-# when compiled for libc.
-rtld-stubbed-symbols = \
-  __GI___pthread_disable_asynccancel \
-  __GI___pthread_enable_asynccancel \
-  __libc_assert_fail \
-  __pthread_disable_asynccancel \
-  __pthread_enable_asynccancel \
-  calloc \
-  free \
-  malloc \
-  realloc \
-  # rtld-stubbed-symbols
-
-ifeq ($(have-ssp),yes)
-# rtld is not built with the stack protector, so these references will
-# go away in the rebuilds.
-rtld-stubbed-symbols += __stack_chk_fail __stack_chk_fail_local
-endif
-
-$(objpfx)librtld.map: $(objpfx)dl-allobjs.os $(common-objpfx)libc_pic.a
-	@-rm -f $@T
-	for symbol in $(rtld-stubbed-symbols); do \
-		echo ".globl $$symbol"; \
-		echo "$$symbol:"; \
-	done | $(CC) -o $@T.o $(ASFLAGS) -c -x assembler -
-	$(reloc-link) -o $@.o $@T.o '-Wl,-(' $^ -lgcc '-Wl,-)' -Wl,-Map,$@T
-	rm -f %@T.o $@.o
-	mv -f $@T $@
-
-# For lld, skip preceding addresses and values before matching the archive and the member.
-$(objpfx)librtld.mk: $(objpfx)librtld.map Makefile
-	LC_ALL=C \
-	sed -n 's@^[0-9a-f ]*$(common-objpfx)\([^(]*\)(\([^)]*\.os\)) *.*$$@\1 \2@p' \
-	    $< | \
-	while read lib file; do \
-	  case $$lib in \
-	  libc_pic.a) \
-	    LC_ALL=C grep -F -l /$$file \
-		  $(common-objpfx)stamp.os $(common-objpfx)*/stamp.os | \
-	    LC_ALL=C \
-	    sed 's@^$(common-objpfx)\([^/]*\)/stamp\.os$$@rtld-\1'" +=$$file@"\
-	    ;; \
-	  */*.a) \
-	    echo rtld-$${lib%%/*} += $$file ;; \
-	  *) echo "Wasn't expecting $$lib($$file)" >&2; exit 1 ;; \
-	  esac; \
-	done > $@T
-	echo rtld-subdirs = `LC_ALL=C sed 's/^rtld-\([^ ]*\).*$$/\1/' $@T \
-			     | LC_ALL=C sort -u` >> $@T
-	mv -f $@T $@
-
-$(objpfx)rtld-libc.a: $(objpfx)librtld.mk FORCE
-	$(MAKE) -f $< -f rtld-Rules
-
-$(objpfx)librtld.os: $(objpfx)dl-allobjs.os $(objpfx)rtld-libc.a
-	$(LINK.o) -nostdlib -nostartfiles -r -o $@ '-Wl,-(' $^ -lgcc '-Wl,-)' \
-		  -Wl,-Map,$@.map
-
-generated += librtld.map librtld.mk rtld-libc.a librtld.os.map
-
-z-now-yes = -Wl,-z,now
-
-$(objpfx)ld.so: $(objpfx)librtld.os $(ld-map)
-# Link into a temporary file so that we don't touch $@ at all
-# if the sanity check below fails.
-	$(LINK.o) -nostdlib -nostartfiles -shared -o $@.new		\
-		  $(LDFLAGS-rtld) -Wl,-z,defs $(z-now-$(bind-now))	\
-		  $(dt-relr-ldflag) \
-		  $(filter-out $(map-file),$^) $(load-map-file)		\
-		  -Wl,-soname=$(rtld-installed-name)
-	$(call after-link,$@.new)
-	$(READELF) -s $@.new \
-	  | $(AWK) '($$7 ~ /^UND(|EF)$$/ && $$1 != "0:" && $$4 != "REGISTER") { print; p=1 } END { exit p != 0 }'
-	mv -f $@.new $@
-
-ifeq (yes,$(build-shared))
-# interp.c exists just to get the runtime linker path into libc.so.
-$(objpfx)interp.os: $(common-objpfx)runtime-linker.h
-endif
-
-ifneq (ld.so,$(rtld-installed-name))
-# Make sure ld.so.1 exists in the build directory so we can link
-# against it.
-$(objpfx)$(rtld-installed-name): $(objpfx)ld.so
-	$(make-link)
-generated += $(rtld-installed-name)
-endif
-
-# Build a file mentioning all trustworthy directories to look for shared
-# libraries when using LD_LIBRARY_PATH in a setuid program.  The user can
-# add directories to the list by defining $(user-defined-trusted-dirs)
-# before starting make.
-$(objpfx)trusted-dirs.h: $(objpfx)trusted-dirs.st; @:
-$(objpfx)trusted-dirs.st: Makefile $(..)Makeconfig
-	$(make-target-directory)
-	echo "$(subst :, ,$(default-rpath) $(user-defined-trusted-dirs))"    \
-	| $(AWK) -f gen-trusted-dirs.awk > ${@:st=T};
-	echo '#define DL_DST_LIB "$(notdir $(slibdir))"' >> ${@:st=T}
-	$(move-if-change) ${@:st=T} ${@:st=h}
-	touch $@
-CPPFLAGS-dl-load.c += -I$(objpfx). -I$(csu-objpfx).
-
-ifeq (yes,$(build-shared))
-$(inst_rtlddir)/$(rtld-installed-name): $(objpfx)ld.so $(+force)
-	$(make-target-directory)
-	$(do-install-program)
-
-# Creates the relative /usr/bin/ld.so symbolic link.
-$(inst_bindir)/ld.so: $(inst_rtlddir)/$(rtld-installed-name)
-	$(make-target-directory)
-	$(make-link)
-
-# Special target called by parent to install just the dynamic linker.
-.PHONY: ldso_install
-ldso_install: $(inst_rtlddir)/$(rtld-installed-name)
-endif # $(build-shared)
-
-
-# Workarounds for ${exec_prefix} expansion in configure variables.
-# config.status cannot be used directly for processing ldd.bash.in or
-# expanding variables such as sysconfdir because the expansion
-# contains the literal string ${exec_prefix}, which is not valid in C
-# headers or installed shell scripts.
-
-ldd-rewrite = -e 's%@RTLD@%$(rtlddir)/$(rtld-installed-name)%g' \
-	      -e 's%@VERSION@%$(version)%g' \
-	      -e 's|@PKGVERSION@|$(PKGVERSION)|g' \
-	      -e 's|@REPORT_BUGS_TO@|$(REPORT_BUGS_TO)|g' \
-	      -e 's%@TEXTDOMAINDIR@%$(localedir)%g'
-
-ifeq ($(ldd-rewrite-script),no)
-define gen-ldd
-LC_ALL=C sed $(ldd-rewrite) < $< > $@.new
-endef
-else
-define gen-ldd
-LC_ALL=C sed $(ldd-rewrite) < $< \
-| LC_ALL=C sed -f $(patsubst $(..)/%,/%,$(..)$(ldd-rewrite-script)) > $@.new
-endef
-endif
-
-$(objpfx)ldd: ldd.bash.in $(common-objpfx)soversions.mk \
-	      $(common-objpfx)config.make
-	$(gen-ldd)
-	chmod 555 $@.new
-	mv -f $@.new $@
-
-$(objpfx)sln: $(sln-modules:%=$(objpfx)%.o)
-
-$(objpfx)ldconfig: $(ldconfig-modules:%=$(objpfx)%.o)
-
-SYSCONF-FLAGS := -D'SYSCONFDIR="$(sysconfdir)"'
-CFLAGS-ldconfig.c += $(SYSCONF-FLAGS) -D'LIBDIR="$(libdir)"' \
-		    -D'SLIBDIR="$(slibdir)"'
-libof-ldconfig = ldconfig
-CFLAGS-dl-cache.c += $(SYSCONF-FLAGS)
-CFLAGS-cache.c += $(SYSCONF-FLAGS)
-CFLAGS-rtld.c += $(SYSCONF-FLAGS)
-CFLAGS-dl-usage.c += $(SYSCONF-FLAGS) \
-  -D'RTLD="$(rtlddir)/$(rtld-installed-name)"'
-CFLAGS-dl-diagnostics.c += $(SYSCONF-FLAGS) \
-  -D'PREFIX="$(prefix)"' \
-  -D'RTLD="$(rtlddir)/$(rtld-installed-name)"'
-
-cpp-srcs-left := $(all-rtld-routines:=.os)
-lib := rtld
-include $(patsubst %,$(..)libof-iterator.mk,$(cpp-srcs-left))
-
-test-modules = $(addprefix $(objpfx),$(addsuffix .so,$(strip $(modules-names))))
-generated += $(addsuffix .so,$(strip $(modules-names)))
-
-$(objpfx)testobj1_1.so: $(objpfx)testobj1.so
-$(objpfx)testobj2.so: $(objpfx)testobj1.so
-$(objpfx)testobj6.so: $(objpfx)testobj1.so $(objpfx)testobj2.so
-$(objpfx)failobj.so: $(objpfx)testobj6.so
-$(objpfx)dep1.so: $(objpfx)dep2.so $(objpfx)dep4.so
-$(objpfx)dep2.so: $(objpfx)dep3.so $(objpfx)dep4.so
-$(objpfx)dep4.so: $(objpfx)dep3.so
-$(objpfx)nodelmod3.so: $(objpfx)nodelmod4.so
-$(objpfx)neededobj2.so: $(objpfx)neededobj1.so
-$(objpfx)neededobj3.so: $(objpfx)neededobj1.so $(objpfx)neededobj2.so
-$(objpfx)neededobj4.so: $(objpfx)neededobj1.so $(objpfx)neededobj2.so \
-			$(objpfx)neededobj3.so
-$(objpfx)neededobj6.so: $(objpfx)neededobj5.so
-$(objpfx)unload2mod.so: $(objpfx)unload2dep.so
-$(objpfx)firstobj.so: $(shared-thread-library)
-$(objpfx)reldep4mod1.so: $(objpfx)reldep4mod3.so
-$(objpfx)reldep4mod2.so: $(objpfx)reldep4mod4.so
-$(objpfx)dblloadmod1.so: $(objpfx)dblloadmod3.so
-$(objpfx)dblloadmod2.so: $(objpfx)dblloadmod3.so
-$(objpfx)reldepmod5.so: $(objpfx)reldepmod2.so
-$(objpfx)reldepmod6.so: $(objpfx)reldepmod2.so
-$(objpfx)reldep6mod1.so: $(objpfx)reldep6mod0.so
-$(objpfx)reldep6mod2.so: $(objpfx)reldep6mod1.so
-$(objpfx)reldep6mod3.so: $(objpfx)reldep6mod2.so
-$(objpfx)reldep6mod4.so: $(objpfx)reldep6mod1.so
-$(objpfx)tst-tlsmod3.so: $(objpfx)tst-tlsmod2.so
-$(objpfx)tst-tlsmod8.so: $(objpfx)tst-tlsmod7.so
-$(objpfx)tst-tlsmod10.so: $(objpfx)tst-tlsmod9.so
-$(objpfx)tst-tlsmod12.so: $(objpfx)tst-tlsmod11.so
-$(objpfx)tst-tlsmod13a.so: $(objpfx)tst-tlsmod13.so
-# For tst-tls9-static, make sure the modules it dlopens have libc.so in DT_NEEDED
-$(objpfx)tst-tlsmod5.so: $(common-objpfx)libc.so
-$(objpfx)tst-tlsmod6.so: $(common-objpfx)libc.so
-$(objpfx)tst-tls19mod1.so: $(objpfx)tst-tls19mod2.so $(objpfx)tst-tls19mod3.so
-$(objpfx)tst-tls19mod3.so: $(objpfx)ld.so
-$(objpfx)reldep8mod3.so: $(objpfx)reldep8mod1.so $(objpfx)reldep8mod2.so
-$(objpfx)nodel2mod3.so: $(objpfx)nodel2mod1.so $(objpfx)nodel2mod2.so
-$(objpfx)reldep9mod2.so: $(objpfx)reldep9mod1.so
-$(objpfx)reldep9mod3.so: $(objpfx)reldep9mod1.so $(objpfx)reldep9mod2.so
-$(objpfx)unload3mod1.so: $(objpfx)unload3mod3.so
-$(objpfx)unload3mod2.so: $(objpfx)unload3mod3.so
-$(objpfx)unload3mod3.so: $(objpfx)unload3mod4.so
-$(objpfx)unload4mod1.so: $(objpfx)unload4mod2.so $(objpfx)unload4mod3.so
-$(objpfx)unload4mod2.so: $(objpfx)unload4mod4.so $(objpfx)unload4mod3.so
-$(objpfx)unload7mod2.so: $(objpfx)unload7mod1.so
-$(objpfx)unload8mod1.so: $(objpfx)unload8mod2.so
-$(objpfx)unload8mod2.so: $(objpfx)unload8mod3.so
-$(objpfx)tst-initordera2.so: $(objpfx)tst-initordera1.so
-$(objpfx)tst-initorderb2.so: $(objpfx)tst-initorderb1.so $(objpfx)tst-initordera2.so
-$(objpfx)tst-initordera3.so: $(objpfx)tst-initorderb2.so $(objpfx)tst-initorderb1.so
-$(objpfx)tst-initordera4.so: $(objpfx)tst-initordera3.so
-$(objpfx)tst-initorder: $(objpfx)tst-initordera4.so $(objpfx)tst-initordera1.so $(objpfx)tst-initorderb2.so
-$(objpfx)tst-null-argv: $(objpfx)tst-null-argv-lib.so
-$(objpfx)tst-tlsalign: $(objpfx)tst-tlsalign-lib.so
-$(objpfx)tst-nodelete-opened.out: $(objpfx)tst-nodelete-opened-lib.so
-
-$(objpfx)tst-tlsalign-extern: $(objpfx)tst-tlsalign-vars.o
-$(objpfx)tst-tlsalign-extern-static: $(objpfx)tst-tlsalign-vars.o
-
-tst-null-argv-ENV = LD_DEBUG=all LD_DEBUG_OUTPUT=$(objpfx)tst-null-argv.debug.out
-LDFLAGS-nodel2mod3.so = -Wl,--no-as-needed
-LDFLAGS-reldepmod5.so = -Wl,--no-as-needed
-LDFLAGS-reldep6mod1.so = -Wl,--no-as-needed
-LDFLAGS-reldep6mod4.so = -Wl,--no-as-needed
-LDFLAGS-reldep8mod3.so = -Wl,--no-as-needed
-LDFLAGS-unload4mod1.so = -Wl,--no-as-needed
-LDFLAGS-unload4mod2.so = -Wl,--no-as-needed
-LDFLAGS-tst-initorder = -Wl,--no-as-needed
-LDFLAGS-tst-initordera2.so = -Wl,--no-as-needed
-LDFLAGS-tst-initordera3.so = -Wl,--no-as-needed
-LDFLAGS-tst-initordera4.so = -Wl,--no-as-needed
-LDFLAGS-tst-initorderb2.so = -Wl,--no-as-needed
-LDFLAGS-tst-tlsmod5.so = -nostdlib -Wl,--no-as-needed
-LDFLAGS-tst-tlsmod6.so = -nostdlib -Wl,--no-as-needed
-
-# The following tests are underlinked, and rely on late loading.  On toolchains
-# that set -z now by default, this leads to failures to load or fix up the
-# executables being tested.
-LDFLAGS-circlemod2.so = -Wl,-z,lazy
-LDFLAGS-tst-tls20mod-bad.so = -Wl,-z,lazy
-LDFLAGS-reldep6mod1.so += -Wl,-z,lazy
-LDFLAGS-constload2.so = -Wl,-z,lazy
-LDFLAGS-constload3.so = -Wl,-z,lazy
-LDFLAGS-dblloadmod3.so = -Wl,-z,lazy
-LDFLAGS-ifuncmod6.so = -Wl,-z,lazy
-LDFLAGS-ltglobmod2.so = -Wl,-z,lazy
-LDFLAGS-testobj1.so = -Wl,-z,lazy
-LDFLAGS-testobj6.so = -Wl,-z,lazy
-
-testobj1.so-no-z-defs = yes
-testobj3.so-no-z-defs = yes
-testobj4.so-no-z-defs = yes
-testobj5.so-no-z-defs = yes
-testobj6.so-no-z-defs = yes
-failobj.so-no-z-defs = yes
-constload2.so-no-z-defs = yes
-constload3.so-no-z-defs = yes
-nodelmod1.so-no-z-defs = yes
-nodelmod2.so-no-z-defs = yes
-nodelmod4.so-no-z-defs = yes
-nodel2mod2.so-no-z-defs = yes
-reldepmod2.so-no-z-defs = yes
-reldepmod3.so-no-z-defs = yes
-reldepmod4.so-no-z-defs = yes
-reldep4mod4.so-no-z-defs = yes
-reldep4mod2.so-no-z-defs = yes
-ltglobmod2.so-no-z-defs = yes
-dblloadmod3.so-no-z-defs = yes
-tst-tlsmod1.so-no-z-defs = yes
-tst-tlsmod2.so-no-z-defs = yes
-tst-tlsmod3.so-no-z-defs = yes
-tst-tlsmod4.so-no-z-defs = yes
-tst-tlsmod7.so-no-z-defs = yes
-tst-tlsmod8.so-no-z-defs = yes
-tst-tlsmod9.so-no-z-defs = yes
-tst-tlsmod10.so-no-z-defs = yes
-tst-tlsmod12.so-no-z-defs = yes
-tst-tlsmod14a.so-no-z-defs = yes
-tst-tlsmod14b.so-no-z-defs = yes
-tst-tlsmod15a.so-no-z-defs = yes
-tst-tlsmod16b.so-no-z-defs = yes
-circlemod2.so-no-z-defs = yes
-circlemod3.so-no-z-defs = yes
-circlemod3a.so-no-z-defs = yes
-reldep8mod2.so-no-z-defs = yes
-reldep9mod1.so-no-z-defs = yes
-unload3mod4.so-no-z-defs = yes
-unload4mod1.so-no-z-defs = yes
-ifuncmod1.so-no-z-defs = yes
-ifuncmod5.so-no-z-defs = yes
-ifuncmod6.so-no-z-defs = yes
-tst-auditmod9a.so-no-z-defs = yes
-tst-auditmod9b.so-no-z-defs = yes
-tst-nodelete-uniquemod.so-no-z-defs = yes
-tst-nodelete-rtldmod.so-no-z-defs = yes
-tst-nodelete-zmod.so-no-z-defs = yes
-tst-nodelete2mod.so-no-z-defs = yes
-
-ifeq ($(build-shared),yes)
-# Build all the modules even when not actually running test programs.
-tests: $(test-modules)
-endif
-
-LDFLAGS-loadtest = -rdynamic
-
-$(objpfx)loadtest.out: $(test-modules)
-
-$(objpfx)neededtest.out: $(objpfx)neededobj1.so $(objpfx)neededobj2.so \
-			 $(objpfx)neededobj3.so
-
-$(objpfx)neededtest2.out: $(objpfx)neededobj1.so $(objpfx)neededobj2.so \
-			  $(objpfx)neededobj3.so
-
-$(objpfx)neededtest3.out: $(objpfx)neededobj1.so $(objpfx)neededobj2.so \
-			  $(objpfx)neededobj3.so $(objpfx)neededobj4.so
-
-$(objpfx)neededtest4: $(objpfx)neededobj1.so
-$(objpfx)neededtest4.out: $(objpfx)neededobj5.so $(objpfx)neededobj6.so
-
-$(objpfx)restest1: $(objpfx)testobj1.so $(objpfx)testobj1_1.so
-LDFLAGS-restest1 = -rdynamic
-
-LDFLAGS-restest2 = -rdynamic
-
-$(objpfx)restest1.out: $(test-modules)
-
-preloadtest-preloads = testobj1 testobj2 testobj3 testobj4 testobj5
-$(objpfx)preloadtest: $(objpfx)testobj6.so
-LDFLAGS-preloadtest = -rdynamic
-$(objpfx)preloadtest.out: $(preloadtest-preloads:%=$(objpfx)%.so)
-preloadtest-ENV = \
-  LD_PRELOAD=$(subst $(empty) ,:,$(strip $(preloadtest-preloads:=.so)))
-
-LDFLAGS-loadfail = -rdynamic
-
-$(objpfx)loadfail.out: $(objpfx)failobj.so $(objpfx)testobj1.so \
-		       $(objpfx)testobj2.so $(objpfx)testobj3.so \
-		       $(objpfx)testobj4.so $(objpfx)testobj5.so
-
-LDFLAGS-multiload = -rdynamic
-CFLAGS-multiload.c += -DOBJDIR=\"$(elf-objpfx)\"
-
-$(objpfx)multiload.out: $(objpfx)testobj1.so
-
-LDFLAGS-origtest = -rdynamic
-$(objpfx)origtest.out: $(objpfx)testobj1.so
-
-$(objpfx)resolvfail.out: $(objpfx)testobj1.so
-ifeq ($(have-thread-library),yes)
-$(objpfx)resolvfail: $(shared-thread-library)
-endif
-
-$(objpfx)constload1.out: $(objpfx)constload2.so $(objpfx)constload3.so
-
-$(objpfx)circleload1.out: $(objpfx)circlemod1.so \
-			  $(objpfx)circlemod1a.so
-
-$(objpfx)circlemod1.so: $(objpfx)circlemod2.so
-$(objpfx)circlemod2.so: $(objpfx)circlemod3.so
-$(objpfx)circlemod1a.so: $(objpfx)circlemod2a.so
-$(objpfx)circlemod2a.so: $(objpfx)circlemod3a.so
-
-$(objpfx)order: $(addprefix $(objpfx),dep4.so dep3.so dep2.so dep1.so)
-
-$(objpfx)order-cmp.out: $(objpfx)order.out
-	(echo "0123456789" | cmp $< -) > $@; \
-	$(evaluate-test)
-
-$(objpfx)vismain: $(addprefix $(objpfx),vismod1.so vismod2.so)
-$(objpfx)vismain.out: $(addprefix $(objpfx),vismod3.so)
-vismain-ENV = LD_PRELOAD=$(addprefix $(objpfx),vismod3.so)
-
-$(objpfx)noload: $(objpfx)testobj1.so
-LDFLAGS-noload = -rdynamic -Wl,--no-as-needed
-$(objpfx)noload.out: $(objpfx)testobj5.so
-
-$(objpfx)noload-mem.out: $(objpfx)noload.out
-	$(common-objpfx)malloc/mtrace $(objpfx)noload.mtrace > $@; \
-	$(evaluate-test)
-noload-ENV = MALLOC_TRACE=$(objpfx)noload.mtrace \
-	     LD_PRELOAD=$(common-objpfx)/malloc/libc_malloc_debug.so
-
-LDFLAGS-nodelete = -rdynamic
-LDFLAGS-nodelmod1.so = -Wl,--enable-new-dtags,-z,nodelete
-LDFLAGS-nodelmod4.so = -Wl,--enable-new-dtags,-z,nodelete
-$(objpfx)nodelete.out: $(objpfx)nodelmod1.so $(objpfx)nodelmod2.so \
-		       $(objpfx)nodelmod3.so
-
-LDFLAGS-nodlopenmod.so = -Wl,--enable-new-dtags,-z,nodlopen
-$(objpfx)nodlopen.out: $(objpfx)nodlopenmod.so
-
-$(objpfx)nodlopenmod2.so: $(objpfx)nodlopenmod.so
-$(objpfx)nodlopen2.out: $(objpfx)nodlopenmod2.so
-
-$(objpfx)filtmod1.so: $(objpfx)filtmod1.os $(objpfx)filtmod2.so
-	$(LINK.o) -shared -o $@ -B$(csu-objpfx) $(LDFLAGS.so) \
-		  $(dt-relr-ldflag) \
-		  -L$(subst :, -L,$(rpath-link)) \
-		  -Wl,-rpath-link=$(rpath-link) \
-		  $< -Wl,-F,$(objpfx)filtmod2.so
-$(objpfx)filter: $(objpfx)filtmod1.so
-
-# This does not link against libc.
-CFLAGS-filtmod1.c += $(no-stack-protector)
-
-$(objpfx)unload.out: $(objpfx)unloadmod.so
-
-$(objpfx)reldep.out: $(objpfx)reldepmod1.so $(objpfx)reldepmod2.so
-
-$(objpfx)reldep2.out: $(objpfx)reldepmod1.so $(objpfx)reldepmod3.so
-
-$(objpfx)reldep3.out: $(objpfx)reldepmod1.so $(objpfx)reldepmod4.so
-
-$(objpfx)reldep4.out: $(objpfx)reldep4mod1.so $(objpfx)reldep4mod2.so
-
-$(objpfx)next: $(objpfx)nextmod1.so $(objpfx)nextmod2.so
-LDFLAGS-next = -Wl,--no-as-needed
-
-$(objpfx)tst-next-ver: $(objpfx)nextmod3.so
-LDFLAGS-tst-next-ver = -Wl,--no-as-needed
-
-$(objpfx)unload2.out: $(objpfx)unload2mod.so $(objpfx)unload2dep.so
-
-$(objpfx)lateglobal.out: $(objpfx)ltglobmod1.so $(objpfx)ltglobmod2.so
-
-$(objpfx)tst-pathopt.out: tst-pathopt.sh $(objpfx)tst-pathopt \
-			  $(objpfx)pathoptobj.so
-	$(SHELL) $< $(common-objpfx) '$(test-wrapper-env)' \
-		 '$(run-program-env)'; \
-	$(evaluate-test)
-
-$(objpfx)tst-rtld-load-self.out: tst-rtld-load-self.sh $(objpfx)ld.so
-	$(SHELL) $^ '$(test-wrapper)' '$(test-wrapper-env)' > $@; \
-	$(evaluate-test)
-
-tst-rtld-preload-OBJS = $(subst $(empty) ,:,$(strip $(preloadtest-preloads:=.so)))
-$(objpfx)tst-rtld-preload.out: tst-rtld-preload.sh $(objpfx)ld.so \
-			       $(objpfx)preloadtest \
-			       $(preloadtest-preloads:%=$(objpfx)%.so)
-	$(SHELL) $< $(objpfx)ld.so $(objpfx)preloadtest \
-		    '$(test-wrapper-env)' '$(run_program_env)' \
-		    '$(rpath-link)' '$(tst-rtld-preload-OBJS)' > $@; \
-	$(evaluate-test)
-
-$(objpfx)initfirst.out: $(objpfx)firstobj.so
-
-$(objpfx)global: $(objpfx)globalmod1.so
-$(objpfx)global.out: $(objpfx)reldepmod1.so $(objpfx)reldepmod4.so
-
-$(objpfx)dblload.out: $(objpfx)dblloadmod1.so $(objpfx)dblloadmod2.so
-
-$(objpfx)dblunload.out: $(objpfx)dblloadmod1.so $(objpfx)dblloadmod2.so
-
-$(objpfx)reldep5.out: $(objpfx)reldepmod5.so $(objpfx)reldepmod6.so
-
-$(objpfx)reldep6.out: $(objpfx)reldep6mod3.so $(objpfx)reldep6mod4.so
-
-$(objpfx)reldep7.out: $(objpfx)reldep7mod1.so $(objpfx)reldep7mod2.so
-
-$(objpfx)reldep8.out: $(objpfx)reldep8mod3.so
-
-LDFLAGS-nodel2mod2.so = -Wl,--enable-new-dtags,-z,nodelete
-$(objpfx)nodelete2.out: $(objpfx)nodel2mod3.so
-
-$(objpfx)reldep9.out: $(objpfx)reldep9mod3.so
-
-$(objpfx)tst-tls3: $(objpfx)tst-tlsmod1.so
-
-$(objpfx)tst-tls4.out: $(objpfx)tst-tlsmod2.so
-
-$(objpfx)tst-tls5.out: $(objpfx)tst-tlsmod2.so
-
-$(objpfx)tst-tls6.out: $(objpfx)tst-tlsmod2.so
-
-$(objpfx)tst-tls7.out: $(objpfx)tst-tlsmod3.so
-
-$(objpfx)tst-tls8.out: $(objpfx)tst-tlsmod3.so $(objpfx)tst-tlsmod4.so
-
-$(objpfx)tst-tls9.out: $(objpfx)tst-tlsmod5.so $(objpfx)tst-tlsmod6.so
-
-$(objpfx)tst-tls10: $(objpfx)tst-tlsmod8.so $(objpfx)tst-tlsmod7.so
-
-$(objpfx)tst-tls11: $(objpfx)tst-tlsmod10.so $(objpfx)tst-tlsmod9.so
-
-$(objpfx)tst-tls12: $(objpfx)tst-tlsmod12.so $(objpfx)tst-tlsmod11.so
-
-$(objpfx)tst-tls13.out: $(objpfx)tst-tlsmod13a.so
-
-$(objpfx)tst-tls14: $(objpfx)tst-tlsmod14a.so
-$(objpfx)tst-tls14.out: $(objpfx)tst-tlsmod14b.so
-
-$(objpfx)tst-tls15.out: $(objpfx)tst-tlsmod15a.so $(objpfx)tst-tlsmod15b.so
-
-$(objpfx)tst-tls-dlinfo.out: $(objpfx)tst-tlsmod2.so
-
-
-
-$(objpfx)tst-tls16.out: $(objpfx)tst-tlsmod16a.so $(objpfx)tst-tlsmod16b.so
-
-$(objpfx)tst-tls17.out: $(objpfx)tst-tlsmod17b.so
-$(patsubst %,$(objpfx)%.os,$(tlsmod17a-modules)): $(objpfx)tst-tlsmod17a%.os: tst-tlsmod17a.c
-	$(compile-command.c) -DN=$*
-$(patsubst %,$(objpfx)%.so,$(tlsmod17a-modules)): $(objpfx)tst-tlsmod17a%.so: $(objpfx)ld.so
-$(objpfx)tst-tlsmod17b.so: $(patsubst %,$(objpfx)%.so,$(tlsmod17a-modules))
-
-$(objpfx)tst-tls18.out: $(patsubst %,$(objpfx)%.so,$(tlsmod18a-modules))
-$(patsubst %,$(objpfx)%.os,$(tlsmod18a-modules)): $(objpfx)tst-tlsmod18a%.os : tst-tlsmod18a.c
-	$(compile-command.c) -DN=$*
-$(patsubst %,$(objpfx)%.so,$(tlsmod18a-modules)): $(objpfx)tst-tlsmod18a%.so: $(objpfx)ld.so
-
-$(objpfx)tst-tls19.out: $(objpfx)tst-tls19mod1.so
-
-CFLAGS-tst-align.c += $(stack-align-test-flags)
-CFLAGS-tst-align2.c += $(stack-align-test-flags)
-CFLAGS-tst-alignmod.c += $(stack-align-test-flags)
-CFLAGS-tst-alignmod2.c += $(stack-align-test-flags)
-$(objpfx)tst-align.out: $(objpfx)tst-alignmod.so
-$(objpfx)tst-align2: $(objpfx)tst-alignmod2.so
-$(objpfx)tst-align3: $(objpfx)tst-alignmod3.so
-ifeq (yes,$(have-fpie))
-CFLAGS-tst-align3.c += $(PIE-ccflag)
-endif
-LDFLAGS-tst-align3 += -Wl,-z,max-page-size=0x200000
-LDFLAGS-tst-alignmod3.so += -Wl,-z,max-page-size=0x200000
-$(objpfx)tst-alignmod3.so: $(libsupport)
-
-$(objpfx)unload3.out: $(objpfx)unload3mod1.so $(objpfx)unload3mod2.so \
-		      $(objpfx)unload3mod3.so $(objpfx)unload3mod4.so
-
-$(objpfx)unload4.out: $(objpfx)unload4mod1.so $(objpfx)unload4mod3.so
-
-$(objpfx)unload5.out: $(objpfx)unload3mod1.so $(objpfx)unload3mod2.so \
-		      $(objpfx)unload3mod3.so $(objpfx)unload3mod4.so
-
-$(objpfx)unload6.out: $(objpfx)unload6mod1.so $(objpfx)unload6mod2.so \
-		      $(objpfx)unload6mod3.so
-
-$(objpfx)unload7.out: $(objpfx)unload7mod1.so $(objpfx)unload7mod2.so
-unload7-ENV = MALLOC_PERTURB_=85
-
-$(objpfx)unload8.out: $(objpfx)unload8mod1.so $(objpfx)unload8mod1x.so
-
-$(objpfx)tst-tls9-static.out: $(objpfx)tst-tlsmod5.so $(objpfx)tst-tlsmod6.so
-
-ifeq ($(have-z-execstack),yes)
-$(objpfx)tst-execstack.out: $(objpfx)tst-execstack-mod.so
-CPPFLAGS-tst-execstack.c += -DUSE_PTHREADS=0
-LDFLAGS-tst-execstack = -Wl,-z,noexecstack
-LDFLAGS-tst-execstack-mod.so = -Wl,-z,execstack
-
-$(objpfx)tst-execstack-needed: $(objpfx)tst-execstack-mod.so
-LDFLAGS-tst-execstack-needed = -Wl,-z,noexecstack
-
-LDFLAGS-tst-execstack-prog = -Wl,-z,execstack
-CFLAGS-tst-execstack-prog.c += -Wno-trampolines
-CFLAGS-tst-execstack-mod.c += -Wno-trampolines
-endif
-
-LDFLAGS-tst-array2 = -Wl,--no-as-needed
-LDFLAGS-tst-array5 = -Wl,--no-as-needed
-
-$(objpfx)tst-array1-cmp.out: tst-array1.exp $(objpfx)tst-array1.out
-	cmp $^ > $@; \
-	$(evaluate-test)
-
-$(objpfx)tst-array1-static-cmp.out: tst-array1.exp \
-				    $(objpfx)tst-array1-static.out
-	cmp $^ > $@; \
-	$(evaluate-test)
-
-$(objpfx)tst-array2: $(objpfx)tst-array2dep.so
-$(objpfx)tst-array2-cmp.out: tst-array2.exp $(objpfx)tst-array2.out
-	cmp $^ > $@; \
-	$(evaluate-test)
-
-$(objpfx)tst-array3-cmp.out: tst-array1.exp $(objpfx)tst-array3.out
-	cmp $^ > $@; \
-	$(evaluate-test)
-
-$(objpfx)tst-array4.out: $(objpfx)tst-array2dep.so
-$(objpfx)tst-array4-cmp.out: tst-array4.exp $(objpfx)tst-array4.out
-	cmp $^ > $@; \
-	$(evaluate-test)
-
-$(objpfx)tst-array5: $(objpfx)tst-array5dep.so
-$(objpfx)tst-array5-cmp.out: tst-array5.exp $(objpfx)tst-array5.out
-	cmp $^ > $@; \
-	$(evaluate-test)
-
-$(objpfx)tst-array5-static-cmp.out: tst-array5-static.exp \
-				$(objpfx)tst-array5-static.out
-	cmp $^ > $@; \
-	$(evaluate-test)
-
-CFLAGS-tst-pie1.c += $(pie-ccflag)
-CFLAGS-tst-pie2.c += $(pie-ccflag)
-
-$(objpfx)tst-piemod1.so: $(libsupport)
-$(objpfx)tst-pie1: $(objpfx)tst-piemod1.so
-$(objpfx)tst-dlopen-pie.out: $(objpfx)tst-pie1
-
-ifeq (yes,$(build-shared))
-# NB: Please keep cet-built-dso in sysdeps/x86/Makefile in sync with
-# all-built-dso here.
-all-built-dso := $(common-objpfx)elf/ld.so $(common-objpfx)libc.so \
-		 $(filter-out $(common-objpfx)linkobj/libc.so, \
-			      $(sort $(wildcard $(addprefix $(common-objpfx), \
-							    */lib*.so \
-							    iconvdata/*.so))))
-
-$(all-built-dso:=.dyn): %.dyn: %
-	@rm -f $@T
-	LC_ALL=C $(READELF) -W -d $< > $@T
-	test -s $@T
-	mv -f $@T $@
-common-generated += $(all-built-dso:$(common-objpfx)%=%.dyn)
-
-$(objpfx)check-textrel.out: $(..)scripts/check-textrel.awk \
-			    $(all-built-dso:=.dyn)
-	LC_ALL=C $(AWK) -f $^ > $@; \
-	$(evaluate-test)
-generated += check-textrel.out
-
-$(objpfx)execstack-default: $(first-word $(wildcard $(sysdirs:%=%/stackinfo.h)))
-	$(make-target-directory)
-	{ echo '#include <elf.h>'; \
-	  echo '#include <stackinfo.h>'; \
-	  echo '#if (DEFAULT_STACK_PERMS & PF_X) == 0'; \
-	  echo '@@@execstack-no@@@'; \
-	  echo '#else'; \
-	  echo '@@@execstack-yes@@@'; \
-	  echo '#endif'; } | \
-	$(CC) $(CFLAGS) $(CPPFLAGS) -E -x c-header - | \
-	sed -n -e 's/^@@@\(.*\)@@@/\1/p' > $@T
-	mv -f $@T $@
-generated += execstack-default
-
-$(all-built-dso:=.phdr): %.phdr: %
-	@rm -f $@T
-	LC_ALL=C $(READELF) -W -l $< > $@T
-	test -s $@T
-	mv -f $@T $@
-common-generated += $(all-built-dso:$(common-objpfx)%=%.phdr)
-
-$(objpfx)check-execstack.out: $(..)scripts/check-execstack.awk \
-			      $(objpfx)execstack-default \
-			      $(all-built-dso:=.phdr)
-	LC_ALL=C $(AWK) -v "xfail=$(check-execstack-xfail)" -f $^ > $@; \
-	$(evaluate-test)
-generated += check-execstack.out
-
-$(objpfx)check-wx-segment.out: $(..)scripts/check-wx-segment.py \
-			      $(all-built-dso:=.phdr)
-	$(PYTHON) $^ --xfail="$(check-wx-segment-xfail)" > $@; \
-	$(evaluate-test)
-generated += check-wx-segment.out
-
-$(objpfx)tst-dlmodcount.out: $(test-modules)
-
-$(all-built-dso:=.jmprel): %.jmprel: % Makefile
-	@rm -f $@T
-	LC_ALL=C $(READELF) -W -S -d -r $< > $@T
-	test -s $@T
-	mv -f $@T $@
-common-generated += $(all-built-dso:$(common-objpfx)%=%.jmprel)
-
-localplt-built-dso := $(addprefix $(common-objpfx),\
-				  libc.so \
-				  elf/ld.so \
-				  math/libm.so \
-				  dlfcn/libdl.so \
-				  resolv/libresolv.so \
-		       )
-ifeq ($(build-mathvec),yes)
-localplt-built-dso += $(addprefix $(common-objpfx), mathvec/libmvec.so)
-endif
-ifeq ($(have-thread-library),yes)
-localplt-built-dso += $(filter-out %_nonshared.a, $(shared-thread-library))
-endif
-ifneq ($(pthread-in-libc),yes)
-localplt-built-dso += $(addprefix $(common-objpfx), rt/librt.so)
-endif
-
-vpath localplt.data $(+sysdep_dirs)
-
-$(objpfx)check-localplt.out: $(..)scripts/check-localplt.awk \
-			     $(..)scripts/localplt.awk \
-			     $(localplt-built-dso:=.jmprel) \
-			     localplt.data
-	LC_ALL=C $(AWK) -f $(filter-out $< %localplt.data,$^) | \
-	  LC_ALL=C $(AWK) -f $< $(filter %localplt.data,$^) - \
-	  > $@; \
-	$(evaluate-test)
-endif
-
-$(all-built-dso:=.dynsym): %.dynsym: %
-	@rm -f $@T
-	LC_ALL=C $(READELF) -W --dyn-syms $< > $@T
-	test -s $@T
-	mv -f $@T $@
-common-generated += $(all-built-dso:$(common-objpfx)%=%.dynsym)
-
-$(objpfx)check-initfini.out: $(..)scripts/check-initfini.awk \
-			    $(all-built-dso:=.dynsym)
-	LC_ALL=C $(AWK) -f $^ > $@; \
-	$(evaluate-test)
-generated += check-initfini.out
-
-$(objpfx)tst-dlopenrpath: $(objpfx)tst-dlopenrpathmod.so
-CFLAGS-tst-dlopenrpath.c += -DPFX=\"$(objpfx)\"
-LDFLAGS-tst-dlopenrpathmod.so += -Wl,-rpath,\$$ORIGIN/test-subdir
-$(objpfx)tst-dlopenrpath.out: $(objpfx)firstobj.so
-
-$(objpfx)tst-deep1mod2.so: $(objpfx)tst-deep1mod3.so
-$(objpfx)tst-deep1: $(objpfx)tst-deep1mod1.so
-$(objpfx)tst-deep1.out: $(objpfx)tst-deep1mod2.so
-LDFLAGS-tst-deep1 += -rdynamic
-tst-deep1mod3.so-no-z-defs = yes
-
-$(objpfx)tst-dlmopen1.out: $(objpfx)tst-dlmopen1mod.so
-
-$(objpfx)tst-dlmopen2.out: $(objpfx)tst-dlmopen1mod.so
-
-$(objpfx)tst-dlmopen3.out: $(objpfx)tst-dlmopen1mod.so
-
-$(objpfx)tst-dlmopen4.out: $(objpfx)tst-dlmopen1mod.so
-
-$(objpfx)tst-audit1.out: $(objpfx)tst-auditmod1.so
-tst-audit1-ENV = LD_AUDIT=$(objpfx)tst-auditmod1.so
-
-$(objpfx)tst-audit2.out: $(objpfx)tst-auditmod1.so $(objpfx)tst-auditmod9b.so
-# Prevent GCC-5 from translating a malloc/memset pair into calloc
-CFLAGS-tst-audit2.c += -fno-builtin
-tst-audit2-ENV = LD_AUDIT=$(objpfx)tst-auditmod1.so
-
-$(objpfx)tst-audit9.out: $(objpfx)tst-auditmod9a.so $(objpfx)tst-auditmod9b.so
-tst-audit9-ENV = LD_AUDIT=$(objpfx)tst-auditmod9a.so
-
-$(objpfx)tst-audit8: $(libm)
-$(objpfx)tst-audit8.out: $(objpfx)tst-auditmod1.so
-tst-audit8-ENV = LD_AUDIT=$(objpfx)tst-auditmod1.so
-
-$(objpfx)tst-global1.out: $(objpfx)testobj6.so $(objpfx)testobj2.so
-
-$(objpfx)tst-global2: $(objpfx)tst-globalmod2.so
-$(objpfx)tst-global2.out: $(objpfx)reldepmod1.so $(objpfx)reldepmod4.so
-LDFLAGS-tst-global2 = -Wl,--enable-new-dtags
-LDFLAGS-tst-globalmod2.so = -Wl,--enable-new-dtags
-
-$(objpfx)order2.out: $(objpfx)order2mod1.so $(objpfx)order2mod2.so
-$(objpfx)order2-cmp.out: $(objpfx)order2.out
-	(echo "12345" | cmp $< -) > $@; \
-	$(evaluate-test)
-$(objpfx)order2mod1.so: $(objpfx)order2mod4.so
-$(objpfx)order2mod4.so: $(objpfx)order2mod3.so
-$(objpfx)order2mod2.so: $(objpfx)order2mod3.so
-order2mod2.so-no-z-defs = yes
-LDFLAGS-order2mod1.so = -Wl,--no-as-needed
-LDFLAGS-order2mod2.so = -Wl,--no-as-needed
-
-tst-stackguard1-ARGS = --command "$(host-test-program-cmd) --child"
-tst-stackguard1-static-ARGS = --command "$(objpfx)tst-stackguard1-static --child"
-
-tst-ptrguard1-ARGS = --command "$(host-test-program-cmd) --child"
-# When built statically, the pointer guard interface uses
-# __pointer_chk_guard_local.
-CFLAGS-tst-ptrguard1-static.c += -DPTRGUARD_LOCAL
-tst-ptrguard1-static-ARGS = --command "$(objpfx)tst-ptrguard1-static --child"
-
-$(objpfx)tst-leaks1-mem.out: $(objpfx)tst-leaks1.out
-	$(common-objpfx)malloc/mtrace $(objpfx)tst-leaks1.mtrace > $@; \
-	$(evaluate-test)
-
-tst-leaks1-ENV = MALLOC_TRACE=$(objpfx)tst-leaks1.mtrace \
-		 LD_PRELOAD=$(common-objpfx)/malloc/libc_malloc_debug.so
-
-$(objpfx)tst-thrlock: $(shared-thread-library)
-$(objpfx)tst-thrlock.out: $(libm)
-$(objpfx)tst-noload.out: $(libm)
-
-tst-tst-dlopen-tlsmodid-no-pie = yes
-$(objpfx)tst-dlopen-tlsmodid: $(shared-thread-library)
-$(objpfx)tst-dlopen-tlsmodid.out: $(objpfx)tst-dlopen-self
-CFLAGS-tst-dlopen-tlsmodid-pie.c += $(pie-ccflag)
-$(objpfx)tst-dlopen-tlsmodid-pie: $(shared-thread-library)
-$(objpfx)tst-dlopen-tlsmodid-pie.out: $(objpfx)tst-dlopen-self-pie
-$(objpfx)tst-dlopen-tlsmodid-container: $(shared-thread-library)
-LDFLAGS-tst-dlopen-tlsmodid-container += -Wl,-rpath,\$$ORIGIN
-
-tst-tst-dlopen-self-no-pie = yes
-CFLAGS-tst-dlopen-self-pie.c += $(pie-ccflag)
-LDFLAGS-tst-dlopen-self-container += -Wl,-rpath,\$$ORIGIN
-
-CFLAGS-ifuncmain1pic.c += $(pic-ccflag)
-CFLAGS-ifuncmain1picstatic.c += $(pic-ccflag)
-CFLAGS-ifuncmain1staticpic.c += $(pic-ccflag)
-CFLAGS-ifuncdep1pic.c += $(pic-ccflag)
-CFLAGS-ifuncmain1vispic.c += $(pic-ccflag)
-CFLAGS-ifuncmain2pic.c += $(pic-ccflag)
-CFLAGS-ifuncmain2picstatic.c += $(pic-ccflag)
-CFLAGS-ifuncdep2pic.c += $(pic-ccflag)
-CFLAGS-ifuncmain4picstatic.c += $(pic-ccflag)
-CFLAGS-ifuncmain5pic.c += $(pic-ccflag)
-CFLAGS-ifuncmain5picstatic.c += $(pic-ccflag)
-CFLAGS-ifuncmain5staticpic.c += $(pic-ccflag)
-CFLAGS-ifuncdep5pic.c += $(pic-ccflag)
-CFLAGS-ifuncmain7pic.c += $(pic-ccflag)
-CFLAGS-ifuncmain7picstatic.c += $(pic-ccflag)
-CFLAGS-ifuncmain9pic.c += $(pic-ccflag)
-CFLAGS-ifuncmain9picstatic.c += $(pic-ccflag)
-
-LDFLAGS-ifuncmain3 = -Wl,-export-dynamic
-
-CFLAGS-ifuncmain1pie.c += $(pie-ccflag)
-CFLAGS-ifuncmain1vispie.c += $(pie-ccflag)
-CFLAGS-ifuncmain1staticpie.c += $(pie-ccflag)
-CFLAGS-ifuncmain5pie.c += $(pie-ccflag)
-CFLAGS-ifuncmain6pie.c += $(pie-ccflag)
-CFLAGS-ifuncmain7pie.c += $(pie-ccflag)
-CFLAGS-ifuncmain9pie.c += $(pie-ccflag)
-CFLAGS-tst-ifunc-textrel.c += $(pic-ccflag)
-
-LDFLAGS-ifuncmain6pie = -Wl,-z,lazy
-
-$(objpfx)ifuncmain1pie: $(objpfx)ifuncmod1.so
-$(objpfx)ifuncmain1staticpie: $(objpfx)ifuncdep1pic.o
-$(objpfx)ifuncmain1vispie: $(objpfx)ifuncmod1.so
-$(objpfx)ifuncmain5pie: $(objpfx)ifuncmod5.so
-$(objpfx)ifuncmain6pie: $(objpfx)ifuncmod6.so
-
-$(objpfx)ifuncmain1: $(addprefix $(objpfx),ifuncmod1.so)
-$(objpfx)ifuncmain1pic: $(addprefix $(objpfx),ifuncmod1.so)
-$(objpfx)ifuncmain1staticpic: $(addprefix $(objpfx),ifuncdep1pic.o)
-$(objpfx)ifuncmain1static: $(addprefix $(objpfx),ifuncdep1.o)
-$(objpfx)ifuncmain1picstatic: $(addprefix $(objpfx),ifuncdep1pic.o)
-$(objpfx)ifuncmain1vis: $(addprefix $(objpfx),ifuncmod1.so)
-$(objpfx)ifuncmain1vispic: $(addprefix $(objpfx),ifuncmod1.so)
-$(objpfx)ifuncmain2: $(addprefix $(objpfx),ifuncdep2.o)
-$(objpfx)ifuncmain2pic: $(addprefix $(objpfx),ifuncdep2pic.o)
-$(objpfx)ifuncmain2static: $(addprefix $(objpfx),ifuncdep2.o)
-$(objpfx)ifuncmain2picstatic: $(addprefix $(objpfx),ifuncdep2pic.o)
-
-$(objpfx)ifuncmain3.out: $(objpfx)ifuncmod3.so
-
-$(objpfx)ifuncmain5: $(addprefix $(objpfx),ifuncmod5.so)
-$(objpfx)ifuncmain5pic: $(addprefix $(objpfx),ifuncmod5.so)
-$(objpfx)ifuncmain5static: $(addprefix $(objpfx),ifuncdep5.o)
-$(objpfx)ifuncmain5staticpic: $(addprefix $(objpfx),ifuncdep5pic.o)
-$(objpfx)ifuncmain5picstatic: $(addprefix $(objpfx),ifuncdep5pic.o)
-
-LDFLAGS-tst-ifunc-fault-lazy = -Wl,-z,lazy
-LDFLAGS-tst-ifunc-fault-bindnow = -Wl,-z,now
-define tst-ifunc-fault-script
-( $(test-wrapper) $(rtld-prefix) --verify $^ \
-  && $(test-wrapper-env) LD_TRACE_LOADED_OBJECTS=1 $(rtld-prefix) $^ \
-  && $(test-wrapper-env) LD_TRACE_LOADED_OBJECTS=1 LD_DEBUG=unused \
-			 $(rtld-prefix) $^ \
-) > $@; $(evaluate-test)
-endef
-$(objpfx)tst-ifunc-fault-lazy.out: $(objpfx)tst-ifunc-fault-lazy $(objpfx)ld.so
-	$(tst-ifunc-fault-script)
-$(objpfx)tst-ifunc-fault-bindnow.out: $(objpfx)tst-ifunc-fault-bindnow \
-   $(objpfx)ld.so
-	$(tst-ifunc-fault-script)
-
-$(objpfx)tst-unique1.out: $(objpfx)tst-unique1mod1.so \
-			  $(objpfx)tst-unique1mod2.so
-
-$(objpfx)tst-unique2: $(objpfx)tst-unique2mod1.so
-$(objpfx)tst-unique2.out: $(objpfx)tst-unique2mod2.so
-
-$(objpfx)tst-unique3: $(objpfx)tst-unique3lib.so
-$(objpfx)tst-unique3.out: $(objpfx)tst-unique3lib2.so
-
-$(objpfx)tst-unique4: $(objpfx)tst-unique4lib.so
-
-$(objpfx)tst-nodelete.out: $(objpfx)tst-nodelete-uniquemod.so \
-			   $(objpfx)tst-nodelete-rtldmod.so \
-			   $(objpfx)tst-nodelete-zmod.so
-
-LDFLAGS-tst-nodelete = -rdynamic
-LDFLAGS-tst-nodelete-zmod.so = -Wl,--enable-new-dtags,-z,nodelete
-
-$(objpfx)tst-nodelete2.out: $(objpfx)tst-nodelete2mod.so
-
-LDFLAGS-tst-nodelete2 = -rdynamic
-
-$(objpfx)tst-initorder-cmp.out: tst-initorder.exp $(objpfx)tst-initorder.out
-	cmp $^ > $@; \
-	$(evaluate-test)
-
-$(objpfx)tst-initorder2: $(objpfx)tst-initorder2a.so $(objpfx)tst-initorder2d.so $(objpfx)tst-initorder2c.so
-$(objpfx)tst-initorder2a.so: $(objpfx)tst-initorder2b.so
-$(objpfx)tst-initorder2b.so: $(objpfx)tst-initorder2c.so
-$(objpfx)tst-initorder2c.so: $(objpfx)tst-initorder2d.so
-LDFLAGS-tst-initorder2 = -Wl,--no-as-needed
-LDFLAGS-tst-initorder2a.so = -Wl,--no-as-needed
-LDFLAGS-tst-initorder2b.so = -Wl,--no-as-needed
-LDFLAGS-tst-initorder2c.so = -Wl,--no-as-needed
-define o-iterator-doit
-$(objpfx)tst-initorder2$o.os: tst-initorder2.c; \
-$$(compile-command.c) -DNAME=\"$o\"
-endef
-object-suffixes-left := a b c d
-include $(o-iterator)
-
-$(objpfx)tst-initorder2-cmp.out: tst-initorder2.exp $(objpfx)tst-initorder2.out
-	cmp $^ > $@; \
-	$(evaluate-test)
-
-$(objpfx)tst-relsort1mod1.so: $(libm) $(objpfx)tst-relsort1mod2.so
-$(objpfx)tst-relsort1mod2.so: $(libm)
-$(objpfx)tst-relsort1.out: $(objpfx)tst-relsort1mod1.so \
-			   $(objpfx)tst-relsort1mod2.so
-
-$(objpfx)tst-unused-dep.out: $(objpfx)testobj1.so
-	$(test-wrapper-env) \
-	LD_TRACE_LOADED_OBJECTS=1 \
-	LD_DEBUG=unused \
-	LD_PRELOAD= \
-	$(rtld-prefix) \
-	  $< > $@; \
-	$(evaluate-test)
-
-$(objpfx)tst-unused-dep-cmp.out: $(objpfx)tst-unused-dep.out
-	cmp $< /dev/null > $@; \
-	$(evaluate-test)
-
-tst-tunables-enable_secure-env-ARGS = -- $(host-test-program-cmd)
-
-$(objpfx)tst-audit11.out: $(objpfx)tst-auditmod11.so $(objpfx)tst-audit11mod1.so
-tst-audit11-ENV = LD_AUDIT=$(objpfx)tst-auditmod11.so
-$(objpfx)tst-audit11mod1.so: $(objpfx)tst-audit11mod2.so
-LDFLAGS-tst-audit11mod2.so = -Wl,--version-script=tst-audit11mod2.map,-soname,tst-audit11mod2.so
-
-$(objpfx)tst-audit12.out: $(objpfx)tst-auditmod12.so $(objpfx)tst-audit12mod1.so $(objpfx)tst-audit12mod3.so
-tst-audit12-ENV = LD_AUDIT=$(objpfx)tst-auditmod12.so
-$(objpfx)tst-audit12mod1.so: $(objpfx)tst-audit12mod2.so
-LDFLAGS-tst-audit12mod2.so = -Wl,--version-script=tst-audit12mod2.map
-
-$(objpfx)tst-audit13.out: $(objpfx)tst-audit13mod1.so
-LDFLAGS-tst-audit13mod1.so = -Wl,-z,lazy
-tst-audit13-ENV = LD_AUDIT=$(objpfx)tst-audit13mod1.so
-
-$(objpfx)tst-auditmany.out: $(objpfx)tst-auditmanymod1.so \
-  $(objpfx)tst-auditmanymod2.so $(objpfx)tst-auditmanymod3.so \
-  $(objpfx)tst-auditmanymod4.so $(objpfx)tst-auditmanymod5.so \
-  $(objpfx)tst-auditmanymod6.so $(objpfx)tst-auditmanymod7.so \
-  $(objpfx)tst-auditmanymod8.so	$(objpfx)tst-auditmanymod9.so
-tst-auditmany-ENV = \
-  LD_AUDIT=tst-auditmanymod1.so:tst-auditmanymod2.so:tst-auditmanymod3.so:tst-auditmanymod4.so:tst-auditmanymod5.so:tst-auditmanymod6.so:tst-auditmanymod7.so:tst-auditmanymod8.so:tst-auditmanymod9.so
-
-LDFLAGS-tst-audit14 = -Wl,--audit=tst-auditlogmod-1.so,--disable-new-dtags
-$(objpfx)tst-auditlogmod-1.so: $(libsupport)
-$(objpfx)tst-audit14.out: $(objpfx)tst-auditlogmod-1.so
-LDFLAGS-tst-audit14a = -Wl,--audit=tst-auditlogmod-1.so,--enable-new-dtags
-$(objpfx)tst-audit14a.out: $(objpfx)tst-auditlogmod-1.so
-LDFLAGS-tst-audit15 = \
-  -Wl,--audit=tst-auditlogmod-1.so,--depaudit=tst-auditlogmod-2.so
-$(objpfx)tst-auditlogmod-2.so: $(libsupport)
-$(objpfx)tst-audit15.out: \
-  $(objpfx)tst-auditlogmod-1.so $(objpfx)tst-auditlogmod-2.so
-LDFLAGS-tst-audit16 = \
-  -Wl,--audit=tst-auditlogmod-1.so:tst-auditlogmod-2.so \
-  -Wl,--depaudit=tst-auditlogmod-3.so
-$(objpfx)tst-auditlogmod-3.so: $(libsupport)
-$(objpfx)tst-audit16.out: \
-  $(objpfx)tst-auditlogmod-1.so $(objpfx)tst-auditlogmod-2.so \
-  $(objpfx)tst-auditlogmod-3.so
-$(objpfx)tst-audit17.out: $(objpfx)tst-auditmod17.so
-# The test check if a audit library without libc.so on DT_NEEDED works as
-# intended, so it uses an explicit link rule.
-$(objpfx)tst-auditmod17.so: $(objpfx)tst-auditmod17.os
-	$(CC) -nostdlib -nostartfiles -shared -o $@.new \
-	$(filter-out $(map-file),$^)
-	$(call after-link,$@.new)
-	mv -f $@.new $@
-CFLAGS-.os += $(call elide-stack-protector,.os,tst-auditmod17)
-tst-audit17-ENV = LD_AUDIT=$(objpfx)tst-auditmod17.so
-
-$(objpfx)tst-audit14-cmp.out: tst-audit14.exp $(objpfx)tst-audit14.out
-	cmp $^ > $@; \
-	$(evaluate-test)
-$(objpfx)tst-audit14a-cmp.out: tst-audit14.exp $(objpfx)tst-audit14a.out
-	cmp $^ > $@; \
-	$(evaluate-test)
-$(objpfx)tst-audit15-cmp.out: tst-audit15.exp $(objpfx)tst-audit15.out
-	cmp $^ > $@; \
-	$(evaluate-test)
-$(objpfx)tst-audit16-cmp.out: tst-audit16.exp $(objpfx)tst-audit16.out
-	cmp $^ > $@; \
-	$(evaluate-test)
-
-$(objpfx)tst-audit18.out: $(objpfx)tst-auditmod18.so \
-			  $(objpfx)tst-audit18mod.so
-tst-audit18-ARGS = -- $(host-test-program-cmd)
-
-$(objpfx)tst-audit19a.out: $(objpfx)tst-auditmod19a.so
-tst-audit19a-ENV = LD_AUDIT=$(objpfx)tst-auditmod19a.so
-
-$(objpfx)tst-audit19b.out: $(objpfx)tst-auditmod19b.so
-$(objpfx)tst-audit19b: $(objpfx)tst-audit19bmod.so
-tst-audit19b-ARGS = -- $(host-test-program-cmd)
-
-$(objpfx)tst-audit20.out: $(objpfx)tst-auditmod20.so
-tst-audit20-ENV = LD_AUDIT=$(objpfx)tst-auditmod20.so
-
-$(objpfx)tst-audit21: $(shared-thread-library)
-$(objpfx)tst-audit21.out: $(objpfx)tst-auditmod21a.so
-$(objpfx)tst-auditmod21a.so: $(objpfx)tst-auditmod21b.so
-tst-audit21-ENV = LD_AUDIT=$(objpfx)tst-auditmod21a.so
-
-$(objpfx)tst-audit22.out: $(objpfx)tst-auditmod22.so
-tst-audit22-ARGS = -- $(host-test-program-cmd)
-
-$(objpfx)tst-audit23.out: $(objpfx)tst-auditmod23.so \
-			  $(objpfx)tst-audit23mod.so
-tst-audit23-ARGS = -- $(host-test-program-cmd)
-
-$(objpfx)tst-audit24a.out: $(objpfx)tst-auditmod24a.so
-$(objpfx)tst-audit24a: $(objpfx)tst-audit24amod1.so \
-		       $(objpfx)tst-audit24amod2.so
-tst-audit24a-ENV = LD_AUDIT=$(objpfx)tst-auditmod24a.so
-LDFLAGS-tst-audit24a = -Wl,-z,now
-
-$(objpfx)tst-audit24b.out: $(objpfx)tst-auditmod24b.so
-$(objpfx)tst-audit24b: $(objpfx)tst-audit24bmod1.so \
-		       $(objpfx)tst-audit24bmod2.so
-$(objpfx)tst-audit24bmod1: $(objpfx)tst-audit24bmod2.so
-# The test checks if a library without .gnu.version correctly calls the
-# audit callbacks.  So it uses an explicit link rule to avoid linking
-# against libc.so.
-$(objpfx)tst-audit24bmod1.so: $(objpfx)tst-audit24bmod1.os
-	$(CC) -nostdlib -nostartfiles -shared -o $@.new $(objpfx)tst-audit24bmod1.os \
-	  -Wl,-z,now
-	$(call after-link,$@.new)
-	mv -f $@.new $@
-CFLAGS-.os += $(call elide-stack-protector,.os,tst-audit24bmod1)
-$(objpfx)tst-audit24bmod2.so: $(objpfx)tst-audit24bmod2.os
-	$(CC) -nostdlib -nostartfiles -shared -o $@.new $(objpfx)tst-audit24bmod2.os
-	$(call after-link,$@.new)
-	mv -f $@.new $@
-CFLAGS-.os += $(call elide-stack-protector,.os,tst-audit24bmod2)
-tst-audit24b-ENV = LD_AUDIT=$(objpfx)tst-auditmod24b.so
-LDFLAGS-tst-audit24b = -Wl,-z,now
-
-# Same as tst-audit24a, but tests LD_BIND_NOW
-$(objpfx)tst-audit24c.out: $(objpfx)tst-auditmod24c.so
-$(objpfx)tst-audit24c: $(objpfx)tst-audit24amod1.so \
-		       $(objpfx)tst-audit24amod2.so
-tst-audit24c-ENV = LD_BIND_NOW=1 LD_AUDIT=$(objpfx)tst-auditmod24c.so
-LDFLAGS-tst-audit24c = -Wl,-z,lazy
-
-$(objpfx)tst-audit24d.out: $(objpfx)tst-auditmod24d.so
-$(objpfx)tst-audit24d: $(objpfx)tst-audit24dmod1.so \
-		       $(objpfx)tst-audit24dmod2.so
-$(objpfx)tst-audit24dmod1.so: $(objpfx)tst-audit24dmod3.so
-LDFLAGS-tst-audit24dmod1.so = -Wl,-z,now
-$(objpfx)tst-audit24dmod2.so: $(objpfx)tst-audit24dmod4.so
-LDFLAGS-tst-audit24dmod2.so = -Wl,-z,lazy
-tst-audit24d-ENV = LD_AUDIT=$(objpfx)tst-auditmod24d.so
-LDFLAGS-tst-audit24d = -Wl,-z,lazy
-
-$(objpfx)tst-audit25a.out: $(objpfx)tst-auditmod25.so
-$(objpfx)tst-audit25a: $(objpfx)tst-audit25mod1.so \
-		       $(objpfx)tst-audit25mod2.so \
-		       $(objpfx)tst-audit25mod3.so \
-		       $(objpfx)tst-audit25mod4.so
-LDFLAGS-tst-audit25a = -Wl,-z,lazy
-$(objpfx)tst-audit25mod1.so: $(objpfx)tst-audit25mod3.so
-LDFLAGS-tst-audit25mod1.so = -Wl,-z,now
-$(objpfx)tst-audit25mod2.so: $(objpfx)tst-audit25mod4.so
-LDFLAGS-tst-audit25mod2.so = -Wl,-z,lazy
-tst-audit25a-ARGS = -- $(host-test-program-cmd)
-
-$(objpfx)tst-audit25b.out: $(objpfx)tst-auditmod25.so
-$(objpfx)tst-audit25b: $(objpfx)tst-audit25mod1.so \
-		       $(objpfx)tst-audit25mod2.so \
-		       $(objpfx)tst-audit25mod3.so \
-		       $(objpfx)tst-audit25mod4.so
-LDFLAGS-tst-audit25b = -Wl,-z,now
-tst-audit25b-ARGS = -- $(host-test-program-cmd)
-
-$(objpfx)tst-audit28.out: $(objpfx)tst-auditmod28.so
-$(objpfx)tst-auditmod28.so: $(libsupport)
-tst-audit28-ENV = LD_AUDIT=$(objpfx)tst-auditmod28.so
-
-# tst-sonamemove links against an older implementation of the library.
-LDFLAGS-tst-sonamemove-linkmod1.so = \
-  -Wl,--version-script=tst-sonamemove-linkmod1.map \
-  -Wl,-soname,tst-sonamemove-runmod1.so
-LDFLAGS-tst-sonamemove-runmod1.so = -Wl,--no-as-needed \
-  -Wl,--version-script=tst-sonamemove-runmod1.map \
-  -Wl,-soname,tst-sonamemove-runmod1.so
-LDFLAGS-tst-sonamemove-runmod2.so = \
-  -Wl,--version-script=tst-sonamemove-runmod2.map \
-  -Wl,-soname,tst-sonamemove-runmod2.so
-$(objpfx)tst-sonamemove-runmod1.so: $(objpfx)tst-sonamemove-runmod2.so
-# Link against the link module, but depend on the run-time modules
-# for execution.
-$(objpfx)tst-sonamemove-link: $(objpfx)tst-sonamemove-linkmod1.so
-$(objpfx)tst-sonamemove-link.out: \
-  $(objpfx)tst-sonamemove-runmod1.so \
-  $(objpfx)tst-sonamemove-runmod2.so
-$(objpfx)tst-sonamemove-dlopen.out: \
-  $(objpfx)tst-sonamemove-runmod1.so \
-  $(objpfx)tst-sonamemove-runmod2.so
-
-$(objpfx)tst-dlmopen-dlerror-mod.so: $(libsupport)
-$(objpfx)tst-dlmopen-dlerror.out: $(objpfx)tst-dlmopen-dlerror-mod.so
-
-# Override -z defs, so that we can reference an undefined symbol.
-# Force lazy binding for the same reason.
-LDFLAGS-tst-latepthreadmod.so = \
-  -Wl,-z,lazy -Wl,--unresolved-symbols=ignore-all
-# Do not optimize sibling calls as the test relies on a JMP_SLOT relocation for
-# function this_function_is_not_defined.
-CFLAGS-tst-latepthreadmod.c += -fno-optimize-sibling-calls
-$(objpfx)tst-latepthreadmod.so: $(shared-thread-library)
-$(objpfx)tst-latepthread.out: $(objpfx)tst-latepthreadmod.so
-
-# The test modules are parameterized by preprocessor macros.
-$(patsubst %,$(objpfx)%.os,$(tst-tls-many-dynamic-modules)): \
-  $(objpfx)tst-tls-manydynamic%mod.os : tst-tls-manydynamicmod.c
-	$(compile-command.c) \
-	  -DNAME=tls_global_$* -DSETTER=set_value_$* -DGETTER=get_value_$*
-$(objpfx)tst-tls-manydynamic: $(shared-thread-library)
-$(objpfx)tst-tls-manydynamic.out: \
-  $(patsubst %,$(objpfx)%.so,$(tst-tls-many-dynamic-modules))
-
-$(objpfx)tst-ldconfig-X.out : tst-ldconfig-X.sh $(objpfx)ldconfig
-	$(SHELL) $< '$(common-objpfx)' '$(test-wrapper-env)' \
-		 '$(run-program-env)' > $@; \
-	$(evaluate-test)
-
-$(objpfx)tst-ldconfig-p.out : tst-ldconfig-p.sh $(objpfx)ldconfig
-	$(SHELL) $< '$(common-objpfx)' '$(sysconfdir)' '$(test-wrapper-env)' \
-		 '$(run-program-env)' > $@; \
-	$(evaluate-test)
-
-LDFLAGS-tst-ldconfig-soname-lib-with-soname.so = \
-  -Wl,-soname,libtst-ldconfig-soname-lib-with-soname.so.1
-
-$(objpfx)tst-ldconfig-soname.out : tst-ldconfig-soname.sh \
-  $(objpfx)ldconfig \
-  $(objpfx)tst-ldconfig-soname-lib-with-soname.so \
-  $(objpfx)tst-ldconfig-soname-lib-without-soname.so
-	$(SHELL) $< '$(common-objpfx)' '$(test-wrapper-env)' \
-		 '$(run-program-env)' > $@; \
-	$(evaluate-test)
-
-# Test static linking of all the libraries we can possibly link
-# together.  Note that in some configurations this may be less than the
-# complete list of libraries we build but we try to maxmimize this list.
-ifeq ($(pthread-in-libc),no)
-$(objpfx)tst-linkall-static: \
-  $(common-objpfx)resolv/libanl.a
-endif
-$(objpfx)tst-linkall-static: \
-  $(common-objpfx)math/libm.a \
-  $(common-objpfx)resolv/libresolv.a \
-  $(common-objpfx)login/libutil.a \
-  $(common-objpfx)rt/librt.a \
-  $(static-thread-library)
-
-LDFLAGS-nextmod3.so = -Wl,--version-script=nextmod3.map
-
-# The application depends on the DSO, and the DSO loads the plugin.
-# The plugin also depends on the DSO. This creates the circular
-# dependency via dlopen that we're testing to make sure works.
-$(objpfx)tst-nodelete-dlclose-plugin.so: $(objpfx)tst-nodelete-dlclose-dso.so
-$(objpfx)tst-nodelete-dlclose: $(objpfx)tst-nodelete-dlclose-dso.so
-$(objpfx)tst-nodelete-dlclose.out: $(objpfx)tst-nodelete-dlclose-dso.so \
-				   $(objpfx)tst-nodelete-dlclose-plugin.so
-
-$(objpfx)tst-debug1.out: $(objpfx)tst-debug1mod1.so
-
-$(objpfx)tst-debug1mod1.so: $(objpfx)testobj1.so
-	$(OBJCOPY) --only-keep-debug $< $@
-
-$(objpfx)tst-main1: $(objpfx)tst-main1mod.so
-CRT-tst-main1 := $(csu-objpfx)crt1.o
-tst-main1-no-pie = yes
-LDLIBS-tst-main1 = $(libsupport)
-tst-main1mod.so-no-z-defs = yes
-
-LDLIBS-tst-absolute-sym-lib.so = tst-absolute-sym-lib.lds
-$(objpfx)tst-absolute-sym-lib.so: $(LDLIBS-tst-absolute-sym-lib.so)
-$(objpfx)tst-absolute-sym: $(objpfx)tst-absolute-sym-lib.so
-
-LDLIBS-tst-absolute-zero-lib.so = tst-absolute-zero-lib.lds
-$(objpfx)tst-absolute-zero-lib.so: $(LDLIBS-tst-absolute-zero-lib.so)
-$(objpfx)tst-absolute-zero: $(objpfx)tst-absolute-zero-lib.so
-
-$(objpfx)tst-big-note: $(objpfx)tst-big-note-lib.so
-# Avoid creating an ABI tag note, which may come before the
-# artificial, large note in tst-big-note-lib.o and invalidate the
-# test.
-$(objpfx)tst-big-note-lib.so: $(objpfx)tst-big-note-lib.o
-	$(LINK.o) -shared -o $@ $(LDFLAGS.so) $(dt-relr-ldflag) $<
-
-$(objpfx)tst-unwind-ctor: $(objpfx)tst-unwind-ctor-lib.so
-
-CFLAGS-tst-unwind-main.c += -funwind-tables -DUSE_PTHREADS=0
-
-$(objpfx)tst-initfinilazyfail.out: \
-  $(objpfx)tst-initlazyfailmod.so $(objpfx)tst-finilazyfailmod.so
-# Override -z defs, so that we can reference an undefined symbol.
-# Force lazy binding for the same reason.
-LDFLAGS-tst-initlazyfailmod.so = \
-  -Wl,-z,lazy -Wl,--unresolved-symbols=ignore-all
-LDFLAGS-tst-finilazyfailmod.so = \
-  -Wl,-z,lazy -Wl,--unresolved-symbols=ignore-all
-
-$(objpfx)tst-dlopenfail.out: \
-  $(objpfx)tst-dlopenfailmod1.so $(objpfx)tst-dlopenfailmod2.so
-# Order matters here.  tst-dlopenfaillinkmod.so's soname ensures a
-# run-time loader failure.  --as-needed breaks this test because
-# nothing actually references tst-dlopenfailmod2.so (with its soname
-# tst-dlopenfail-missingmod.so).
-LDFLAGS-tst-dlopenfailmod1.so = -Wl,--no-as-needed
-$(objpfx)tst-dlopenfailmod1.so: \
-  $(shared-thread-library) $(objpfx)tst-dlopenfaillinkmod.so
-LDFLAGS-tst-dlopenfaillinkmod.so = -Wl,-soname,tst-dlopenfail-missingmod.so
-$(objpfx)tst-dlopenfailmod2.so: $(objpfx)tst-dlopenfailnodelmod.so
-$(objpfx)tst-dlopenfail-2.out: \
-  $(objpfx)tst-dlopenfailmod1.so $(objpfx)tst-dlopenfailmod2.so \
-  $(objpfx)tst-dlopenfailmod3.so
-# tst-dlopenfailnodelmod.so emulates how libpthread was linked.
-$(objpfx)tst-dlopenfailnodelmod.so: $(libsupport)
-LDFLAGS-tst-dlopenfailnodelmod.so = \
-  -Wl,--enable-new-dtags,-z,nodelete,-z,initfirst
-# tst-dlopenfail should export the libsupport symbols, so that
-# tst-dlopenfailnodelmod.so uses them for error reporting.
-LDFLAGS-tst-dlopenfail = -Wl,-E
-
-$(objpfx)tst-dlopen-nodelete-reloc.out: \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod1.so \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod2.so \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod3.so \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod4.so \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod5.so \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod6.so \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod7.so \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod8.so \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod9.so \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod10.so \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod11.so \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod12.so \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod13.so \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod14.so \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod15.so \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod16.so \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod17.so
-tst-dlopen-nodelete-reloc-mod2.so-no-z-defs = yes
-LDFLAGS-tst-dlopen-nodelete-reloc-mod2.so = -Wl,-z,nodelete
-$(objpfx)tst-dlopen-nodelete-reloc-mod4.so: \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod3.so
-LDFLAGS-tst-dlopen-nodelete-reloc-mod4.so = -Wl,--no-as-needed
-$(objpfx)tst-dlopen-nodelete-reloc-mod5.so: \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod4.so
-LDFLAGS-tst-dlopen-nodelete-reloc-mod5.so = -Wl,-z,nodelete,--no-as-needed
-tst-dlopen-nodelete-reloc-mod5.so-no-z-defs = yes
-tst-dlopen-nodelete-reloc-mod7.so-no-z-defs = yes
-tst-dlopen-nodelete-reloc-mod11.so-no-z-defs = yes
-$(objpfx)tst-dlopen-nodelete-reloc-mod13.so: \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod12.so
-$(objpfx)tst-dlopen-nodelete-reloc-mod15.so: \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod14.so
-tst-dlopen-nodelete-reloc-mod16.so-no-z-defs = yes
-$(objpfx)tst-dlopen-nodelete-reloc-mod16.so: \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod15.so
-LDFLAGS-tst-dlopen-nodelete-reloc-mod16.so = -Wl,--no-as-needed
-$(objpfx)tst-dlopen-nodelete-reloc-mod17.so: \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod15.so \
-  $(objpfx)tst-dlopen-nodelete-reloc-mod16.so
-LDFLAGS-tst-dlopen-nodelete-reloc-mod17.so = -Wl,--no-as-needed
-
-$(objpfx)tst-ldconfig-ld_so_conf-update.out: $(objpfx)tst-ldconfig-ld-mod.so
-
-LDFLAGS-tst-filterobj-flt.so = -Wl,--filter=$(objpfx)tst-filterobj-filtee.so
-$(objpfx)tst-filterobj: $(objpfx)tst-filterobj-flt.so
-$(objpfx)tst-filterobj.out: $(objpfx)tst-filterobj-filtee.so
-$(objpfx)tst-filterobj-dlopen.out: $(objpfx)tst-filterobj-filtee.so
-
-LDFLAGS-tst-filterobj-aux.so = -Wl,--auxiliary=$(objpfx)tst-filterobj-filtee.so
-$(objpfx)tst-auxobj: $(objpfx)tst-filterobj-aux.so
-$(objpfx)tst-auxobj.out: $(objpfx)tst-filterobj-filtee.so
-$(objpfx)tst-auxobj-dlopen.out: $(objpfx)tst-filterobj-filtee.so
-
-$(objpfx)tst-single_threaded: $(objpfx)tst-single_threaded-mod1.so
-$(objpfx)tst-single_threaded.out: \
-  $(objpfx)tst-single_threaded-mod2.so $(objpfx)tst-single_threaded-mod3.so
-$(objpfx)tst-single_threaded-static-dlopen: \
-  $(objpfx)tst-single_threaded-mod1.o
-$(objpfx)tst-single_threaded-static-dlopen.out: \
-  $(objpfx)tst-single_threaded-mod2.so
-$(objpfx)tst-single_threaded-pthread: \
-  $(objpfx)tst-single_threaded-mod1.so $(shared-thread-library)
-$(objpfx)tst-single_threaded-pthread.out: \
-  $(objpfx)tst-single_threaded-mod2.so $(objpfx)tst-single_threaded-mod3.so \
-  $(objpfx)tst-single_threaded-mod4.so
-$(objpfx)tst-single_threaded-pthread-static: $(static-thread-library)
-
-$(objpfx)tst-tls-ie: $(shared-thread-library)
-$(objpfx)tst-tls-ie.out: \
-  $(objpfx)tst-tls-ie-mod0.so \
-  $(objpfx)tst-tls-ie-mod1.so \
-  $(objpfx)tst-tls-ie-mod2.so \
-  $(objpfx)tst-tls-ie-mod3.so \
-  $(objpfx)tst-tls-ie-mod4.so \
-  $(objpfx)tst-tls-ie-mod5.so \
-  $(objpfx)tst-tls-ie-mod6.so
-
-$(objpfx)tst-tls-ie-dlmopen: $(shared-thread-library)
-$(objpfx)tst-tls-ie-dlmopen.out: \
-  $(objpfx)tst-tls-ie-mod0.so \
-  $(objpfx)tst-tls-ie-mod1.so \
-  $(objpfx)tst-tls-ie-mod2.so \
-  $(objpfx)tst-tls-ie-mod3.so \
-  $(objpfx)tst-tls-ie-mod4.so \
-  $(objpfx)tst-tls-ie-mod5.so \
-  $(objpfx)tst-tls-ie-mod6.so
-
-$(objpfx)argv0test.out: tst-rtld-argv0.sh $(objpfx)ld.so \
-			$(objpfx)argv0test
-	$(SHELL) $< $(objpfx)ld.so $(objpfx)argv0test \
-            '$(test-wrapper-env)' '$(run_program_env)' \
-            '$(rpath-link)' 'test-argv0' > $@; \
-    $(evaluate-test)
-
-# A list containing the name of the most likely searched subdirectory
-# of the glibc-hwcaps directory, for each supported architecture (in
-# other words, the oldest hardware level recognized by the
-# glibc-hwcaps mechanism for this architecture).  Used to obtain test
-# coverage for some glibc-hwcaps tests for the widest possible range
-# of systems.
-glibc-hwcaps-first-subdirs-for-tests = power9 x86-64-v2 z13
-
-# The test modules are parameterized by preprocessor macros.
-LDFLAGS-libmarkermod1-1.so += -Wl,-soname,libmarkermod1.so
-LDFLAGS-libmarkermod2-1.so += -Wl,-soname,libmarkermod2.so
-LDFLAGS-libmarkermod3-1.so += -Wl,-soname,libmarkermod3.so
-LDFLAGS-libmarkermod4-1.so += -Wl,-soname,libmarkermod4.so
-LDFLAGS-libmarkermod5-1.so += -Wl,-soname,libmarkermod5.so
-$(objpfx)libmarkermod%.os : markermodMARKER-VALUE.c
-	$(compile-command.c) \
-	  -DMARKER=marker$(firstword $(subst -, ,$*)) \
-	  -DVALUE=$(lastword $(subst -, ,$*))
-$(objpfx)libmarkermod1.so: $(objpfx)libmarkermod1-1.so
-	cp $< $@
-$(objpfx)libmarkermod2.so: $(objpfx)libmarkermod2-1.so
-	cp $< $@
-$(objpfx)libmarkermod3.so: $(objpfx)libmarkermod3-1.so
-	cp $< $@
-$(objpfx)libmarkermod4.so: $(objpfx)libmarkermod4-1.so
-	cp $< $@
-$(objpfx)libmarkermod5.so: $(objpfx)libmarkermod5-1.so
-	cp $< $@
-
-# tst-glibc-hwcaps-prepend checks that --glibc-hwcaps-prepend is
-# preferred over auto-detected subdirectories.
-$(objpfx)tst-glibc-hwcaps-prepend: $(objpfx)libmarkermod1-1.so
-$(objpfx)glibc-hwcaps/prepend-markermod1/libmarkermod1.so: \
-  $(objpfx)libmarkermod1-2.so
-	$(make-target-directory)
-	cp $< $@
-$(objpfx)glibc-hwcaps/%/libmarkermod1.so: $(objpfx)libmarkermod1-3.so
-	$(make-target-directory)
-	cp $< $@
-$(objpfx)tst-glibc-hwcaps-prepend.out: \
-  $(objpfx)tst-glibc-hwcaps-prepend $(objpfx)libmarkermod1.so \
-  $(patsubst %,$(objpfx)glibc-hwcaps/%/libmarkermod1.so,prepend-markermod1 \
-    $(glibc-hwcaps-first-subdirs-for-tests))
-	$(test-wrapper) $(rtld-prefix) \
-	  --glibc-hwcaps-prepend prepend-markermod1 \
-	  $< > $@; \
-	$(evaluate-test)
-
-# Like tst-glibc-hwcaps-prepend, but uses a container and loads the
-# library via ld.so.cache.  Test setup is contained in the test
-# itself.
-$(objpfx)tst-glibc-hwcaps-prepend-cache.out: \
-  $(objpfx)tst-glibc-hwcaps-prepend-cache $(objpfx)libmarkermod1-1.so \
-  $(objpfx)libmarkermod1-2.so $(objpfx)libmarkermod1-3.so
-
-# tst-glibc-hwcaps-mask checks that --glibc-hwcaps-mask can be used to
-# suppress all auto-detected subdirectories.
-$(objpfx)tst-glibc-hwcaps-mask: $(objpfx)libmarkermod1-1.so
-$(objpfx)tst-glibc-hwcaps-mask.out: \
-  $(objpfx)tst-glibc-hwcaps-mask $(objpfx)libmarkermod1.so \
-  $(patsubst %,$(objpfx)glibc-hwcaps/%/libmarkermod1.so,\
-    $(glibc-hwcaps-first-subdirs-for-tests))
-	$(test-wrapper) $(rtld-prefix) \
-	  --glibc-hwcaps-mask does-not-exist \
-	  $< > $@; \
-	$(evaluate-test)
-
-# Generic dependency for sysdeps implementation of
-# tst-glibc-hwcaps-cache.
-$(objpfx)tst-glibc-hwcaps-cache.out: $(objpfx)tst-glibc-hwcaps
-
-tst-tunables-ARGS = -- $(host-test-program-cmd)
-tst-tunables-enable_secure-ARGS = -- $(host-test-program-cmd)
-
-$(objpfx)list-tunables.out: tst-rtld-list-tunables.sh $(objpfx)ld.so
-	$(SHELL) $< $(objpfx)ld.so '$(test-wrapper-env)' \
-	    '$(run_program_env)' > $(objpfx)/tst-rtld-list-tunables.out
-	cmp tst-rtld-list-tunables.exp \
-	    $(objpfx)/tst-rtld-list-tunables.out > $@; \
-	$(evaluate-test)
-
-tst-dst-static-ENV = LD_LIBRARY_PATH='$$ORIGIN'
-
-$(objpfx)tst-rtld-help.out: $(objpfx)ld.so
-	$(test-wrapper) $(rtld-prefix) --help > $@; \
-	status=$$?; \
-	echo "info: ld.so exit status: $$status" >> $@; \
-	(exit $$status); \
-	$(evaluate-test)
-
-# Reuses tst-tls-many-dynamic-modules
-$(patsubst %,$(objpfx)%.os,$(tst-tls-many-dynamic-modules-dep)): \
-  $(objpfx)tst-tls-manydynamic%mod-dep.os : tst-tls-manydynamicmod.c
-	$(compile-command.c) \
-	  -DNAME=tls_global_$* -DSETTER=set_value_$* -DGETTER=get_value_$*
-$(patsubst %,$(objpfx)%.os,$(tst-tls-many-dynamic-modules-dep-bad)): \
-  $(objpfx)tst-tls-manydynamic%mod-dep-bad.os : tst-tls-manydynamicmod.c
-	$(compile-command.c) \
-	  -DNAME=tls_global_$* -DSETTER=set_value_$* -DGETTER=get_value_$*
-tst-tls20mod-bad.so-no-z-defs = yes
-# Single dependency.
-$(objpfx)tst-tls-manydynamic0mod-dep.so: $(objpfx)tst-tls-manydynamic1mod-dep.so
-# Double dependencies.
-$(objpfx)tst-tls-manydynamic2mod-dep.so: $(objpfx)tst-tls-manydynamic3mod-dep.so \
-					 $(objpfx)tst-tls-manydynamic4mod-dep.so
-# Double dependencies with each dependency dependent of another module.
-$(objpfx)tst-tls-manydynamic5mod-dep.so: $(objpfx)tst-tls-manydynamic6mod-dep.so \
-					 $(objpfx)tst-tls-manydynamic7mod-dep.so
-$(objpfx)tst-tls-manydynamic6mod-dep.so: $(objpfx)tst-tls-manydynamic8mod-dep.so
-$(objpfx)tst-tls-manydynamic7mod-dep.so: $(objpfx)tst-tls-manydynamic8mod-dep.so
-# Long chain with one double dependency in the middle
-$(objpfx)tst-tls-manydynamic9mod-dep.so: $(objpfx)tst-tls-manydynamic10mod-dep.so \
-					 $(objpfx)tst-tls-manydynamic11mod-dep.so
-$(objpfx)tst-tls-manydynamic10mod-dep.so: $(objpfx)tst-tls-manydynamic12mod-dep.so
-$(objpfx)tst-tls-manydynamic12mod-dep.so: $(objpfx)tst-tls-manydynamic13mod-dep.so
-# Long chain with two double dependencies in the middle
-$(objpfx)tst-tls-manydynamic14mod-dep.so: $(objpfx)tst-tls-manydynamic15mod-dep.so
-$(objpfx)tst-tls-manydynamic15mod-dep.so: $(objpfx)tst-tls-manydynamic16mod-dep.so \
-					  $(objpfx)tst-tls-manydynamic17mod-dep.so
-$(objpfx)tst-tls-manydynamic16mod-dep.so: $(objpfx)tst-tls-manydynamic18mod-dep.so \
-					  $(objpfx)tst-tls-manydynamic19mod-dep.so
-# Same but with an invalid module.
-# Single dependency.
-$(objpfx)tst-tls-manydynamic0mod-dep-bad.so: $(objpfx)tst-tls20mod-bad.so
-LDFLAGS-tst-tls-manydynamic0mod-dep-bad.so = -Wl,--no-as-needed
-# Double dependencies.
-$(objpfx)tst-tls-manydynamic1mod-dep-bad.so: $(objpfx)tst-tls-manydynamic2mod-dep-bad.so \
-					     $(objpfx)tst-tls20mod-bad.so
-LDFLAGS-tst-tls-manydynamic1mod-dep-bad.so = -Wl,--no-as-needed
-# Double dependencies with each dependency dependent of another module.
-$(objpfx)tst-tls-manydynamic3mod-dep-bad.so: $(objpfx)tst-tls-manydynamic4mod-dep-bad.so \
-					     $(objpfx)tst-tls-manydynamic5mod-dep-bad.so
-LDFLAGS-tst-tls-manydynamic3mod-dep-bad.so = -Wl,--no-as-needed
-$(objpfx)tst-tls-manydynamic4mod-dep-bad.so: $(objpfx)tst-tls20mod-bad.so
-LDFLAGS-tst-tls-manydynamic4mod-dep-bad.so = -Wl,--no-as-needed
-$(objpfx)tst-tls-manydynamic5mod-dep-bad.so: $(objpfx)tst-tls20mod-bad.so
-LDFLAGS-tst-tls-manydynamic5mod-dep-bad.so = -Wl,--no-as-needed
-# Long chain with one double dependency in the middle
-$(objpfx)tst-tls-manydynamic6mod-dep-bad.so: $(objpfx)tst-tls-manydynamic7mod-dep-bad.so \
-					     $(objpfx)tst-tls-manydynamic8mod-dep-bad.so
-LDFLAGS-tst-tls-manydynamic6mod-dep-bad.so = -Wl,--no-as-needed
-$(objpfx)tst-tls-manydynamic7mod-dep-bad.so: $(objpfx)tst-tls-manydynamic9mod-dep-bad.so
-LDFLAGS-tst-tls-manydynamic7mod-dep-bad.so = -Wl,--no-as-needed
-$(objpfx)tst-tls-manydynamic9mod-dep-bad.so: $(objpfx)tst-tls20mod-bad.so
-LDFLAGS-tst-tls-manydynamic9mod-dep-bad.so = -Wl,--no-as-needed
-# Long chain with two double dependencies in the middle
-$(objpfx)tst-tls-manydynamic10mod-dep-bad.so: $(objpfx)tst-tls-manydynamic11mod-dep-bad.so
-LDFLAGS-tst-tls-manydynamic10mod-dep-bad.so = -Wl,--no-as-needed
-$(objpfx)tst-tls-manydynamic11mod-dep-bad.so: $(objpfx)tst-tls-manydynamic12mod-dep-bad.so \
-					      $(objpfx)tst-tls-manydynamic13mod-dep-bad.so
-LDFLAGS-tst-tls-manydynamic11mod-dep-bad.so = -Wl,--no-as-needed
-$(objpfx)tst-tls-manydynamic12mod-dep-bad.so: $(objpfx)tst-tls-manydynamic14mod-dep-bad.so \
-					      $(objpfx)tst-tls20mod-bad.so
-LDFLAGS-tst-tls-manydynamic12mod-dep-bad.so = -Wl,--no-as-needed
-$(objpfx)tst-tls20: $(shared-thread-library)
-$(objpfx)tst-tls20.out: $(objpfx)tst-tls20mod-bad.so \
-			$(tst-tls-many-dynamic-modules:%=$(objpfx)%.so) \
-			$(tst-tls-many-dynamic-modules-dep:%=$(objpfx)%.so) \
-			$(tst-tls-many-dynamic-modules-dep-bad:%=$(objpfx)%.so) \
-
-# Reuses tst-tls-many-dynamic-modules
-$(objpfx)tst-tls21: $(shared-thread-library)
-$(objpfx)tst-tls21.out: $(objpfx)tst-tls21mod.so
-$(objpfx)tst-tls21mod.so: $(tst-tls-many-dynamic-modules:%=$(objpfx)%.so)
-
-$(objpfx)tst-getauxval-static.out: $(objpfx)tst-auxvalmod.so
-tst-getauxval-static-ENV = LD_LIBRARY_PATH=$(objpfx):$(common-objpfx)
-
-$(objpfx)tst-dlmopen-gethostbyname.out: $(objpfx)tst-dlmopen-gethostbyname-mod.so
-
-$(objpfx)tst-ro-dynamic: $(objpfx)tst-ro-dynamic-mod.so
-$(objpfx)tst-ro-dynamic-mod.so: $(objpfx)tst-ro-dynamic-mod.os \
-  tst-ro-dynamic-mod.map
-	$(LINK.o) -nostdlib -nostartfiles -shared -o $@ \
-		$(dt-relr-ldflag) \
-		-Wl,--script=tst-ro-dynamic-mod.map \
-		$(objpfx)tst-ro-dynamic-mod.os
-
-$(objpfx)tst-rtld-list-diagnostics.out: tst-rtld-list-diagnostics.py \
-  $(..)manual/dynlink.texi $(objpfx)$(rtld-installed-name)
-	$(PYTHON) tst-rtld-list-diagnostics.py \
-	  --manual=$(..)manual/dynlink.texi \
-	  "$(test-wrapper-env) $(objpfx)$(rtld-installed-name) --list-diagnostics" \
-	  > $@; \
-	$(evaluate-test)
-
-$(objpfx)tst-rtld-run-static.out: $(objpfx)/ldconfig
-
-$(objpfx)tst-dl_find_object.out: \
-  $(objpfx)tst-dl_find_object-mod1.so $(objpfx)tst-dl_find_object-mod2.so
-$(objpfx)tst-dl_find_object-static.out: \
-  $(objpfx)tst-dl_find_object-mod1.so $(objpfx)tst-dl_find_object-mod2.so
-tst-dl_find_object-static-ENV = $(static-dlopen-environment)
-CFLAGS-tst-dl_find_object.c += -funwind-tables
-CFLAGS-tst-dl_find_object-static.c += -funwind-tables
-LDFLAGS-tst-dl_find_object-static += -Wl,--eh-frame-hdr
-CFLAGS-tst-dl_find_object-mod1.c += -funwind-tables
-CFLAGS-tst-dl_find_object-mod2.c += -funwind-tables
-LDFLAGS-tst-dl_find_object-mod2.so += -Wl,--enable-new-dtags,-z,nodelete
-$(objpfx)tst-dl_find_object-threads: $(shared-thread-library)
-CFLAGS-tst-dl_find_object-threads.c += -funwind-tables
-$(objpfx)tst-dl_find_object-threads.out: \
-  $(objpfx)tst-dl_find_object-mod1.so \
-  $(objpfx)tst-dl_find_object-mod2.so \
-  $(objpfx)tst-dl_find_object-mod3.so \
-  $(objpfx)tst-dl_find_object-mod4.so \
-  $(objpfx)tst-dl_find_object-mod5.so \
-  $(objpfx)tst-dl_find_object-mod6.so \
-  $(objpfx)tst-dl_find_object-mod7.so \
-  $(objpfx)tst-dl_find_object-mod8.so \
-  $(objpfx)tst-dl_find_object-mod9.so
-CFLAGS-tst-dl_find_object-mod3.c += -funwind-tables
-CFLAGS-tst-dl_find_object-mod4.c += -funwind-tables
-CFLAGS-tst-dl_find_object-mod5.c += -funwind-tables
-CFLAGS-tst-dl_find_object-mod6.c += -funwind-tables
-CFLAGS-tst-dl_find_object-mod7.c += -funwind-tables
-CFLAGS-tst-dl_find_object-mod8.c += -funwind-tables
-CFLAGS-tst-dl_find_object-mod9.c += -funwind-tables
-
-$(objpfx)tst-p_alignmod-base.so: $(libsupport)
-LDFLAGS-tst-p_alignmod-base.so += -Wl,-z,max-page-size=0x200000
-
-$(objpfx)tst-p_align1: $(objpfx)tst-p_alignmod1.so
-
-# Make a copy of tst-p_alignmod-base.so and lower p_align of the first
-# PT_LOAD segment.
-$(objpfx)tst-p_alignmod1.so: $(objpfx)tst-p_alignmod-base.so
-	rm -f $@
-	cp $(objpfx)tst-p_alignmod-base.so $@
-	$(PYTHON) $(..)scripts/tst-elf-edit.py -a half $@
-
-$(objpfx)tst-p_align2: $(objpfx)tst-p_alignmod2.so
-
-# Make a copy of tst-p_alignmod-base.so and update p_align of the first
-# PT_LOAD segment.
-$(objpfx)tst-p_alignmod2.so: $(objpfx)tst-p_alignmod-base.so
-	rm -f $@
-	cp $(objpfx)tst-p_alignmod-base.so $@
-	$(PYTHON) $(..)scripts/tst-elf-edit.py -a 1 $@
-
-LDFLAGS-tst-p_alignmod3.so += -Wl,-z,max-page-size=0x100,-z,common-page-size=0x100
-
-$(objpfx)tst-p_align3: $(objpfx)tst-p_alignmod3.so
-$(objpfx)tst-p_align3.out: tst-p_align3.sh $(objpfx)tst-p_align3
-	$(SHELL) $< $(common-objpfx) '$(test-program-prefix)'; \
-	$(evaluate-test)
-
-$(objpfx)check-abi-version-libc.out: $(common-objpfx)libc.so
-	LC_ALL=C $(READELF) -V -W $< \
-		| sed -ne '/.gnu.version_d/, /.gnu.version_r/ p' \
-		| grep GLIBC_ABI_DT_RELR > $@; \
-	$(evaluate-test)
-
-$(objpfx)check-tst-relr-pie.out: $(objpfx)tst-relr-pie
-	LC_ALL=C $(OBJDUMP) -p $< \
-		| sed -ne '/required from libc.so/,$$ p' \
-		| grep GLIBC_ABI_DT_RELR > $@; \
-	$(evaluate-test)
-
-# The test checks if a DT_RELR shared library without DT_NEEDED works as
-# intended, so it uses an explicit link rule.
-$(objpfx)tst-relr2: $(objpfx)tst-relr-mod2.so
-$(objpfx)tst-relr-mod2.so: $(objpfx)tst-relr-mod2.os
-	$(LINK.o) -nostdlib -nostartfiles -Wl,-z,pack-relative-relocs \
-	$(LDFLAGS-soname-fname) \
-	-shared -o $@.new $(filter-out $(map-file),$^)
-	$(call after-link,$@.new)
-	mv -f $@.new $@
-
-# The test checks if a DT_RELR shared library without DT_VERNEED works as
-# intended, so it uses an explicit link rule.
-$(objpfx)tst-relr3: $(objpfx)tst-relr-mod3a.so
-$(objpfx)tst-relr-mod3b.so: $(objpfx)tst-relr-mod3b.os
-	$(LINK.o) -nostdlib -nostartfiles -Wl,-z,pack-relative-relocs \
-	$(LDFLAGS-soname-fname) \
-	-shared -o $@.new $(filter-out $(map-file),$^)
-	$(call after-link,$@.new)
-	mv -f $@.new $@
-
-$(objpfx)tst-relr-mod3a.so: $(objpfx)tst-relr-mod3a.os \
-  $(objpfx)tst-relr-mod3b.so
-	$(LINK.o) -nostdlib -nostartfiles -Wl,-z,pack-relative-relocs \
-	$(LDFLAGS-soname-fname) $(LDFLAGS-rpath-ORIGIN) \
-	-shared -o $@.new $(filter-out $(map-file),$^)
-	$(call after-link,$@.new)
-	mv -f $@.new $@
-
-# The test checks if a DT_RELR shared library without libc.so on DT_NEEDED
-# works as intended, so it uses an explicit link rule.
-$(objpfx)tst-relr4: $(objpfx)tst-relr-mod4a.so
-$(objpfx)tst-relr-mod4b.so: $(objpfx)tst-relr-mod4b.os
-	$(LINK.o) -nostdlib -nostartfiles -Wl,-z,pack-relative-relocs \
-	$(LDFLAGS-soname-fname) \
-	-Wl,--version-script=tst-relr-mod4b.map \
-	-shared -o $@.new $(filter-out $(map-file),$^)
-	$(call after-link,$@.new)
-	mv -f $@.new $@
-
-$(objpfx)tst-relr-mod4a.so: $(objpfx)tst-relr-mod4a.os \
-  $(objpfx)tst-relr-mod4b.so
-	$(LINK.o) -nostdlib -nostartfiles -Wl,-z,pack-relative-relocs \
-	$(LDFLAGS-soname-fname) $(LDFLAGS-rpath-ORIGIN) \
-	-shared -o $@.new $(filter-out $(map-file),$^)
-	$(call after-link,$@.new)
-	mv -f $@.new $@
-
-LDFLAGS-libtracemod1-1.so += -Wl,-soname,libtracemod1.so
-LDFLAGS-libtracemod2-1.so += -Wl,-soname,libtracemod2.so
-LDFLAGS-libtracemod3-1.so += -Wl,-soname,libtracemod3.so
-LDFLAGS-libtracemod4-1.so += -Wl,-soname,libtracemod4.so
-LDFLAGS-libtracemod5-1.so += -Wl,-soname,libtracemod5.so
-
-$(objpfx)libtracemod1-1.so: $(objpfx)libtracemod2-1.so \
-			    $(objpfx)libtracemod3-1.so
-$(objpfx)libtracemod2-1.so: $(objpfx)libtracemod4-1.so \
-			    $(objpfx)libtracemod5-1.so
-
-define libtracemod-x
-$(objpfx)libtracemod$(1)/libtracemod$(1).so: $(objpfx)libtracemod$(1)-1.so
-	$$(make-target-directory)
-	cp $$< $$@
-endef
-libtracemod-suffixes = 1 2 3 4 5
-$(foreach i,$(libtracemod-suffixes), $(eval $(call libtracemod-x,$(i))))
-
-define tst-trace-skeleton
-$(objpfx)tst-trace$(1).out: $(objpfx)libtracemod1/libtracemod1.so \
-			    $(objpfx)libtracemod2/libtracemod2.so \
-			    $(objpfx)libtracemod3/libtracemod3.so \
-			    $(objpfx)libtracemod4/libtracemod4.so \
-			    $(objpfx)libtracemod5/libtracemod5.so \
-			    $(..)scripts/tst-ld-trace.py \
-			    tst-trace$(1).exp
-	${ $(PYTHON) $(..)scripts/tst-ld-trace.py \
-	    "$(test-wrapper-env) $(elf-objpfx)$(rtld-installed-name) \
-	    --library-path $(common-objpfx):$(strip $(2)) \
-	    $(objpfx)libtracemod1/libtracemod1.so" tst-trace$(1).exp \
-	} > $$@; $$(evaluate-test)
-endef
-
-$(eval $(call tst-trace-skeleton,1,))
-$(eval $(call tst-trace-skeleton,2,\
-	$(objpfx)libtracemod2))
-$(eval $(call tst-trace-skeleton,3,\
-	$(objpfx)libtracemod2:$(objpfx)libtracemod3))
-$(eval $(call tst-trace-skeleton,4,\
-	$(objpfx)libtracemod2:$(objpfx)libtracemod3:$(objpfx)libtracemod4))
-$(eval $(call tst-trace-skeleton,5,\
-	$(objpfx)libtracemod2:$(objpfx)libtracemod3:$(objpfx)libtracemod4:$(objpfx)libtracemod5))
-
-$(objpfx)tst-tls-allocation-failure-static-patched: \
-  $(objpfx)tst-tls-allocation-failure-static $(..)scripts/tst-elf-edit.py
-	cp $< $@
-	$(PYTHON) $(..)scripts/tst-elf-edit.py --maximize-tls-size $@
-
-$(objpfx)tst-tls-allocation-failure-static-patched.out: \
-  $(objpfx)tst-tls-allocation-failure-static-patched
-	$(test-wrapper) $< > $@ 2>&1; echo "status: $$?" >> $@
-	grep -q '^Fatal glibc error: Cannot allocate TLS block$$' $@ \
-	  && grep -q '^status: 127$$' $@; \
-	  $(evaluate-test)
-
-$(objpfx)tst-audit-tlsdesc: $(objpfx)tst-audit-tlsdesc-mod1.so \
-			    $(objpfx)tst-audit-tlsdesc-mod2.so \
-			    $(shared-thread-library)
-ifneq (no,$(have-mtls-descriptor))
-# The test is valid for all TLS types, but we want to exercise GNU2
-# TLS if possible.
-CFLAGS-tst-audit-tlsdesc-mod1.c += -mtls-dialect=$(have-mtls-descriptor)
-CFLAGS-tst-audit-tlsdesc-mod2.c += -mtls-dialect=$(have-mtls-descriptor)
-endif
-$(objpfx)tst-audit-tlsdesc-dlopen: $(shared-thread-library)
-$(objpfx)tst-audit-tlsdesc-dlopen.out: $(objpfx)tst-audit-tlsdesc-mod1.so \
-				       $(objpfx)tst-audit-tlsdesc-mod2.so
-$(objpfx)tst-audit-tlsdesc-mod1.so: $(objpfx)tst-audit-tlsdesc-mod2.so
-$(objpfx)tst-audit-tlsdesc.out: $(objpfx)tst-auditmod-tlsdesc.so
-tst-audit-tlsdesc-ENV = LD_AUDIT=$(objpfx)tst-auditmod-tlsdesc.so
-$(objpfx)tst-audit-tlsdesc-dlopen.out: $(objpfx)tst-auditmod-tlsdesc.so
-tst-audit-tlsdesc-dlopen-ENV = LD_AUDIT=$(objpfx)tst-auditmod-tlsdesc.so
-
-$(objpfx)tst-dlmopen-twice.out: \
-  $(objpfx)tst-dlmopen-twice-mod1.so \
-  $(objpfx)tst-dlmopen-twice-mod2.so
-
-LDFLAGS-tst-sprof-mod.so = -Wl,-soname,tst-sprof-mod.so
-$(objpfx)tst-sprof-basic: $(objpfx)tst-sprof-mod.so
-$(objpfx)tst-sprof-basic.out: tst-sprof-basic.sh $(objpfx)tst-sprof-basic
-	$(SHELL) $< $(common-objpfx) '$(test-wrapper-env)' \
-		 '$(run-program-env)' > $@; \
-	$(evaluate-test)
-generated += tst-sprof-mod.so.profile
-
-LDFLAGS-tst-dlclose-lazy-mod1.so = -Wl,-z,lazy,--no-as-needed
-$(objpfx)tst-dlclose-lazy-mod1.so: $(objpfx)tst-dlclose-lazy-mod2.so
-$(objpfx)tst-dlclose-lazy.out: \
-  $(objpfx)tst-dlclose-lazy-mod1.so $(objpfx)tst-dlclose-lazy-mod2.so
-
-$(objpfx)tst-decorate-maps: $(shared-thread-library)
-
-tst-decorate-maps-ENV = \
-  GLIBC_TUNABLES=glibc.malloc.arena_max=8:glibc.malloc.mmap_threshold=1024:glibc.mem.decorate_maps=1
-tst-decorate-maps-ARGS = 8
-
-LDFLAGS-tst-non-directory-mod.so = -Wl,-soname,tst-non-directory-mod.so
-$(objpfx)tst-non-directory-path: $(objpfx)tst-non-directory-mod.so
-$(objpfx)tst-non-directory-path.out: tst-non-directory-path.sh \
-	$(objpfx)tst-non-directory-path
-	$(SHELL) tst-non-directory-path.sh $(objpfx)ld.so $(objpfx)tst-non-directory-path \
-		    '$(test-wrapper-env)' '$(run_program_env)' \
-		    '$(rpath-link)' $(objpfx) > $@; \
-	$(evaluate-test)
-
-tst-env-setuid-ARGS = -- $(host-test-program-cmd)
-
-# Reuse a module with a SONAME, to specific as the LD_PROFILE.
-$(objpfx)tst-env-setuid: $(objpfx)tst-sonamemove-runmod2.so
-$(objpfx)tst-env-setuid-static.out: $(objpfx)tst-sonamemove-runmod1.so
-
-# The object tst-nodeps1-mod.so has no explicit dependencies on libc.so.
-# We do not use $(link-test-modules-rpath-link) since the object has no
-# DT_NEEDED.
-$(objpfx)tst-nodeps1-mod.so: $(objpfx)tst-nodeps1-mod.os
-	$(LINK.o) -nostartfiles -nostdlib -shared -o $@ $^
-tst-nodeps1.so-no-z-defs = yes
-# Link libc.so before the test module with the IFUNC resolver reference.
-LDFLAGS-tst-nodeps1 = $(common-objpfx)libc.so $(objpfx)tst-nodeps1-mod.so
-$(objpfx)tst-nodeps1: $(objpfx)tst-nodeps1-mod.so
-# Reuse the tst-nodeps1 module.  Link libc.so before the test module
-# with the IFUNC resolver reference.
-$(objpfx)tst-nodeps2-mod.so: $(common-objpfx)libc.so \
-  $(objpfx)tst-nodeps1-mod.so $(objpfx)tst-nodeps2-mod.os
-	$(LINK.o) -Wl,--no-as-needed -nostartfiles -nostdlib -shared -o $@ $^ \
-	$(link-test-modules-rpath-link)
-$(objpfx)tst-nodeps2.out: \
-  $(objpfx)tst-nodeps1-mod.so $(objpfx)tst-nodeps2-mod.so
-
-$(objpfx)tst-tlsgap: $(shared-thread-library)
-$(objpfx)tst-tlsgap.out: \
-  $(objpfx)tst-tlsgap-mod0.so \
-  $(objpfx)tst-tlsgap-mod1.so \
-  $(objpfx)tst-tlsgap-mod2.so
-
-$(objpfx)tst-gnu2-tls2: $(shared-thread-library)
-$(objpfx)tst-gnu2-tls2.out: \
-  $(objpfx)tst-gnu2-tls2mod0.so \
-  $(objpfx)tst-gnu2-tls2mod1.so \
-  $(objpfx)tst-gnu2-tls2mod2.so
-
-ifneq (no,$(have-mtls-descriptor))
-CFLAGS-tst-tlsgap-mod0.c += -mtls-dialect=$(have-mtls-descriptor)
-CFLAGS-tst-tlsgap-mod1.c += -mtls-dialect=$(have-mtls-descriptor)
-CFLAGS-tst-tlsgap-mod2.c += -mtls-dialect=$(have-mtls-descriptor)
-CFLAGS-tst-gnu2-tls2mod0.c += -mtls-dialect=$(have-mtls-descriptor)
-CFLAGS-tst-gnu2-tls2mod1.c += -mtls-dialect=$(have-mtls-descriptor)
-CFLAGS-tst-gnu2-tls2mod2.c += -mtls-dialect=$(have-mtls-descriptor)
-endif
-
-$(objpfx)tst-recursive-tls: $(objpfx)tst-recursive-tlsmallocmod.so
-# More objects than DTV_SURPLUS, to trigger DTV reallocation.
-$(objpfx)tst-recursive-tls.out: \
-  $(patsubst %,$(objpfx)tst-recursive-tlsmod%.so, \
-    0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)
-$(objpfx)tst-recursive-tlsmod%.os: tst-recursive-tlsmodN.c
-	$(compile-command.c) -DVAR=thread_$* -DFUNC=get_threadvar_$*
-
-# Order matters here.  The test needs the constructor for
-# tst-dlopen-tlsreinitmod2.so to be called first.
-LDFLAGS-tst-dlopen-tlsreinitmod1.so = -Wl,--no-as-needed
-$(objpfx)tst-dlopen-tlsreinitmod1.so: \
-  $(objpfx)tst-dlopen-tlsreinitmod3.so $(objpfx)tst-dlopen-tlsreinitmod2.so
-LDFLAGS-tst-dlopen-tlsreinit2 = -Wl,--no-as-needed
-$(objpfx)tst-dlopen-tlsreinit2: \
-  $(objpfx)tst-dlopen-tlsreinitmod3.so $(objpfx)tst-dlopen-tlsreinitmod2.so
-LDFLAGS-tst-dlopen-tlsreinit4 = -Wl,--no-as-needed
-$(objpfx)tst-dlopen-tlsreinit4: \
-  $(objpfx)tst-dlopen-tlsreinitmod3.so $(objpfx)tst-dlopen-tlsreinitmod2.so
-# tst-dlopen-tlsreinitmod2.so is underlinked and refers to
-# tst-dlopen-tlsreinitmod3.so.  The dependency is provided via
-# $(objpfx)tst-dlopen-tlsreinitmod1.so.
-tst-dlopen-tlsreinitmod2.so-no-z-defs = yes
-$(objpfx)tst-dlopen-tlsreinit1.out: $(objpfx)tst-dlopen-tlsreinitmod1.so \
-  $(objpfx)tst-dlopen-tlsreinitmod2.so $(objpfx)tst-dlopen-tlsreinitmod3.so
-# Reuse an audit module which provides ample debug logging.
-$(objpfx)tst-dlopen-tlsreinit3.out: $(objpfx)tst-auditmod1.so
-tst-dlopen-tlsreinit3-ENV = LD_AUDIT=$(objpfx)tst-auditmod1.so
-$(objpfx)tst-dlopen-tlsreinit4.out: $(objpfx)tst-auditmod1.so
-tst-dlopen-tlsreinit4-ENV = LD_AUDIT=$(objpfx)tst-auditmod1.so
diff --git a/elf/dl-libc.c b/elf/dl-libc.c
index 3c048cc6c179..d65faa971aa4 100644
--- a/elf/dl-libc.c
+++ b/elf/dl-libc.c
@@ -18,177 +18,22 @@
 
 #include <dlfcn.h>
 #include <stdlib.h>
-#include <ldsodefs.h>
-#include <dl-hash.h>
+#include <pizlonated_syscalls.h>
 
-extern int __libc_argc attribute_hidden;
-extern char **__libc_argv attribute_hidden;
-
-extern char **__environ;
-
-/* The purpose of this file is to provide wrappers around the dynamic
-   linker error mechanism (similar to dlopen() et al in libdl) which
-   are usable from within libc.  Generally we want to throw away the
-   string that dlerror() would return and just pass back a null pointer
-   for errors.  This also lets the rest of libc not know about the error
-   handling mechanism.
-
-   Much of this code came from gconv_dl.c with slight modifications. */
-
-static int
-dlerror_run (void (*operate) (void *), void *args)
-{
-  const char *objname;
-  const char *last_errstring = NULL;
-  bool malloced;
-
-  int result = (GLRO (dl_catch_error) (&objname, &last_errstring, &malloced,
-				       operate, args)
-		?: last_errstring != NULL);
-
-  if (result && malloced)
-    GLRO (dl_error_free) ((char *) last_errstring);
-
-  return result;
-}
-
-/* These functions are called by dlerror_run... */
-
-struct do_dlopen_args
-{
-  /* Argument to do_dlopen.  */
-  const char *name;
-  /* Opening mode.  */
-  int mode;
-  /* This is the caller of the dlopen() function.  */
-  const void *caller_dlopen;
-
-  /* Return from do_dlopen.  */
-  struct link_map *map;
-};
-
-struct do_dlsym_args
-{
-  /* Arguments to do_dlsym.  */
-  struct link_map *map;
-  const char *name;
-
-  /* Return values of do_dlsym.  */
-  lookup_t loadbase;
-  const ElfW(Sym) *ref;
-};
-
-struct do_dlvsym_args
-{
-  /* dlvsym is like dlsym.  */
-  struct do_dlsym_args dlsym;
-
-  /* But dlvsym needs a version  as well.  */
-  struct r_found_version version;
-};
-
-static void
-do_dlopen (void *ptr)
-{
-  struct do_dlopen_args *args = (struct do_dlopen_args *) ptr;
-  /* Open and relocate the shared object.  */
-  args->map = GLRO(dl_open) (args->name, args->mode, args->caller_dlopen,
-			     __LM_ID_CALLER, __libc_argc, __libc_argv,
-			     __environ);
-}
-
-static void
-do_dlsym (void *ptr)
-{
-  struct do_dlsym_args *args = (struct do_dlsym_args *) ptr;
-  args->ref = NULL;
-  args->loadbase = GLRO(dl_lookup_symbol_x) (args->name, args->map, &args->ref,
-					     args->map->l_local_scope, NULL, 0,
-					     DL_LOOKUP_RETURN_NEWEST, NULL);
-}
-
-static void
-do_dlvsym (void *ptr)
-{
-  struct do_dlvsym_args *args = ptr;
-  args->dlsym.ref = NULL;
-  args->dlsym.loadbase
-    = GLRO(dl_lookup_symbol_x) (args->dlsym.name, args->dlsym.map,
-				&args->dlsym.ref,
-				args->dlsym.map->l_local_scope,
-				&args->version, 0, 0, NULL);
-}
-
-static void
-do_dlclose (void *ptr)
-{
-  GLRO(dl_close) ((struct link_map *) ptr);
-}
-
-#ifndef SHARED
-static void
-do_dlsym_private (void *ptr)
-{
-  lookup_t l;
-  struct r_found_version vers;
-  vers.name = "GLIBC_PRIVATE";
-  vers.hidden = 1;
-  /* vers.hash = _dl_elf_hash (vers.name);  */
-  vers.hash = 0x0963cf85;
-  vers.filename = NULL;
-
-  struct do_dlsym_args *args = (struct do_dlsym_args *) ptr;
-  args->ref = NULL;
-  l = GLRO(dl_lookup_symbol_x) (args->name, args->map, &args->ref,
-				args->map->l_scope, &vers, 0, 0, NULL);
-  args->loadbase = l;
-}
-#endif
-
-/* ... and these functions call dlerror_run. */
+/* FIXME: This sets the dlerror even though in yolo-glibc, these functions throw away the error.
+ 
+   I'm not sure that matters? */
 
 void *
 __libc_dlopen_mode (const char *name, int mode)
 {
-  struct do_dlopen_args args;
-  args.name = name;
-  args.mode = mode;
-  args.caller_dlopen = RETURN_ADDRESS (0);
-
-#ifdef SHARED
-  if (GLRO (dl_dlfcn_hook) != NULL)
-    return GLRO (dl_dlfcn_hook)->libc_dlopen_mode (name, mode);
-#endif
-  return dlerror_run (do_dlopen, &args) ? NULL : (void *) args.map;
+  return zsys_dlopen (name, mode);
 }
 
-#ifndef SHARED
-void *
-__libc_dlsym_private (struct link_map *map, const char *name)
-{
-  struct do_dlsym_args sargs;
-  sargs.map = map;
-  sargs.name = name;
-
-  if (! dlerror_run (do_dlsym_private, &sargs))
-    return DL_SYMBOL_ADDRESS (sargs.loadbase, sargs.ref);
-  return NULL;
-}
-#endif
-
 void *
 __libc_dlsym (void *map, const char *name)
 {
-  struct do_dlsym_args args;
-  args.map = map;
-  args.name = name;
-
-#ifdef SHARED
-  if (GLRO (dl_dlfcn_hook) != NULL)
-    return GLRO (dl_dlfcn_hook)->libc_dlsym (map, name);
-#endif
-  return (dlerror_run (do_dlsym, &args) ? NULL
-	  : (void *) (DL_SYMBOL_ADDRESS (args.loadbase, args.ref)));
+  return zsys_dlsym (map, name);
 }
 
 /* Replacement for dlvsym.  MAP must be a real map.  This function
@@ -197,139 +42,13 @@ __libc_dlsym (void *map, const char *name)
 void *
 __libc_dlvsym (void *map, const char *name, const char *version)
 {
-#ifdef SHARED
-  if (GLRO (dl_dlfcn_hook) != NULL)
-    return GLRO (dl_dlfcn_hook)->libc_dlvsym (map, name, version);
-#endif
-
-  struct do_dlvsym_args args;
-  args.dlsym.map = map;
-  args.dlsym.name = name;
-
-  /* See _dl_vsym in dl-sym.c.  */
-  args.version.name = version;
-  args.version.hidden = 1;
-  args.version.hash = _dl_elf_hash (version);
-  args.version.filename = NULL;
-
-  return (dlerror_run (do_dlvsym, &args) ? NULL
-	  : (void *) (DL_SYMBOL_ADDRESS (args.dlsym.loadbase,
-					 args.dlsym.ref)));
+  return zsys_dlvsym (map, name, version);
 }
 
 int
 __libc_dlclose (void *map)
 {
-#ifdef SHARED
-  if (GLRO (dl_dlfcn_hook) != NULL)
-    return GLRO (dl_dlfcn_hook)->libc_dlclose (map);
-#endif
-  return dlerror_run (do_dlclose, map);
-}
-
-
-static bool
-free_slotinfo (struct dtv_slotinfo_list **elemp)
-{
-  size_t cnt;
-
-  if (*elemp == NULL)
-    /* Nothing here, all is removed (or there never was anything).  */
-    return true;
-
-  if (!free_slotinfo (&(*elemp)->next))
-    /* We cannot free the entry.  */
-    return false;
-
-  /* That cleared our next pointer for us.  */
-
-  for (cnt = 0; cnt < (*elemp)->len; ++cnt)
-    if ((*elemp)->slotinfo[cnt].map != NULL)
-      /* Still used.  */
-      return false;
-
-  /* We can remove the list element.  */
-  free (*elemp);
-  *elemp = NULL;
-
-  return true;
+  return 0;
 }
 
 
-void
-__dl_libc_freemem (void)
-{
-  struct link_map *l;
-  struct r_search_path_elem *d;
-
-  /* Remove all search directories.  */
-  d = GL(dl_all_dirs);
-  while (d != GLRO(dl_init_all_dirs))
-    {
-      struct r_search_path_elem *old = d;
-      d = d->next;
-      free (old);
-    }
-
-  for (Lmid_t ns = 0; ns < GL(dl_nns); ++ns)
-    {
-      for (l = GL(dl_ns)[ns]._ns_loaded; l != NULL; l = l->l_next)
-	{
-	  struct libname_list *lnp = l->l_libname->next;
-
-	  l->l_libname->next = NULL;
-
-	  /* Remove all additional names added to the objects.  */
-	  while (lnp != NULL)
-	    {
-	      struct libname_list *old = lnp;
-	      lnp = lnp->next;
-	      if (! old->dont_free)
-		free (old);
-	    }
-
-	  /* Free the initfini dependency list.  */
-	  if (l->l_free_initfini)
-	    free (l->l_initfini);
-	  l->l_initfini = NULL;
-	}
-
-      if (__builtin_expect (GL(dl_ns)[ns]._ns_global_scope_alloc, 0) != 0
-	  && (GL(dl_ns)[ns]._ns_main_searchlist->r_nlist
-	      // XXX Check whether we need NS-specific initial_searchlist
-	      == GLRO(dl_initial_searchlist).r_nlist))
-	{
-	  /* All object dynamically loaded by the program are unloaded.  Free
-	     the memory allocated for the global scope variable.  */
-	  struct link_map **old = GL(dl_ns)[ns]._ns_main_searchlist->r_list;
-
-	  /* Put the old map in.  */
-	  GL(dl_ns)[ns]._ns_main_searchlist->r_list
-	    // XXX Check whether we need NS-specific initial_searchlist
-	    = GLRO(dl_initial_searchlist).r_list;
-	  /* Signal that the original map is used.  */
-	  GL(dl_ns)[ns]._ns_global_scope_alloc = 0;
-
-	  /* Now free the old map.  */
-	  free (old);
-	}
-    }
-
-  /* Free the memory allocated for the dtv slotinfo array.  We can do
-     this only if all modules which used this memory are unloaded.  */
-#ifdef SHARED
-  if (GL(dl_initial_dtv) == NULL)
-    /* There was no initial TLS setup, it was set up later when
-       it used the normal malloc.  */
-    free_slotinfo (&GL(dl_tls_dtv_slotinfo_list));
-  else
-#endif
-    /* The first element of the list does not have to be deallocated.
-       It was allocated in the dynamic linker (i.e., with a different
-       malloc), and in the static library it's in .bss space.  */
-    free_slotinfo (&GL(dl_tls_dtv_slotinfo_list)->next);
-
-  void *scope_free_list = GL(dl_scope_free_list);
-  GL(dl_scope_free_list) = NULL;
-  free (scope_free_list);
-}
diff --git a/elf/dl-support.c b/elf/dl-support.c
index 451932dd03e9..8971711cd93c 100644
--- a/elf/dl-support.c
+++ b/elf/dl-support.c
@@ -228,119 +228,8 @@ __rtld_lock_define_initialized_recursive (, _dl_load_tls_lock)
 #include <dl-parse_auxv.h>
 
 int _dl_clktck;
-
-void
-_dl_aux_init (ElfW(auxv_t) *av)
-{
-#ifdef NEED_DL_SYSINFO
-  /* NB: Avoid RELATIVE relocation in static PIE.  */
-  GL(dl_sysinfo) = DL_SYSINFO_DEFAULT;
 #endif
 
-  _dl_auxv = av;
-  dl_parse_auxv_t auxv_values;
-  /* Use an explicit initialization loop here because memset may not
-     be available yet.  */
-  for (int i = 0; i < array_length (auxv_values); ++i)
-    auxv_values[i] = 0;
-  _dl_parse_auxv (av, auxv_values);
-
-  _dl_phdr = (void*) auxv_values[AT_PHDR];
-  _dl_phnum = auxv_values[AT_PHNUM];
-
-  if (_dl_phdr == NULL)
-    {
-      /* Starting from binutils-2.23, the linker will define the
-         magic symbol __ehdr_start to point to our own ELF header
-         if it is visible in a segment that also includes the phdrs.
-         So we can set up _dl_phdr and _dl_phnum even without any
-         information from auxv.  */
-
-      extern const ElfW(Ehdr) __ehdr_start attribute_hidden;
-      assert (__ehdr_start.e_phentsize == sizeof *GL(dl_phdr));
-      _dl_phdr = (const void *) &__ehdr_start + __ehdr_start.e_phoff;
-      _dl_phnum = __ehdr_start.e_phnum;
-    }
-
-  assert (_dl_phdr != NULL);
-}
-#endif
-
-
-void
-_dl_non_dynamic_init (void)
-{
-  _dl_main_map.l_origin = _dl_get_origin ();
-  _dl_main_map.l_phdr = GL(dl_phdr);
-  _dl_main_map.l_phnum = GL(dl_phnum);
-
-  /* Set up the data structures for the system-supplied DSO early,
-     so they can influence _dl_init_paths.  */
-  setup_vdso (NULL, NULL);
-
-  /* With vDSO setup we can initialize the function pointers.  */
-  setup_vdso_pointers ();
-
-  if (__libc_enable_secure)
-    {
-      static const char unsecure_envvars[] =
-	UNSECURE_ENVVARS
-	;
-      const char *cp = unsecure_envvars;
-
-      while (cp < unsecure_envvars + sizeof (unsecure_envvars))
-	{
-	  __unsetenv (cp);
-	  cp = strchr (cp, '\0') + 1;
-	}
-    }
-
-  _dl_verbose = *(getenv ("LD_WARN") ?: "") == '\0' ? 0 : 1;
-
-  /* Initialize the data structures for the search paths for shared
-     objects.  */
-  _dl_init_paths (getenv ("LD_LIBRARY_PATH"), "LD_LIBRARY_PATH",
-		  /* No glibc-hwcaps selection support in statically
-		     linked binaries.  */
-		  NULL, NULL);
-
-  /* Remember the last search directory added at startup.  */
-  _dl_init_all_dirs = GL(dl_all_dirs);
-
-  _dl_lazy = *(getenv ("LD_BIND_NOW") ?: "") == '\0';
-
-  _dl_bind_not = *(getenv ("LD_BIND_NOT") ?: "") != '\0';
-
-  _dl_dynamic_weak = *(getenv ("LD_DYNAMIC_WEAK") ?: "") == '\0';
-
-#ifdef DL_PLATFORM_INIT
-  DL_PLATFORM_INIT;
-#endif
-
-  /* Now determine the length of the platform string.  */
-  if (_dl_platform != NULL)
-    _dl_platformlen = strlen (_dl_platform);
-
-  for (const ElfW(Phdr) *ph = _dl_phdr; ph < &_dl_phdr[_dl_phnum]; ++ph)
-    switch (ph->p_type)
-      {
-      /* Check if the stack is nonexecutable.  */
-      case PT_GNU_STACK:
-	_dl_stack_flags = ph->p_flags;
-	break;
-
-      case PT_GNU_RELRO:
-	_dl_main_map.l_relro_addr = ph->p_vaddr;
-	_dl_main_map.l_relro_size = ph->p_memsz;
-	break;
-      }
-
-  call_function_static_weak (_dl_find_object_init);
-
-  /* Setup relro on the binary itself.  */
-  if (_dl_main_map.l_relro_size != 0)
-    _dl_protect_relro (&_dl_main_map);
-}
 
 #ifdef DL_SYSINFO_IMPLEMENTATION
 DL_SYSINFO_IMPLEMENTATION
diff --git a/elf/dl-tls_init_tp.c b/elf/dl-tls_init_tp.c
index f180d16b5010..656a91ff87f8 100644
--- a/elf/dl-tls_init_tp.c
+++ b/elf/dl-tls_init_tp.c
@@ -18,35 +18,6 @@
 
 #include <ldsodefs.h>
 
-#if defined SHARED && defined _LIBC_REENTRANT \
-    && defined __rtld_lock_default_lock_recursive
-static void
-rtld_lock_default_lock_recursive (void *lock)
-{
-  __rtld_lock_default_lock_recursive (lock);
-}
-
-static void
-rtld_lock_default_unlock_recursive (void *lock)
-{
-  __rtld_lock_default_unlock_recursive (lock);
-}
-#endif
-
-void
-__tls_pre_init_tp (void)
-{
-#if !PTHREAD_IN_LIBC
-  GL(dl_init_static_tls) = &_dl_nothread_init_static_tls;
-#endif
-
-#if defined SHARED && defined _LIBC_REENTRANT \
-    && defined __rtld_lock_default_lock_recursive
-  GL(dl_rtld_lock_recursive) = rtld_lock_default_lock_recursive;
-  GL(dl_rtld_unlock_recursive) = rtld_lock_default_unlock_recursive;
-#endif
-}
-
 void
 __tls_init_tp (void)
 {
diff --git a/elf/dl-tunables.c b/elf/dl-tunables.c
index 147cc4cf23f5..4027549620ff 100644
--- a/elf/dl-tunables.c
+++ b/elf/dl-tunables.c
@@ -33,6 +33,7 @@
 #include <array_length.h>
 #include <dl-minimal-malloc.h>
 #include <dl-symbol-redir-ifunc.h>
+#include <stdfil.h>
 
 #define TUNABLES_INTERNAL 1
 #include "dl-tunables.h"
@@ -123,7 +124,7 @@ static bool
 tunable_parse_num (const char *strval, size_t len, tunable_num_t *val)
 {
   char *endptr = NULL;
-  uint64_t numval = _dl_strtoul (strval, &endptr);
+  uint64_t numval = strtoul (strval, &endptr, 10);
   if (endptr != strval + len)
     return false;
   *val = (tunable_num_t) numval;
@@ -242,11 +243,11 @@ parse_tunables_string (const char *valstring, struct tunable_toset_t *tunables)
 static void
 parse_tunable_print_error (const struct tunable_toset_t *toset)
 {
-  _dl_error_printf ("WARNING: ld.so: invalid GLIBC_TUNABLES value `%.*s' "
-		    "for option `%s': ignored.\n",
-		    (int) toset->len,
-		    toset->value,
-		    toset->t->name);
+  zprintf ("WARNING: libc: invalid GLIBC_TUNABLES value `%.*s' "
+           "for option `%s': ignored.\n",
+           (int) toset->len,
+           toset->value,
+           toset->t->name);
 }
 
 static void
@@ -255,8 +256,8 @@ parse_tunables (const char *valstring)
   struct tunable_toset_t tunables[tunables_list_size] = { 0 };
   if (parse_tunables_string (valstring, tunables) == -1)
     {
-      _dl_error_printf (
-        "WARNING: ld.so: invalid GLIBC_TUNABLES `%s': ignored.\n", valstring);
+      zprintf (
+        "WARNING: libc: invalid GLIBC_TUNABLES `%s': ignored.\n", valstring);
       return;
     }
 
@@ -362,34 +363,34 @@ __tunables_print (void)
       const tunable_t *cur = &tunable_list[i];
       if (cur->type.type_code == TUNABLE_TYPE_STRING
 	  && cur->val.strval.str == NULL)
-	_dl_printf ("%s:\n", cur->name);
+       zprintf ("%s:\n", cur->name);
       else
 	{
-	  _dl_printf ("%s: ", cur->name);
+	  zprintf ("%s: ", cur->name);
 	  switch (cur->type.type_code)
 	    {
 	    case TUNABLE_TYPE_INT_32:
-	      _dl_printf ("%d (min: %d, max: %d)\n",
-			  (int) cur->val.numval,
-			  (int) cur->type.min,
-			  (int) cur->type.max);
+	      zprintf ("%d (min: %d, max: %d)\n",
+                       (int) cur->val.numval,
+                       (int) cur->type.min,
+                       (int) cur->type.max);
 	      break;
 	    case TUNABLE_TYPE_UINT_64:
-	      _dl_printf ("0x%lx (min: 0x%lx, max: 0x%lx)\n",
-			  (long int) cur->val.numval,
-			  (long int) cur->type.min,
-			  (long int) cur->type.max);
+	      zprintf ("0x%lx (min: 0x%lx, max: 0x%lx)\n",
+                       (long int) cur->val.numval,
+                       (long int) cur->type.min,
+                       (long int) cur->type.max);
 	      break;
 	    case TUNABLE_TYPE_SIZE_T:
-	      _dl_printf ("0x%zx (min: 0x%zx, max: 0x%zx)\n",
-			  (size_t) cur->val.numval,
-			  (size_t) cur->type.min,
-			  (size_t) cur->type.max);
+	      zprintf ("0x%zx (min: 0x%zx, max: 0x%zx)\n",
+                       (size_t) cur->val.numval,
+                       (size_t) cur->type.min,
+                       (size_t) cur->type.max);
 	      break;
 	    case TUNABLE_TYPE_STRING:
-	      _dl_printf ("%.*s\n",
-			  (int) cur->val.strval.len,
-			  cur->val.strval.str);
+	      zprintf ("%.*s\n",
+                       (int) cur->val.strval.len,
+                       cur->val.strval.str);
 	      break;
 	    default:
 	      __builtin_unreachable ();
diff --git a/gmon/gmon.c b/gmon/gmon.c
index 996b6a62a4a6..208bfc065abc 100644
--- a/gmon/gmon.c
+++ b/gmon/gmon.c
@@ -422,9 +422,6 @@ write_gmon (void)
 
     /* Get load_address to profile PIE.  */
     u_long load_address = 0;
-#ifdef PIC
-    __dl_iterate_phdr (callback, &load_address);
-#endif
 
     /* write PC histogram: */
     write_hist (fd, load_address);
diff --git a/iconv/loop.c b/iconv/loop.c
index 5340dafc709f..ec3f51c56af2 100644
--- a/iconv/loop.c
+++ b/iconv/loop.c
@@ -57,6 +57,8 @@
 #include <stddef.h>
 #include <libc-diag.h>
 
+#pragma clang diagnostic ignored "-Wstring-plus-int"
+
 #undef FCTNAME2
 #define FCTNAME(name) name
 
diff --git a/iconvdata/8bit-gap.c b/iconvdata/8bit-gap.c
index 8eb328b4b7a8..dd372e508107 100644
--- a/iconvdata/8bit-gap.c
+++ b/iconvdata/8bit-gap.c
@@ -20,6 +20,8 @@
 #include <dlfcn.h>
 #include <stdint.h>
 
+#pragma clang diagnostic ignored "-Wgnu-designator"
+
 struct gap
 {
   uint16_t start;
diff --git a/include/alloc_buffer.h b/include/alloc_buffer.h
index 888b976d376c..2f31275bc185 100644
--- a/include/alloc_buffer.h
+++ b/include/alloc_buffer.h
@@ -101,8 +101,8 @@ struct alloc_buffer
      avoid issues undefined subtractions if the buffer covers more
      than half of the address space (which would result in differences
      which could not be represented as a ptrdiff_t value).  */
-  uintptr_t __alloc_buffer_current;
-  uintptr_t __alloc_buffer_end;
+  char* __alloc_buffer_current;
+  char* __alloc_buffer_end;
 };
 
 enum
@@ -125,8 +125,8 @@ libc_hidden_proto (__libc_alloc_buffer_create_failure)
 static inline struct alloc_buffer
 alloc_buffer_create (void *start, size_t size)
 {
-  uintptr_t current = (uintptr_t) start;
-  uintptr_t end = (uintptr_t) start + size;
+  char *current = (char *) start;
+  char *end = (char *) start + size;
   if (end < current)
     __libc_alloc_buffer_create_failure (start, size);
   return (struct alloc_buffer) { current, end };
@@ -153,8 +153,8 @@ struct alloc_buffer alloc_buffer_allocate (size_t size, void **pptr)
 static inline void __attribute__ ((nonnull (1)))
 alloc_buffer_mark_failed (struct alloc_buffer *buf)
 {
-  buf->__alloc_buffer_current = __ALLOC_BUFFER_INVALID_POINTER;
-  buf->__alloc_buffer_end = __ALLOC_BUFFER_INVALID_POINTER;
+  buf->__alloc_buffer_current = (char*)__ALLOC_BUFFER_INVALID_POINTER;
+  buf->__alloc_buffer_end = (char*)__ALLOC_BUFFER_INVALID_POINTER;
 }
 
 /* Return the remaining number of bytes in the buffer.  */
@@ -168,7 +168,7 @@ alloc_buffer_size (const struct alloc_buffer *buf)
 static inline bool __attribute__ ((nonnull (1)))
 alloc_buffer_has_failed (const struct alloc_buffer *buf)
 {
-  return buf->__alloc_buffer_current == __ALLOC_BUFFER_INVALID_POINTER;
+  return buf->__alloc_buffer_current == (char*)__ALLOC_BUFFER_INVALID_POINTER;
 }
 
 /* Add a single byte to the buffer (consuming the space for this
@@ -254,11 +254,11 @@ __alloc_buffer_alloc (struct alloc_buffer *buf, size_t size, size_t align)
   if (size == 1 && align == 1)
     return alloc_buffer_alloc_bytes (buf, size);
 
-  uintptr_t current = buf->__alloc_buffer_current;
-  uintptr_t aligned = roundup (current, align);
-  uintptr_t new_current = aligned + size;
+  char *current = buf->__alloc_buffer_current;
+  char *aligned = (char *) roundup ((uintptr_t) current, align);
+  char *new_current = aligned + size;
   if (aligned >= current        /* No overflow in align step.  */
-      && new_current >= size    /* No overflow in size computation.  */
+      && new_current >= (char *) size    /* No overflow in size computation.  */
       && new_current <= buf->__alloc_buffer_end) /* Room in buffer.  */
     {
       buf->__alloc_buffer_current = new_current;
@@ -288,8 +288,8 @@ __alloc_buffer_next (struct alloc_buffer *buf, size_t align)
   if (align == 1)
     return (const void *) buf->__alloc_buffer_current;
 
-  uintptr_t current = buf->__alloc_buffer_current;
-  uintptr_t aligned = roundup (current, align);
+  char *current = buf->__alloc_buffer_current;
+  char *aligned = (char *) roundup ((uintptr_t) current, align);
   if (aligned >= current        /* No overflow in align step.  */
       && aligned <= buf->__alloc_buffer_end) /* Room in buffer.  */
     {
diff --git a/include/dlfcn.h b/include/dlfcn.h
index f49ee1b0c995..1d88bd47b96f 100644
--- a/include/dlfcn.h
+++ b/include/dlfcn.h
@@ -49,7 +49,7 @@ extern char **__libc_argv attribute_hidden;
    RTLD_LAZY is not a big difference in performance, but RTLD_NOW has
    better error handling semantics for the library.  */
 #define __libc_dlopen(name) \
-  __libc_dlopen_mode (name, RTLD_NOW | __RTLD_DLOPEN)
+  __libc_dlopen_mode (name, RTLD_NOW)
 extern void *__libc_dlopen_mode  (const char *__name, int __mode)
   attribute_hidden;
 extern void *__libc_dlsym   (void *__map, const char *__name)
@@ -88,12 +88,6 @@ extern void *_dl_sym (void *handle, const char *name, void *who)
 extern void *_dl_vsym (void *handle, const char *name, const char *version,
 		       void *who) attribute_hidden;
 
-/* Helper function for <dlfcn.h> functions.  Runs the OPERATE function via
-   _dl_catch_error.  Returns zero for success, nonzero for failure; and
-   arranges for `dlerror' to return the error details.
-   ARGS is passed as argument to OPERATE.  */
-extern int _dlerror_run (void (*operate) (void *), void *args) attribute_hidden;
-
 /* This structure is used to make the outer (statically linked)
    implementation of dlopen and related functions to the inner libc
    after static dlopen, via the GLRO (dl_dlfcn_hook) pointer.  */
diff --git a/include/libc-symbols.h b/include/libc-symbols.h
index 4367aa6740bf..2c24993009e2 100644
--- a/include/libc-symbols.h
+++ b/include/libc-symbols.h
@@ -20,6 +20,8 @@
 #ifndef _LIBC_SYMBOLS_H
 #define _LIBC_SYMBOLS_H	1
 
+#pragma clang diagnostic ignored "-Wunused-function"
+
 /* This file is included implicitly in the compilation of every source file,
    using -include.  It includes config.h.  */
 
@@ -215,26 +217,17 @@
 #else
 # define __sec_comment "\n\t#"
 #endif
-#define link_warning(symbol, msg) \
-  __make_section_unallocated (".gnu.warning." #symbol) \
-  static const char __evoke_link_warning_##symbol[]	\
-    __attribute__ ((used, section (".gnu.warning." #symbol __sec_comment))) \
-    = msg;
+#define link_warning(symbol, msg)
 
 /* A canned warning for sysdeps/stub functions.  */
-#define	stub_warning(name) \
-  __make_section_unallocated (".gnu.glibc-stub." #name) \
-  link_warning (name, #name " is not implemented and will always fail")
+#define	stub_warning(name)
 
 /* Warning for linking functions calling dlopen into static binaries.  */
 #ifdef SHARED
 #define static_link_warning(name)
 #else
 #define static_link_warning(name) static_link_warning1(name)
-#define static_link_warning1(name) \
-  link_warning(name, "Using '" #name "' in statically linked applications \
-requires at runtime the shared libraries from the glibc version used \
-for linking")
+#define static_link_warning1(name)
 #endif
 
 /* Declare SYMBOL to be TYPE (`function' or `object') of SIZE bytes
@@ -251,19 +244,8 @@ for linking")
    .type C_SYMBOL_NAME (symbol), %object ASM_LINE_SEP \
    .size C_SYMBOL_NAME (symbol), s_size ASM_LINE_SEP
 #else /* Not __ASSEMBLER__.  */
-# ifdef HAVE_ASM_SET_DIRECTIVE
-#  define declare_object_symbol_alias_1(symbol, original, size) \
-     asm (".global " __SYMBOL_PREFIX # symbol "\n" \
-	  ".type " __SYMBOL_PREFIX # symbol ", %object\n" \
-	  ".set " __SYMBOL_PREFIX #symbol ", " __SYMBOL_PREFIX original "\n" \
-	  ".size " __SYMBOL_PREFIX #symbol ", " #size "\n");
-# else
-#  define declare_object_symbol_alias_1(symbol, original, size) \
-     asm (".global " __SYMBOL_PREFIX # symbol "\n" \
-	  ".type " __SYMBOL_PREFIX # symbol ", %object\n" \
-	  __SYMBOL_PREFIX #symbol " = " __SYMBOL_PREFIX original "\n" \
-	  ".size " __SYMBOL_PREFIX #symbol ", " #size "\n");
-# endif /* HAVE_ASM_SET_DIRECTIVE */
+# define declare_object_symbol_alias_1(symbol, original, size) \
+     asm (".filc_alias " __SYMBOL_PREFIX original ", " __SYMBOL_PREFIX #symbol);
 #endif /* __ASSEMBLER__ */
 
 
@@ -364,12 +346,7 @@ for linking")
 
 /* Used to disable stack protection in sensitive places, like ifunc
    resolvers and early static TLS init.  */
-#ifdef HAVE_CC_NO_STACK_PROTECTOR
-# define inhibit_stack_protector \
-    __attribute__ ((__optimize__ ("-fno-stack-protector")))
-#else
-# define inhibit_stack_protector
-#endif
+#define inhibit_stack_protector
 
 /* The following macros are used for PLT bypassing within libc.so
    (and if needed other libraries similarly).
@@ -453,46 +430,38 @@ for linking")
   __hidden_proto (name, , __GI_##name, ##attrs)
 #  define hidden_proto_alias(name, alias, attrs...) \
   __hidden_proto_alias (name, , alias, ##attrs)
-#  define hidden_tls_proto(name, attrs...) \
-  __hidden_proto (name, __thread, __GI_##name, ##attrs)
+#  define hidden_tls_proto_not_implemented(name, attrs...) /* I don't think I'll need this. */
 #  define __hidden_proto(name, thread, internal, attrs...)	     \
-  extern thread __typeof (name) name __asm__ (__hidden_asmname (#internal)) \
-  __hidden_proto_hiddenattr (attrs);
+  __asm(".filc_rename " #name ", " __hidden_asmname (#internal));
 #  define __hidden_proto_alias(name, thread, internal, attrs...)	     \
   extern thread __typeof (name) internal __hidden_proto_hiddenattr (attrs);
 #  define __hidden_asmname(name) \
   __hidden_asmname1 (__USER_LABEL_PREFIX__, name)
 #  define __hidden_asmname1(prefix, name) __hidden_asmname2(prefix, name)
 #  define __hidden_asmname2(prefix, name) #prefix name
-#  define __hidden_ver1(local, internal, name) \
-  __hidden_ver2 (, local, internal, name)
-#  define __hidden_ver2(thread, local, internal, name)			\
-  extern thread __typeof (name) __EI_##name \
-    __asm__(__hidden_asmname (#internal));  \
-  extern thread __typeof (name) __EI_##name \
-    __attribute__((alias (__hidden_asmname (#local))))	\
-    __attribute_copy__ (name)
-#  define hidden_ver(local, name)	__hidden_ver1(local, __GI_##name, name);
-#  define hidden_def(name)		__hidden_ver1(__GI_##name, name, name);
+#  define __hidden_ver1(local, internal, name, weak) \
+  __hidden_ver2 (, local, internal, name, weak)
+#  define __hidden_ver2(thread, local, internal, name, weak)			\
+  __asm(".filc_" weak "alias " __hidden_asmname (#local) ", " __hidden_asmname (#internal))
+#  define hidden_ver(local, name)	__hidden_ver1(local, __GI_##name, name, "");
+#  define hidden_def(name)		__hidden_ver1(__GI_##name, name, name, "");
 #  define hidden_def_alias(name, internal) \
   strong_alias (name, internal)
 #  define hidden_data_def(name)		hidden_def(name)
 #  define hidden_data_def_alias(name, alias) hidden_def_alias(name, alias)
-#  define hidden_tls_def(name)				\
-  __hidden_ver2 (__thread, __GI_##name, name, name);
+#  define hidden_tls_def_not_implemented(name) /* I don't think I'll need this. */
 #  define hidden_weak(name) \
-	__hidden_ver1(__GI_##name, name, name) __attribute__((weak));
+  __hidden_ver1(__GI_##name, name, name, "weak_");
 #  define hidden_data_weak(name)	hidden_weak(name)
 #  define hidden_nolink(name, lib, version) \
   __hidden_nolink1 (__GI_##name, __EI_##name, name, VERSION_##lib##_##version)
 #  define __hidden_nolink1(local, internal, name, version) \
   __hidden_nolink2 (local, internal, name, version)
 #  define __hidden_nolink2(local, internal, name, version) \
-  extern __typeof (name) internal __attribute__ ((alias (#local)))	\
-    __attribute_copy__ (name);						\
+  __asm(".filc_alias " #local ", " #internal); \
   __hidden_nolink3 (local, internal, #name "@" #version)
 #  define __hidden_nolink3(local, internal, vername) \
-  __asm__ (".symver " #internal ", " vername);
+  __asm(".filc_symver " #internal ", " vername);
 # else
 /* For assembly, we need to do the opposite of what we do in C:
    in assembly gcc __REDIRECT stuff is not in place, so functions
@@ -677,14 +646,15 @@ for linking")
   }
 
 #ifdef HAVE_GCC_IFUNC
-# define __ifunc_args(type_name, name, expr, init, ...)			\
-  extern __typeof (type_name) name __attribute__			\
-			      ((ifunc (#name "_ifunc")));		\
+# define __ifunc_args(type_name, name, expr, init, ...)                        \
+  extern __typeof (type_name) name __attribute__                       \
+                             ((ifunc (#name "_ifunc")));               \
   __ifunc_resolver (type_name, name, expr, init, static, __VA_ARGS__)
 
 # define __ifunc_args_hidden(type_name, name, expr, init, ...)		\
   __ifunc_args (type_name, name, expr, init, __VA_ARGS__)
 #else
+#error "DO NOT have GCC ifunc"
 /* Gcc does not support __attribute__ ((ifunc (...))).  Use the old behaviour
    as fallback.  But keep in mind that the debug information for the ifunc
    resolver functions is not correct.  It contains the ifunc'ed function as
@@ -808,13 +778,8 @@ for linking")
 /* Add the compiler optimization to inhibit loop transformation to library
    calls.  This is used to avoid recursive calls in memset and memmove
    default implementations.  */
-#ifdef HAVE_CC_INHIBIT_LOOP_TO_LIBCALL
-# define inhibit_loop_to_libcall \
-    __attribute__ ((__optimize__ ("-fno-tree-loop-distribute-patterns")))
-#else
-# define inhibit_loop_to_libcall
-#endif
-
+#define inhibit_loop_to_libcall
+
 /* These macros facilitate sharing source files with gnulib.
 
    They are here instead of sys/cdefs.h because they should not be
diff --git a/include/setjmp.h b/include/setjmp.h
index d2353be71bdc..554c0dc20ac0 100644
--- a/include/setjmp.h
+++ b/include/setjmp.h
@@ -1,44 +1,9 @@
 #ifndef _SETJMP_H
 #include <setjmp/setjmp.h>
 
-#ifndef _ISOMAC
-/* Now define the internal interfaces.  */
-
-/* Internal machine-dependent function to restore context sans signal mask.  */
-extern void __longjmp (__jmp_buf __env, int __val)
-     __attribute__ ((__noreturn__)) attribute_hidden;
-
-extern void ____longjmp_chk (__jmp_buf __env, int __val)
-     __attribute__ ((__noreturn__)) attribute_hidden;
-
-extern void __longjmp_chk (sigjmp_buf env, int val)
-	  __attribute__ ((noreturn)) attribute_hidden;
-/* The redirection in the installed header does not work with
-   libc_hidden_proto.  */
-#define longjmp __longjmp_chk
-#define siglongjmp __longjmp_chk
-libc_hidden_proto (__longjmp_chk)
-
-/* Internal function to possibly save the current mask of blocked signals
-   in ENV, and always set the flag saying whether or not it was saved.
-   This is used by the machine-dependent definition of `__sigsetjmp'.
-   Always returns zero, for convenience.  */
-extern int __sigjmp_save (jmp_buf __env, int __savemask);
-
-extern void _longjmp_unwind (jmp_buf env, int val);
-
 extern void __libc_siglongjmp (sigjmp_buf env, int val)
 	  __attribute__ ((noreturn)) attribute_hidden;
 extern void __libc_longjmp (sigjmp_buf env, int val)
      __attribute__ ((noreturn)) attribute_hidden;
 
-libc_hidden_proto (_setjmp)
-libc_hidden_proto (__sigsetjmp)
-
-# if IS_IN (rtld)
-extern __typeof (__sigsetjmp) __sigsetjmp attribute_hidden;
-# endif
-
-#endif
-
 #endif
diff --git a/include/unistd.h b/include/unistd.h
index e241603b8131..6401fd932160 100644
--- a/include/unistd.h
+++ b/include/unistd.h
@@ -145,8 +145,6 @@ libc_hidden_proto (__getresuid)
 libc_hidden_proto (__getresgid)
 libc_hidden_proto (__setresuid)
 libc_hidden_proto (__setresgid)
-extern __pid_t __vfork (void);
-libc_hidden_proto (__vfork)
 extern int __ttyname_r (int __fd, char *__buf, size_t __buflen);
 libc_hidden_proto (__ttyname_r)
 extern __pid_t _Fork (void);
diff --git a/inet/net-internal.h b/inet/net-internal.h
index f5749a86629e..5c6239972099 100644
--- a/inet/net-internal.h
+++ b/inet/net-internal.h
@@ -105,8 +105,6 @@ __deadline_is_infinite (struct deadline deadline)
  * A GCC bug has been filed here:
  *    https://gcc.gnu.org/bugzilla/show_bug.cgi?id=91691
  */
-DIAG_PUSH_NEEDS_COMMENT;
-DIAG_IGNORE_NEEDS_COMMENT (9, "-Wmaybe-uninitialized");
 
 /* Return true if the current time is at the deadline or past it.  */
 static inline bool
@@ -132,8 +130,6 @@ __deadline_first (struct deadline left, struct deadline right)
     return right;
 }
 
-DIAG_POP_NEEDS_COMMENT;
-
 /* Add TV to the current time and return it.  Returns a special
    infinite absolute deadline on overflow.  */
 struct deadline __deadline_from_timeval (struct deadline_current_time,
diff --git a/intl/localealias.c b/intl/localealias.c
index 446b38b4d1ea..59e26eb2e692 100644
--- a/intl/localealias.c
+++ b/intl/localealias.c
@@ -338,6 +338,8 @@ read_alias_file (const char *fname, int fname_len)
 			    {
 			      map[i].alias += new_pool - string_space;
 			      map[i].value += new_pool - string_space;
+                              map[i].alias = zmkptr (new_pool, (uintptr_t) map[i].alias);
+                              map[i].value = zmkptr (new_pool, (uintptr_t) map[i].value);
 			    }
 			}
 
diff --git a/libio/libioP.h b/libio/libioP.h
index 616253fcd00f..d88325d3efb2 100644
--- a/libio/libioP.h
+++ b/libio/libioP.h
@@ -528,7 +528,7 @@ extern const struct _IO_jump_t __io_vtables[] attribute_hidden;
 #ifdef SHARED
 # define libio_static_fn_required(name)
 #else
-# define libio_static_fn_required(name) __asm (".globl " #name);
+# define libio_static_fn_required(name) __asm (".filc_globl " #name);
 #endif
 
 extern int _IO_do_write (FILE *, const char *, size_t);
diff --git a/libio/vtables.c b/libio/vtables.c
index 8a2c726bf5b4..353f2314a147 100644
--- a/libio/vtables.c
+++ b/libio/vtables.c
@@ -503,34 +503,6 @@ void (*IO_accept_foreign_vtables) (void) attribute_hidden;
 void attribute_hidden
 _IO_vtable_check (void)
 {
-#ifdef SHARED
-  /* Honor the compatibility flag.  */
-  void (*flag) (void) = atomic_load_relaxed (&IO_accept_foreign_vtables);
-  PTR_DEMANGLE (flag);
-  if (flag == &_IO_vtable_check)
-    return;
-
-  /* In case this libc copy is in a non-default namespace, we always
-     need to accept foreign vtables because there is always a
-     possibility that FILE * objects are passed across the linking
-     boundary.  */
-  {
-    Dl_info di;
-    struct link_map *l;
-    if (!rtld_active ()
-        || (_dl_addr (_IO_vtable_check, &di, &l, NULL) != 0
-            && l->l_ns != LM_ID_BASE))
-      return;
-  }
-
-#else /* !SHARED */
-  /* We cannot perform vtable validation in the static dlopen case
-     because FILE * handles might be passed back and forth across the
-     boundary.  Therefore, we disable checking in this case.  */
-  if (__dlopen != NULL)
-    return;
-#endif
-
   __libc_fatal ("Fatal error: glibc detected an invalid stdio handle\n");
 }
 
diff --git a/locale/lc-ctype.c b/locale/lc-ctype.c
index c77ec51cb89b..309e56700f59 100644
--- a/locale/lc-ctype.c
+++ b/locale/lc-ctype.c
@@ -27,6 +27,36 @@ _NL_CURRENT_DEFINE (LC_CTYPE);
    the variables used by the ctype.h macros.  */
 
 
+#include <shlib-compat.h>
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_3)
+  /* We must use the exported names to access these so we are sure to
+     be accessing the main executable's copy if it has COPY relocs.  */
+
+  extern const unsigned short int *__ctype_b; /* Characteristics.  */
+  extern const __int32_t *__ctype_tolower; /* Case conversions.  */
+  extern const __int32_t *__ctype_toupper; /* Case conversions.  */
+
+  extern const uint32_t *__ctype32_b;
+  extern const uint32_t *__ctype32_toupper;
+  extern const uint32_t *__ctype32_tolower;
+
+  /* We need the .symver declarations these macros generate so that
+     our references are explicitly bound to the versioned symbol names
+     rather than the unadorned names that are not exported.  When the
+     linker sees these bound to local symbols (as the unexported names are)
+     then it doesn't generate a proper relocation to the global symbols.
+     We need those relocations so that a versioned definition with a COPY
+     reloc in an executable will override the libc.so definition.  */
+
+compat_symbol_reference (libc, __ctype_b, __ctype_b, GLIBC_2_0);
+compat_symbol_reference (libc, __ctype_tolower, __ctype_tolower, GLIBC_2_0);
+compat_symbol_reference (libc, __ctype_toupper, __ctype_toupper, GLIBC_2_0);
+compat_symbol_reference (libc, __ctype32_b, __ctype32_b, GLIBC_2_0);
+compat_symbol_reference (libc, __ctype32_tolower, __ctype32_tolower,
+			  GLIBC_2_2);
+compat_symbol_reference (libc, __ctype32_toupper, __ctype32_toupper,
+			 GLIBC_2_2);
+#endif
 
 void
 _nl_postload_ctype (void)
@@ -72,36 +102,7 @@ _nl_postload_ctype (void)
 		      (void *) _nl_global_locale.__ctype_tolower);
     }
 
-#include <shlib-compat.h>
 #if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_3)
-  /* We must use the exported names to access these so we are sure to
-     be accessing the main executable's copy if it has COPY relocs.  */
-
-  extern const unsigned short int *__ctype_b; /* Characteristics.  */
-  extern const __int32_t *__ctype_tolower; /* Case conversions.  */
-  extern const __int32_t *__ctype_toupper; /* Case conversions.  */
-
-  extern const uint32_t *__ctype32_b;
-  extern const uint32_t *__ctype32_toupper;
-  extern const uint32_t *__ctype32_tolower;
-
-  /* We need the .symver declarations these macros generate so that
-     our references are explicitly bound to the versioned symbol names
-     rather than the unadorned names that are not exported.  When the
-     linker sees these bound to local symbols (as the unexported names are)
-     then it doesn't generate a proper relocation to the global symbols.
-     We need those relocations so that a versioned definition with a COPY
-     reloc in an executable will override the libc.so definition.  */
-
-compat_symbol_reference (libc, __ctype_b, __ctype_b, GLIBC_2_0);
-compat_symbol_reference (libc, __ctype_tolower, __ctype_tolower, GLIBC_2_0);
-compat_symbol_reference (libc, __ctype_toupper, __ctype_toupper, GLIBC_2_0);
-compat_symbol_reference (libc, __ctype32_b, __ctype32_b, GLIBC_2_0);
-compat_symbol_reference (libc, __ctype32_tolower, __ctype32_tolower,
-			  GLIBC_2_2);
-compat_symbol_reference (libc, __ctype32_toupper, __ctype32_toupper,
-			 GLIBC_2_2);
-
   __ctype_b = current (uint16_t, CLASS, 128);
   __ctype_toupper = current (int32_t, TOUPPER, 128);
   __ctype_tolower = current (int32_t, TOLOWER, 128);
diff --git a/locale/localeinfo.h b/locale/localeinfo.h
index ed698faef1b3..265706a3fe65 100644
--- a/locale/localeinfo.h
+++ b/locale/localeinfo.h
@@ -283,19 +283,11 @@ extern __thread struct __locale_data *const *_nl_current_##category \
   ((uint32_t) (*_nl_current_##category)->values[_NL_ITEM_INDEX (item)].word)
 
 /* This is used in lc-CATEGORY.c to define _nl_current_CATEGORY.  The symbol
-   _nl_current_CATEGORY_used is set to a value unequal to zero to mark this
-   category as used.  On S390 the used relocation to load the symbol address
-   can only handle even addresses.  */
+   _nl_current_CATEGORY_used is defined to mark this category as used. */
 #define _NL_CURRENT_DEFINE(category) \
   __thread struct __locale_data *const *_nl_current_##category \
     attribute_hidden = &_nl_global_locale.__locales[category]; \
-  asm (".globl " __SYMBOL_PREFIX "_nl_current_" #category "_used\n" \
-       _NL_CURRENT_DEFINE_ABS (_nl_current_##category##_used, 2));
-#ifdef HAVE_ASM_SET_DIRECTIVE
-# define _NL_CURRENT_DEFINE_ABS(sym, val) ".set " #sym ", " #val
-#else
-# define _NL_CURRENT_DEFINE_ABS(sym, val) #sym " = " #val
-#endif
+  char _nl_current_##category##_used;
 
 #else
 
diff --git a/locale/programs/ld-collate.c b/locale/programs/ld-collate.c
index 5048adbd9f03..4d7ce4dd4bda 100644
--- a/locale/programs/ld-collate.c
+++ b/locale/programs/ld-collate.c
@@ -1821,7 +1821,7 @@ symbol `%s' has the same encoding as"), (*eptr)->name);
 
   /* Now determine whether the UNDEFINED entry is needed and if yes,
      whether it was defined.  */
-  collate->undefined.used_in_level = need_undefined ? ~0ul : 0;
+  collate->undefined.used_in_level = need_undefined ? ~0u : 0;
   if (collate->undefined.file == NULL)
     {
       if (need_undefined)
diff --git a/malloc/Makefile b/malloc/Makefile
index 98d507a6eb61..e3d5074180c3 100644
--- a/malloc/Makefile
+++ b/malloc/Makefile
@@ -195,7 +195,7 @@ install-lib := libmcheck.a
 non-lib.a := libmcheck.a
 
 # Additional libraries.
-extra-libs = libmemusage libc_malloc_debug
+extra-libs = 
 extra-libs-others = $(extra-libs)
 
 # Helper objects for some tests.
diff --git a/malloc/alloc_buffer_alloc_array.c b/malloc/alloc_buffer_alloc_array.c
index 31cb9ec6a49f..3abf6e5cbeed 100644
--- a/malloc/alloc_buffer_alloc_array.c
+++ b/malloc/alloc_buffer_alloc_array.c
@@ -23,15 +23,15 @@ void *
 __libc_alloc_buffer_alloc_array (struct alloc_buffer *buf, size_t element_size,
                                  size_t align, size_t count)
 {
-  uintptr_t current = buf->__alloc_buffer_current;
+  char *current = buf->__alloc_buffer_current;
   /* The caller asserts that align is a power of two.  */
-  uintptr_t aligned = ALIGN_UP (current, align);
+  char *aligned = (char *) ALIGN_UP ((uintptr_t) current, align);
   size_t size;
   bool overflow = __builtin_mul_overflow (element_size, count, &size);
-  uintptr_t new_current = aligned + size;
+  char *new_current = aligned + size;
   if (!overflow                /* Multiplication did not overflow.  */
       && aligned >= current    /* No overflow in align step.  */
-      && new_current >= size   /* No overflow in size computation.  */
+      && new_current >= (char *) size   /* No overflow in size computation.  */
       && new_current <= buf->__alloc_buffer_end) /* Room in buffer.  */
     {
       buf->__alloc_buffer_current = new_current;
diff --git a/malloc/alloc_buffer_allocate.c b/malloc/alloc_buffer_allocate.c
index a121d1d02efe..aba29dce4203 100644
--- a/malloc/alloc_buffer_allocate.c
+++ b/malloc/alloc_buffer_allocate.c
@@ -27,8 +27,8 @@ __libc_alloc_buffer_allocate (size_t size, void **pptr)
   if (*pptr == NULL)
     return (struct alloc_buffer)
       {
-        .__alloc_buffer_current = __ALLOC_BUFFER_INVALID_POINTER,
-        .__alloc_buffer_end = __ALLOC_BUFFER_INVALID_POINTER
+          .__alloc_buffer_current = (char *) __ALLOC_BUFFER_INVALID_POINTER,
+          .__alloc_buffer_end = (char *) __ALLOC_BUFFER_INVALID_POINTER
       };
   else
     return alloc_buffer_create (*pptr, size);
diff --git a/malloc/malloc.c b/malloc/malloc.c
index bcb6e5b83ca9..8c059ed7e6ef 100644
--- a/malloc/malloc.c
+++ b/malloc/malloc.c
@@ -3292,6 +3292,9 @@ tcache_thread_shutdown (void)
 void *
 __libc_malloc (size_t bytes)
 {
+  if ((true))
+    return zgc_alloc(bytes);
+  
   mstate ar_ptr;
   void *victim;
 
@@ -3357,6 +3360,11 @@ libc_hidden_def (__libc_malloc)
 void
 __libc_free (void *mem)
 {
+  if ((true)) {
+    zgc_free(mem);
+    return;
+  }
+  
   mstate ar_ptr;
   mchunkptr p;                          /* chunk corresponding to mem */
 
@@ -3405,6 +3413,9 @@ libc_hidden_def (__libc_free)
 void *
 __libc_realloc (void *oldmem, size_t bytes)
 {
+  if ((true))
+    return zgc_realloc(oldmem, bytes);
+  
   mstate ar_ptr;
   INTERNAL_SIZE_T nb;         /* padded request size */
 
@@ -3541,6 +3552,9 @@ libc_hidden_def (__libc_realloc)
 void *
 __libc_memalign (size_t alignment, size_t bytes)
 {
+  if ((true))
+    return zgc_aligned_alloc(alignment, bytes);
+  
   if (!__malloc_initialized)
     ptmalloc_init ();
 
@@ -3554,6 +3568,9 @@ void *
 weak_function
 aligned_alloc (size_t alignment, size_t bytes)
 {
+  if ((true))
+    return zgc_aligned_alloc(alignment, bytes);
+  
   if (!__malloc_initialized)
     ptmalloc_init ();
 
@@ -3664,22 +3681,30 @@ _mid_memalign (size_t alignment, size_t bytes, void *address)
 void *
 __libc_valloc (size_t bytes)
 {
+  size_t pagesize = GLRO (dl_pagesize);
+
+  if ((true))
+    return zgc_aligned_alloc(pagesize, bytes);
+  
   if (!__malloc_initialized)
     ptmalloc_init ();
 
   void *address = RETURN_ADDRESS (0);
-  size_t pagesize = GLRO (dl_pagesize);
   return _mid_memalign (pagesize, bytes, address);
 }
 
 void *
 __libc_pvalloc (size_t bytes)
 {
+  size_t pagesize = GLRO (dl_pagesize);
+
+  if ((true))
+    return zgc_aligned_alloc(pagesize, bytes);
+  
   if (!__malloc_initialized)
     ptmalloc_init ();
 
   void *address = RETURN_ADDRESS (0);
-  size_t pagesize = GLRO (dl_pagesize);
   size_t rounded_bytes;
   /* ALIGN_UP with overflow check.  */
   if (__glibc_unlikely (__builtin_add_overflow (bytes,
@@ -3697,6 +3722,17 @@ __libc_pvalloc (size_t bytes)
 void *
 __libc_calloc (size_t n, size_t elem_size)
 {
+  ptrdiff_t bytes;
+  
+  if (__glibc_unlikely (__builtin_mul_overflow (n, elem_size, &bytes)))
+    {
+       __set_errno (ENOMEM);
+       return NULL;
+    }
+
+  if ((true))
+    return zgc_alloc(bytes);
+
   mstate av;
   mchunkptr oldtop;
   INTERNAL_SIZE_T sz, oldtopsize;
@@ -3704,13 +3740,6 @@ __libc_calloc (size_t n, size_t elem_size)
   unsigned long clearsize;
   unsigned long nclears;
   INTERNAL_SIZE_T *d;
-  ptrdiff_t bytes;
-
-  if (__glibc_unlikely (__builtin_mul_overflow (n, elem_size, &bytes)))
-    {
-       __set_errno (ENOMEM);
-       return NULL;
-    }
 
   sz = bytes;
 
@@ -5206,6 +5235,12 @@ mtrim (mstate av, size_t pad)
 int
 __malloc_trim (size_t s)
 {
+  if ((true)) {
+    zgc_request_and_wait();
+    zscavenge_synchronously();
+    return 1;
+  }
+  
   int result = 0;
 
   if (!__malloc_initialized)
@@ -5247,6 +5282,11 @@ musable (void *mem)
 size_t
 __malloc_usable_size (void *m)
 {
+  if ((true)) {
+    if (!zhasvalidcap(m) || !zinbounds(m))
+      return 0;
+    return (char*)zgetupper(m) - (char*)m;
+  }
   if (m == NULL)
     return 0;
   return musable (m);
@@ -5374,6 +5414,9 @@ __libc_mallinfo (void)
 void
 __malloc_stats (void)
 {
+  if ((true))
+    return;
+  
   int i;
   mstate ar_ptr;
   unsigned int in_use_b = mp_.mmapped_mem, system_b = in_use_b;
@@ -5557,6 +5600,9 @@ do_set_hugetlb (size_t value)
 int
 __libc_mallopt (int param_number, int value)
 {
+  if ((true))
+    return 1;
+  
   mstate av = &main_arena;
   int res = 1;
 
@@ -5781,6 +5827,11 @@ malloc_printerr (const char *str)
 int
 __posix_memalign (void **memptr, size_t alignment, size_t size)
 {
+  if ((true)) {
+    *memptr = zgc_aligned_alloc(alignment, size);
+    return 0;
+  }
+  
   void *mem;
 
   if (!__malloc_initialized)
@@ -5812,6 +5863,9 @@ weak_alias (__posix_memalign, posix_memalign)
 int
 __malloc_info (int options, FILE *fp)
 {
+  if ((true))
+    return 0;
+  
   /* For now, at least.  */
   if (options != 0)
     return EINVAL;
diff --git a/malloc/obstack.h b/malloc/obstack.h
index 95e4907a530a..7c52b54e7c8a 100644
--- a/malloc/obstack.h
+++ b/malloc/obstack.h
@@ -104,6 +104,8 @@
 #ifndef _OBSTACK_H
 #define _OBSTACK_H 1
 
+#include <stdfil.h>
+
 /* We need the type of a pointer subtraction.  If __PTRDIFF_TYPE__ is
    defined, as with GNU C, use that; that way we don't pollute the
    namespace with <stddef.h>'s symbols.  Otherwise, include <stddef.h>
@@ -120,7 +122,10 @@
    aligning P to the next multiple of A + 1.  B and P must be of type
    char *.  A + 1 must be a power of 2.  */
 
-#define __BPTR_ALIGN(B, P, A) ((B) + (((P) - (B) + (A)) & ~(A)))
+#define __BPTR_ALIGN(B, P, A)                                            \
+  __extension__                                                          \
+    ({ char *__P = (char *) (P);                                         \
+       zmkptr(__P, (PTR_INT_TYPE)((B) + ((__P - (B) + (A)) & ~(A)))); })
 
 /* Similar to _BPTR_ALIGN (B, P, A), except optimize the common case
    where pointers can be converted to integers, aligned as integers,
diff --git a/malloc/set-freeres.c b/malloc/set-freeres.c
index 4976d55c1919..e6c3dcaaa53d 100644
--- a/malloc/set-freeres.c
+++ b/malloc/set-freeres.c
@@ -136,7 +136,6 @@ __libc_freeres (void)
       _IO_cleanup ();
 
       /* We run the resource freeing after IO cleanup.  */
-      call_function_static_weak (__dl_libc_freemem);
       call_function_static_weak (__hdestroy);
       call_function_static_weak (__gconv_cache_freemem);
       call_function_static_weak (__gconv_conf_freemem);
@@ -186,10 +185,6 @@ __libc_freeres (void)
 
       call_function_static_weak (__libc_dlerror_result_free);
 
-#ifdef SHARED
-      GLRO (dl_libc_freeres) ();
-#endif
-
       call_free_static_weak (__libc_fgetgrent_freemem_ptr);
       call_free_static_weak (__libc_fgetsgent_freeres_ptr);
       call_free_static_weak (__libc_getnetgrent_freemem_ptr);
diff --git a/math/e_exp10l.c b/math/e_exp10l.c
new file mode 100644
index 000000000000..233e587227fc
--- /dev/null
+++ b/math/e_exp10l.c
@@ -0,0 +1,9 @@
+#include <libm-alias-finite.h>
+#include <pizlonated_math.h>
+
+long double __ieee754_exp10l(long double x)
+{
+    return zmath_exp10l(x);
+}
+
+libm_alias_finite (__ieee754_exp10l, __exp10l)
diff --git a/math/e_exp2l.c b/math/e_exp2l.c
new file mode 100644
index 000000000000..15d046e2232a
--- /dev/null
+++ b/math/e_exp2l.c
@@ -0,0 +1,9 @@
+#include <libm-alias-finite.h>
+#include <pizlonated_math.h>
+
+long double __ieee754_exp2l(long double x)
+{
+    return zmath_exp2l(x);
+}
+
+libm_alias_finite (__ieee754_exp2l, __exp2l)
diff --git a/math/e_expl.c b/math/e_expl.c
new file mode 100644
index 000000000000..bae68e66a4da
--- /dev/null
+++ b/math/e_expl.c
@@ -0,0 +1,9 @@
+#include <libm-alias-finite.h>
+#include <pizlonated_math.h>
+
+long double __ieee754_expl(long double x)
+{
+    return zmath_expl(x);
+}
+
+libm_alias_finite (__ieee754_expl, __expl)
diff --git a/math/e_fmodl.c b/math/e_fmodl.c
new file mode 100644
index 000000000000..469ed060f8b8
--- /dev/null
+++ b/math/e_fmodl.c
@@ -0,0 +1,9 @@
+#include <libm-alias-finite.h>
+#include <pizlonated_math.h>
+
+long double __ieee754_fmodl(long double x, long double y)
+{
+    return zmath_fmodl(x, y);
+}
+
+libm_alias_finite (__ieee754_fmodl, __fmodl)
diff --git a/math/e_ilogbl.c b/math/e_ilogbl.c
new file mode 100644
index 000000000000..f2806e679830
--- /dev/null
+++ b/math/e_ilogbl.c
@@ -0,0 +1,8 @@
+#include <libm-alias-finite.h>
+#include <pizlonated_math.h>
+
+long double __ieee754_ilogbl(long double x)
+{
+    return zmath_ilogbl(x);
+}
+
diff --git a/math/e_log10l.c b/math/e_log10l.c
new file mode 100644
index 000000000000..020e590d1d93
--- /dev/null
+++ b/math/e_log10l.c
@@ -0,0 +1,14 @@
+#include <libm-alias-finite.h>
+#include <pizlonated_math.h>
+
+long double __ieee754_log10l (long double x)
+{
+    return zmath_log10l (x);
+}
+
+long double __log10l_finite (long double x)
+{
+    return zmath_log10l_finite (x);
+}
+
+libm_alias_finite (__log10l_finite, __log10l)
diff --git a/math/e_log2l.c b/math/e_log2l.c
new file mode 100644
index 000000000000..4a2867569d4c
--- /dev/null
+++ b/math/e_log2l.c
@@ -0,0 +1,14 @@
+#include <libm-alias-finite.h>
+#include <pizlonated_math.h>
+
+long double __ieee754_log2l (long double x)
+{
+    return zmath_log2l (x);
+}
+
+long double __log2l_finite (long double x)
+{
+    return zmath_log2l_finite (x);
+}
+
+libm_alias_finite (__log2l_finite, __log2l)
diff --git a/math/e_logl.c b/math/e_logl.c
new file mode 100644
index 000000000000..9697611f96da
--- /dev/null
+++ b/math/e_logl.c
@@ -0,0 +1,14 @@
+#include <libm-alias-finite.h>
+#include <pizlonated_math.h>
+
+long double __ieee754_logl (long double x)
+{
+    return zmath_logl (x);
+}
+
+long double __logl_finite (long double x)
+{
+    return zmath_logl_finite (x);
+}
+
+libm_alias_finite (__logl_finite, __logl)
diff --git a/math/e_powl.c b/math/e_powl.c
new file mode 100644
index 000000000000..16db944b0e59
--- /dev/null
+++ b/math/e_powl.c
@@ -0,0 +1,9 @@
+#include <libm-alias-finite.h>
+#include <pizlonated_math.h>
+
+long double __ieee754_powl(long double x, long double y)
+{
+    return zmath_powl(x, y);
+}
+
+libm_alias_finite (__ieee754_powl, __powl)
diff --git a/math/e_remainderl.c b/math/e_remainderl.c
new file mode 100644
index 000000000000..1d385c33f128
--- /dev/null
+++ b/math/e_remainderl.c
@@ -0,0 +1,9 @@
+#include <libm-alias-finite.h>
+#include <pizlonated_math.h>
+
+long double __ieee754_remainderl(long double x, long double y)
+{
+    return zmath_remainderl(x, y);
+}
+
+libm_alias_finite (__ieee754_remainderl, __remainderl)
diff --git a/math/e_scalbl.c b/math/e_scalbl.c
new file mode 100644
index 000000000000..caf40e62da8a
--- /dev/null
+++ b/math/e_scalbl.c
@@ -0,0 +1,9 @@
+#include <libm-alias-finite.h>
+#include <pizlonated_math.h>
+
+long double __ieee754_scalbl(long double x, long double exp)
+{
+    return zmath_scalbl(x, exp);
+}
+
+libm_alias_finite (__ieee754_scalbl, __scalbl)
diff --git a/math/math.h b/math/math.h
index 1e300c4223be..f759f8196c59 100644
--- a/math/math.h
+++ b/math/math.h
@@ -863,6 +863,8 @@ extern int signgam;
 # error "Unsupported _FloatN or _FloatNx types for <math.h>."
 #endif
 
+#pragma clang diagnostic ignored "-Wabsolute-value"
+
 /* Depending on the type of TG_ARG, call an appropriately suffixed
    version of FUNC with arguments (including parentheses) ARGS.
    Suffixed functions may not exist for long double if it has the same
diff --git a/math/s_expm1l.c b/math/s_expm1l.c
new file mode 100644
index 000000000000..2d1a4b97b408
--- /dev/null
+++ b/math/s_expm1l.c
@@ -0,0 +1,11 @@
+#include <math.h>
+#include <libm-alias-ldouble.h>
+#include <pizlonated_math.h>
+
+long double __expm1l(long double x)
+{
+    return zmath_expm1l(x);
+}
+
+libm_hidden_def (__expm1l)
+libm_alias_ldouble (__expm1, expm1)
diff --git a/math/s_finitel.c b/math/s_finitel.c
new file mode 100644
index 000000000000..d8b7b2ebe9a3
--- /dev/null
+++ b/math/s_finitel.c
@@ -0,0 +1,9 @@
+#include <libm-alias-ldouble.h>
+#include <pizlonated_math.h>
+
+int __finitel(long double x)
+{
+    return zmath_finitel(x);
+}
+
+libm_alias_ldouble (__finite, finite)
diff --git a/math/s_llrintl.c b/math/s_llrintl.c
new file mode 100644
index 000000000000..7f969ba84e47
--- /dev/null
+++ b/math/s_llrintl.c
@@ -0,0 +1,11 @@
+#include <libm-alias-ldouble.h>
+#include <pizlonated_math.h>
+
+long long __llrintl(long double x)
+{
+    return zmath_llrintl(x);
+}
+
+libm_alias_ldouble (__llrint, llrint)
+strong_alias (__llrintl, __lrintl)
+libm_alias_ldouble (__llrint, lrint)
diff --git a/math/s_log1pl.c b/math/s_log1pl.c
new file mode 100644
index 000000000000..0976dfcc90aa
--- /dev/null
+++ b/math/s_log1pl.c
@@ -0,0 +1,8 @@
+#include <libm-alias-ldouble.h>
+#include <pizlonated_math.h>
+
+int __log1pl (long double x)
+{
+    return zmath_log1pl (x);
+}
+
diff --git a/math/s_lrintl.c b/math/s_lrintl.c
new file mode 100644
index 000000000000..db3355f5988e
--- /dev/null
+++ b/math/s_lrintl.c
@@ -0,0 +1 @@
+/* Not needed */
diff --git a/math/s_nearbyintl.c b/math/s_nearbyintl.c
new file mode 100644
index 000000000000..649be1322ba2
--- /dev/null
+++ b/math/s_nearbyintl.c
@@ -0,0 +1,10 @@
+#include <libm-alias-ldouble.h>
+#include <pizlonated_math.h>
+
+long double __nearbyintl(long double x)
+{
+    return zmath_nearbyintl(x);
+}
+
+libm_alias_ldouble (__nearbyint, nearbyint)
+
diff --git a/math/s_scalbnl.c b/math/s_scalbnl.c
new file mode 100644
index 000000000000..ac7fb6491349
--- /dev/null
+++ b/math/s_scalbnl.c
@@ -0,0 +1,9 @@
+#include <libm-alias-ldouble.h>
+#include <pizlonated_math.h>
+
+long double __scalbnl(long double x, int exp)
+{
+    return zmath_scalbnl(x, exp);
+}
+
+libm_alias_ldouble (__scalbn, scalbn)
diff --git a/misc/syslog.c b/misc/syslog.c
index 4af87f54fdbe..447269972201 100644
--- a/misc/syslog.c
+++ b/misc/syslog.c
@@ -43,6 +43,8 @@ static char sccsid[] = "@(#)syslog.c	8.4 (Berkeley) 3/18/94";
 #include <syslog.h>
 #include <limits.h>
 
+#pragma clang diagnostic ignored "-Wstring-plus-int"
+
 static int LogType = SOCK_DGRAM;	/* type of socket connection */
 static int LogFile = -1;		/* fd for log */
 static bool connected;			/* have done connect */
diff --git a/misc/tsearch.c b/misc/tsearch.c
index d7dd4d9c8ff4..f567fb3a271c 100644
--- a/misc/tsearch.c
+++ b/misc/tsearch.c
@@ -95,7 +95,7 @@
    visible and always allocated by malloc.  The user provides the key
    pointer and so that can point anywhere and doesn't have to be
    aligned.  */
-#define USE_MALLOC_LOW_BIT 1
+//#define USE_MALLOC_LOW_BIT 1
 
 #ifndef USE_MALLOC_LOW_BIT
 typedef struct node_t
diff --git a/nis/nis_table.c b/nis/nis_table.c
index 56c1aa262d22..f4377d72a50b 100644
--- a/nis/nis_table.c
+++ b/nis/nis_table.c
@@ -180,7 +180,6 @@ __follow_path (char **tablepath, char **tableptr, struct ib_request *ibreq,
   /* Since tableptr is only set here, and it's set when tablepath is NULL,
      which it is initially defined as, we know it will always be set here.  */
   DIAG_PUSH_NEEDS_COMMENT;
-  DIAG_IGNORE_NEEDS_COMMENT (4.7, "-Wmaybe-uninitialized");
 
   if (*tableptr == NULL)
     return NIS_NOTFOUND;
diff --git a/nptl/allocatestack.c b/nptl/allocatestack.c
index 2cb562f8eac8..cbbf78fdc688 100644
--- a/nptl/allocatestack.c
+++ b/nptl/allocatestack.c
@@ -36,500 +36,40 @@
 #include <intprops.h>
 #include <setvmaname.h>
 
-/* Default alignment of stack.  */
-#ifndef STACK_ALIGN
-# define STACK_ALIGN __alignof__ (long double)
-#endif
-
-/* Default value for minimal stack size after allocating thread
-   descriptor and guard.  */
-#ifndef MINIMAL_REST_STACK
-# define MINIMAL_REST_STACK	4096
-#endif
-
-
-/* Newer kernels have the MAP_STACK flag to indicate a mapping is used for
-   a stack.  Use it when possible.  */
-#ifndef MAP_STACK
-# define MAP_STACK 0
-#endif
-
-/* Get a stack frame from the cache.  We have to match by size since
-   some blocks might be too small or far too large.  */
-static struct pthread *
-get_cached_stack (size_t *sizep, void **memp)
-{
-  size_t size = *sizep;
-  struct pthread *result = NULL;
-  list_t *entry;
-
-  lll_lock (GL (dl_stack_cache_lock), LLL_PRIVATE);
-
-  /* Search the cache for a matching entry.  We search for the
-     smallest stack which has at least the required size.  Note that
-     in normal situations the size of all allocated stacks is the
-     same.  As the very least there are only a few different sizes.
-     Therefore this loop will exit early most of the time with an
-     exact match.  */
-  list_for_each (entry, &GL (dl_stack_cache))
-    {
-      struct pthread *curr;
-
-      curr = list_entry (entry, struct pthread, list);
-      if (__nptl_stack_in_use (curr) && curr->stackblock_size >= size)
-	{
-	  if (curr->stackblock_size == size)
-	    {
-	      result = curr;
-	      break;
-	    }
-
-	  if (result == NULL
-	      || result->stackblock_size > curr->stackblock_size)
-	    result = curr;
-	}
-    }
-
-  if (__builtin_expect (result == NULL, 0)
-      /* Make sure the size difference is not too excessive.  In that
-	 case we do not use the block.  */
-      || __builtin_expect (result->stackblock_size > 4 * size, 0))
-    {
-      /* Release the lock.  */
-      lll_unlock (GL (dl_stack_cache_lock), LLL_PRIVATE);
-
-      return NULL;
-    }
-
-  /* Don't allow setxid until cloned.  */
-  result->setxid_futex = -1;
-
-  /* Dequeue the entry.  */
-  __nptl_stack_list_del (&result->list);
-
-  /* And add to the list of stacks in use.  */
-  __nptl_stack_list_add (&result->list, &GL (dl_stack_used));
-
-  /* And decrease the cache size.  */
-  GL (dl_stack_cache_actsize) -= result->stackblock_size;
-
-  /* Release the lock early.  */
-  lll_unlock (GL (dl_stack_cache_lock), LLL_PRIVATE);
-
-  /* Report size and location of the stack to the caller.  */
-  *sizep = result->stackblock_size;
-  *memp = result->stackblock;
-
-  /* Cancellation handling is back to the default.  */
-  result->cancelhandling = 0;
-  result->cleanup = NULL;
-  result->setup_failed = 0;
-
-  /* No pending event.  */
-  result->nextevent = NULL;
-
-  result->exiting = false;
-  __libc_lock_init (result->exit_lock);
-  memset (&result->tls_state, 0, sizeof result->tls_state);
-
-  /* Clear the DTV.  */
-  dtv_t *dtv = GET_DTV (TLS_TPADJ (result));
-  for (size_t cnt = 0; cnt < dtv[-1].counter; ++cnt)
-    free (dtv[1 + cnt].pointer.to_free);
-  memset (dtv, '\0', (dtv[-1].counter + 1) * sizeof (dtv_t));
-
-  /* Re-initialize the TLS.  */
-  _dl_allocate_tls_init (TLS_TPADJ (result), false);
-
-  return result;
-}
-
-/* Return the guard page position on allocated stack.  */
-static inline char *
-__attribute ((always_inline))
-guard_position (void *mem, size_t size, size_t guardsize, struct pthread *pd,
-		size_t pagesize_m1)
-{
-#if _STACK_GROWS_DOWN
-  return mem;
-#elif _STACK_GROWS_UP
-  return (char *) (((uintptr_t) pd - guardsize) & ~pagesize_m1);
-#endif
-}
-
-/* Based on stack allocated with PROT_NONE, setup the required portions with
-   'prot' flags based on the guard page position.  */
-static inline int
-setup_stack_prot (char *mem, size_t size, char *guard, size_t guardsize,
-		  const int prot)
-{
-  char *guardend = guard + guardsize;
-#if _STACK_GROWS_DOWN
-  /* As defined at guard_position, for architectures with downward stack
-     the guard page is always at start of the allocated area.  */
-  if (__mprotect (guardend, size - guardsize, prot) != 0)
-    return errno;
-#else
-  size_t mprots1 = (uintptr_t) guard - (uintptr_t) mem;
-  if (__mprotect (mem, mprots1, prot) != 0)
-    return errno;
-  size_t mprots2 = ((uintptr_t) mem + size) - (uintptr_t) guardend;
-  if (__mprotect (guardend, mprots2, prot) != 0)
-    return errno;
-#endif
-  return 0;
-}
-
-/* Mark the memory of the stack as usable to the kernel.  It frees everything
-   except for the space used for the TCB itself.  */
-static __always_inline void
-advise_stack_range (void *mem, size_t size, uintptr_t pd, size_t guardsize)
-{
-  uintptr_t sp = (uintptr_t) CURRENT_STACK_FRAME;
-  size_t pagesize_m1 = __getpagesize () - 1;
-#if _STACK_GROWS_DOWN
-  size_t freesize = (sp - (uintptr_t) mem) & ~pagesize_m1;
-  assert (freesize < size);
-  if (freesize > PTHREAD_STACK_MIN)
-    __madvise (mem, freesize - PTHREAD_STACK_MIN, MADV_DONTNEED);
-#else
-  /* Page aligned start of memory to free (higher than or equal
-     to current sp plus the minimum stack size).  */
-  uintptr_t freeblock = (sp + PTHREAD_STACK_MIN + pagesize_m1) & ~pagesize_m1;
-  uintptr_t free_end = (pd - guardsize) & ~pagesize_m1;
-  if (free_end > freeblock)
-    {
-      size_t freesize = free_end - freeblock;
-      assert (freesize < size);
-      __madvise ((void*) freeblock, freesize, MADV_DONTNEED);
-    }
-#endif
-}
-
 /* Returns a usable stack for a new thread either by allocating a
    new stack or reusing a cached stack of sufficient size.
    ATTR must be non-NULL and point to a valid pthread_attr.
    PDP must be non-NULL.  */
 static int
-allocate_stack (const struct pthread_attr *attr, struct pthread **pdp,
-		void **stack, size_t *stacksize)
+allocate_stack (const struct pthread_attr *attr, struct pthread **pdp)
 {
   struct pthread *pd;
-  size_t size;
-  size_t pagesize_m1 = __getpagesize () - 1;
-  size_t tls_static_size_for_stack = __nptl_tls_static_size_for_stack ();
-  size_t tls_static_align_m1 = GLRO (dl_tls_static_align) - 1;
-
-  assert (powerof2 (pagesize_m1 + 1));
-  assert (TCB_ALIGNMENT >= STACK_ALIGN);
-
-  /* Get the stack size from the attribute if it is set.  Otherwise we
-     use the default we determined at start time.  */
-  if (attr->stacksize != 0)
-    size = attr->stacksize;
-  else
-    {
-      lll_lock (__default_pthread_attr_lock, LLL_PRIVATE);
-      size = __default_pthread_attr.internal.stacksize;
-      lll_unlock (__default_pthread_attr_lock, LLL_PRIVATE);
-    }
 
   /* Get memory for the stack.  */
   if (__glibc_unlikely (attr->flags & ATTR_FLAG_STACKADDR))
     {
-      uintptr_t adj;
-      char *stackaddr = (char *) attr->stackaddr;
-
-      /* Assume the same layout as the _STACK_GROWS_DOWN case, with struct
-	 pthread at the top of the stack block.  Later we adjust the guard
-	 location and stack address to match the _STACK_GROWS_UP case.  */
-      if (_STACK_GROWS_UP)
-	stackaddr += attr->stacksize;
-
-      /* If the user also specified the size of the stack make sure it
-	 is large enough.  */
-      if (attr->stacksize != 0
-	  && attr->stacksize < (tls_static_size_for_stack
-				+ MINIMAL_REST_STACK))
-	return EINVAL;
-
-      /* Adjust stack size for alignment of the TLS block.  */
-#if TLS_TCB_AT_TP
-      adj = ((uintptr_t) stackaddr - TLS_TCB_SIZE)
-	    & tls_static_align_m1;
-      assert (size > adj + TLS_TCB_SIZE);
-#elif TLS_DTV_AT_TP
-      adj = ((uintptr_t) stackaddr - tls_static_size_for_stack)
-	    & tls_static_align_m1;
-      assert (size > adj);
-#endif
-
-      /* The user provided some memory.  Let's hope it matches the
-	 size...  We do not allocate guard pages if the user provided
-	 the stack.  It is the user's responsibility to do this if it
-	 is wanted.  */
-#if TLS_TCB_AT_TP
-      pd = (struct pthread *) ((uintptr_t) stackaddr
-			       - TLS_TCB_SIZE - adj);
-#elif TLS_DTV_AT_TP
-      pd = (struct pthread *) (((uintptr_t) stackaddr
-				- tls_static_size_for_stack - adj)
-			       - TLS_PRE_TCB_SIZE);
-#endif
-
-      /* The user provided stack memory needs to be cleared.  */
-      memset (pd, '\0', sizeof (struct pthread));
-
-      /* The first TSD block is included in the TCB.  */
+      zerror("pthreadattr stack attributes not supported yet.");
+      return ENOSYS;
+    }
+  else
+    {
+      pd = zgc_alloc(TLS_TCB_SIZE);
+      
+      /* We allocated the first block thread-specific data array.
+         This address will not change for the lifetime of this
+         descriptor.  */
       pd->specific[0] = pd->specific_1stblock;
-
-      /* Remember the stack-related values.  */
-      pd->stackblock = (char *) stackaddr - size;
-      pd->stackblock_size = size;
-
-      /* This is a user-provided stack.  It will not be queued in the
-	 stack cache nor will the memory (except the TLS memory) be freed.  */
-      pd->user_stack = true;
-
+      
       /* This is at least the second thread.  */
       pd->header.multiple_threads = 1;
 
 #ifdef NEED_DL_SYSINFO
       SETUP_THREAD_SYSINFO (pd);
 #endif
-
-      /* Don't allow setxid until cloned.  */
+      
+      /* Don't allow setxid until cloned.  
+         FIXME: This is probably not needed. */
       pd->setxid_futex = -1;
-
-      /* Allocate the DTV for this thread.  */
-      if (_dl_allocate_tls (TLS_TPADJ (pd)) == NULL)
-	{
-	  /* Something went wrong.  */
-	  assert (errno == ENOMEM);
-	  return errno;
-	}
-
-
-      /* Prepare to modify global data.  */
-      lll_lock (GL (dl_stack_cache_lock), LLL_PRIVATE);
-
-      /* And add to the list of stacks in use.  */
-      list_add (&pd->list, &GL (dl_stack_user));
-
-      lll_unlock (GL (dl_stack_cache_lock), LLL_PRIVATE);
-    }
-  else
-    {
-      /* Allocate some anonymous memory.  If possible use the cache.  */
-      size_t guardsize;
-      size_t reported_guardsize;
-      size_t reqsize;
-      void *mem;
-      const int prot = (PROT_READ | PROT_WRITE
-			| ((GL(dl_stack_flags) & PF_X) ? PROT_EXEC : 0));
-
-      /* Adjust the stack size for alignment.  */
-      size &= ~tls_static_align_m1;
-      assert (size != 0);
-
-      /* Make sure the size of the stack is enough for the guard and
-	 eventually the thread descriptor.  On some targets there is
-	 a minimum guard size requirement, ARCH_MIN_GUARD_SIZE, so
-	 internally enforce it (unless the guard was disabled), but
-	 report the original guard size for backward compatibility:
-	 before POSIX 2008 the guardsize was specified to be one page
-	 by default which is observable via pthread_attr_getguardsize
-	 and pthread_getattr_np.  */
-      guardsize = (attr->guardsize + pagesize_m1) & ~pagesize_m1;
-      reported_guardsize = guardsize;
-      if (guardsize > 0 && guardsize < ARCH_MIN_GUARD_SIZE)
-	guardsize = ARCH_MIN_GUARD_SIZE;
-      if (guardsize < attr->guardsize || size + guardsize < guardsize)
-	/* Arithmetic overflow.  */
-	return EINVAL;
-      size += guardsize;
-      if (__builtin_expect (size < ((guardsize + tls_static_size_for_stack
-				     + MINIMAL_REST_STACK + pagesize_m1)
-				    & ~pagesize_m1),
-			    0))
-	/* The stack is too small (or the guard too large).  */
-	return EINVAL;
-
-      /* Try to get a stack from the cache.  */
-      reqsize = size;
-      pd = get_cached_stack (&size, &mem);
-      if (pd == NULL)
-	{
-	  /* If a guard page is required, avoid committing memory by first
-	     allocate with PROT_NONE and then reserve with required permission
-	     excluding the guard page.  */
-	  mem = __mmap (NULL, size, (guardsize == 0) ? prot : PROT_NONE,
-			MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);
-
-	  if (__glibc_unlikely (mem == MAP_FAILED))
-	    return errno;
-
-	  /* Do madvise in case the tunable glibc.pthread.stack_hugetlb is
-	     set to 0, disabling hugetlb.  */
-	  if (__glibc_unlikely (__nptl_stack_hugetlb == 0)
-	      && __madvise (mem, size, MADV_NOHUGEPAGE) != 0)
-	    return errno;
-
-	  /* SIZE is guaranteed to be greater than zero.
-	     So we can never get a null pointer back from mmap.  */
-	  assert (mem != NULL);
-
-	  /* Place the thread descriptor at the end of the stack.  */
-#if TLS_TCB_AT_TP
-	  pd = (struct pthread *) ((((uintptr_t) mem + size)
-				    - TLS_TCB_SIZE)
-				   & ~tls_static_align_m1);
-#elif TLS_DTV_AT_TP
-	  pd = (struct pthread *) ((((uintptr_t) mem + size
-				    - tls_static_size_for_stack)
-				    & ~tls_static_align_m1)
-				   - TLS_PRE_TCB_SIZE);
-#endif
-
-	  /* Now mprotect the required region excluding the guard area.  */
-	  if (__glibc_likely (guardsize > 0))
-	    {
-	      char *guard = guard_position (mem, size, guardsize, pd,
-					    pagesize_m1);
-	      if (setup_stack_prot (mem, size, guard, guardsize, prot) != 0)
-		{
-		  __munmap (mem, size);
-		  return errno;
-		}
-	    }
-
-	  /* Remember the stack-related values.  */
-	  pd->stackblock = mem;
-	  pd->stackblock_size = size;
-	  /* Update guardsize for newly allocated guardsize to avoid
-	     an mprotect in guard resize below.  */
-	  pd->guardsize = guardsize;
-
-	  /* We allocated the first block thread-specific data array.
-	     This address will not change for the lifetime of this
-	     descriptor.  */
-	  pd->specific[0] = pd->specific_1stblock;
-
-	  /* This is at least the second thread.  */
-	  pd->header.multiple_threads = 1;
-
-#ifdef NEED_DL_SYSINFO
-	  SETUP_THREAD_SYSINFO (pd);
-#endif
-
-	  /* Don't allow setxid until cloned.  */
-	  pd->setxid_futex = -1;
-
-	  /* Allocate the DTV for this thread.  */
-	  if (_dl_allocate_tls (TLS_TPADJ (pd)) == NULL)
-	    {
-	      /* Something went wrong.  */
-	      assert (errno == ENOMEM);
-
-	      /* Free the stack memory we just allocated.  */
-	      (void) __munmap (mem, size);
-
-	      return errno;
-	    }
-
-
-	  /* Prepare to modify global data.  */
-	  lll_lock (GL (dl_stack_cache_lock), LLL_PRIVATE);
-
-	  /* And add to the list of stacks in use.  */
-	  __nptl_stack_list_add (&pd->list, &GL (dl_stack_used));
-
-	  lll_unlock (GL (dl_stack_cache_lock), LLL_PRIVATE);
-
-
-	  /* There might have been a race.  Another thread might have
-	     caused the stacks to get exec permission while this new
-	     stack was prepared.  Detect if this was possible and
-	     change the permission if necessary.  */
-	  if (__builtin_expect ((GL(dl_stack_flags) & PF_X) != 0
-				&& (prot & PROT_EXEC) == 0, 0))
-	    {
-	      int err = __nptl_change_stack_perm (pd);
-	      if (err != 0)
-		{
-		  /* Free the stack memory we just allocated.  */
-		  (void) __munmap (mem, size);
-
-		  return err;
-		}
-	    }
-
-
-	  /* Note that all of the stack and the thread descriptor is
-	     zeroed.  This means we do not have to initialize fields
-	     with initial value zero.  This is specifically true for
-	     the 'tid' field which is always set back to zero once the
-	     stack is not used anymore and for the 'guardsize' field
-	     which will be read next.  */
-	}
-
-      /* Create or resize the guard area if necessary.  */
-      if (__glibc_unlikely (guardsize > pd->guardsize))
-	{
-	  char *guard = guard_position (mem, size, guardsize, pd,
-					pagesize_m1);
-	  if (__mprotect (guard, guardsize, PROT_NONE) != 0)
-	    {
-	    mprot_error:
-	      lll_lock (GL (dl_stack_cache_lock), LLL_PRIVATE);
-
-	      /* Remove the thread from the list.  */
-	      __nptl_stack_list_del (&pd->list);
-
-	      lll_unlock (GL (dl_stack_cache_lock), LLL_PRIVATE);
-
-	      /* Get rid of the TLS block we allocated.  */
-	      _dl_deallocate_tls (TLS_TPADJ (pd), false);
-
-	      /* Free the stack memory regardless of whether the size
-		 of the cache is over the limit or not.  If this piece
-		 of memory caused problems we better do not use it
-		 anymore.  Uh, and we ignore possible errors.  There
-		 is nothing we could do.  */
-	      (void) __munmap (mem, size);
-
-	      return errno;
-	    }
-
-	  pd->guardsize = guardsize;
-	}
-      else if (__builtin_expect (pd->guardsize - guardsize > size - reqsize,
-				 0))
-	{
-	  /* The old guard area is too large.  */
-
-#if _STACK_GROWS_DOWN
-	  if (__mprotect ((char *) mem + guardsize, pd->guardsize - guardsize,
-			prot) != 0)
-	    goto mprot_error;
-#elif _STACK_GROWS_UP
-         char *new_guard = (char *)(((uintptr_t) pd - guardsize)
-                                    & ~pagesize_m1);
-         char *old_guard = (char *)(((uintptr_t) pd - pd->guardsize)
-                                    & ~pagesize_m1);
-         /* The guard size difference might be > 0, but once rounded
-            to the nearest page the size difference might be zero.  */
-         if (new_guard > old_guard
-             && __mprotect (old_guard, new_guard - old_guard, prot) != 0)
-	    goto mprot_error;
-#endif
-
-	  pd->guardsize = guardsize;
-	}
-      /* The pthread_getattr_np() calls need to get passed the size
-	 requested in the attribute, regardless of how large the
-	 actually used guardsize is.  */
-      pd->reported_guardsize = reported_guardsize;
     }
 
   /* Initialize the lock.  We have to do this unconditionally since the
@@ -551,18 +91,6 @@ allocate_stack (const struct pthread_attr *attr, struct pthread **pdp,
   /* We place the thread descriptor at the end of the stack.  */
   *pdp = pd;
 
-  void *stacktop;
-
-#if TLS_TCB_AT_TP
-  /* The stack begins before the TCB and the static TLS block.  */
-  stacktop = ((char *) (pd + 1) - tls_static_size_for_stack);
-#elif TLS_DTV_AT_TP
-  stacktop = (char *) (pd - 1);
-#endif
-
-  *stacksize = stacktop - pd->stackblock;
-  *stack = pd->stackblock;
-
   return 0;
 }
 
diff --git a/nptl/descr.h b/nptl/descr.h
index c4bdd7757aa3..b6a31d9f7a36 100644
--- a/nptl/descr.h
+++ b/nptl/descr.h
@@ -172,6 +172,10 @@ struct pthread
      therefore stack) used' flag.  */
   pid_t tid;
 
+  void* zthread;
+
+  int dead;
+
   /* List of robust mutexes the thread is holding.  */
 #if __PTHREAD_MUTEX_HAVE_PREV
   void *robust_prev;
@@ -347,7 +351,8 @@ struct pthread
      in normal operation.  */
   struct pthread *joinid;
   /* Check whether a thread is detached.  */
-#define IS_DETACHED(pd) ((pd)->joinid == (pd))
+#define IS_DETACHED(pd) ((pd)->joinid == (pd) || \
+                         (pd)->joinid == (struct pthread *) ((char *) (pd) + 1))
 
   /* The result of the thread function.  */
   void *result;
diff --git a/nptl/futex-internal.c b/nptl/futex-internal.c
index 0bb1dd51f668..7c3aabe2a8dc 100644
--- a/nptl/futex-internal.c
+++ b/nptl/futex-internal.c
@@ -22,111 +22,13 @@
 #include <futex-internal.h>
 #include <kernel-features.h>
 
-#ifndef __ASSUME_TIME64_SYSCALLS
-static int
-__futex_abstimed_wait_common32 (unsigned int* futex_word,
-                                unsigned int expected, int op,
-                                const struct __timespec64* abstime,
-                                int private, bool cancel)
-{
-  struct timespec ts32, *pts32 = NULL;
-  if (abstime != NULL)
-    {
-      ts32 = valid_timespec64_to_timespec (*abstime);
-      pts32 = &ts32;
-    }
-
-  if (cancel)
-    return INTERNAL_SYSCALL_CANCEL (futex, futex_word, op, expected,
-                                    pts32, NULL /* Unused.  */,
-                                    FUTEX_BITSET_MATCH_ANY);
-  else
-    return INTERNAL_SYSCALL_CALL (futex, futex_word, op, expected,
-                                  pts32, NULL /* Unused.  */,
-                                  FUTEX_BITSET_MATCH_ANY);
-}
-#endif /* ! __ASSUME_TIME64_SYSCALLS */
-
-static int
-__futex_abstimed_wait_common64 (unsigned int* futex_word,
-                                unsigned int expected, int op,
-                                const struct __timespec64* abstime,
-                                int private, bool cancel)
-{
-  if (cancel)
-    return INTERNAL_SYSCALL_CANCEL (futex_time64, futex_word, op, expected,
-				    abstime, NULL /* Unused.  */,
-				    FUTEX_BITSET_MATCH_ANY);
-  else
-    return INTERNAL_SYSCALL_CALL (futex_time64, futex_word, op, expected,
-				  abstime, NULL /* Unused.  */,
-				  FUTEX_BITSET_MATCH_ANY);
-}
-
-static int
-__futex_abstimed_wait_common (unsigned int* futex_word,
-                              unsigned int expected, clockid_t clockid,
-                              const struct __timespec64* abstime,
-                              int private, bool cancel)
-{
-  int err;
-  unsigned int clockbit;
-
-  /* Work around the fact that the kernel rejects negative timeout values
-     despite them being valid.  */
-  if (__glibc_unlikely ((abstime != NULL) && (abstime->tv_sec < 0)))
-    return ETIMEDOUT;
-
-  if (! lll_futex_supported_clockid (clockid))
-    return EINVAL;
-
-  clockbit = (clockid == CLOCK_REALTIME) ? FUTEX_CLOCK_REALTIME : 0;
-  int op = __lll_private_flag (FUTEX_WAIT_BITSET | clockbit, private);
-
-#ifdef __ASSUME_TIME64_SYSCALLS
-  err = __futex_abstimed_wait_common64 (futex_word, expected, op, abstime,
-					private, cancel);
-#else
-  bool need_time64 = abstime != NULL && !in_int32_t_range (abstime->tv_sec);
-  if (need_time64)
-    {
-      err = __futex_abstimed_wait_common64 (futex_word, expected, op, abstime,
-					    private, cancel);
-      if (err == -ENOSYS)
-	err = -EOVERFLOW;
-    }
-  else
-    err = __futex_abstimed_wait_common32 (futex_word, expected, op, abstime,
-                                          private, cancel);
-#endif
-
-  switch (err)
-    {
-    case 0:
-    case -EAGAIN:
-    case -EINTR:
-    case -ETIMEDOUT:
-    case -EINVAL:
-    case -EOVERFLOW:  /* Passed absolute timeout uses 64 bit time_t type, but
-                         underlying kernel does not support 64 bit time_t futex
-                         syscalls.  */
-      return -err;
-
-    case -EFAULT: /* Must have been caused by a glibc or application bug.  */
-    case -ENOSYS: /* Must have been caused by a glibc bug.  */
-    /* No other errors are documented at this time.  */
-    default:
-      futex_fatal_error ();
-    }
-}
-
 int
 __futex_abstimed_wait64 (unsigned int* futex_word, unsigned int expected,
                          clockid_t clockid,
                          const struct __timespec64* abstime, int private)
 {
-  return __futex_abstimed_wait_common (futex_word, expected, clockid,
-                                       abstime, private, false);
+  return zsys_futex_timedwait ((volatile int *) futex_word, expected, clockid,
+                               abstime, __lll_zsys_private_arg (private));
 }
 libc_hidden_def (__futex_abstimed_wait64)
 
@@ -136,8 +38,8 @@ __futex_abstimed_wait_cancelable64 (unsigned int* futex_word,
                                     const struct __timespec64* abstime,
                                     int private)
 {
-  return __futex_abstimed_wait_common (futex_word, expected, clockid,
-                                       abstime, private, true);
+  return __futex_abstimed_wait64 (futex_word, expected, clockid, abstime,
+                                  private);
 }
 libc_hidden_def (__futex_abstimed_wait_cancelable64)
 
@@ -145,61 +47,7 @@ int
 __futex_lock_pi64 (int *futex_word, clockid_t clockid,
 		   const struct __timespec64 *abstime, int private)
 {
-  int err;
-
-  unsigned int clockbit = clockid == CLOCK_REALTIME
-			  ? FUTEX_CLOCK_REALTIME : 0;
-  int op_pi2 = __lll_private_flag (FUTEX_LOCK_PI2 | clockbit, private);
-#if __ASSUME_FUTEX_LOCK_PI2
-  /* Assume __ASSUME_TIME64_SYSCALLS since FUTEX_LOCK_PI2 was added later.  */
-  err = INTERNAL_SYSCALL_CALL (futex_time64, futex_word, op_pi2, 0, abstime);
-#else
-  /* FUTEX_LOCK_PI does not support clock selection, so for CLOCK_MONOTONIC
-     the only option is to use FUTEX_LOCK_PI2.  */
-  int op_pi1 = __lll_private_flag (FUTEX_LOCK_PI, private);
-  int op_pi = abstime != NULL && clockid != CLOCK_REALTIME ? op_pi2 : op_pi1;
-
-# ifdef __ASSUME_TIME64_SYSCALLS
-  err = INTERNAL_SYSCALL_CALL (futex_time64, futex_word, op_pi, 0, abstime);
-# else
-  bool need_time64 = abstime != NULL && !in_int32_t_range (abstime->tv_sec);
-  if (need_time64)
-    err = INTERNAL_SYSCALL_CALL (futex_time64, futex_word, op_pi, 0, abstime);
-  else
-    {
-      struct timespec ts32, *pts32 = NULL;
-      if (abstime != NULL)
-	{
-	  ts32 = valid_timespec64_to_timespec (*abstime);
-	  pts32 = &ts32;
-	}
-      err = INTERNAL_SYSCALL_CALL (futex, futex_word, op_pi, 0, pts32);
-    }
-# endif	 /* __ASSUME_TIME64_SYSCALLS */
-   /* FUTEX_LOCK_PI2 is not available on this kernel.  */
-   if (err == -ENOSYS)
-     err = -EINVAL;
-#endif /* __ASSUME_FUTEX_LOCK_PI2  */
-
-  switch (err)
-    {
-    case 0:
-    case -EAGAIN:
-    case -EINTR:
-    case -ETIMEDOUT:
-    case -ESRCH:
-    case -EDEADLK:
-    case -EINVAL: /* This indicates either state corruption or that the kernel
-                     found a waiter on futex address which is waiting via
-                     FUTEX_WAIT or FUTEX_WAIT_BITSET.  This is reported on
-                     some futex_lock_pi usage (pthread_mutex_timedlock for
-                     instance).  */
-      return -err;
-
-    case -EFAULT: /* Must have been caused by a glibc or application bug.  */
-    case -ENOSYS: /* Must have been caused by a glibc bug.  */
-    /* No other errors are documented at this time.  */
-    default:
-      futex_fatal_error ();
-    }
+  ZASSERT(clockid == CLOCK_REALTIME); /* FIXME: It would be easy to support monotonic times. */
+  return zsys_futex_lock_pi ((volatile int *) futex_word,
+                             __lll_zsys_private_arg (private), abstime);
 }
diff --git a/nptl/nptl-stack.c b/nptl/nptl-stack.c
index 396f2261411a..eeff439e78ee 100644
--- a/nptl/nptl-stack.c
+++ b/nptl/nptl-stack.c
@@ -19,114 +19,12 @@
 #include <nptl-stack.h>
 #include <ldsodefs.h>
 #include <pthreadP.h>
-
-size_t __nptl_stack_cache_maxsize = 40 * 1024 * 1024;
-int32_t __nptl_stack_hugetlb = 1;
-
-void
-__nptl_stack_list_del (list_t *elem)
-{
-  GL (dl_in_flight_stack) = (uintptr_t) elem;
-
-  atomic_write_barrier ();
-
-  list_del (elem);
-
-  atomic_write_barrier ();
-
-  GL (dl_in_flight_stack) = 0;
-}
-libc_hidden_def (__nptl_stack_list_del)
-
-void
-__nptl_stack_list_add (list_t *elem, list_t *list)
-{
-  GL (dl_in_flight_stack) = (uintptr_t) elem | 1;
-
-  atomic_write_barrier ();
-
-  list_add (elem, list);
-
-  atomic_write_barrier ();
-
-  GL (dl_in_flight_stack) = 0;
-}
-libc_hidden_def (__nptl_stack_list_add)
-
-void
-__nptl_free_stacks (size_t limit)
-{
-  /* We reduce the size of the cache.  Remove the last entries until
-     the size is below the limit.  */
-  list_t *entry;
-  list_t *prev;
-
-  /* Search from the end of the list.  */
-  list_for_each_prev_safe (entry, prev, &GL (dl_stack_cache))
-    {
-      struct pthread *curr;
-
-      curr = list_entry (entry, struct pthread, list);
-      if (__nptl_stack_in_use (curr))
-	{
-	  /* Unlink the block.  */
-	  __nptl_stack_list_del (entry);
-
-	  /* Account for the freed memory.  */
-	  GL (dl_stack_cache_actsize) -= curr->stackblock_size;
-
-	  /* Free the memory associated with the ELF TLS.  */
-	  _dl_deallocate_tls (TLS_TPADJ (curr), false);
-
-	  /* Remove this block.  This should never fail.  If it does
-	     something is really wrong.  */
-	  if (__munmap (curr->stackblock, curr->stackblock_size) != 0)
-	    abort ();
-
-	  /* Maybe we have freed enough.  */
-	  if (GL (dl_stack_cache_actsize) <= limit)
-	    break;
-	}
-    }
-}
-
-/* Add a stack frame which is not used anymore to the stack.  Must be
-   called with the cache lock held.  */
-static inline void
-__attribute ((always_inline))
-queue_stack (struct pthread *stack)
-{
-  /* We unconditionally add the stack to the list.  The memory may
-     still be in use but it will not be reused until the kernel marks
-     the stack as not used anymore.  */
-  __nptl_stack_list_add (&stack->list, &GL (dl_stack_cache));
-
-  GL (dl_stack_cache_actsize) += stack->stackblock_size;
-  if (__glibc_unlikely (GL (dl_stack_cache_actsize)
-			> __nptl_stack_cache_maxsize))
-    __nptl_free_stacks (__nptl_stack_cache_maxsize);
-}
+#include <stdfil.h>
 
 void
 __nptl_deallocate_stack (struct pthread *pd)
 {
-  lll_lock (GL (dl_stack_cache_lock), LLL_PRIVATE);
-
-  /* Remove the thread from the list of threads with user defined
-     stacks.  */
-  __nptl_stack_list_del (&pd->list);
-
-  /* Not much to do.  Just free the mmap()ed memory.  Note that we do
-     not reset the 'used' flag in the 'tid' field.  This is done by
-     the kernel.  If no thread has been created yet this field is
-     still zero.  */
-  if (__glibc_likely (! pd->user_stack))
-    (void) queue_stack (pd);
-  else
-    /* Free the memory associated with the ELF TLS.  */
-    _dl_deallocate_tls (TLS_TPADJ (pd), false);
-
-  lll_unlock (GL (dl_stack_cache_lock), LLL_PRIVATE);
+  zgc_free(pd);
 }
 libc_hidden_def (__nptl_deallocate_stack)
 
@@ -141,7 +39,6 @@ libc_hidden_def (__nptl_deallocate_stack)
 size_t
 __pthread_get_minstack (const pthread_attr_t *attr)
 {
-  return (GLRO(dl_pagesize) + __nptl_tls_static_size_for_stack ()
-	  + PTHREAD_STACK_MIN);
+  return 0; /* FIXME */
 }
 libc_hidden_def (__pthread_get_minstack)
diff --git a/nptl/nptl-stack.h b/nptl/nptl-stack.h
index 6f34b34936b7..d468c4231f52 100644
--- a/nptl/nptl-stack.h
+++ b/nptl/nptl-stack.h
@@ -58,7 +58,7 @@ void __nptl_free_stacks (size_t limit) attribute_hidden;
 static inline size_t
 __nptl_tls_static_size_for_stack (void)
 {
-  return roundup (GLRO (dl_tls_static_size), GLRO (dl_tls_static_align));
+  return 0; /* FIXME: Maybe this should actually give an accurate answer? */
 }
 
 #endif /* _NPTL_STACK_H */
diff --git a/nptl/nptlfreeres.c b/nptl/nptlfreeres.c
index 42e923a69b36..46c07dee8043 100644
--- a/nptl/nptlfreeres.c
+++ b/nptl/nptlfreeres.c
@@ -26,5 +26,4 @@ void
 __libpthread_freeres (void)
 {
   call_function_static_weak (__default_pthread_attr_freeres);
-  __nptl_free_stacks (0);
 }
diff --git a/nptl/pthread_cleanup_upto.c b/nptl/pthread_cleanup_upto.c
index 4f7fa9a0f2b3..48ae5469f23d 100644
--- a/nptl/pthread_cleanup_upto.c
+++ b/nptl/pthread_cleanup_upto.c
@@ -26,36 +26,7 @@ __pthread_cleanup_upto (__jmp_buf target, char *targetframe)
   struct pthread *self = THREAD_SELF;
   struct _pthread_cleanup_buffer *cbuf;
 
-  /* Adjust all pointers used in comparisons, so that top of thread's
-     stack is at the top of address space.  Without that, things break
-     if stack is allocated above the main stack.  */
-  uintptr_t adj = (uintptr_t) self->stackblock + self->stackblock_size;
-  uintptr_t targetframe_adj = (uintptr_t) targetframe - adj;
-
-  for (cbuf = THREAD_GETMEM (self, cleanup);
-       cbuf != NULL && _JMPBUF_UNWINDS_ADJ (target, cbuf, adj);
-       cbuf = cbuf->__prev)
-    {
-#if _STACK_GROWS_DOWN
-      if ((uintptr_t) cbuf - adj <= targetframe_adj)
-        {
-          cbuf = NULL;
-          break;
-        }
-#elif _STACK_GROWS_UP
-      if ((uintptr_t) cbuf - adj >= targetframe_adj)
-        {
-          cbuf = NULL;
-          break;
-        }
-#else
-# error "Define either _STACK_GROWS_DOWN or _STACK_GROWS_UP"
-#endif
-
-      /* Call the cleanup code.  */
-      cbuf->__routine (cbuf->__arg);
-    }
-
-  THREAD_SETMEM (self, cleanup, cbuf);
+  cbuf = THREAD_GETMEM (self, cleanup);
+  ZASSERT(!cbuf);
 }
 libc_hidden_def (__pthread_cleanup_upto)
diff --git a/nptl/pthread_create.c b/nptl/pthread_create.c
index 1d3665d5edb6..dc84f2efd50a 100644
--- a/nptl/pthread_create.c
+++ b/nptl/pthread_create.c
@@ -43,6 +43,9 @@
 
 #include <stap-probe.h>
 
+#include <pizlonated_runtime.h>
+#include <pizlonated_syscalls.h>
+
 
 /* Globally enabled events.  */
 extern td_thr_events_t __nptl_threads_events;
@@ -56,41 +59,9 @@ libc_hidden_proto (__nptl_last_event)
 struct pthread *__nptl_last_event;
 libc_hidden_data_def (__nptl_last_event)
 
-#ifdef SHARED
-/* This variable is used to access _rtld_global from libthread_db.  If
-   GDB loads libpthread before ld.so, it is not possible to resolve
-   _rtld_global directly during libpthread initialization.  */
-struct rtld_global *__nptl_rtld_global = &_rtld_global;
-#endif
-
 /* Version of the library, used in libthread_db to detect mismatches.  */
 const char __nptl_version[] = VERSION;
 
-/* This performs the initialization necessary when going from
-   single-threaded to multi-threaded mode for the first time.  */
-static void
-late_init (void)
-{
-  struct sigaction sa;
-  __sigemptyset (&sa.sa_mask);
-
-  /* Install the handle to change the threads' uid/gid.  Use
-     SA_ONSTACK because the signal may be sent to threads that are
-     running with custom stacks.  (This is less likely for
-     SIGCANCEL.)  */
-  sa.sa_sigaction = __nptl_setxid_sighandler;
-  sa.sa_flags = SA_ONSTACK | SA_SIGINFO | SA_RESTART;
-  (void) __libc_sigaction (SIGSETXID, &sa, NULL);
-
-  /* The parent process might have left the signals blocked.  Just in
-     case, unblock it.  We reuse the signal mask in the sigaction
-     structure.  It is already cleared.  */
-  __sigaddset (&sa.sa_mask, SIGCANCEL);
-  __sigaddset (&sa.sa_mask, SIGSETXID);
-  INTERNAL_SYSCALL_CALL (rt_sigprocmask, SIG_UNBLOCK, &sa.sa_mask,
-			 NULL, __NSIG_BYTES);
-}
-
 /* Code to allocate and deallocate a stack.  */
 #include "allocatestack.c"
 
@@ -228,11 +199,10 @@ late_init (void)
    be set to true iff the thread actually started up but before calling
    the user code (*PD->start_routine).  */
 
-static int _Noreturn start_thread (void *arg);
+static void * start_thread (void *arg);
 
 static int create_thread (struct pthread *pd, const struct pthread_attr *attr,
-			  bool *stopped_start, void *stackaddr,
-			  size_t stacksize, bool *thread_ran)
+			  bool *stopped_start, bool *thread_ran)
 {
   /* Determine whether the newly created threads has to be started
      stopped since we have to set the scheduling parameters or set the
@@ -248,54 +218,7 @@ static int create_thread (struct pthread *pd, const struct pthread_attr *attr,
   if (__glibc_unlikely (*stopped_start))
     lll_lock (pd->lock, LLL_PRIVATE);
 
-  /* We rely heavily on various flags the CLONE function understands:
-
-     CLONE_VM, CLONE_FS, CLONE_FILES
-	These flags select semantics with shared address space and
-	file descriptors according to what POSIX requires.
-
-     CLONE_SIGHAND, CLONE_THREAD
-	This flag selects the POSIX signal semantics and various
-	other kinds of sharing (itimers, POSIX timers, etc.).
-
-     CLONE_SETTLS
-	The sixth parameter to CLONE determines the TLS area for the
-	new thread.
-
-     CLONE_PARENT_SETTID
-	The kernels writes the thread ID of the newly created thread
-	into the location pointed to by the fifth parameters to CLONE.
-
-	Note that it would be semantically equivalent to use
-	CLONE_CHILD_SETTID but it is be more expensive in the kernel.
-
-     CLONE_CHILD_CLEARTID
-	The kernels clears the thread ID of a thread that has called
-	sys_exit() in the location pointed to by the seventh parameter
-	to CLONE.
-
-     The termination signal is chosen to be zero which means no signal
-     is sent.  */
-  const int clone_flags = (CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SYSVSEM
-			   | CLONE_SIGHAND | CLONE_THREAD
-			   | CLONE_SETTLS | CLONE_PARENT_SETTID
-			   | CLONE_CHILD_CLEARTID
-			   | 0);
-
-  TLS_DEFINE_INIT_TP (tp, pd);
-
-  struct clone_args args =
-    {
-      .flags = clone_flags,
-      .pidfd = (uintptr_t) &pd->tid,
-      .parent_tid = (uintptr_t) &pd->tid,
-      .child_tid = (uintptr_t) &pd->tid,
-      .stack = (uintptr_t) stackaddr,
-      .stack_size = stacksize,
-      .tls = (uintptr_t) tp,
-    };
-  int ret = __clone_internal (&args, &start_thread, pd);
-  if (__glibc_unlikely (ret == -1))
+  if (!zthread_create2(start_thread, pd, &pd->zthread, &pd->tid))
     return errno;
 
   /* It's started now, so if we fail below, we'll have to let it clean itself
@@ -333,11 +256,14 @@ static int create_thread (struct pthread *pd, const struct pthread_attr *attr,
 }
 
 /* Local function to start thread and handle cleanup.  */
-static int _Noreturn
+static void *
 start_thread (void *arg)
 {
   struct pthread *pd = arg;
 
+  zthread_set_self_cookie (pd);
+  pd->tid = zthread_self_id();
+
   /* We are either in (a) or (b), and in either case we either own PD already
      (2) or are about to own PD (1), and so our only restriction would be that
      we can't free PD until we know we have ownership (see CONCURRENCY NOTES
@@ -369,26 +295,6 @@ start_thread (void *arg)
   /* Initialize pointers to locale data.  */
   __ctype_init ();
 
-  /* Name the thread stack if kernel supports it.  */
-  name_stack_maps (pd, true);
-
-  /* Register rseq TLS to the kernel.  */
-  {
-    bool do_rseq = THREAD_GETMEM (pd, flags) & ATTR_FLAG_DO_RSEQ;
-    if (!rseq_register_current_thread (pd, do_rseq) && do_rseq)
-      __libc_fatal ("Fatal glibc error: rseq registration failed\n");
-  }
-
-#ifndef __ASSUME_SET_ROBUST_LIST
-  if (__nptl_set_robust_list_avail)
-#endif
-    {
-      /* This call should never fail because the initial call in init.c
-	 succeeded.  */
-      INTERNAL_SYSCALL_CALL (set_robust_list, &pd->robust_head,
-			     sizeof (struct robust_list_head));
-    }
-
   /* This is where the try/finally block should be created.  For
      compilers without that support we do use setjmp.  */
   struct pthread_unwind_buf unwind_buf;
@@ -505,8 +411,7 @@ start_thread (void *arg)
      computing the signal mask, to save stack space.  */
   internal_sigfillset (&pd->sigmask);
   internal_sigdelset (&pd->sigmask, SIGSETXID);
-  INTERNAL_SYSCALL_CALL (rt_sigprocmask, SIG_BLOCK, &pd->sigmask, NULL,
-			 __NSIG_BYTES);
+  ZASSERT (!zsys_sigprocmask (SIG_BLOCK, &pd->sigmask, NULL));
 
   /* Tell __pthread_kill_internal that this thread is about to exit.
      If there is a __pthread_kill_internal in progress, this delays
@@ -549,56 +454,31 @@ start_thread (void *arg)
     }
 #endif
 
-  if (!pd->user_stack)
-    advise_stack_range (pd->stackblock, pd->stackblock_size, (uintptr_t) pd,
-			pd->guardsize);
-
-  if (__glibc_unlikely (pd->cancelhandling & SETXID_BITMASK))
+  /* If the thread is detached free the TCB.  */
+  bool was_detached = false;
+  for (;;)
     {
-      /* Some other thread might call any of the setXid functions and expect
-	 us to reply.  In this case wait until we did that.  */
-      do
-	/* XXX This differs from the typical futex_wait_simple pattern in that
-	   the futex_wait condition (setxid_futex) is different from the
-	   condition used in the surrounding loop (cancelhandling).  We need
-	   to check and document why this is correct.  */
-	futex_wait_simple (&pd->setxid_futex, 0, FUTEX_PRIVATE);
-      while (pd->cancelhandling & SETXID_BITMASK);
-
-      /* Reset the value so that the stack can be reused.  */
-      pd->setxid_futex = 0;
+      struct pthread* joinid = pd->joinid;
+      was_detached = joinid == pd;
+      if (!atomic_compare_and_exchange_bool_acq (&pd->joinid,
+                                                 (struct pthread *) ((char *) joinid + 1),
+                                                 joinid))
+        break;
     }
-
-  /* If the thread is detached free the TCB.  */
-  if (IS_DETACHED (pd))
+  if (was_detached) {
     /* Free the TCB.  */
     __nptl_free_tcb (pd);
-
-  /* Remove the associated name from the thread stack.  */
-  name_stack_maps (pd, false);
+    goto really_done;
+  }
 
 out:
-  /* We cannot call '_exit' here.  '_exit' will terminate the process.
-
-     The 'exit' implementation in the kernel will signal when the
-     process is really dead since 'clone' got passed the CLONE_CHILD_CLEARTID
-     flag.  The 'tid' field in the TCB will be set to zero.
-
-     rseq TLS is still registered at this point.  Rely on implicit
-     unregistration performed by the kernel on thread teardown.  This is not a
-     problem because the rseq TLS lives on the stack, and the stack outlives
-     the thread.  If TCB allocation is ever changed, additional steps may be
-     required, such as performing explicit rseq unregistration before
-     reclaiming the rseq TLS area memory.  It is NOT sufficient to block
-     signals because the kernel may write to the rseq area even without
-     signals.
-
-     The exit code is zero since in case all threads exit by calling
-     'pthread_exit' the exit status must be 0 (zero).  */
-  while (1)
-    INTERNAL_SYSCALL_CALL (exit, 0);
-
+  pd->tid = 0;
+  pd->dead = 1;
+  futex_wake (&pd->dead, -1, FUTEX_PRIVATE);
+really_done:
+  zthread_exit (0);
   /* NOTREACHED */
+  return NULL;
 }
 
 
@@ -624,14 +504,10 @@ int
 __pthread_create_2_1 (pthread_t *newthread, const pthread_attr_t *attr,
 		      void *(*start_routine) (void *), void *arg)
 {
-  void *stackaddr = NULL;
-  size_t stacksize = 0;
-
   /* Avoid a data race in the multi-threaded case, and call the
      deferred initialization only once.  */
   if (__libc_single_threaded_internal)
     {
-      late_init ();
       __libc_single_threaded_internal = 0;
       /* __libc_single_threaded can be accessed through copy relocations, so
 	 it requires to update the external copy.  */
@@ -652,7 +528,7 @@ __pthread_create_2_1 (pthread_t *newthread, const pthread_attr_t *attr,
     }
 
   struct pthread *pd = NULL;
-  int err = allocate_stack (iattr, &pd, &stackaddr, &stacksize);
+  int err = allocate_stack (iattr, &pd);
   int retval = 0;
 
   if (__glibc_unlikely (err != 0))
@@ -689,11 +565,6 @@ __pthread_create_2_1 (pthread_t *newthread, const pthread_attr_t *attr,
   pd->flags = ((iattr->flags & ~(ATTR_FLAG_SCHED_SET | ATTR_FLAG_POLICY_SET))
 	       | (self->flags & (ATTR_FLAG_SCHED_SET | ATTR_FLAG_POLICY_SET)));
 
-  /* Inherit rseq registration state.  Without seccomp filters, rseq
-     registration will either always fail or always succeed.  */
-  if ((int) THREAD_GETMEM_VOLATILE (self, rseq_area.cpu_id) >= 0)
-    pd->flags |= ATTR_FLAG_DO_RSEQ;
-
   /* Initialize the field for the ID of the thread which is waiting
      for us.  This is a self-reference in case the thread is created
      detached.  */
@@ -801,8 +672,7 @@ __pthread_create_2_1 (pthread_t *newthread, const pthread_attr_t *attr,
 
       /* We always create the thread stopped at startup so we can
 	 notify the debugger.  */
-      retval = create_thread (pd, iattr, &stopped_start, stackaddr,
-			      stacksize, &thread_ran);
+      retval = create_thread (pd, iattr, &stopped_start, &thread_ran);
       if (retval == 0)
 	{
 	  /* We retain ownership of PD until (a) (see CONCURRENCY NOTES
@@ -833,8 +703,7 @@ __pthread_create_2_1 (pthread_t *newthread, const pthread_attr_t *attr,
 	}
     }
   else
-    retval = create_thread (pd, iattr, &stopped_start, stackaddr,
-			    stacksize, &thread_ran);
+    retval = create_thread (pd, iattr, &stopped_start, &thread_ran);
 
   /* Return to the previous signal mask, after creating the new
      thread.  */
@@ -945,11 +814,7 @@ __pthread_create_2_0 (pthread_t *newthread, const pthread_attr_t *attr,
 compat_symbol (libpthread, __pthread_create_2_0, pthread_create,
 	       GLIBC_2_0);
 #endif
-
-/* Information for libthread_db.  */
 
-#include "../nptl_db/db_info.c"
-
 /* If pthread_create is present, libgcc_eh.a and libsupc++.a expects some other POSIX thread
    functions to be present as well.  */
 PTHREAD_STATIC_FN_REQUIRE (__pthread_mutex_lock)
diff --git a/nptl/pthread_detach.c b/nptl/pthread_detach.c
index 25eea5263b43..e4b6fd756a67 100644
--- a/nptl/pthread_detach.c
+++ b/nptl/pthread_detach.c
@@ -30,27 +30,40 @@ ___pthread_detach (pthread_t th)
     /* Not a valid thread handle.  */
     return ESRCH;
 
-  int result = 0;
-
-  /* Mark the thread as detached.  */
-  if (atomic_compare_and_exchange_bool_acq (&pd->joinid, pd, NULL))
+  for (;;)
     {
-      /* There are two possibilities here.  First, the thread might
-	 already be detached.  In this case we return EINVAL.
-	 Otherwise there might already be a waiter.  The standard does
-	 not mention what happens in this case.  */
-      if (IS_DETACHED (pd))
-	result = EINVAL;
+      struct pthread *joinid = pd->joinid;
+      /* Here are the possibilities:
+         
+         - joinid == NULL.
+         
+           The thread was joinable. We'll just make it detached instead. Nothing else to do.
+         
+         - joinid == 1.
+           
+           The thread was joinable and is now done executing, but has not deleted pd. So, we have to
+           join it.
+         
+         - joinid == pd or joinid == pd + 1.
+         
+           The thread was already detached. Glibc semantics say that we return EINVAL.
+           
+         - Any other case.
+         
+           The thread is already being joined. Glibc semantics say that we just return 0. */
+
+      if (joinid == (struct pthread *) 1)
+        return __pthread_join(th, NULL);
+
+      if (joinid == pd || joinid == (struct pthread *) ((char*)pd + 1))
+        return EINVAL;
+
+      if (joinid != NULL)
+        return 0;
+
+      if (!atomic_compare_and_exchange_bool_acq (&pd->joinid, pd, NULL))
+        return 0;
     }
-  else
-    /* Check whether the thread terminated meanwhile.  In this case we
-       will just free the TCB.  */
-    if ((pd->cancelhandling & EXITING_BITMASK) != 0)
-      /* Note that the code in __free_tcb makes sure each thread
-	 control block is freed only once.  */
-      __nptl_free_tcb (pd);
-
-  return result;
 }
 versioned_symbol (libc, ___pthread_detach, pthread_detach, GLIBC_2_34);
 libc_hidden_ver (___pthread_detach, __pthread_detach)
diff --git a/nptl/pthread_exit.c b/nptl/pthread_exit.c
index dc2635f82700..9d54e3f4d38e 100644
--- a/nptl/pthread_exit.c
+++ b/nptl/pthread_exit.c
@@ -24,13 +24,6 @@
 void
 __pthread_exit (void *value)
 {
-  {
-    struct unwind_link *unwind_link = __libc_unwind_link_get ();
-    if (unwind_link == NULL)
-      __libc_fatal (LIBGCC_S_SO
-                    " must be installed for pthread_exit to work\n");
-  }
-
   THREAD_SETMEM (THREAD_SELF, result, value);
 
   __do_cancel ();
diff --git a/nptl/pthread_getaffinity.c b/nptl/pthread_getaffinity.c
index 823c4d6d5627..03a3788ae70e 100644
--- a/nptl/pthread_getaffinity.c
+++ b/nptl/pthread_getaffinity.c
@@ -23,6 +23,7 @@
 #include <sys/param.h>
 #include <sys/types.h>
 #include <shlib-compat.h>
+#include <pizlonated_syscalls.h>
 
 
 int
@@ -30,13 +31,12 @@ __pthread_getaffinity_np (pthread_t th, size_t cpusetsize, cpu_set_t *cpuset)
 {
   const struct pthread *pd = (const struct pthread *) th;
 
-  int res = INTERNAL_SYSCALL_CALL (sched_getaffinity, pd->tid,
-				   MIN (INT_MAX, cpusetsize), cpuset);
-  if (INTERNAL_SYSCALL_ERROR_P (res))
-    return INTERNAL_SYSCALL_ERRNO (res);
-
-  /* Clean the rest of the memory the kernel didn't do.  */
-  memset ((char *) cpuset + res, '\0', cpusetsize - res);
+  int saved_errno = errno;
+  int res = zsys_sched_getaffinity (pd->tid, MIN (INT_MAX, cpusetsize), cpuset);
+  int result_errno = errno;
+  errno = saved_errno;
+  if (res < 0)
+    return result_errno;
 
   return 0;
 }
diff --git a/nptl/pthread_join_common.c b/nptl/pthread_join_common.c
index 9c685c79cfd1..7e84f10d0a5b 100644
--- a/nptl/pthread_join_common.c
+++ b/nptl/pthread_join_common.c
@@ -21,6 +21,7 @@
 #include <stap-probe.h>
 #include <time.h>
 #include <futex-internal.h>
+#include <stdfil.h>
 
 static void
 cleanup (void *arg)
@@ -29,7 +30,7 @@ cleanup (void *arg)
      fail for any reason but the thread not having done that yet so
      there is no reason for a loop.  */
   struct pthread *self = THREAD_SELF;
-  atomic_compare_exchange_weak_acquire (&arg, &self, NULL);
+  atomic_compare_and_exchange_bool_acq ((void **) arg, NULL, self);
 }
 
 int
@@ -71,11 +72,19 @@ __pthread_clockjoin_ex (pthread_t threadid, void **thread_return,
 
   /* Wait for the thread to finish.  If it is already locked something
      is wrong.  There can only be one waiter.  */
-  else if (__glibc_unlikely (atomic_compare_exchange_weak_acquire (&pd->joinid,
-								   &self,
-								   NULL)))
-    /* There is already somebody waiting for the thread.  */
-    return EINVAL;
+  else
+    {
+      for (;;)
+        {
+          struct pthread* joinid = pd->joinid;
+          if (joinid != NULL && joinid != (struct pthread *)1)
+            return EINVAL;
+          if (!atomic_compare_and_exchange_bool_acq (&pd->joinid,
+                                                     self,
+                                                     joinid))
+            break;
+        }
+    }
 
   /* BLOCK waits either indefinitely or based on an absolute time.  POSIX also
      states a cancellation point shall occur for pthread_join, and we use the
@@ -90,8 +99,8 @@ __pthread_clockjoin_ex (pthread_t threadid, void **thread_return,
 
       /* We need acquire MO here so that we synchronize with the
          kernel's store to 0 when the clone terminates. (see above)  */
-      pid_t tid;
-      while ((tid = atomic_load_acquire (&pd->tid)) != 0)
+      int dead;
+      while ((dead = atomic_load_acquire (&pd->dead)) == 0)
         {
          /* The kernel notifies a process which uses CLONE_CHILD_CLEARTID via
 	    futex wake-up when the clone terminates.  The memory location
@@ -100,7 +109,7 @@ __pthread_clockjoin_ex (pthread_t threadid, void **thread_return,
 	    does not use the private futex operations for futex wake-up when
 	    the clone terminates.  */
 	  int ret = __futex_abstimed_wait_cancelable64 (
-	    (unsigned int *) &pd->tid, tid, clockid, abstime, LLL_SHARED);
+	    (unsigned int *) &pd->dead, dead, clockid, abstime, LLL_PRIVATE);
 	  if (ret == ETIMEDOUT || ret == EOVERFLOW)
 	    {
 	      result = ret;
diff --git a/nptl/pthread_kill.c b/nptl/pthread_kill.c
index 71e5a7bf5b8b..e85bd6bdb647 100644
--- a/nptl/pthread_kill.c
+++ b/nptl/pthread_kill.c
@@ -20,6 +20,7 @@
 #include <unistd.h>
 #include <pthreadP.h>
 #include <shlib-compat.h>
+#include <pizlonated_runtime.h>
 
 /* Sends SIGNO to THREADID.  If the thread is about to exit or has
    already exited on the kernel side, return NO_TID.  Otherwise return
@@ -28,21 +29,6 @@ static int
 __pthread_kill_implementation (pthread_t threadid, int signo, int no_tid)
 {
   struct pthread *pd = (struct pthread *) threadid;
-  if (pd == THREAD_SELF)
-    {
-      /* Use the actual TID from the kernel, so that it refers to the
-         current thread even if called after vfork.  There is no
-         signal blocking in this case, so that the signal is delivered
-         immediately, before __pthread_kill_internal returns: a signal
-         sent to the thread itself needs to be delivered
-         synchronously.  (It is unclear if Linux guarantees the
-         delivery of all pending signals after unblocking in the code
-         below.  POSIX only guarantees delivery of a single signal,
-         which may not be the right one.)  */
-      pid_t tid = INTERNAL_SYSCALL_CALL (gettid);
-      int ret = INTERNAL_SYSCALL_CALL (tgkill, __getpid (), tid, signo);
-      return INTERNAL_SYSCALL_ERROR_P (ret) ? INTERNAL_SYSCALL_ERRNO (ret) : 0;
-    }
 
   /* Block all signals, as required by pd->exit_lock.  */
   internal_sigset_t old_mask;
@@ -59,8 +45,10 @@ __pthread_kill_implementation (pthread_t threadid, int signo, int no_tid)
     ret = no_tid;
   else
     {
-      ret = INTERNAL_SYSCALL_CALL (tgkill, __getpid (), pd->tid, signo);
-      ret = INTERNAL_SYSCALL_ERROR_P (ret) ? INTERNAL_SYSCALL_ERRNO (ret) : 0;
+      if (zthread_kill (pd->zthread, signo))
+        ret = 0;
+      else
+        ret = errno;
     }
 
   __libc_lock_unlock (pd->exit_lock);
diff --git a/nptl/pthread_mutex_conf.c b/nptl/pthread_mutex_conf.c
index 8aac5f21ff23..be41d0500810 100644
--- a/nptl/pthread_mutex_conf.c
+++ b/nptl/pthread_mutex_conf.c
@@ -41,13 +41,11 @@ TUNABLE_CALLBACK (set_mutex_spin_count) (tunable_val_t *valp)
 static void
 TUNABLE_CALLBACK (set_stack_cache_size) (tunable_val_t *valp)
 {
-  __nptl_stack_cache_maxsize = valp->numval;
 }
 
 static void
 TUNABLE_CALLBACK (set_stack_hugetlb) (tunable_val_t *valp)
 {
-  __nptl_stack_hugetlb = (int32_t) valp->numval;
 }
 
 void
@@ -55,8 +53,4 @@ __pthread_tunables_init (void)
 {
   TUNABLE_GET (mutex_spin_count, int32_t,
                TUNABLE_CALLBACK (set_mutex_spin_count));
-  TUNABLE_GET (stack_cache_size, size_t,
-               TUNABLE_CALLBACK (set_stack_cache_size));
-  TUNABLE_GET (stack_hugetlb, int32_t,
-	       TUNABLE_CALLBACK (set_stack_hugetlb));
 }
diff --git a/nptl/pthread_setaffinity.c b/nptl/pthread_setaffinity.c
index 2dec8f27b5b2..5538a19473a2 100644
--- a/nptl/pthread_setaffinity.c
+++ b/nptl/pthread_setaffinity.c
@@ -20,6 +20,7 @@
 #include <sysdep.h>
 #include <sys/types.h>
 #include <shlib-compat.h>
+#include <pizlonated_syscalls.h>
 
 
 int
@@ -27,14 +28,14 @@ __pthread_setaffinity_new (pthread_t th, size_t cpusetsize,
 			   const cpu_set_t *cpuset)
 {
   const struct pthread *pd = (const struct pthread *) th;
-  int res;
 
-  res = INTERNAL_SYSCALL_CALL (sched_setaffinity, pd->tid, cpusetsize,
-			       cpuset);
-
-  return (INTERNAL_SYSCALL_ERROR_P (res)
-	  ? INTERNAL_SYSCALL_ERRNO (res)
-	  : 0);
+  int saved_errno = errno;
+  int res = zsys_sched_setaffinity (pd->tid, cpusetsize, cpuset);
+  int result_errno = errno;
+  errno = saved_errno;
+  if (res < 0)
+    return result_errno;
+  return 0;
 }
 versioned_symbol (libc, __pthread_setaffinity_new,
 		  pthread_setaffinity_np, GLIBC_2_34);
diff --git a/nptl/pthread_sigmask.c b/nptl/pthread_sigmask.c
index a39f3ca33537..56738f2cfba5 100644
--- a/nptl/pthread_sigmask.c
+++ b/nptl/pthread_sigmask.c
@@ -19,30 +19,12 @@
 #include <pthreadP.h>
 #include <sysdep.h>
 #include <shlib-compat.h>
+#include <pizlonated_syscalls.h>
 
 int
 __pthread_sigmask (int how, const sigset_t *newmask, sigset_t *oldmask)
 {
-  sigset_t local_newmask;
-
-  /* The only thing we have to make sure here is that SIGCANCEL and
-     SIGSETXID is not blocked.  */
-  if (newmask != NULL
-      && (__glibc_unlikely (__sigismember (newmask, SIGCANCEL))
-         || __glibc_unlikely (__sigismember (newmask, SIGSETXID))))
-    {
-      local_newmask = *newmask;
-      clear_internal_signals (&local_newmask);
-      newmask = &local_newmask;
-    }
-
-  /* We know that realtime signals are available if NPTL is used.  */
-  int result = INTERNAL_SYSCALL_CALL (rt_sigprocmask, how, newmask,
-				      oldmask, __NSIG_BYTES);
-
-  return (INTERNAL_SYSCALL_ERROR_P (result)
-	  ? INTERNAL_SYSCALL_ERRNO (result)
-	  : 0);
+  return ((zsys_sigprocmask (how, newmask, oldmask) < 0) ? errno : 0);
 }
 libc_hidden_def (__pthread_sigmask)
 
diff --git a/nptl/pthread_tryjoin.c b/nptl/pthread_tryjoin.c
index 7e4ad5ac4b9a..946706609aa5 100644
--- a/nptl/pthread_tryjoin.c
+++ b/nptl/pthread_tryjoin.c
@@ -23,7 +23,7 @@ __pthread_tryjoin_np (pthread_t threadid, void **thread_return)
 {
   /* Return right away if the thread hasn't terminated yet.  */
   struct pthread *pd = (struct pthread *) threadid;
-  if (pd->tid != 0)
+  if (pd->dead == 0)
     return EBUSY;
 
   /* If pd->tid == 0 then lll_wait_tid will not block on futex
diff --git a/nptl/shlib-versions b/nptl/shlib-versions
index e08931af1a68..b8d559264d1f 100644
--- a/nptl/shlib-versions
+++ b/nptl/shlib-versions
@@ -1 +1 @@
-libpthread=0
+libpthread=6660
diff --git a/nptl/thrd_yield.c b/nptl/thrd_yield.c
index 000e0ae42a31..56d0e570eeac 100644
--- a/nptl/thrd_yield.c
+++ b/nptl/thrd_yield.c
@@ -17,9 +17,10 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include "thrd_priv.h"
+#include <pizlonated_syscalls.h>
 
 void
 thrd_yield (void)
 {
-  INTERNAL_SYSCALL_CALL (sched_yield);
+  zsys_sched_yield ();
 }
diff --git a/nptl/unwind.c b/nptl/unwind.c
index 3688981ef726..61e9ce185083 100644
--- a/nptl/unwind.c
+++ b/nptl/unwind.c
@@ -61,34 +61,7 @@ unwind_stop (int version, _Unwind_Action actions,
 				    adj))
     do_longjump = 1;
 
-  if (__glibc_unlikely (curp != NULL))
-    {
-      /* Handle the compatibility stuff.  Execute all handlers
-	 registered with the old method which would be unwound by this
-	 step.  */
-      struct _pthread_cleanup_buffer *oldp = buf->priv.data.cleanup;
-      void *cfa = (void *) (_Unwind_Ptr) _Unwind_GetCFA (context);
-
-      if (curp != oldp && (do_longjump || FRAME_LEFT (cfa, curp, adj)))
-	{
-	  do
-	    {
-	      /* Pointer to the next element.  */
-	      struct _pthread_cleanup_buffer *nextp = curp->__prev;
-
-	      /* Call the handler.  */
-	      curp->__routine (curp->__arg);
-
-	      /* To the next.  */
-	      curp = nextp;
-	    }
-	  while (curp != oldp
-		 && (do_longjump || FRAME_LEFT (cfa, curp, adj)));
-
-	  /* Mark the current element as handled.  */
-	  THREAD_SETMEM (self, cleanup, curp);
-	}
-    }
+  ZASSERT(!curp);
 
   DIAG_PUSH_NEEDS_COMMENT;
 #if __GNUC_PREREQ (7, 0)
diff --git a/nss/getaddrinfo.c b/nss/getaddrinfo.c
index 3ccd3905fa0f..aa8da5ec5faf 100644
--- a/nss/getaddrinfo.c
+++ b/nss/getaddrinfo.c
@@ -84,6 +84,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <scratch_buffer.h>
 #include <inet/net-internal.h>
 
+#pragma clang diagnostic ignored "-Wsometimes-uninitialized"
+
 /* Former AI_IDN_ALLOW_UNASSIGNED and AI_IDN_USE_STD3_ASCII_RULES
    flags, now ignored.  */
 #define DEPRECATED_AI_IDN 0x300
diff --git a/nss/nss_module.c b/nss/nss_module.c
index 32ab8921a095..b8bf692f55fe 100644
--- a/nss/nss_module.c
+++ b/nss/nss_module.c
@@ -34,6 +34,8 @@
 #include <string.h>
 #include <pointer_guard.h>
 
+#pragma clang diagnostic ignored "-Wstring-plus-int"
+
 /* Suffix after .so of NSS service modules.  This is a bit of magic,
    but we assume LIBNSS_FILES_SO looks like "libnss_files.so.2" and we
    want a pointer to the ".2" part.  We have no API to extract this
diff --git a/posix/Versions b/posix/Versions
index 0624d24bccef..081547d778eb 100644
--- a/posix/Versions
+++ b/posix/Versions
@@ -62,7 +62,6 @@ libc {
     uname;
 
     # v*
-    vfork;
 
     # w*
     wait; wait3; wait4; waitpid;
@@ -86,7 +85,6 @@ libc {
   }
   GLIBC_2.1.2 {
     # functions used in other libraries
-    __vfork;
   }
   GLIBC_2.2 {
     # p*
diff --git a/posix/unistd.h b/posix/unistd.h
index 54d7d7527ee2..d544aefaa31f 100644
--- a/posix/unistd.h
+++ b/posix/unistd.h
@@ -777,15 +777,6 @@ extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
    and the process ID of the new process to the old process.  */
 extern __pid_t fork (void) __THROWNL;
 
-#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8) \
-    || defined __USE_MISC
-/* Clone the calling process, but without copying the whole address space.
-   The calling process is suspended until the new process exits or is
-   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
-   and the process ID of the new process to the old process.  */
-extern __pid_t vfork (void) __THROW;
-#endif /* Use misc or XPG < 7. */
-
 #ifdef __USE_GNU
 /* This is similar to fork, however it does not run the atfork handlers
    neither reinitialize any internal locks in multithread case.
diff --git a/posix/vfork.c b/posix/vfork.c
index de949a7e2d4b..42f26f346cd3 100644
--- a/posix/vfork.c
+++ b/posix/vfork.c
@@ -17,14 +17,5 @@
 
 #include <errno.h>
 #include <unistd.h>
+#include <stdfil.h>
 
-/* If we don't have vfork, fork is close enough.  */
-
-__pid_t
-__vfork (void)
-{
-  return __fork ();
-}
-libc_hidden_def (__vfork)
-
-weak_alias (__vfork, vfork)
diff --git a/resolv/libanl-compat.c b/resolv/libanl-compat.c
index 99058a5b6048..e303aea27948 100644
--- a/resolv/libanl-compat.c
+++ b/resolv/libanl-compat.c
@@ -19,6 +19,7 @@
 #if PTHREAD_IN_LIBC
 # include <shlib-compat.h>
 # include <sys/cdefs.h>
+# include <sched.h>
 
 /* This file is used to keep specific symbol versions occupied, so
    that ld does not generate weak symbol version definitions.  */
@@ -28,6 +29,7 @@ attribute_compat_text_section
 __attribute_used__
 __libanl_version_placeholder_1 (void)
 {
+  sched_yield ();
 }
 
 compat_symbol (libanl, __libanl_version_placeholder_1,
diff --git a/resolv/res_send.c b/resolv/res_send.c
index 9c77613f374e..c3f4c0555839 100644
--- a/resolv/res_send.c
+++ b/resolv/res_send.c
@@ -265,10 +265,7 @@ __res_context_send (struct resolv_context *ctx,
 	   it is a false-positive - see comment in send_vc.
 	   Here the variable n is set to the return value of send_vc.
 	   See below.  */
-	DIAG_PUSH_NEEDS_COMMENT;
-	DIAG_IGNORE_NEEDS_COMMENT (9, "-Wmaybe-uninitialized");
 	int n;
-	DIAG_POP_NEEDS_COMMENT;
 
 	if (statp->nscount == 0) {
 		__set_errno (ESRCH);
@@ -363,11 +360,8 @@ __res_context_send (struct resolv_context *ctx,
 			if (n < 0)
 				return (-1);
 			/* See comment at the declaration of n.  */
-			DIAG_PUSH_NEEDS_COMMENT;
-			DIAG_IGNORE_NEEDS_COMMENT (9, "-Wmaybe-uninitialized");
 			if (n == 0 && (buf2 == NULL || *resplen2 == 0))
 				goto next_ns;
-			DIAG_POP_NEEDS_COMMENT;
 		} else {
 			/* Use datagrams. */
 			n = send_dg(statp, buf, buflen, buf2, buflen2,
@@ -387,8 +381,6 @@ __res_context_send (struct resolv_context *ctx,
 		resplen = n;
 
 		/* See comment at the declaration of n.  Note: resplen = n;  */
-		DIAG_PUSH_NEEDS_COMMENT;
-		DIAG_IGNORE_NEEDS_COMMENT (9, "-Wmaybe-uninitialized");
 		/* Mask the AD bit in both responses unless it is
 		   marked trusted.  */
 		if (resplen > HFIXEDSZ)
@@ -398,7 +390,6 @@ __res_context_send (struct resolv_context *ctx,
 		    else
 		      mask_ad_bit (ctx, ans);
 		  }
-		DIAG_POP_NEEDS_COMMENT;
 		if (resplen2 != NULL && *resplen2 > HFIXEDSZ)
 		  mask_ad_bit (ctx, *ansp2);
 
@@ -579,10 +570,7 @@ send_vc(res_state statp,
 	   times round the loop resplen has been initialized.  So this is
 	   a false-positive.
 	 */
-	DIAG_PUSH_NEEDS_COMMENT;
-	DIAG_IGNORE_NEEDS_COMMENT (5, "-Wmaybe-uninitialized");
 	int resplen;
-	DIAG_POP_NEEDS_COMMENT;
 	struct iovec iov[4];
 	u_short len;
 	u_short len2;
@@ -851,10 +839,7 @@ reopen (res_state statp, int *terrno, int ns)
 		   EXT(statp).nssocks[ns] are initialized together or
 		   the function return -1 before control flow reaches
 		   the call to connect with slen.  */
-		DIAG_PUSH_NEEDS_COMMENT;
-		DIAG_IGNORE_Os_NEEDS_COMMENT (5, "-Wmaybe-uninitialized");
 		if (__connect (EXT (statp).nssocks[ns], nsap, slen) < 0) {
-		DIAG_POP_NEEDS_COMMENT;
 			__res_iclose(statp, false);
 			return (0);
 		}
diff --git a/resolv/resolv_conf.c b/resolv/resolv_conf.c
index 37c2e8bc4f1b..484eb4552c6c 100644
--- a/resolv/resolv_conf.c
+++ b/resolv/resolv_conf.c
@@ -35,7 +35,7 @@
    free list entries (if the LSB is set).  The free list is used to
    speed up finding available entries in the array.  */
 #define DYNARRAY_STRUCT resolv_conf_array
-#define DYNARRAY_ELEMENT uintptr_t
+#define DYNARRAY_ELEMENT struct resolv_conf *
 #define DYNARRAY_PREFIX resolv_conf_array_
 #define DYNARRAY_INITIAL_SIZE 0
 #include <malloc/dynarray-skeleton.c>
@@ -190,10 +190,10 @@ resolv_conf_get_1 (const struct __res_state *resp)
   struct resolv_conf *conf = NULL;
   if (index < resolv_conf_array_size (&global_copy->array))
     {
-      uintptr_t *slot = resolv_conf_array_at (&global_copy->array, index);
-      if (!(*slot & 1))
+      struct resolv_conf **slot = resolv_conf_array_at (&global_copy->array, index);
+      if (!((uintptr_t) *slot & 1))
         {
-          conf = (struct resolv_conf *) *slot;
+          conf = *slot;
           assert (conf->__refcount > 0);
           ++conf->__refcount;
         }
@@ -564,14 +564,14 @@ decrement_at_index (struct resolv_conf_global *global_copy, size_t index)
   if (index < resolv_conf_array_size (&global_copy->array))
     {
       /* Index found.  */
-      uintptr_t *slot = resolv_conf_array_at (&global_copy->array, index);
+      struct resolv_conf **slot = resolv_conf_array_at (&global_copy->array, index);
       /* Check that the slot is not already part of the free list.  */
-      if (!(*slot & 1))
+      if (!((uintptr_t) *slot & 1))
         {
-          struct resolv_conf *conf = (struct resolv_conf *) *slot;
+          struct resolv_conf *conf = *slot;
           conf_decrement (conf);
           /* Put the slot onto the free list.  */
-          *slot = global_copy->free_list_start;
+          *slot = (struct resolv_conf *) global_copy->free_list_start;
           global_copy->free_list_start = (index << 1) | 1;
         }
     }
@@ -593,18 +593,18 @@ __resolv_conf_attach (struct __res_state *resp, struct resolv_conf *conf)
       {
         /* Unlink from the free list.  */
         index = global_copy->free_list_start >> 1;
-        uintptr_t *slot = resolv_conf_array_at (&global_copy->array, index);
-        global_copy->free_list_start = *slot;
+        struct resolv_conf **slot = resolv_conf_array_at (&global_copy->array, index);
+        global_copy->free_list_start = (uintptr_t) *slot;
         assert (global_copy->free_list_start == 0
                 || global_copy->free_list_start & 1);
         /* Install the configuration pointer.  */
-        *slot = (uintptr_t) conf;
+        *slot = conf;
       }
     else
       {
         size_t size = resolv_conf_array_size (&global_copy->array);
         /* No usable index found.  Increase the array size.  */
-        resolv_conf_array_add (&global_copy->array, (uintptr_t) conf);
+        resolv_conf_array_add (&global_copy->array, conf);
         if (resolv_conf_array_has_failed (&global_copy->array))
           {
             put_locked_global (global_copy);
diff --git a/setjmp/Makefile b/setjmp/Makefile
index 1b59095d770a..aa418ad80b1d 100644
--- a/setjmp/Makefile
+++ b/setjmp/Makefile
@@ -25,8 +25,7 @@ include ../Makeconfig
 headers	:= setjmp.h bits/setjmp.h bits/setjmp2.h \
 	   bits/types/struct___jmp_buf_tag.h
 
-routines	:= setjmp sigjmp bsd-setjmp bsd-_setjmp \
-		   longjmp __longjmp jmp-unwind
+routines	:= longjmp
 
 tests		:= tst-setjmp jmpbug bug269-setjmp tst-setjmp-fp \
 		   tst-sigsetjmp tst-setjmp-static
diff --git a/setjmp/longjmp.c b/setjmp/longjmp.c
index c464f84fa154..42a9ace2b2ed 100644
--- a/setjmp/longjmp.c
+++ b/setjmp/longjmp.c
@@ -15,30 +15,16 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
+#include <setjmp.h>
 #include <stddef.h>
-#include <setjmpP.h>
 #include <signal.h>
+#include <pizlonated_runtime.h>
 
-#undef longjmp
-#undef siglongjmp
+#pragma clang diagnostic ignored "-Winvalid-noreturn"
 
-/* Set the signal mask to the one specified in ENV, and jump
-   to the position specified in ENV, causing the setjmp
-   call there to return VAL, or 1 if VAL is 0.  */
-void
-__libc_siglongjmp (sigjmp_buf env, int val)
+void __libc_siglongjmp (sigjmp_buf env, int val)
 {
-  /* Perform any cleanups needed by the frames being unwound.  */
-  _longjmp_unwind (env, val);
-
-  if (env[0].__mask_was_saved)
-    /* Restore the saved signal mask.  */
-    (void) __sigprocmask (SIG_SETMASK,
-			  (sigset_t *) &env[0].__saved_mask,
-			  (sigset_t *) NULL);
-
-  /* Call the machine-dependent function to restore machine state.  */
-  __longjmp (env[0].__jmpbuf, val ?: 1);
+  zlongjmp (*(zjmp_buf**)env, val);
 }
 
 #ifndef __libc_siglongjmp
@@ -50,4 +36,5 @@ strong_alias (__libc_siglongjmp, __libc_longjmp)
 weak_alias (__libc_siglongjmp, _longjmp)
 weak_alias (__libc_siglongjmp, longjmp)
 weak_alias (__libc_siglongjmp, siglongjmp)
+weak_alias (__libc_siglongjmp, __longjmp_chk)
 #endif
diff --git a/setjmp/setjmp.h b/setjmp/setjmp.h
index 1309c6210d17..d064db495adf 100644
--- a/setjmp/setjmp.h
+++ b/setjmp/setjmp.h
@@ -36,9 +36,8 @@ typedef struct __jmp_buf_tag jmp_buf[1];
 extern int setjmp (jmp_buf __env) __THROWNL;
 
 /* Store the calling environment in ENV, also saving the
-   signal mask if SAVEMASK is nonzero.  Return 0.
-   This is the internal name for `sigsetjmp'.  */
-extern int __sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask) __THROWNL;
+   signal mask if SAVEMASK is nonzero.  Return 0.  */
+extern int sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask) __THROWNL;
 
 /* Store the calling environment in ENV, not saving the signal mask.
    Return 0.  */
@@ -69,10 +68,6 @@ extern void _longjmp (struct __jmp_buf_tag __env[1], int __val)
    or not `longjmp' will restore the signal mask.  */
 typedef struct __jmp_buf_tag sigjmp_buf[1];
 
-/* Store the calling environment in ENV, also saving the
-   signal mask if SAVEMASK is nonzero.  Return 0.  */
-# define sigsetjmp(env, savemask)	__sigsetjmp (env, savemask)
-
 /* Jump to the environment saved in ENV, making the
    sigsetjmp call there return VAL, or 1 if VAL is 0.
    Restore the signal mask if that sigsetjmp call saved it.
diff --git a/shlib-versions b/shlib-versions
index b1fd0a5eab4b..202426db9dbe 100644
--- a/shlib-versions
+++ b/shlib-versions
@@ -27,44 +27,44 @@
 ld=ld.so.1
 
 # The -ldl interface (see <dlfcn.h>) is the same on all platforms.
-libdl=2
+libdl=6662
 
 # So far the -lutil interface is the same on all platforms, except for the
 # `struct utmp' format, which depends on libc.
-libutil=1
+libutil=6661
 
 # Version number 2 is used on other systems for the BIND 4.9.5 resolver
 # interface.
-libresolv=2
+libresolv=6662
 
 # Interface revision of nss_* modules.  This must match NSS_SHLIB_REVISION
 # in nss/nsswitch.h, which determines the library names used for service
 # names given in /etc/nsswitch.conf.
-libnss_files=2
-libnss_dns=2
-libnss_compat=2
-libnss_ldap=2
-libnss_hesiod=2
-libnss_db=2
+libnss_files=6662
+libnss_dns=6662
+libnss_compat=6662
+libnss_ldap=6662
+libnss_hesiod=6662
+libnss_db=6662
 
 # Version for libnsl with YP and NIS+ functions.
-libnsl=1
+libnsl=6661
 
 # The gross patch for programs assuming broken locale implementations.
-libBrokenLocale=1
+libBrokenLocale=6661
 
 # The real-time library from POSIX.1b.
-librt=1
+librt=6661
 
 # The asynchronous name lookup library.
-libanl=1
+libanl=6661
 
 # This defines the libgcc soname version this glibc is to load for
 # asynchronous cancellation to work correctly.
-libgcc_s=1
+libgcc_s=6661
 
 # The vector math library
-libmvec=1
+libmvec=6661
 
 # The malloc debug library
-libc_malloc_debug=0
+libc_malloc_debug=6660
diff --git a/stdio-common/Makefile b/stdio-common/Makefile
index 3396090be189..6a7a8cbba60a 100644
--- a/stdio-common/Makefile
+++ b/stdio-common/Makefile
@@ -133,12 +133,12 @@ routines_no_fortify += \
 
 aux := \
   errlist \
-  errlist-data \
+  errlist-data-gen \
   errname \
   fxprintf \
   printf-parsemb \
   printf-parsewc \
-  siglist \
+  siglist-gen \
   # aux
 
 tests := \
@@ -287,13 +287,6 @@ tests-container += \
   tst-popen3
   # tests-container
 
-generated += \
-  errlist-data-aux-shared.S \
-  errlist-data-aux.S \
-  siglist-aux-shared.S \
-  siglist-aux.S \
-  # generated
-
 tests-internal = \
   tst-grouping_iterator \
   # tests-internal
@@ -347,41 +340,6 @@ tests-special += $(objpfx)tst-errno-manual.out
 
 include ../Rules
 
-# The errlist.c is built in two phases because compiler might reorder the
-# compat_symbol directive prior the object itself and on binutils older
-# than 2.29 it might generate object sizes different than the expected ones.
-$(objpfx)errlist-data-aux-shared.S: errlist-data-gen.c
-	$(make-target-directory)
-	$(compile-command.c) $(pic-cppflags) $(pic-ccflag) $(no-stack-protector) -S
-
-$(objpfx)errlist-data-aux.S: errlist-data-gen.c
-	$(make-target-directory)
-	$(compile-command.c) $(pie-default) $(no-stack-protector) -S
-
-ifndef no_deps
--include $(objpfx)errlist-data-aux.S.d $(objpfx)errlist-data-aux-shared.S.d
-endif
-
-$(objpfx)errlist-data.os: $(objpfx)errlist-data-aux-shared.S
-$(addprefix $(objpfx)errlist-data, $(object-suffixes-noshared)): \
-  $(objpfx)errlist-data-aux.S
-
-$(objpfx)siglist-aux-shared.S: siglist-gen.c
-	$(make-target-directory)
-	$(compile-command.c) $(pic-cppflags) $(pic-ccflag) $(no-stack-protector) -S
-
-$(objpfx)siglist-aux.S: siglist-gen.c
-	$(make-target-directory)
-	$(compile-command.c) $(pie-default) $(no-stack-protector) -S
-
-ifndef no_deps
--include $(objpfx)siglist-aux.S.d $(objpfx)siglist-aux-shared.S.d
-endif
-
-$(objpfx)siglist.os: $(objpfx)siglist-aux-shared.S
-$(addprefix $(objpfx)siglist, $(object-suffixes-noshared)): \
-  $(objpfx)siglist-aux.S
-
 ifeq ($(run-built-tests),yes)
 LOCALES := \
   bn_BD.UTF-8 \
diff --git a/stdio-common/vfprintf-internal.c b/stdio-common/vfprintf-internal.c
index 771beca9bf71..0679807fcfed 100644
--- a/stdio-common/vfprintf-internal.c
+++ b/stdio-common/vfprintf-internal.c
@@ -37,6 +37,8 @@
 #include <printf_buffer.h>
 #include <printf_buffer_to_file.h>
 
+#pragma clang diagnostic ignored "-Wtautological-constant-out-of-range-compare"
+
 /* This code is shared between the standard stdio implementation found
    in GNU C library and the libio implementation originally found in
    GNU libg++.
diff --git a/stdio-common/vfscanf-internal.c b/stdio-common/vfscanf-internal.c
index 1b82deffa7f9..1c3c22484ed0 100644
--- a/stdio-common/vfscanf-internal.c
+++ b/stdio-common/vfscanf-internal.c
@@ -1608,7 +1608,6 @@ __vfscanf_internal (FILE *s, const char *format, va_list argptr,
 			 above, but the test for "map != NULL" is done
 			 inside the loop here and outside the loop there.  */
 		      DIAG_PUSH_NEEDS_COMMENT;
-		      DIAG_IGNORE_NEEDS_COMMENT (4.7, "-Wmaybe-uninitialized");
 
 		      if (__glibc_unlikely (map != NULL))
 			wcdigits[n] = digits_extended[n];
diff --git a/stdlib/abort.c b/stdlib/abort.c
index e2b84baac48c..8e6b5e66d855 100644
--- a/stdlib/abort.c
+++ b/stdlib/abort.c
@@ -22,6 +22,7 @@
 #include <string.h>
 #include <unistd.h>
 #include <internal-signals.h>
+#include <stdfil.h>
 
 /* Try to get a machine dependent instruction which will make the
    program crash.  This is used in case everything else fails.  */
@@ -35,84 +36,11 @@
 struct abort_msg_s *__abort_msg;
 libc_hidden_def (__abort_msg)
 
-/* We must avoid to run in circles.  Therefore we remember how far we
-   already got.  */
-static int stage;
-
-/* We should be prepared for multiple threads trying to run abort.  */
-__libc_lock_define_initialized_recursive (static, lock);
-
-
 /* Cause an abnormal program termination with core-dump.  */
 void
 abort (void)
 {
-  struct sigaction act;
-
-  /* First acquire the lock.  */
-  __libc_lock_lock_recursive (lock);
-
-  /* Now it's for sure we are alone.  But recursive calls are possible.  */
-
-  /* Unblock SIGABRT.  */
-  if (stage == 0)
-    {
-      ++stage;
-      internal_sigset_t sigs;
-      internal_sigemptyset (&sigs);
-      internal_sigaddset (&sigs, SIGABRT);
-      internal_sigprocmask (SIG_UNBLOCK, &sigs, NULL);
-    }
-
-  /* Send signal which possibly calls a user handler.  */
-  if (stage == 1)
-    {
-      /* This stage is special: we must allow repeated calls of
-	 `abort' when a user defined handler for SIGABRT is installed.
-	 This is risky since the `raise' implementation might also
-	 fail but I don't see another possibility.  */
-      int save_stage = stage;
-
-      stage = 0;
-      __libc_lock_unlock_recursive (lock);
-
-      raise (SIGABRT);
-
-      __libc_lock_lock_recursive (lock);
-      stage = save_stage + 1;
-    }
-
-  /* There was a handler installed.  Now remove it.  */
-  if (stage == 2)
-    {
-      ++stage;
-      memset (&act, '\0', sizeof (struct sigaction));
-      act.sa_handler = SIG_DFL;
-      __sigfillset (&act.sa_mask);
-      act.sa_flags = 0;
-      __sigaction (SIGABRT, &act, NULL);
-    }
-
-  /* Try again.  */
-  if (stage == 3)
-    {
-      ++stage;
-      raise (SIGABRT);
-    }
-
-  /* Now try to abort using the system specific command.  */
-  if (stage == 4)
-    {
-      ++stage;
-      ABORT_INSTRUCTION;
-    }
-
-  /* If we can't signal ourselves and the abort instruction failed, exit.  */
-  if (stage == 5)
-    {
-      ++stage;
-      _exit (127);
-    }
+  zerror ("abort(3) called.");
 
   /* If even this fails try to use the provided instruction to crash
      or otherwise make sure we never return.  */
diff --git a/stdlib/atexit.c b/stdlib/atexit.c
index e3185c3cf025..1c049aa41ae4 100644
--- a/stdlib/atexit.c
+++ b/stdlib/atexit.c
@@ -43,5 +43,5 @@ attribute_hidden
 #endif
 atexit (void (*func) (void))
 {
-  return __cxa_atexit ((void (*) (void *)) func, NULL, __dso_handle);
+  return __cxa_atexit ((void (*) (void *)) func, NULL, NULL);
 }
diff --git a/stdlib/cxa_thread_atexit_impl.c b/stdlib/cxa_thread_atexit_impl.c
index c215bdd3dd81..2b9b738447b0 100644
--- a/stdlib/cxa_thread_atexit_impl.c
+++ b/stdlib/cxa_thread_atexit_impl.c
@@ -77,90 +77,8 @@
 #include <ldsodefs.h>
 #include <pointer_guard.h>
 
-typedef void (*dtor_func) (void *);
-
-struct dtor_list
-{
-  dtor_func func;
-  void *obj;
-  struct link_map *map;
-  struct dtor_list *next;
-};
-
-static __thread struct dtor_list *tls_dtor_list;
-static __thread void *dso_symbol_cache;
-static __thread struct link_map *lm_cache;
-
-/* Register a destructor for TLS variables declared with the 'thread_local'
-   keyword.  This function is only called from code generated by the C++
-   compiler.  FUNC is the destructor function and OBJ is the object to be
-   passed to the destructor.  DSO_SYMBOL is the __dso_handle symbol that each
-   DSO has at a unique address in its map, added from crtbegin.o during the
-   linking phase.  */
-int
-__cxa_thread_atexit_impl (dtor_func func, void *obj, void *dso_symbol)
-{
-  PTR_MANGLE (func);
-
-  /* Prepend.  */
-  struct dtor_list *new = calloc (1, sizeof (struct dtor_list));
-  if (__glibc_unlikely (new == NULL))
-    __libc_fatal ("Fatal glibc error: failed to register TLS destructor: "
-		  "out of memory\n");
-  new->func = func;
-  new->obj = obj;
-  new->next = tls_dtor_list;
-  tls_dtor_list = new;
-
-  /* We have to acquire the big lock to prevent a racing dlclose from pulling
-     our DSO from underneath us while we're setting up our destructor.  */
-  __rtld_lock_lock_recursive (GL(dl_load_lock));
-
-  /* See if we already encountered the DSO.  */
-  if (__glibc_unlikely (dso_symbol_cache != dso_symbol))
-    {
-      ElfW(Addr) caller = (ElfW(Addr)) dso_symbol;
-
-      struct link_map *l = _dl_find_dso_for_object (caller);
-
-      /* If the address is not recognized the call comes from the main
-	 program (we hope).  */
-      lm_cache = l ? l : GL(dl_ns)[LM_ID_BASE]._ns_loaded;
-    }
-
-  /* This increment may only be concurrently observed either by the decrement
-     in __call_tls_dtors since the other l_tls_dtor_count access in
-     _dl_close_worker is protected by the dl_load_lock.  The execution in
-     __call_tls_dtors does not really depend on this value beyond the fact that
-     it should be atomic, so Relaxed MO should be sufficient.  */
-  atomic_fetch_add_relaxed (&lm_cache->l_tls_dtor_count, 1);
-  __rtld_lock_unlock_recursive (GL(dl_load_lock));
-
-  new->map = lm_cache;
-
-  return 0;
-}
-
-/* Call the destructors.  This is called either when a thread returns from the
-   initial function or when the process exits via the exit function.  */
 void
 __call_tls_dtors (void)
 {
-  while (tls_dtor_list)
-    {
-      struct dtor_list *cur = tls_dtor_list;
-      dtor_func func = cur->func;
-      PTR_DEMANGLE (func);
-
-      tls_dtor_list = tls_dtor_list->next;
-      func (cur->obj);
-
-      /* Ensure that the MAP dereference happens before
-	 l_tls_dtor_count decrement.  That way, we protect this access from a
-	 potential DSO unload in _dl_close_worker, which happens when
-	 l_tls_dtor_count is 0.  See CONCURRENCY NOTES for more detail.  */
-      atomic_fetch_add_release (&cur->map->l_tls_dtor_count, -1);
-      free (cur);
-    }
 }
 libc_hidden_def (__call_tls_dtors)
diff --git a/stdlib/exit.c b/stdlib/exit.c
index 5166c7804433..bbf6cbf698ff 100644
--- a/stdlib/exit.c
+++ b/stdlib/exit.c
@@ -22,6 +22,7 @@
 #include <libc-lock.h>
 #include <set-freeres.h>
 #include "exit.h"
+#include <pizlonated_syscalls.h>
 
 /* Initialize the flag that indicates exit function processing
    is complete. See concurrency notes in stdlib/exit.h where
@@ -128,7 +129,8 @@ __run_exit_handlers (int status, struct exit_function_list **listp,
   if (run_list_atexit)
     call_function_static_weak (_IO_cleanup);
 
-  _exit (status);
+#pragma clang diagnostic ignored "-Winvalid-noreturn"
+  zsys_exit_soft (status);
 }
 
 
diff --git a/stdlib/longlong.h b/stdlib/longlong.h
index 241b2f0f99a9..2d44e5fe3b95 100644
--- a/stdlib/longlong.h
+++ b/stdlib/longlong.h
@@ -110,6 +110,10 @@ extern const UQItype __clz_tab[256] attribute_hidden;
    for the CPUs below!
    (E.g. WE32100, IBM360.)  */
 
+#ifndef NO_ASM
+#define NO_ASM 1
+#endif
+
 #if defined (__GNUC__) && !defined (NO_ASM)
 
 /* We sometimes need to clobber "cc" with gcc2, but that would not be
diff --git a/stdlib/qsort.c b/stdlib/qsort.c
index be47aebbe05b..210a5c404880 100644
--- a/stdlib/qsort.c
+++ b/stdlib/qsort.c
@@ -128,15 +128,6 @@ heapify (void *base, size_t size, size_t n, enum swap_type_t swap_type,
 static enum swap_type_t
 get_swap_type (void *const pbase, size_t size)
 {
-  if ((size & (sizeof (uint32_t) - 1)) == 0
-      && ((uintptr_t) pbase) % __alignof__ (uint32_t) == 0)
-    {
-      if (size == sizeof (uint32_t))
-	return SWAP_WORDS_32;
-      else if (size == sizeof (uint64_t)
-	       && ((uintptr_t) pbase) % __alignof__ (uint64_t) == 0)
-	return SWAP_WORDS_64;
-    }
   return SWAP_BYTES;
 }
 
diff --git a/stdlib/setenv.c b/stdlib/setenv.c
index e2164371ade8..de31bde114b5 100644
--- a/stdlib/setenv.c
+++ b/stdlib/setenv.c
@@ -24,7 +24,7 @@
    there seems to be no way to pacify GCC selectively, only for the
    place where it's needed.  Do not use DIAG_IGNORE_NEEDS_COMMENT
    here, as it's not defined yet.  */
-#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
+/* #pragma GCC diagnostic ignored "-Wmaybe-uninitialized" */
 
 #include <errno.h>
 #if !_LIBC
diff --git a/string/memchr.c b/string/memchr.c
index 08b5c416677a..81c6e10f098e 100644
--- a/string/memchr.c
+++ b/string/memchr.c
@@ -22,6 +22,7 @@
 #include <string-fzi.h>
 #include <string-shift.h>
 #include <string.h>
+#include <stdfil.h>
 
 #undef memchr
 
@@ -51,7 +52,7 @@ __memchr (void const *s, int c_in, size_t n)
   op_t repeated_c = repeat_bytes (c_in);
   /* Compute the address of the last byte taking in consideration possible
      overflow.  */
-  const char *lbyte = sadd (s_int, n - 1);
+  const char *lbyte = zmkptr ((void *) s, (uintptr_t) sadd (s_int, n - 1));
   /* And also the address of the word containing the last byte. */
   const op_t *lword = (const op_t *) PTR_ALIGN_DOWN (lbyte, sizeof (op_t));
 
diff --git a/string/memmove.c b/string/memmove.c
index 3fad5f11acdf..dc2d42dd2466 100644
--- a/string/memmove.c
+++ b/string/memmove.c
@@ -19,6 +19,7 @@
 
 #include <string.h>
 #include <memcopy.h>
+#include <stdfil.h>
 
 /* All this is so that bcopy.c can #include
    this file after defining some things.  */
@@ -39,74 +40,9 @@
 #endif
 
 rettype
-inhibit_loop_to_libcall
 MEMMOVE (a1const void *a1, a2const void *a2, size_t len)
 {
-  unsigned long int dstp = (long int) dest;
-  unsigned long int srcp = (long int) src;
-
-  /* This test makes the forward copying code be used whenever possible.
-     Reduces the working set.  */
-  if (dstp - srcp >= len)	/* *Unsigned* compare!  */
-    {
-      /* Copy from the beginning to the end.  */
-
-#if MEMCPY_OK_FOR_FWD_MEMMOVE
-      dest = memcpy (dest, src, len);
-#else
-      /* If there not too few bytes to copy, use word copy.  */
-      if (len >= OP_T_THRES)
-	{
-	  /* Copy just a few bytes to make DSTP aligned.  */
-	  len -= (-dstp) % OPSIZ;
-	  BYTE_COPY_FWD (dstp, srcp, (-dstp) % OPSIZ);
-
-	  /* Copy whole pages from SRCP to DSTP by virtual address
-	     manipulation, as much as possible.  */
-
-	  PAGE_COPY_FWD_MAYBE (dstp, srcp, len, len);
-
-	  /* Copy from SRCP to DSTP taking advantage of the known
-	     alignment of DSTP.  Number of bytes remaining is put
-	     in the third argument, i.e. in LEN.  This number may
-	     vary from machine to machine.  */
-
-	  WORD_COPY_FWD (dstp, srcp, len, len);
-
-	  /* Fall out and copy the tail.  */
-	}
-
-      /* There are just a few bytes to copy.  Use byte memory operations.  */
-      BYTE_COPY_FWD (dstp, srcp, len);
-#endif /* MEMCPY_OK_FOR_FWD_MEMMOVE */
-    }
-  else
-    {
-      /* Copy from the end to the beginning.  */
-      srcp += len;
-      dstp += len;
-
-      /* If there not too few bytes to copy, use word copy.  */
-      if (len >= OP_T_THRES)
-	{
-	  /* Copy just a few bytes to make DSTP aligned.  */
-	  len -= dstp % OPSIZ;
-	  BYTE_COPY_BWD (dstp, srcp, dstp % OPSIZ);
-
-	  /* Copy from SRCP to DSTP taking advantage of the known
-	     alignment of DSTP.  Number of bytes remaining is put
-	     in the third argument, i.e. in LEN.  This number may
-	     vary from machine to machine.  */
-
-	  WORD_COPY_BWD (dstp, srcp, len, len);
-
-	  /* Fall out and copy the tail.  */
-	}
-
-      /* There are just a few bytes to copy.  Use byte memory operations.  */
-      BYTE_COPY_BWD (dstp, srcp, len);
-    }
-
+  zmemmove(a1, (void *) a2, len);
   RETURN (dest);
 }
 #ifndef memmove
diff --git a/string/memset.c b/string/memset.c
index 64e382a0df67..a5c049199e1c 100644
--- a/string/memset.c
+++ b/string/memset.c
@@ -17,74 +17,16 @@
 
 #include <string.h>
 #include <memcopy.h>
+#include <stdfil.h>
 
 #ifndef MEMSET
 # define MEMSET memset
 #endif
 
 void *
-inhibit_loop_to_libcall
 MEMSET (void *dstpp, int c, size_t len)
 {
-  long int dstp = (long int) dstpp;
-
-  if (len >= 8)
-    {
-      size_t xlen;
-      op_t cccc;
-
-      cccc = (unsigned char) c;
-      cccc |= cccc << 8;
-      cccc |= cccc << 16;
-      if (OPSIZ > 4)
-	/* Do the shift in two steps to avoid warning if long has 32 bits.  */
-	cccc |= (cccc << 16) << 16;
-
-      /* There are at least some bytes to set.
-	 No need to test for LEN == 0 in this alignment loop.  */
-      while (dstp % OPSIZ != 0)
-	{
-	  ((byte *) dstp)[0] = c;
-	  dstp += 1;
-	  len -= 1;
-	}
-
-      /* Write 8 `op_t' per iteration until less than 8 `op_t' remain.  */
-      xlen = len / (OPSIZ * 8);
-      while (xlen > 0)
-	{
-	  ((op_t *) dstp)[0] = cccc;
-	  ((op_t *) dstp)[1] = cccc;
-	  ((op_t *) dstp)[2] = cccc;
-	  ((op_t *) dstp)[3] = cccc;
-	  ((op_t *) dstp)[4] = cccc;
-	  ((op_t *) dstp)[5] = cccc;
-	  ((op_t *) dstp)[6] = cccc;
-	  ((op_t *) dstp)[7] = cccc;
-	  dstp += 8 * OPSIZ;
-	  xlen -= 1;
-	}
-      len %= OPSIZ * 8;
-
-      /* Write 1 `op_t' per iteration until less than OPSIZ bytes remain.  */
-      xlen = len / OPSIZ;
-      while (xlen > 0)
-	{
-	  ((op_t *) dstp)[0] = cccc;
-	  dstp += OPSIZ;
-	  xlen -= 1;
-	}
-      len %= OPSIZ;
-    }
-
-  /* Write the last few bytes.  */
-  while (len > 0)
-    {
-      ((byte *) dstp)[0] = c;
-      dstp += 1;
-      len -= 1;
-    }
-
+  zmemset(dstpp, c, len);
   return dstpp;
 }
 libc_hidden_builtin_def (MEMSET)
diff --git a/string/string.h b/string/string.h
index d2d5c5f1f914..04788a8e4f63 100644
--- a/string/string.h
+++ b/string/string.h
@@ -542,13 +542,6 @@ extern char *basename (const char *__filename) __THROW __nonnull ((1));
 # endif
 #endif
 
-#if __GNUC_PREREQ (3,4)
-# if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function
-/* Functions with security checks.  */
-#  include <bits/string_fortified.h>
-# endif
-#endif
-
 __END_DECLS
 
 #endif /* string.h  */
diff --git a/string/wordcopy.c b/string/wordcopy.c
index 4e77cdb13294..0f2197568c6b 100644
--- a/string/wordcopy.c
+++ b/string/wordcopy.c
@@ -28,10 +28,7 @@
 
    Since the usage is within the MERGE macro we disable the
    warning in the definition, but only in this file.  */
-DIAG_PUSH_NEEDS_COMMENT;
-DIAG_IGNORE_NEEDS_COMMENT (6, "-Wmaybe-uninitialized");
 #include <memcopy.h>
-DIAG_POP_NEEDS_COMMENT;
 
 /* _wordcopy_fwd_aligned -- Copy block beginning at SRCP to
    block beginning at DSTP with LEN `op_t' words (not LEN bytes!).
@@ -111,10 +108,7 @@ WORDCOPY_FWD_ALIGNED (long int dstp, long int srcp, size_t len)
 	 do-while loop iteration or directly via the earlier switch 'case 1:'
 	 case. The switch case always sets 'a1' and all previous loop
 	 iterations will also have set 'a1' before the use.  */
-      DIAG_PUSH_NEEDS_COMMENT;
-      DIAG_IGNORE_NEEDS_COMMENT (6, "-Wmaybe-uninitialized");
       ((op_t *) dstp)[0] = a1;
-      DIAG_POP_NEEDS_COMMENT;
     do7:
       a1 = ((op_t *) srcp)[1];
       ((op_t *) dstp)[1] = a0;
@@ -312,10 +306,7 @@ WORDCOPY_BWD_ALIGNED (long int dstp, long int srcp, size_t len)
     do8:
       a0 = ((op_t *) srcp)[7];
       /* Check the comment on WORDCOPY_FWD_ALIGNED.  */
-      DIAG_PUSH_NEEDS_COMMENT;
-      DIAG_IGNORE_NEEDS_COMMENT (6, "-Wmaybe-uninitialized");
       ((op_t *) dstp)[7] = a1;
-      DIAG_POP_NEEDS_COMMENT;
     do7:
       a1 = ((op_t *) srcp)[6];
       ((op_t *) dstp)[6] = a0;
diff --git a/sunrpc/clnt_udp.c b/sunrpc/clnt_udp.c
index ee79b09b40e7..e7e37ac9488d 100644
--- a/sunrpc/clnt_udp.c
+++ b/sunrpc/clnt_udp.c
@@ -298,10 +298,7 @@ clntudp_call (/* client handle */
      condition.  The same warning is also disabled in
      inet/net-internal.h because in some other configurations GCC
      gives the warning in an inline function.  */
-  DIAG_PUSH_NEEDS_COMMENT;
-  DIAG_IGNORE_NEEDS_COMMENT (10, "-Wmaybe-uninitialized");
   struct deadline total_deadline; /* Determined once by overall timeout.  */
-  DIAG_POP_NEEDS_COMMENT;
   struct deadline response_deadline; /* Determined anew for each query.  */
 
   /* Choose the timeout value.  For non-sending usage (xargs == NULL),
diff --git a/sunrpc/key_call.c b/sunrpc/key_call.c
index b0b29e09a7fa..bbf6020cfea6 100644
--- a/sunrpc/key_call.c
+++ b/sunrpc/key_call.c
@@ -51,6 +51,8 @@
 #include <libc-lock.h>
 #include <shlib-compat.h>
 
+#pragma clang diagnostic ignored "-Wparentheses-equality"
+
 #define KEY_TIMEOUT	5	/* per-try timeout in seconds */
 #define KEY_NRETRY	12	/* number of retries */
 
diff --git a/sunrpc/svc_unix.c b/sunrpc/svc_unix.c
index 8363669c091b..db66a4eeb672 100644
--- a/sunrpc/svc_unix.c
+++ b/sunrpc/svc_unix.c
@@ -66,6 +66,8 @@
 #include <wchar.h>
 #include <shlib-compat.h>
 
+#pragma clang diagnostic ignored "-Wgnu-variable-sized-type-not-at-end"
+
 /*
  * Ops vector for AF_UNIX based rpc service handle
  */
diff --git a/support/Makefile b/support/Makefile
index aa57207bdccc..d3841f671dc9 100644
--- a/support/Makefile
+++ b/support/Makefile
@@ -301,9 +301,9 @@ others-noinstall += \
 others += $(LINKS_DSO_PROGRAM)
 others-noinstall += $(LINKS_DSO_PROGRAM)
 
-others += test-run-command
-others-static += test-run-command
-others-noinstall += test-run-command
+others += 
+others-static += 
+others-noinstall += 
 LDLIBS-test-run-command = $(libsupport)
 
 $(objpfx)test-container : $(libsupport)
diff --git a/support/dtotimespec.c b/support/dtotimespec.c
index 106b64f4861b..6bf380510564 100644
--- a/support/dtotimespec.c
+++ b/support/dtotimespec.c
@@ -23,6 +23,8 @@
 #include <support/timespec.h>
 #include <intprops.h>
 
+#pragma clang diagnostic ignored "-Wimplicit-const-int-float-conversion"
+
 struct timespec
 dtotimespec (double sec)
 {
diff --git a/sysdeps/generic/ldsodefs.h b/sysdeps/generic/ldsodefs.h
index 259ce2e7d6e8..4f7a86c4f44c 100644
--- a/sysdeps/generic/ldsodefs.h
+++ b/sysdeps/generic/ldsodefs.h
@@ -290,19 +290,8 @@ typedef void (*receiver_fct) (int, const char *, const char *);
    user interface to run-time dynamic linking.  */
 
 
-#ifndef SHARED
-# define EXTERN extern
-# define GL(name) _##name
-#else
-# define EXTERN
-# if IS_IN (rtld)
-#  define GL(name) _rtld_local._##name
-# else
-#  define GL(name) _rtld_global._##name
-# endif
-struct rtld_global
-{
-#endif
+#define EXTERN extern
+#define GL(name) _##name
   /* Don't change the order of the following elements.  'dl_loaded'
      must remain the first element.  Forever.  */
 
@@ -397,7 +386,7 @@ struct rtld_global
 #ifdef SHARED
   /* Used to store the audit information for the link map of the
      dynamic loader.  */
-  struct auditstate _dl_rtld_auditstate[DL_NNS];
+  EXTERN struct auditstate _dl_rtld_auditstate[DL_NNS];
 #endif
 
 #if !PTHREAD_IN_LIBC && defined SHARED \
@@ -498,36 +487,8 @@ struct rtld_global
   EXTERN struct __pthread **_dl_pthread_threads;
   __libc_rwlock_define (EXTERN, _dl_pthread_threads_lock)
 #endif
-#ifdef SHARED
-};
-# define __rtld_global_attribute__
-# if IS_IN (rtld)
-#  ifdef HAVE_SDATA_SECTION
-#   define __rtld_local_attribute__ \
-	    __attribute__ ((visibility ("hidden"), section (".sdata")))
-#   undef __rtld_global_attribute__
-#   define __rtld_global_attribute__ __attribute__ ((section (".sdata")))
-#  else
-#   define __rtld_local_attribute__ __attribute__ ((visibility ("hidden")))
-#  endif
-extern struct rtld_global _rtld_local __rtld_local_attribute__;
-#  undef __rtld_local_attribute__
-# endif
-extern struct rtld_global _rtld_global __rtld_global_attribute__;
-# undef __rtld_global_attribute__
-#endif
 
-#ifndef SHARED
-# define GLRO(name) _##name
-#else
-# if IS_IN (rtld)
-#  define GLRO(name) _rtld_local_ro._##name
-# else
-#  define GLRO(name) _rtld_global_ro._##name
-# endif
-struct rtld_global_ro
-{
-#endif
+#define GLRO(name) _##name
 
   /* If nonzero the appropriate debug information is printed.  */
   EXTERN int _dl_debug_mask;
@@ -652,46 +613,6 @@ struct rtld_global_ro
   EXTERN enum dso_sort_algorithm _dl_dso_sort_algo;
 
 #ifdef SHARED
-  /* We add a function table to _rtld_global which is then used to
-     call the function instead of going through the PLT.  The result
-     is that we can avoid exporting the functions and we do not jump
-     PLT relocations in libc.so.  */
-  void (*_dl_debug_printf) (const char *, ...)
-       __attribute__ ((__format__ (__printf__, 1, 2)));
-  void (*_dl_mcount) (ElfW(Addr) frompc, ElfW(Addr) selfpc);
-  lookup_t (*_dl_lookup_symbol_x) (const char *, struct link_map *,
-				   const ElfW(Sym) **, struct r_scope_elem *[],
-				   const struct r_found_version *, int, int,
-				   struct link_map *);
-  void *(*_dl_open) (const char *file, int mode, const void *caller_dlopen,
-		     Lmid_t nsid, int argc, char *argv[], char *env[]);
-  void (*_dl_close) (void *map);
-  /* libdl in a secondary namespace (after dlopen) must use
-     _dl_catch_error from the main namespace, so it has to be
-     exported in some way.  */
-  int (*_dl_catch_error) (const char **objname, const char **errstring,
-			  bool *mallocedp, void (*operate) (void *),
-			  void *args);
-  /* libdl in a secondary namespace must use free from the base
-     namespace.  */
-  void (*_dl_error_free) (void *);
-  void *(*_dl_tls_get_addr_soft) (struct link_map *);
-
-  /* Called from __libc_shared to deallocate malloc'ed memory.  */
-  void (*_dl_libc_freeres) (void);
-
-  /* Implementation of _dl_find_object.  The public entry point is in
-     libc, and this is patched by __rtld_static_init to support static
-     dlopen.  */
-  int (*_dl_find_object) (void *, struct dl_find_object *);
-
-  /* Dynamic linker operations used after static dlopen.  */
-  const struct dlfcn_hook *_dl_dlfcn_hook;
-
-  /* List of auditing interfaces.  */
-  struct audit_ifaces *_dl_audit;
-  unsigned int _dl_naudit;
-};
 # define __rtld_global_attribute__
 # if IS_IN (rtld)
 #  define __rtld_local_attribute__ __attribute__ ((visibility ("hidden")))
@@ -703,7 +624,7 @@ extern struct rtld_global_ro _rtld_global_ro
 # else
 /* We cheat a bit here.  We declare the variable as as const even
    though it is at startup.  */
-extern const struct rtld_global_ro _rtld_global_ro
+extern struct rtld_global_ro _rtld_global_ro
     attribute_relro __rtld_global_attribute__;
 # endif
 # undef __rtld_global_attribute__
@@ -1165,12 +1086,12 @@ void __tls_pre_init_tp (void) attribute_hidden;
    initialization of the thread library.  */
 void __tls_init_tp (void) attribute_hidden;
 
-#ifndef SHARED
 /* Set up the TCB for statically linked applications.  This is called
    early during startup because we always use TLS (for errno and the
    stack protector, among other things).  */
 void __libc_setup_tls (void);
 
+#ifndef SHARED
 # if ENABLE_STATIC_PIE
 /* Relocate static executable with PIE.  */
 extern void _dl_relocate_static_pie (void) attribute_hidden;
diff --git a/sysdeps/generic/libc-symver.h b/sysdeps/generic/libc-symver.h
index 7dd4762a7046..b674a902a431 100644
--- a/sysdeps/generic/libc-symver.h
+++ b/sysdeps/generic/libc-symver.h
@@ -44,7 +44,7 @@
      .symver real, name##@##version
 #else
 # define symbol_version_reference(real, name, version) \
-  __asm__ (".symver " #real "," #name "@" #version)
+  __asm__ (".filc_symver " #real "," #name "@" #version)
 #endif  /* !__ASSEMBLER__ */
 
 #if SYMVER_NEEDS_ALIAS
@@ -63,9 +63,8 @@
   .symver alias, name_version
 # else
 #  define _set_symbol_version_2(real, alias, name_version) \
-  __asm__ (".globl " #alias "\n\t"                         \
-           ".equiv " #alias ", " #real "\n\t"              \
-           ".symver " #alias "," name_version)
+  __asm__ (".filc_alias " #real ", " #alias "\n\t"         \
+           ".filc_symver " #alias ", " name_version)
 # endif
 # define _set_symbol_version_1(real, alias, name_version) \
   _set_symbol_version_2 (real, alias, name_version)
@@ -80,7 +79,7 @@
   .symver real, name_version
 # else
 #  define _set_symbol_version(real, name_version) \
-  __asm__ (".symver " #real "," name_version)
+  __asm__ (".filc_symver " #real "," name_version)
 # endif
 #endif  /* !SYMVER_NEEDS_ALIAS */
 
diff --git a/sysdeps/generic/memswap.h b/sysdeps/generic/memswap.h
index 49b9a3dc9404..027a0d13370d 100644
--- a/sysdeps/generic/memswap.h
+++ b/sysdeps/generic/memswap.h
@@ -32,10 +32,7 @@ __memswap (void *__restrict p1, void *__restrict p2, size_t n)
       p2 = __mempcpy (p2, tmp, SWAP_GENERIC_SIZE);
       n -= SWAP_GENERIC_SIZE;
     }
-  while (n > 0)
-    {
-      unsigned char t = ((unsigned char *)p1)[--n];
-      ((unsigned char *)p1)[n] = ((unsigned char *)p2)[n];
-      ((unsigned char *)p2)[n] = t;
-    }
+  memcpy (tmp, p1, n);
+  memcpy (p1, p2, n);
+  memcpy (p2, tmp, n);
 }
diff --git a/sysdeps/generic/symbol-hacks.h b/sysdeps/generic/symbol-hacks.h
index 1115e4c0a7af..d9269dac46ae 100644
--- a/sysdeps/generic/symbol-hacks.h
+++ b/sysdeps/generic/symbol-hacks.h
@@ -1,20 +1 @@
-/* Some compiler optimizations may transform loops into memset/memmove
-   calls and without proper declaration it may generate PLT calls.  */
-#if !defined __ASSEMBLER__ && IS_IN (libc) && defined SHARED \
-    && !defined LIBC_NONSHARED
-asm ("memmove = __GI_memmove");
-asm ("memset = __GI_memset");
-asm ("memcpy = __GI_memcpy");
-
-/* Some targets do not use __stack_chk_fail_local.  In libc.so,
-   redirect __stack_chk_fail to a hidden reference
-   __stack_chk_fail_local, to avoid the PLT reference.
-   __stack_chk_fail itself is a global symbol, exported from libc.so,
-   and cannot be made hidden.  */
-
-# if IS_IN (libc) && defined SHARED \
-  && defined STACK_PROTECTOR_LEVEL && STACK_PROTECTOR_LEVEL > 0
-asm (".hidden __stack_chk_fail_local\n"
-     "__stack_chk_fail = __stack_chk_fail_local");
-# endif
-#endif
+/* In Fil-C we don't need any of this stuff. */
diff --git a/sysdeps/generic/unwind-resume.c b/sysdeps/generic/unwind-resume.c
index 90f45302bb66..a647f969860b 100644
--- a/sysdeps/generic/unwind-resume.c
+++ b/sysdeps/generic/unwind-resume.c
@@ -21,39 +21,3 @@
 #include <sysdep.h>
 #include <unwind-resume.h>
 
-static struct unwind_link *
-link (void)
-{
-  struct unwind_link *unwind_link = __libc_unwind_link_get ();
-  if (unwind_link == NULL)
-    __libc_fatal (LIBGCC_S_SO " must be installed for unwinding to work\n");
-  return unwind_link;
-}
-
-#if !HAVE_ARCH_UNWIND_RESUME
-void
-_Unwind_Resume (struct _Unwind_Exception *exc)
-{
-  UNWIND_LINK_PTR (link (), _Unwind_Resume) (exc);
-}
-#endif
-
-_Unwind_Reason_Code
-__gcc_personality_v0 PERSONALITY_PROTO
-{
-  return UNWIND_LINK_PTR (link (), personality) PERSONALITY_ARGS;
-}
-
-_Unwind_Reason_Code
-_Unwind_ForcedUnwind (struct _Unwind_Exception *exc, _Unwind_Stop_Fn stop,
-                      void *stop_argument)
-{
-  return UNWIND_LINK_PTR (link (), _Unwind_ForcedUnwind)
-    (exc, stop, stop_argument);
-}
-
-_Unwind_Word
-_Unwind_GetCFA (struct _Unwind_Context *context)
-{
-  return UNWIND_LINK_PTR (link (), _Unwind_GetCFA) (context);
-}
diff --git a/sysdeps/ieee754/dbl-64/e_lgamma_r.c b/sysdeps/ieee754/dbl-64/e_lgamma_r.c
index 72c68b66828a..660eef0b37d9 100644
--- a/sysdeps/ieee754/dbl-64/e_lgamma_r.c
+++ b/sysdeps/ieee754/dbl-64/e_lgamma_r.c
@@ -304,7 +304,6 @@ __ieee754_lgamma_r(double x, int *signgamp)
 	   although in the cases where it is used it has always been
 	   set.  */
 	DIAG_PUSH_NEEDS_COMMENT;
-	DIAG_IGNORE_NEEDS_COMMENT (4.9, "-Wmaybe-uninitialized");
 	if(hx<0) r = nadj - r;
 	DIAG_POP_NEEDS_COMMENT;
 	return r;
diff --git a/sysdeps/ieee754/dbl-64/s_llround.c b/sysdeps/ieee754/dbl-64/s_llround.c
index 1d44fafcebbb..c7376f9b13b9 100644
--- a/sysdeps/ieee754/dbl-64/s_llround.c
+++ b/sysdeps/ieee754/dbl-64/s_llround.c
@@ -28,6 +28,8 @@
 #include <libm-alias-double.h>
 #include <fix-fp-int-convert-overflow.h>
 
+#pragma clang diagnostic ignored "-Wincompatible-library-redeclaration"
+
 long long int
 __llround (double x)
 {
diff --git a/sysdeps/ieee754/flt-32/e_lgammaf_r.c b/sysdeps/ieee754/flt-32/e_lgammaf_r.c
index a1a3a6045404..cd06ce3b6b55 100644
--- a/sysdeps/ieee754/flt-32/e_lgammaf_r.c
+++ b/sysdeps/ieee754/flt-32/e_lgammaf_r.c
@@ -239,7 +239,6 @@ __ieee754_lgammaf_r(float x, int *signgamp)
 	   although in the cases where it is used it has always been
 	   set.  */
 	DIAG_PUSH_NEEDS_COMMENT;
-	DIAG_IGNORE_NEEDS_COMMENT (4.9, "-Wmaybe-uninitialized");
 	if(hx<0) r = nadj - r;
 	DIAG_POP_NEEDS_COMMENT;
 	return r;
diff --git a/sysdeps/ieee754/ldbl-96/e_lgammal_r.c b/sysdeps/ieee754/ldbl-96/e_lgammal_r.c
index 148c21bb8d1e..e62f55f9b694 100644
--- a/sysdeps/ieee754/ldbl-96/e_lgammal_r.c
+++ b/sysdeps/ieee754/ldbl-96/e_lgammal_r.c
@@ -431,7 +431,6 @@ __ieee754_lgammal_r (long double x, int *signgamp)
      in warnings that it may be used uninitialized although in the
      cases where it is used it has always been set.  */
   DIAG_PUSH_NEEDS_COMMENT;
-  DIAG_IGNORE_NEEDS_COMMENT (4.9, "-Wmaybe-uninitialized");
   if (se & 0x8000)
     r = nadj - r;
   DIAG_POP_NEEDS_COMMENT;
diff --git a/sysdeps/ieee754/ldbl-96/k_tanl.c b/sysdeps/ieee754/ldbl-96/k_tanl.c
index 43a5aa44234d..642b664062af 100644
--- a/sysdeps/ieee754/ldbl-96/k_tanl.c
+++ b/sysdeps/ieee754/ldbl-96/k_tanl.c
@@ -140,7 +140,6 @@ __kernel_tanl (long double x, long double y, int iy)
         uninitialized although in the cases where it is used it has
         always been set.  */
       DIAG_PUSH_NEEDS_COMMENT;
-      DIAG_IGNORE_NEEDS_COMMENT (4.8, "-Wmaybe-uninitialized");
       if (sign < 0)
 	w = -w;
       DIAG_POP_NEEDS_COMMENT;
diff --git a/sysdeps/nptl/_Fork.c b/sysdeps/nptl/_Fork.c
index ef199ddbc37e..014a0b8916c6 100644
--- a/sysdeps/nptl/_Fork.c
+++ b/sysdeps/nptl/_Fork.c
@@ -18,32 +18,14 @@
 
 #include <arch-fork.h>
 #include <pthreadP.h>
+#include <pizlonated_syscalls.h>
 
 pid_t
 _Fork (void)
 {
-  pid_t pid = arch_fork (&THREAD_SELF->tid);
+  pid_t pid = zsys_fork ();
   if (pid == 0)
-    {
-      struct pthread *self = THREAD_SELF;
-
-      /* Initialize the robust mutex list setting in the kernel which has
-	 been reset during the fork.  We do not check for errors because if
-	 it fails here, it must have failed at process startup as well and
-	 nobody could have used robust mutexes.
-	 Before we do that, we have to clear the list of robust mutexes
-	 because we do not inherit ownership of mutexes from the parent.
-	 We do not have to set self->robust_head.futex_offset since we do
-	 inherit the correct value from the parent.  We do not need to clear
-	 the pending operation because it must have been zero when fork was
-	 called.  */
-#if __PTHREAD_MUTEX_HAVE_PREV
-      self->robust_prev = &self->robust_head;
-#endif
-      self->robust_head.list = &self->robust_head;
-      INTERNAL_SYSCALL_CALL (set_robust_list, &self->robust_head,
-			     sizeof (struct robust_list_head));
-    }
+    THREAD_SETMEM (THREAD_SELF, tid, zthread_self_id ());
   return pid;
 }
 libc_hidden_def (_Fork)
diff --git a/sysdeps/nptl/bits/pthreadtypes.h b/sysdeps/nptl/bits/pthreadtypes.h
index bace817f0b7e..d0feb7ed50ab 100644
--- a/sysdeps/nptl/bits/pthreadtypes.h
+++ b/sysdeps/nptl/bits/pthreadtypes.h
@@ -24,7 +24,7 @@
 
 /* Thread identifiers.  The structure of the attribute type is not
    exposed on purpose.  */
-typedef unsigned long int pthread_t;
+typedef void* pthread_t;
 
 
 /* Data structures for mutex handling.  The structure of the attribute
diff --git a/sysdeps/nptl/bits/thread-shared-types.h b/sysdeps/nptl/bits/thread-shared-types.h
index df54eef6f71f..79e10ade2a67 100644
--- a/sysdeps/nptl/bits/thread-shared-types.h
+++ b/sysdeps/nptl/bits/thread-shared-types.h
@@ -103,7 +103,7 @@ struct __pthread_cond_s
 };
 
 typedef unsigned int __tss_t;
-typedef unsigned long int __thrd_t;
+typedef void* __thrd_t;
 
 typedef struct
 {
diff --git a/sysdeps/nptl/dl-tls_init_tp.c b/sysdeps/nptl/dl-tls_init_tp.c
index 7803e19fd16a..02e0ee7cab9b 100644
--- a/sysdeps/nptl/dl-tls_init_tp.c
+++ b/sysdeps/nptl/dl-tls_init_tp.c
@@ -35,44 +35,19 @@ rtld_hidden_data_def (__nptl_set_robust_list_avail)
 bool __nptl_initial_report_events;
 rtld_hidden_def (__nptl_initial_report_events)
 
-#ifdef SHARED
-/* Dummy implementation.  See __rtld_mutex_init.  */
-static int
-rtld_mutex_dummy (pthread_mutex_t *lock)
-{
-  return 0;
-}
-#endif
-
 const unsigned int __rseq_flags;
 
-void
-__tls_pre_init_tp (void)
-{
-  /* The list data structures are not consistent until
-     initialized.  */
-  INIT_LIST_HEAD (&GL (dl_stack_used));
-  INIT_LIST_HEAD (&GL (dl_stack_user));
-  INIT_LIST_HEAD (&GL (dl_stack_cache));
-
-#ifdef SHARED
-  ___rtld_mutex_lock = rtld_mutex_dummy;
-  ___rtld_mutex_unlock = rtld_mutex_dummy;
-#endif
-}
-
 void
 __tls_init_tp (void)
 {
   struct pthread *pd = THREAD_SELF;
 
-  /* Set up thread stack list management.  */
-  list_add (&pd->list, &GL (dl_stack_user));
-
    /* Early initialization of the TCB.   */
-   pd->tid = INTERNAL_SYSCALL_CALL (set_tid_address, &pd->tid);
-   THREAD_SETMEM (pd, specific[0], &pd->specific_1stblock[0]);
-   THREAD_SETMEM (pd, user_stack, true);
+  pd->tid = zthread_self_id ();
+  pd->zthread = zthread_self ();
+  pd->dead = 0;
+  THREAD_SETMEM (pd, specific[0], &pd->specific_1stblock[0]);
+  THREAD_SETMEM (pd, user_stack, true);
 
   /* Before initializing GL (dl_stack_user), the debugger could not
      find us and had to set __nptl_initial_report_events.  Propagate
@@ -88,29 +63,8 @@ __tls_init_tp (void)
     pd->robust_head.futex_offset = (offsetof (pthread_mutex_t, __data.__lock)
                                     - offsetof (pthread_mutex_t,
                                                 __data.__list.__next));
-    int res = INTERNAL_SYSCALL_CALL (set_robust_list, &pd->robust_head,
-                                     sizeof (struct robust_list_head));
-    if (!INTERNAL_SYSCALL_ERROR_P (res))
-      {
 #ifndef __ASSUME_SET_ROBUST_LIST
-        __nptl_set_robust_list_avail = true;
-#endif
-      }
-  }
-
-  {
-    bool do_rseq = true;
-    do_rseq = TUNABLE_GET (rseq, int, NULL);
-    if (rseq_register_current_thread (pd, do_rseq))
-      _rseq_size = RSEQ_AREA_SIZE_INITIAL_USED;
-
-#ifdef RSEQ_SIG
-    /* This should be a compile-time constant, but the current
-       infrastructure makes it difficult to determine its value.  Not
-       all targets support __thread_pointer, so set __rseq_offset only
-       if the rseq registration may have happened because RSEQ_SIG is
-       defined.  */
-    _rseq_offset = (char *) &pd->rseq_area - (char *) __thread_pointer ();
+    __nptl_set_robust_list_avail = false;
 #endif
   }
 
diff --git a/sysdeps/nptl/fork.h b/sysdeps/nptl/fork.h
index 7643926df9e3..3b7cb3f6221b 100644
--- a/sysdeps/nptl/fork.h
+++ b/sysdeps/nptl/fork.h
@@ -55,98 +55,6 @@ fork_system_setup_after_fork (void)
 static void
 reclaim_stacks (void)
 {
-  struct pthread *self = (struct pthread *) THREAD_SELF;
-
-  /* No locking necessary.  The caller is the only stack in use.  But
-     we have to be aware that we might have interrupted a list
-     operation.  */
-
-  if (GL (dl_in_flight_stack) != 0)
-    {
-      bool add_p = GL (dl_in_flight_stack) & 1;
-      list_t *elem = (list_t *) (GL (dl_in_flight_stack) & ~(uintptr_t) 1);
-
-      if (add_p)
-	{
-	  /* We always add at the beginning of the list.  So in this case we
-	     only need to check the beginning of these lists to see if the
-	     pointers at the head of the list are inconsistent.  */
-	  list_t *l = NULL;
-
-	  if (GL (dl_stack_used).next->prev != &GL (dl_stack_used))
-	    l = &GL (dl_stack_used);
-	  else if (GL (dl_stack_cache).next->prev != &GL (dl_stack_cache))
-	    l = &GL (dl_stack_cache);
-
-	  if (l != NULL)
-	    {
-	      assert (l->next->prev == elem);
-	      elem->next = l->next;
-	      elem->prev = l;
-	      l->next = elem;
-	    }
-	}
-      else
-	{
-	  /* We can simply always replay the delete operation.  */
-	  elem->next->prev = elem->prev;
-	  elem->prev->next = elem->next;
-	}
-
-      GL (dl_in_flight_stack) = 0;
-    }
-
-  /* Mark all stacks except the still running one as free.  */
-  list_t *runp;
-  list_for_each (runp, &GL (dl_stack_used))
-    {
-      struct pthread *curp = list_entry (runp, struct pthread, list);
-      if (curp != self)
-	{
-	  /* This marks the stack as free.  */
-	  curp->tid = 0;
-
-	  /* Account for the size of the stack.  */
-	  GL (dl_stack_cache_actsize) += curp->stackblock_size;
-
-	  if (curp->specific_used)
-	    {
-	      /* Clear the thread-specific data.  */
-	      memset (curp->specific_1stblock, '\0',
-		      sizeof (curp->specific_1stblock));
-
-	      curp->specific_used = false;
-
-	      for (size_t cnt = 1; cnt < PTHREAD_KEY_1STLEVEL_SIZE; ++cnt)
-		if (curp->specific[cnt] != NULL)
-		  {
-		    memset (curp->specific[cnt], '\0',
-			    sizeof (curp->specific_1stblock));
-
-		    /* We have allocated the block which we do not
-		       free here so re-set the bit.  */
-		    curp->specific_used = true;
-		  }
-	    }
-	}
-    }
-
-  /* Add the stack of all running threads to the cache.  */
-  list_splice (&GL (dl_stack_used), &GL (dl_stack_cache));
-
-  /* Remove the entry for the current thread to from the cache list
-     and add it to the list of running threads.  Which of the two
-     lists is decided by the user_stack flag.  */
-  list_del (&self->list);
-
-  /* Re-initialize the lists for all the threads.  */
-  INIT_LIST_HEAD (&GL (dl_stack_used));
-  INIT_LIST_HEAD (&GL (dl_stack_user));
-
-  if (__glibc_unlikely (THREAD_GETMEM (self, user_stack)))
-    list_add (&self->list, &GL (dl_stack_user));
-  else
-    list_add (&self->list, &GL (dl_stack_used));
 }
 
 
diff --git a/sysdeps/nptl/futex-internal.h b/sysdeps/nptl/futex-internal.h
index 0e87e92d15ab..6636e64f8bd3 100644
--- a/sysdeps/nptl/futex-internal.h
+++ b/sysdeps/nptl/futex-internal.h
@@ -143,24 +143,8 @@ futex_supports_pshared (int pshared)
 static __always_inline int
 futex_wait (unsigned int *futex_word, unsigned int expected, int private)
 {
-  int err = lll_futex_timed_wait (futex_word, expected, NULL, private);
-  switch (err)
-    {
-    case 0:
-    case -EAGAIN:
-    case -EINTR:
-      return -err;
-
-    case -ETIMEDOUT: /* Cannot have happened as we provided no timeout.  */
-    case -EFAULT: /* Must have been caused by a glibc or application bug.  */
-    case -EINVAL: /* Either due to wrong alignment or due to the timeout not
-		     being normalized.  Must have been caused by a glibc or
-		     application bug.  */
-    case -ENOSYS: /* Must have been caused by a glibc bug.  */
-    /* No other errors are documented at this time.  */
-    default:
-      futex_fatal_error ();
-    }
+  zsys_futex_wait ((volatile int *) futex_word, expected, __lll_zsys_private_arg (private));
+  return 0;
 }
 
 /* Like futex_wait but does not provide any indication why we stopped waiting.
diff --git a/sysdeps/nptl/lowlevellock-futex.h b/sysdeps/nptl/lowlevellock-futex.h
index 278213a37b10..8bfc91e36f88 100644
--- a/sysdeps/nptl/lowlevellock-futex.h
+++ b/sysdeps/nptl/lowlevellock-futex.h
@@ -23,6 +23,7 @@
 # include <sysdep.h>
 # include <sysdep-cancel.h>
 # include <kernel-features.h>
+# include <pizlonated_syscalls.h>
 #endif
 
 #define FUTEX_WAIT		0
@@ -54,6 +55,12 @@
 # define __lll_private_flag(fl, private) \
   (((fl) | FUTEX_PRIVATE_FLAG) ^ (private))
 
+# define __lll_zsys_private_arg(private)                        \
+  ({                                                            \
+    ZASSERT(private == LLL_PRIVATE || private == LLL_SHARED);   \
+    (private == LLL_PRIVATE ? 1 : 0);                           \
+  })
+
 # define lll_futex_syscall(nargs, futexp, op, ...)                      \
   ({                                                                    \
     long int __ret = INTERNAL_SYSCALL (futex, nargs, futexp, op, 	\
@@ -70,8 +77,12 @@
 
 
 /* Wait while *FUTEXP == VAL for an lll_futex_wake call on FUTEXP.  */
-# define lll_futex_wait(futexp, val, private) \
-  lll_futex_timed_wait (futexp, val, NULL, private)
+# define lll_futex_wait(futexp, val, private)           \
+  ({                                                    \
+    zsys_futex_wait ((volatile int *) futexp, val,      \
+                     __lll_zsys_private_arg (private)); \
+    0;                                                  \
+  })
 
 # define lll_futex_timed_wait(futexp, val, timeout, private)     \
   lll_futex_syscall (4, futexp,                                 \
@@ -84,9 +95,12 @@
   ((clockid) == CLOCK_REALTIME || (clockid) == CLOCK_MONOTONIC)
 
 /* Wake up up to NR waiters on FUTEXP.  */
-# define lll_futex_wake(futexp, nr, private)                             \
-  lll_futex_syscall (4, futexp,                                         \
-		     __lll_private_flag (FUTEX_WAKE, private), nr, 0)
+# define lll_futex_wake(futexp, nr, private)            \
+  ({                                                    \
+    zsys_futex_wake ((volatile int *) futexp, nr,       \
+                     __lll_zsys_private_arg (private)); \
+    0;                                                  \
+  })
 
 /* Wake up up to NR_WAKE waiters on FUTEXP.  Move up to NR_MOVE of the
    rest from waiting on FUTEXP to waiting on MUTEX (a different futex).
@@ -106,9 +120,8 @@
 
 
 #define lll_futex_timed_unlock_pi(futexp, private) 			\
-  lll_futex_syscall (4, futexp,						\
-		     __lll_private_flag (FUTEX_UNLOCK_PI, private),	\
-		     0, 0)
+  zsys_futex_unlock_pi ((volatile int *) futexp,                        \
+                        __lll_zsys_private_arg (private))
 
 /* Like lll_futex_requeue, but pairs with lll_futex_wait_requeue_pi
    and inherits priority from the waiter.  */
diff --git a/sysdeps/nptl/pthread.h b/sysdeps/nptl/pthread.h
index 3d4f4a756c66..419670530a7b 100644
--- a/sysdeps/nptl/pthread.h
+++ b/sysdeps/nptl/pthread.h
@@ -769,9 +769,9 @@ extern int __REDIRECT_NTHNL (__sigsetjmp_cancel,
 			     __sigsetjmp) __attribute_returns_twice__;
 #else
 # define __sigsetjmp_cancel(env, savemask) \
-  __sigsetjmp ((struct __jmp_buf_tag *) (void *) (env), (savemask))
-extern int __sigsetjmp (struct __jmp_buf_tag __env[1],
-			int __savemask) __THROWNL;
+  sigsetjmp ((struct __jmp_buf_tag *) (void *) (env), (savemask))
+extern int sigsetjmp (struct __jmp_buf_tag __env[1],
+                      int __savemask) __THROWNL;
 #endif
 
 
diff --git a/sysdeps/nptl/pthreadP.h b/sysdeps/nptl/pthreadP.h
index 30e8a2d17700..0d4636dc2fde 100644
--- a/sysdeps/nptl/pthreadP.h
+++ b/sysdeps/nptl/pthreadP.h
@@ -666,7 +666,7 @@ int __pthread_attr_extension (struct pthread_attr *attr) attribute_hidden
 #ifdef SHARED
 # define PTHREAD_STATIC_FN_REQUIRE(name)
 #else
-# define PTHREAD_STATIC_FN_REQUIRE(name) __asm (".globl " #name);
+# define PTHREAD_STATIC_FN_REQUIRE(name) __asm (".filc_globl " #name);
 #endif
 
 /* Make a deep copy of the attribute *SOURCE in *TARGET.  *TARGET is
diff --git a/sysdeps/pthread/pthread_atfork.c b/sysdeps/pthread/pthread_atfork.c
index 5d937d43658f..55b30410fa44 100644
--- a/sysdeps/pthread/pthread_atfork.c
+++ b/sysdeps/pthread/pthread_atfork.c
@@ -36,7 +36,7 @@
 #include <register-atfork.h>
 #include <dso_handle.h>
 #include <register-atfork.h>
-
+#include <stdfil.h>
 
 /* Hide the symbol so that no definition but the one locally in the
    executable or DSO is used.  */
@@ -48,7 +48,7 @@ attribute_hidden
 __pthread_atfork (void (*prepare) (void), void (*parent) (void),
 		  void (*child) (void))
 {
-  return __register_atfork (prepare, parent, child, __dso_handle);
+  return __register_atfork (prepare, parent, child, NULL);
 }
 #ifndef __pthread_atfork
 extern int pthread_atfork (void (*prepare) (void), void (*parent) (void),
diff --git a/sysdeps/unix/Makefile b/sysdeps/unix/Makefile
index 209f7d7c04a2..caa8af3c0df0 100644
--- a/sysdeps/unix/Makefile
+++ b/sysdeps/unix/Makefile
@@ -86,7 +86,7 @@ endif
 
 # This is the end of the pipeline for compiling the syscall stubs.
 # The stdin is assembler with cpp using sysdep.h macros.
-compile-syscall = $(COMPILE.S) -o $@ -x assembler-with-cpp - \
+compile-syscall = $(COMPILE.c) -o $@ -x c - \
 			       $(compile-mkdep-flags)
 
 ifndef avoid-generated
@@ -97,7 +97,7 @@ $(common-objpfx)sysd-syscalls: $(..)sysdeps/unix/make-syscalls.sh \
 	for dir in $(+sysdep_dirs); do \
 	  test -f $$dir/syscalls.list && \
 	  { sysdirs='$(sysdirs)' \
-	    asm_CPP='$(COMPILE.S) -E -x assembler-with-cpp' \
+	    c_CPP='$(COMPILE.c) -E -x c' \
 	    $(SHELL) $(dir $<)$(notdir $<) $$dir || exit 1; }; \
 	  test $$dir = $(..)sysdeps/unix && break; \
 	done > $@T
diff --git a/sysdeps/unix/make-syscalls.sh b/sysdeps/unix/make-syscalls.sh
index 4f6c3490a20b..607bfcdf2229 100644
--- a/sysdeps/unix/make-syscalls.sh
+++ b/sysdeps/unix/make-syscalls.sh
@@ -100,11 +100,11 @@ emit_weak_aliases()
 	else
 	  source="${strong}_${vcount}"
 	  vcount=`expr $vcount + 1`
-	  echo "	 echo 'strong_alias ($strong, $source)'; \\"
+	  echo "	 echo 'strong_alias ($strong, $source);'; \\"
 	fi
-	echo "	 echo 'versioned_symbol (libc, $source, $base, $ver)'; \\"
+	echo "	 echo 'versioned_symbol (libc, $source, $base, $ver);'; \\"
 	echo "	 echo '#else'; \\"
-	echo "	 echo 'weak_alias ($strong, $base)'; \\"
+	echo "	 echo 'weak_alias ($strong, $base);'; \\"
 	echo "	 echo '#endif'; \\"
 	;;
       *@*)
@@ -127,19 +127,19 @@ emit_weak_aliases()
 	else
 	  source="${strong}_${vcount}"
 	  vcount=`expr $vcount + 1`
-	  echo "	 echo 'strong_alias ($strong, $source)'; \\"
+	  echo "	 echo 'strong_alias ($strong, $source);'; \\"
 	fi
-	echo "	 echo 'compat_symbol (libc, $source, $base, $ver)'; \\"
+	echo "	 echo 'compat_symbol (libc, $source, $base, $ver);'; \\"
 	echo "	 echo '#endif'; \\"
 	;;
       !*)
 	name=`echo $name | sed 's/.//'`
-	echo "	 echo 'strong_alias ($strong, $name)'; \\"
-	echo "	 echo 'hidden_def ($name)'; \\"
+	echo "	 echo 'strong_alias ($strong, $name);'; \\"
+	echo "	 echo 'strong_alias ($name, __GI_$name);'; \\"
 	;;
       *)
-	echo "	 echo 'weak_alias ($strong, $name)'; \\"
-	echo "	 echo 'hidden_weak ($name)'; \\"
+	echo "	 echo 'weak_alias ($strong, $name);'; \\"
+	echo "	 echo 'strong_alias ($name, __GI_$name);'; \\"
 	;;
     esac
   done
@@ -157,7 +157,7 @@ while read file srcfile caller syscall args strong weak; do
   callnum=-
   eval `{ echo "#include <sysdep.h>";
 	echo "callnum=SYS_ify ($syscall)"; } |
-	  $asm_CPP -D__OPTIMIZE__ - |
+	  $c_CPP -D__OPTIMIZE__ - |
 	  sed -n -e "/^callnum=.*$syscall/d" \
 		 -e "/^\(callnum=\)[ 	]*\(.*\)/s//\1'\2'/p"`
   ;;
@@ -265,14 +265,13 @@ while read file srcfile caller syscall args strong weak; do
   x*)
   echo "\
 	\$(make-target-directory)
-	(echo '#define SYSCALL_NAME $syscall'; \\
-	 echo '#define SYSCALL_NARGS $nargs'; \\
-	 echo '#define SYSCALL_ULONG_ARG_1 $ulong_arg_1'; \\
-	 echo '#define SYSCALL_ULONG_ARG_2 $ulong_arg_2'; \\
-	 echo '#define SYSCALL_SYMBOL $strong'; \\
-	 echo '#define SYSCALL_NOERRNO $noerrno'; \\
-	 echo '#define SYSCALL_ERRVAL $errval'; \\
-	 echo '#include <syscall-template.S>'; \\"
+	(echo '#include <pizlonated_syscalls.h>'; \\
+	 echo 'void $strong(void)'; \\
+	 echo '{'; \\
+	 echo '  zreturn(zcall(zsys_$syscall, zargs()));'; \\
+	 echo '}'; \\
+	 echo '#include <libc-symbols.h>'; \\
+	 echo 'strong_alias($strong, __GI_$strong);'; \\"
   ;;
   esac
 
diff --git a/sysdeps/unix/sysv/linux/Makefile b/sysdeps/unix/sysv/linux/Makefile
index 34890ef69a53..4e695c6d55e3 100644
--- a/sysdeps/unix/sysv/linux/Makefile
+++ b/sysdeps/unix/sysv/linux/Makefile
@@ -631,11 +631,9 @@ sysdep-rtld-routines += \
   # sysdep-rtld-routines
 
 others += \
-  pldd \
   # others
 
 install-bin += \
-  pldd \
   # install-bin
 
 $(objpfx)pldd: $(objpfx)xmalloc.o
diff --git a/sysdeps/unix/sysv/linux/_exit.c b/sysdeps/unix/sysv/linux/_exit.c
index 1e3992310764..eae713d5e385 100644
--- a/sysdeps/unix/sysv/linux/_exit.c
+++ b/sysdeps/unix/sysv/linux/_exit.c
@@ -20,19 +20,14 @@
 #include <unistd.h>
 #include <sysdep.h>
 #include <abort-instr.h>
+#include <pizlonated_syscalls.h>
 
 
 void
 _exit (int status)
 {
-  while (1)
-    {
-      INLINE_SYSCALL (exit_group, 1, status);
-
-#ifdef ABORT_INSTRUCTION
-      ABORT_INSTRUCTION;
-#endif
-    }
+#pragma clang diagnostic ignored "-Winvalid-noreturn"
+  return zsys_exit_hard (status);
 }
 libc_hidden_def (_exit)
 rtld_hidden_def (_exit)
diff --git a/sysdeps/unix/sysv/linux/accept.c b/sysdeps/unix/sysv/linux/accept.c
index cf526618348e..800bbd6a03e1 100644
--- a/sysdeps/unix/sysv/linux/accept.c
+++ b/sysdeps/unix/sysv/linux/accept.c
@@ -18,17 +18,12 @@
 #include <sys/socket.h>
 #include <sysdep-cancel.h>
 #include <socketcall.h>
+#include <pizlonated_syscalls.h>
 
 int
 __libc_accept (int fd, __SOCKADDR_ARG addr, socklen_t *len)
 {
-#ifdef __ASSUME_ACCEPT_SYSCALL
-  return SYSCALL_CANCEL (accept, fd, addr.__sockaddr__, len);
-#elif defined __ASSUME_ACCEPT4_SYSCALL
-  return SYSCALL_CANCEL (accept4, fd, addr.__sockaddr__, len, 0);
-#else
-  return SOCKETCALL_CANCEL (accept, fd, addr.__sockaddr__, len);
-#endif
+  return zsys_accept (fd, addr.__sockaddr__, len);
 }
 weak_alias (__libc_accept, accept)
 libc_hidden_def (accept)
diff --git a/sysdeps/unix/sysv/linux/accept4.c b/sysdeps/unix/sysv/linux/accept4.c
index 63133c8c3972..4b3af23b1d25 100644
--- a/sysdeps/unix/sysv/linux/accept4.c
+++ b/sysdeps/unix/sysv/linux/accept4.c
@@ -23,13 +23,10 @@
 #include <sys/syscall.h>
 #include <socketcall.h>
 #include <kernel-features.h>
+#include <pizlonated_syscalls.h>
 
 int
 accept4 (int fd, __SOCKADDR_ARG addr, socklen_t *addr_len, int flags)
 {
-#ifdef __ASSUME_ACCEPT4_SYSCALL
-  return SYSCALL_CANCEL (accept4, fd, addr.__sockaddr__, addr_len, flags);
-#else
-  return SOCKETCALL_CANCEL (accept4, fd, addr.__sockaddr__, addr_len, flags);
-#endif
+  return zsys_accept4 (fd, addr.__sockaddr__, addr_len, flags);
 }
diff --git a/sysdeps/unix/sysv/linux/access.c b/sysdeps/unix/sysv/linux/access.c
index 4b7c3be0cf21..a414c76f1b1d 100644
--- a/sysdeps/unix/sysv/linux/access.c
+++ b/sysdeps/unix/sysv/linux/access.c
@@ -19,15 +19,12 @@
 #include <fcntl.h>
 #include <unistd.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 int
 __access (const char *file, int type)
 {
-#ifdef __NR_access
-  return INLINE_SYSCALL_CALL (access, file, type);
-#else
-  return INLINE_SYSCALL_CALL (faccessat, AT_FDCWD, file, type);
-#endif
+  return zsys_access (file, type);
 }
 libc_hidden_def (__access)
 weak_alias (__access, access)
diff --git a/sysdeps/unix/sysv/linux/chmod.c b/sysdeps/unix/sysv/linux/chmod.c
index 2743fb5b9993..9f3cbd052718 100644
--- a/sysdeps/unix/sysv/linux/chmod.c
+++ b/sysdeps/unix/sysv/linux/chmod.c
@@ -18,16 +18,13 @@
 
 #include <fcntl.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 /* Change the protections of FILE to MODE.  */
 int
 __chmod (const char *file, mode_t mode)
 {
-#ifdef __NR_chmod
-  return INLINE_SYSCALL_CALL (chmod, file, mode);
-#else
-  return INLINE_SYSCALL_CALL (fchmodat, AT_FDCWD, file, mode);
-#endif
+  return zsys_chmod (file, mode);
 }
 
 libc_hidden_def (__chmod)
diff --git a/sysdeps/unix/sysv/linux/clock_getres.c b/sysdeps/unix/sysv/linux/clock_getres.c
index 89119ed8e58a..0b8e6f44a1a6 100644
--- a/sysdeps/unix/sysv/linux/clock_getres.c
+++ b/sysdeps/unix/sysv/linux/clock_getres.c
@@ -20,58 +20,18 @@
 #include <errno.h>
 #include <time.h>
 
-#include <sysdep-vdso.h>
 #include <shlib-compat.h>
-#include <kernel-features.h>
+#include <pizlonated_syscalls.h>
 
 /* Get resolution of clock.  */
 int
 __clock_getres64 (clockid_t clock_id, struct __timespec64 *res)
 {
-  int r;
-
-#ifndef __NR_clock_getres_time64
-# define __NR_clock_getres_time64 __NR_clock_getres
-#endif
-
-#ifdef HAVE_CLOCK_GETRES64_VSYSCALL
-  r = INLINE_VSYSCALL (clock_getres_time64, 2, clock_id, res);
-#else
-  r = INLINE_SYSCALL_CALL (clock_getres_time64, clock_id, res);
-#endif
-  if (r == 0 || errno != ENOSYS)
-    return r;
-
-#ifndef __ASSUME_TIME64_SYSCALLS
-  /* Fallback code that uses 32-bit support.  */
-  struct timespec ts32;
-# ifdef HAVE_CLOCK_GETRES_VSYSCALL
-  r = INLINE_VSYSCALL (clock_getres, 2, clock_id, &ts32);
-# else
-  r = INLINE_SYSCALL_CALL (clock_getres, clock_id, &ts32);
-# endif
-  if (r == 0 && res != NULL)
-    *res = valid_timespec_to_timespec64 (ts32);
-#endif
-
-  return r;
+  return zsys_clock_getres (clock_id, res);
 }
 
 #if __TIMESIZE != 64
-libc_hidden_def (__clock_getres64)
-
-int
-__clock_getres (clockid_t clock_id, struct timespec *res)
-{
-  struct __timespec64 ts64;
-  int retval;
-
-  retval = __clock_getres64 (clock_id, &ts64);
-  if (retval == 0 && res != NULL)
-    *res = valid_timespec64_to_timespec (ts64);
-
-  return retval;
-}
+#error "Time is 64-bit bruh"
 #endif
 libc_hidden_def (__clock_getres)
 
diff --git a/sysdeps/unix/sysv/linux/clock_gettime.c b/sysdeps/unix/sysv/linux/clock_gettime.c
index f10a289f791b..7b3363a2aba5 100644
--- a/sysdeps/unix/sysv/linux/clock_gettime.c
+++ b/sysdeps/unix/sysv/linux/clock_gettime.c
@@ -17,98 +17,20 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include <sysdep.h>
-#include <kernel-features.h>
 #include <errno.h>
 #include <time.h>
-#include "kernel-posix-cpu-timers.h"
-#include <sysdep-vdso.h>
 #include <shlib-compat.h>
+#include <pizlonated_syscalls.h>
 
 /* Get current value of CLOCK and store it in TP.  */
 int
 __clock_gettime64 (clockid_t clock_id, struct __timespec64 *tp)
 {
-  int r;
-
-#ifndef __NR_clock_gettime64
-# define __NR_clock_gettime64 __NR_clock_gettime
-#endif
-
-#ifdef HAVE_CLOCK_GETTIME64_VSYSCALL
-  int (*vdso_time64) (clockid_t clock_id, struct __timespec64 *tp)
-    = GLRO(dl_vdso_clock_gettime64);
-  if (vdso_time64 != NULL)
-    {
-      r = INTERNAL_VSYSCALL_CALL (vdso_time64, 2, clock_id, tp);
-      if (r == 0)
-	return 0;
-      return INLINE_SYSCALL_ERROR_RETURN_VALUE (-r);
-    }
-#endif
-
-#ifdef HAVE_CLOCK_GETTIME_VSYSCALL
-  int (*vdso_time) (clockid_t clock_id, struct timespec *tp)
-    = GLRO(dl_vdso_clock_gettime);
-  if (vdso_time != NULL)
-    {
-      struct timespec tp32;
-      r = INTERNAL_VSYSCALL_CALL (vdso_time, 2, clock_id, &tp32);
-      if (r == 0 && tp32.tv_sec >= 0)
-	{
-	  *tp = valid_timespec_to_timespec64 (tp32);
-	  return 0;
-	}
-      else if (r != 0)
-	return INLINE_SYSCALL_ERROR_RETURN_VALUE (-r);
-
-      /* Fallback to syscall if the 32-bit time_t vDSO returns overflows.  */
-    }
-#endif
-
-  r = INTERNAL_SYSCALL_CALL (clock_gettime64, clock_id, tp);
-  if (r == 0)
-    return 0;
-  if (r != -ENOSYS)
-    return INLINE_SYSCALL_ERROR_RETURN_VALUE (-r);
-
-#ifndef __ASSUME_TIME64_SYSCALLS
-  /* Fallback code that uses 32-bit support.  */
-  struct timespec tp32;
-  r = INTERNAL_SYSCALL_CALL (clock_gettime, clock_id, &tp32);
-  if (r == 0)
-    {
-      *tp = valid_timespec_to_timespec64 (tp32);
-      return 0;
-    }
-#endif
-
-  return INLINE_SYSCALL_ERROR_RETURN_VALUE (-r);
+  return zsys_clock_gettime (clock_id, tp);
 }
 
 #if __TIMESIZE != 64
-libc_hidden_def (__clock_gettime64)
-
-int
-__clock_gettime (clockid_t clock_id, struct timespec *tp)
-{
-  int ret;
-  struct __timespec64 tp64;
-
-  ret = __clock_gettime64 (clock_id, &tp64);
-
-  if (ret == 0)
-    {
-      if (! in_time_t_range (tp64.tv_sec))
-        {
-          __set_errno (EOVERFLOW);
-          return -1;
-        }
-
-      *tp = valid_timespec64_to_timespec (tp64);
-    }
-
-  return ret;
-}
+#error "Time is 64-bit bro"
 #endif
 libc_hidden_def (__clock_gettime)
 
diff --git a/sysdeps/unix/sysv/linux/clock_nanosleep.c b/sysdeps/unix/sysv/linux/clock_nanosleep.c
index 7f9d4e122478..85ff85c0fedf 100644
--- a/sysdeps/unix/sysv/linux/clock_nanosleep.c
+++ b/sysdeps/unix/sysv/linux/clock_nanosleep.c
@@ -23,6 +23,7 @@
 #include "kernel-posix-cpu-timers.h"
 
 #include <shlib-compat.h>
+#include <pizlonated_syscalls.h>
 
 /* We can simply use the syscall.  The CPU clocks are not supported
    with this function.  */
@@ -31,44 +32,7 @@ __clock_nanosleep_time64 (clockid_t clock_id, int flags,
 			  const struct __timespec64 *req,
 			  struct __timespec64 *rem)
 {
-  if (clock_id == CLOCK_THREAD_CPUTIME_ID)
-    return EINVAL;
-  if (clock_id == CLOCK_PROCESS_CPUTIME_ID)
-    clock_id = PROCESS_CLOCK;
-
-  /* If the call is interrupted by a signal handler or encounters an error,
-     it returns a positive value similar to errno.  */
-
-#ifndef __NR_clock_nanosleep_time64
-# define __NR_clock_nanosleep_time64 __NR_clock_nanosleep
-#endif
-
-  int r;
-#ifdef __ASSUME_TIME64_SYSCALLS
-  r = INTERNAL_SYSCALL_CANCEL (clock_nanosleep_time64, clock_id, flags, req,
-			       rem);
-#else
-  if (!in_int32_t_range (req->tv_sec))
-    {
-      r = INTERNAL_SYSCALL_CANCEL (clock_nanosleep_time64, clock_id, flags,
-				   req, rem);
-      if (r == -ENOSYS)
-	r = -EOVERFLOW;
-    }
-  else
-    {
-      struct timespec tr32;
-      struct timespec ts32 = valid_timespec64_to_timespec (*req);
-      r = INTERNAL_SYSCALL_CANCEL (clock_nanosleep, clock_id, flags, &ts32,
-				   &tr32);
-      if (INTERNAL_SYSCALL_ERROR_P (r))
-	{
-	  if (r == -EINTR && rem != NULL && (flags & TIMER_ABSTIME) == 0)
-	    *rem = valid_timespec_to_timespec64 (tr32);
-	}
-    }
-#endif
-  return -r;
+  return zsys_clock_nanosleep (clock_id, flags, req, rem);
 }
 
 #if __TIMESIZE != 64
diff --git a/sysdeps/unix/sysv/linux/clock_settime.c b/sysdeps/unix/sysv/linux/clock_settime.c
index f1f4f361d78e..53ef58390378 100644
--- a/sysdeps/unix/sysv/linux/clock_settime.c
+++ b/sysdeps/unix/sysv/linux/clock_settime.c
@@ -20,38 +20,13 @@
 #include <time.h>
 #include <shlib-compat.h>
 #include <kernel-features.h>
+#include <pizlonated_syscalls.h>
 
 /* Set CLOCK to value TP.  */
 int
 __clock_settime64 (clockid_t clock_id, const struct __timespec64 *tp)
 {
-  /* Make sure the time cvalue is OK.  */
-  if (! valid_nanoseconds (tp->tv_nsec))
-    {
-      __set_errno (EINVAL);
-      return -1;
-    }
-
-#ifndef __NR_clock_settime64
-# define __NR_clock_settime64 __NR_clock_settime
-#endif
-  int ret = INLINE_SYSCALL_CALL (clock_settime64, clock_id, tp);
-
-#ifndef __ASSUME_TIME64_SYSCALLS
-  if (ret == 0 || errno != ENOSYS)
-    return ret;
-
-  if (! in_int32_t_range (tp->tv_sec))
-    {
-      __set_errno (EOVERFLOW);
-      return -1;
-    }
-
-  struct timespec ts32 = valid_timespec64_to_timespec (*tp);
-  ret = INLINE_SYSCALL_CALL (clock_settime, clock_id, &ts32);
-#endif
-
-  return ret;
+  return zsys_clock_settime (clock_id, tp);
 }
 
 #if __TIMESIZE != 64
diff --git a/sysdeps/x86_64/memcmpeq.S b/sysdeps/unix/sysv/linux/clone.c
similarity index 69%
rename from projects/user-glibc-2.40/sysdeps/x86_64/memcmpeq.S
rename to projects/user-glibc-2.40/sysdeps/unix/sysv/linux/clone.c
index cb22f1108bff..9f88cec7c9e1 100644
--- a/sysdeps/x86_64/memcmpeq.S
+++ b/sysdeps/unix/sysv/linux/clone.c
@@ -1,4 +1,4 @@
-/* __memcmpeq hook for non-multiarch and RTLD build.
+/* Linux close syscall implementation.
    Copyright (C) 2017-2024 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -16,12 +16,17 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#define MEMCMPEQ	__memcmpeq
+#include <unistd.h>
+#include <sched.h>
+#include <stdfil.h>
 
-#define DEFAULT_IMPL_V1	"multiarch/memcmpeq-sse2.S"
-#define DEFAULT_IMPL_V3	"multiarch/memcmpeq-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/memcmpeq-evex.S"
-
-#include "isa-default-impl.h"
-
-libc_hidden_def(__memcmpeq)
+/* Close the file descriptor FD.  */
+int
+__clone (int (*fun) (void *), void* stack, int flags, void* arg, ...)
+{
+  zerror("clone not implemented.");
+  return -1;
+}
+libc_hidden_def (__clone)
+strong_alias (__clone, __libc_clone)
+weak_alias (__clone, clone)
diff --git a/sysdeps/unix/sysv/linux/clone3.c b/sysdeps/unix/sysv/linux/clone3.c
index de963ef89d3f..0715a1b20e18 100644
--- a/sysdeps/unix/sysv/linux/clone3.c
+++ b/sysdeps/unix/sysv/linux/clone3.c
@@ -1 +1,35 @@
-/* An empty placeholder.  */
+/* Linux close syscall implementation.
+   Copyright (C) 2017-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <unistd.h>
+#include <sched.h>
+#include <stdfil.h>
+#include <clone3.h>
+#include <clone_internal.h>
+
+/* Close the file descriptor FD.  */
+int
+__clone3 (struct clone_args *cl_args, size_t size,
+          int (*__func) (void *__arg), void *__arg)
+{
+  zerror("clone3 not implemented.");
+  return -1;
+}
+libc_hidden_def (__clone3)
+strong_alias (__clone3, __libc_clone3)
+weak_alias (__clone3, clone3)
diff --git a/sysdeps/unix/sysv/linux/close.c b/sysdeps/unix/sysv/linux/close.c
index 00a0aba98978..067f44d61865 100644
--- a/sysdeps/unix/sysv/linux/close.c
+++ b/sysdeps/unix/sysv/linux/close.c
@@ -19,12 +19,13 @@
 #include <unistd.h>
 #include <sysdep-cancel.h>
 #include <not-cancel.h>
+#include <pizlonated_syscalls.h>
 
 /* Close the file descriptor FD.  */
 int
 __close (int fd)
 {
-  return SYSCALL_CANCEL (close, fd);
+  return zsys_close (fd);
 }
 libc_hidden_def (__close)
 strong_alias (__close, __libc_close)
diff --git a/sysdeps/unix/sysv/linux/close_nocancel.c b/sysdeps/unix/sysv/linux/close_nocancel.c
index 509cc8989911..f37762eda225 100644
--- a/sysdeps/unix/sysv/linux/close_nocancel.c
+++ b/sysdeps/unix/sysv/linux/close_nocancel.c
@@ -19,10 +19,11 @@
 #include <unistd.h>
 #include <sysdep-cancel.h>
 #include <not-cancel.h>
+#include <pizlonated_syscalls.h>
 
 int
 __close_nocancel (int fd)
 {
-  return INLINE_SYSCALL_CALL (close, fd);
+  return zsys_close (fd);
 }
 libc_hidden_def (__close_nocancel)
diff --git a/sysdeps/unix/sysv/linux/connect.c b/sysdeps/unix/sysv/linux/connect.c
index 109cfc45c123..8eeb2bcaf756 100644
--- a/sysdeps/unix/sysv/linux/connect.c
+++ b/sysdeps/unix/sysv/linux/connect.c
@@ -18,15 +18,12 @@
 #include <sys/socket.h>
 #include <sysdep-cancel.h>
 #include <socketcall.h>
+#include <pizlonated_syscalls.h>
 
 int
 __libc_connect (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len)
 {
-#ifdef __ASSUME_CONNECT_SYSCALL
-  return SYSCALL_CANCEL (connect, fd, addr.__sockaddr__, len);
-#else
-  return SOCKETCALL_CANCEL (connect, fd, addr.__sockaddr__, len);
-#endif
+  return zsys_connect (fd, addr.__sockaddr__, len);
 }
 weak_alias (__libc_connect, connect)
 weak_alias (__libc_connect, __connect)
diff --git a/sysdeps/unix/sysv/linux/copy_file_range.c b/sysdeps/unix/sysv/linux/copy_file_range.c
index ac32e7ed4659..0a1005e077bd 100644
--- a/sysdeps/unix/sysv/linux/copy_file_range.c
+++ b/sysdeps/unix/sysv/linux/copy_file_range.c
@@ -19,12 +19,12 @@
 #include <errno.h>
 #include <sysdep-cancel.h>
 #include <unistd.h>
+#include <pizlonated_syscalls.h>
 
 ssize_t
 copy_file_range (int infd, __off64_t *pinoff,
                  int outfd, __off64_t *poutoff,
                  size_t length, unsigned int flags)
 {
-  return SYSCALL_CANCEL (copy_file_range, infd, pinoff, outfd, poutoff,
-                         length, flags);
+  return zsys_copy_file_range (infd, pinoff, outfd, poutoff, length, flags);
 }
diff --git a/sysdeps/unix/sysv/linux/creat64.c b/sysdeps/unix/sysv/linux/creat64.c
index 2f65ec30aab6..44efa269c344 100644
--- a/sysdeps/unix/sysv/linux/creat64.c
+++ b/sysdeps/unix/sysv/linux/creat64.c
@@ -19,17 +19,13 @@
 #include <fcntl.h>
 #include <sys/types.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 /* Create FILE with protections MODE.  */
 int
 __creat64 (const char *file, mode_t mode)
 {
-#if defined __OFF_T_MATCHES_OFF64_T && defined __NR_creat
-  return SYSCALL_CANCEL (creat, file, mode);
-#else
-  /* We need to pass O_LARGEFILE.  */
-  return __open64 (file, O_WRONLY | O_CREAT | O_TRUNC, mode);
-#endif
+  return zsys_open (file, O_WRONLY | O_CREAT | O_TRUNC, mode);
 }
 weak_alias (__creat64, creat64)
 
diff --git a/sysdeps/unix/sysv/linux/dl-sysdep.c b/sysdeps/unix/sysv/linux/dl-sysdep.c
index a8ec2d7c18cc..a6fa97cff536 100644
--- a/sysdeps/unix/sysv/linux/dl-sysdep.c
+++ b/sysdeps/unix/sysv/linux/dl-sysdep.c
@@ -45,211 +45,3 @@
 #include <dl-machine.h>
 #include <dl-hwcap-check.h>
 
-#ifdef SHARED
-extern char **_environ attribute_hidden;
-extern char _end[] attribute_hidden;
-
-/* Protect SUID program against misuse of file descriptors.  */
-extern void __libc_check_standard_fds (void);
-
-int __libc_enable_secure attribute_relro = 0;
-rtld_hidden_data_def (__libc_enable_secure)
-/* This variable contains the lowest stack address ever used.  */
-void *__libc_stack_end attribute_relro = NULL;
-rtld_hidden_data_def(__libc_stack_end)
-void *_dl_random attribute_relro = NULL;
-
-#ifndef DL_STACK_END
-# define DL_STACK_END(cookie) ((void *) (cookie))
-#endif
-
-/* Arguments passed to dl_main.  */
-struct dl_main_arguments
-{
-  const ElfW(Phdr) *phdr;
-  ElfW(Word) phnum;
-  ElfW(Addr) user_entry;
-};
-
-/* Separate function, so that dl_main can be called without the large
-   array on the stack.  */
-static void
-_dl_sysdep_parse_arguments (void **start_argptr,
-			    struct dl_main_arguments *args)
-{
-  _dl_argc = (intptr_t) *start_argptr;
-  _dl_argv = (char **) (start_argptr + 1); /* Necessary aliasing violation.  */
-  _environ = _dl_argv + _dl_argc + 1;
-  for (char **tmp = _environ; ; ++tmp)
-    if (*tmp == NULL)
-      {
-	/* Another necessary aliasing violation.  */
-	GLRO(dl_auxv) = (ElfW(auxv_t) *) (tmp + 1);
-	break;
-      }
-
-  dl_parse_auxv_t auxv_values = { 0, };
-  _dl_parse_auxv (GLRO(dl_auxv), auxv_values);
-
-  args->phdr = (const ElfW(Phdr) *) auxv_values[AT_PHDR];
-  args->phnum = auxv_values[AT_PHNUM];
-  args->user_entry = auxv_values[AT_ENTRY];
-}
-
-ElfW(Addr)
-_dl_sysdep_start (void **start_argptr,
-		  void (*dl_main) (const ElfW(Phdr) *phdr, ElfW(Word) phnum,
-				   ElfW(Addr) *user_entry, ElfW(auxv_t) *auxv))
-{
-  __libc_stack_end = DL_STACK_END (start_argptr);
-
-  struct dl_main_arguments dl_main_args;
-  _dl_sysdep_parse_arguments (start_argptr, &dl_main_args);
-
-  dl_hwcap_check ();
-
-  __tunables_init (_environ);
-
-  /* Initialize DSO sorting algorithm after tunables.  */
-  _dl_sort_maps_init ();
-
-  __brk (0);			/* Initialize the break.  */
-
-#ifdef DL_PLATFORM_INIT
-  DL_PLATFORM_INIT;
-#endif
-
-  /* Determine the length of the platform name.  */
-  if (GLRO(dl_platform) != NULL)
-    GLRO(dl_platformlen) = strlen (GLRO(dl_platform));
-
-  if (__sbrk (0) == _end)
-    /* The dynamic linker was run as a program, and so the initial break
-       starts just after our bss, at &_end.  The malloc in dl-minimal.c
-       will consume the rest of this page, so tell the kernel to move the
-       break up that far.  When the user program examines its break, it
-       will see this new value and not clobber our data.  */
-    __sbrk (GLRO(dl_pagesize)
-	    - (((uintptr_t) _end) & (GLRO(dl_pagesize) - 1)));
-
-  /* If this is a SUID program we make sure that FDs 0, 1, and 2 are
-     allocated.  If necessary we are doing it ourself.  If it is not
-     possible we stop the program.  */
-  if (__builtin_expect (__libc_enable_secure, 0))
-    __libc_check_standard_fds ();
-
-  (*dl_main) (dl_main_args.phdr, dl_main_args.phnum,
-              &dl_main_args.user_entry, GLRO(dl_auxv));
-  return dl_main_args.user_entry;
-}
-
-void
-_dl_sysdep_start_cleanup (void)
-{
-}
-
-void
-_dl_show_auxv (void)
-{
-  char buf[64];
-  ElfW(auxv_t) *av;
-
-  /* Terminate string.  */
-  buf[63] = '\0';
-
-  /* The following code assumes that the AT_* values are encoded
-     starting from 0 with AT_NULL, 1 for AT_IGNORE, and all other values
-     close by (otherwise the array will be too large).  In case we have
-     to support a platform where these requirements are not fulfilled
-     some alternative implementation has to be used.  */
-  for (av = GLRO(dl_auxv); av->a_type != AT_NULL; ++av)
-    {
-      static const struct
-      {
-	const char label[22];
-	enum { unknown = 0, dec, hex, str, ignore } form : 8;
-      } auxvars[] =
-	{
-	  [AT_EXECFD - 2] =		{ "EXECFD:            ", dec },
-	  [AT_EXECFN - 2] =		{ "EXECFN:            ", str },
-	  [AT_PHDR - 2] =		{ "PHDR:              0x", hex },
-	  [AT_PHENT - 2] =		{ "PHENT:             ", dec },
-	  [AT_PHNUM - 2] =		{ "PHNUM:             ", dec },
-	  [AT_PAGESZ - 2] =		{ "PAGESZ:            ", dec },
-	  [AT_BASE - 2] =		{ "BASE:              0x", hex },
-	  [AT_FLAGS - 2] =		{ "FLAGS:             0x", hex },
-	  [AT_ENTRY - 2] =		{ "ENTRY:             0x", hex },
-	  [AT_NOTELF - 2] =		{ "NOTELF:            ", hex },
-	  [AT_UID - 2] =		{ "UID:               ", dec },
-	  [AT_EUID - 2] =		{ "EUID:              ", dec },
-	  [AT_GID - 2] =		{ "GID:               ", dec },
-	  [AT_EGID - 2] =		{ "EGID:              ", dec },
-	  [AT_PLATFORM - 2] =		{ "PLATFORM:          ", str },
-	  [AT_HWCAP - 2] =		{ "HWCAP:             ", hex },
-	  [AT_CLKTCK - 2] =		{ "CLKTCK:            ", dec },
-	  [AT_FPUCW - 2] =		{ "FPUCW:             ", hex },
-	  [AT_DCACHEBSIZE - 2] =	{ "DCACHEBSIZE:       0x", hex },
-	  [AT_ICACHEBSIZE - 2] =	{ "ICACHEBSIZE:       0x", hex },
-	  [AT_UCACHEBSIZE - 2] =	{ "UCACHEBSIZE:       0x", hex },
-	  [AT_IGNOREPPC - 2] =		{ "IGNOREPPC", ignore },
-	  [AT_SECURE - 2] =		{ "SECURE:            ", dec },
-	  [AT_BASE_PLATFORM - 2] =	{ "BASE_PLATFORM:     ", str },
-	  [AT_SYSINFO - 2] =		{ "SYSINFO:           0x", hex },
-	  [AT_SYSINFO_EHDR - 2] =	{ "SYSINFO_EHDR:      0x", hex },
-	  [AT_RANDOM - 2] =		{ "RANDOM:            0x", hex },
-	  [AT_HWCAP2 - 2] =		{ "HWCAP2:            0x", hex },
-	  [AT_HWCAP3 - 2] =		{ "HWCAP3:            0x", hex },
-	  [AT_HWCAP4 - 2] =		{ "HWCAP4:            0x", hex },
-	  [AT_MINSIGSTKSZ - 2] =	{ "MINSIGSTKSZ:       ", dec },
-	  [AT_L1I_CACHESIZE - 2] =	{ "L1I_CACHESIZE:     ", dec },
-	  [AT_L1I_CACHEGEOMETRY - 2] =	{ "L1I_CACHEGEOMETRY: 0x", hex },
-	  [AT_L1D_CACHESIZE - 2] =	{ "L1D_CACHESIZE:     ", dec },
-	  [AT_L1D_CACHEGEOMETRY - 2] =	{ "L1D_CACHEGEOMETRY: 0x", hex },
-	  [AT_L2_CACHESIZE - 2] =	{ "L2_CACHESIZE:      ", dec },
-	  [AT_L2_CACHEGEOMETRY - 2] =	{ "L2_CACHEGEOMETRY:  0x", hex },
-	  [AT_L3_CACHESIZE - 2] =	{ "L3_CACHESIZE:      ", dec },
-	  [AT_L3_CACHEGEOMETRY - 2] =	{ "L3_CACHEGEOMETRY:  0x", hex },
-	};
-      unsigned int idx = (unsigned int) (av->a_type - 2);
-
-      if ((unsigned int) av->a_type < 2u
-	  || (idx < sizeof (auxvars) / sizeof (auxvars[0])
-	      && auxvars[idx].form == ignore))
-	continue;
-
-      assert (AT_NULL == 0);
-      assert (AT_IGNORE == 1);
-
-      /* Some entries are handled in a special way per platform.  */
-      if (_dl_procinfo (av->a_type, av->a_un.a_val) == 0)
-	continue;
-
-      if (idx < sizeof (auxvars) / sizeof (auxvars[0])
-	  && auxvars[idx].form != unknown)
-	{
-	  const char *val = (char *) av->a_un.a_val;
-
-	  if (__builtin_expect (auxvars[idx].form, dec) == dec)
-	    val = _itoa ((unsigned long int) av->a_un.a_val,
-			 buf + sizeof buf - 1, 10, 0);
-	  else if (__builtin_expect (auxvars[idx].form, hex) == hex)
-	    val = _itoa ((unsigned long int) av->a_un.a_val,
-			 buf + sizeof buf - 1, 16, 0);
-
-	  _dl_printf ("AT_%s%s\n", auxvars[idx].label, val);
-
-	  continue;
-	}
-
-      /* Unknown value: print a generic line.  */
-      char buf2[17];
-      buf2[sizeof (buf2) - 1] = '\0';
-      const char *val2 = _itoa ((unsigned long int) av->a_un.a_val,
-				buf2 + sizeof buf2 - 1, 16, 0);
-      const char *val =  _itoa ((unsigned long int) av->a_type,
-				buf + sizeof buf - 1, 16, 0);
-      _dl_printf ("AT_??? (0x%s): 0x%s\n", val, val2);
-    }
-}
-
-#endif /* SHARED */
diff --git a/sysdeps/unix/sysv/linux/dup2.c b/sysdeps/unix/sysv/linux/dup2.c
index 8c3e8b0b63fb..5032c9794a59 100644
--- a/sysdeps/unix/sysv/linux/dup2.c
+++ b/sysdeps/unix/sysv/linux/dup2.c
@@ -19,22 +19,14 @@
 #include <fcntl.h>
 #include <unistd.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 /* Duplicate FD to FD2, closing the old FD2 and making FD2 be
    open the same file as FD is.  Return FD2 or -1.  */
 int
 __dup2 (int fd, int fd2)
 {
-#ifdef __NR_dup2
-  return INLINE_SYSCALL_CALL (dup2, fd, fd2);
-#else
-  /* For the degenerate case, check if the fd is valid (by trying to
-     get the file status flags) and return it, or else return EBADF.  */
-  if (fd == fd2)
-    return __libc_fcntl (fd, F_GETFL, 0) < 0 ? -1 : fd;
-
-  return INLINE_SYSCALL_CALL (dup3, fd, fd2, 0);
-#endif
+  return zsys_dup2 (fd, fd2);
 }
 libc_hidden_def (__dup2)
 weak_alias (__dup2, dup2)
diff --git a/sysdeps/unix/sysv/linux/epoll_create.c b/sysdeps/unix/sysv/linux/epoll_create.c
index 5417bd8ed367..7f3c8ff12b41 100644
--- a/sysdeps/unix/sysv/linux/epoll_create.c
+++ b/sysdeps/unix/sysv/linux/epoll_create.c
@@ -18,22 +18,19 @@
 
 #include <sys/epoll.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 libc_hidden_proto (epoll_create)
 
 int
 epoll_create (int size)
 {
-#ifdef __NR_epoll_create
-  return INLINE_SYSCALL_CALL (epoll_create, size);
-#else
   if (size <= 0)
     {
       __set_errno (EINVAL);
       return -1;
     }
 
-  return INLINE_SYSCALL_CALL (epoll_create1, 0);
-#endif
+  return zsys_epoll_create1 (0);
 }
 libc_hidden_def (epoll_create)
diff --git a/sysdeps/unix/sysv/linux/epoll_pwait.c b/sysdeps/unix/sysv/linux/epoll_pwait.c
index d0bd3d0d47a5..3c81048c7425 100644
--- a/sysdeps/unix/sysv/linux/epoll_pwait.c
+++ b/sysdeps/unix/sysv/linux/epoll_pwait.c
@@ -22,6 +22,7 @@
 
 #include <sysdep-cancel.h>
 #include <sys/syscall.h>
+#include <pizlonated_syscalls.h>
 
 /* Wait for events on an epoll instance "epfd". Returns the number of
    triggered events returned in "events" buffer. Or -1 in case of
@@ -37,7 +38,6 @@ int epoll_pwait (int epfd, struct epoll_event *events,
 		 int maxevents, int timeout,
 		 const sigset_t *set)
 {
-  return SYSCALL_CANCEL (epoll_pwait, epfd, events, maxevents,
-			 timeout, set, __NSIG_BYTES);
+  return zsys_epoll_pwait (epfd, events, maxevents, timeout, set);
 }
 libc_hidden_def (epoll_pwait)
diff --git a/sysdeps/unix/sysv/linux/epoll_pwait2.c b/sysdeps/unix/sysv/linux/epoll_pwait2.c
index 0f6ac3e15901..dba5206c59e1 100644
--- a/sysdeps/unix/sysv/linux/epoll_pwait2.c
+++ b/sysdeps/unix/sysv/linux/epoll_pwait2.c
@@ -23,8 +23,7 @@ int
 __epoll_pwait2_time64 (int fd, struct epoll_event *ev, int maxev,
 		       const struct __timespec64 *tmo, const sigset_t *s)
 {
-  /* The syscall only supports 64-bit time_t.  */
-  return SYSCALL_CANCEL (epoll_pwait2, fd, ev, maxev, tmo, s, __NSIG_BYTES);
+  return zsys_epoll_pwait2 (fd, ev, maxev, tmo, s);
 }
 #if __TIMESIZE != 64
 libc_hidden_def (__epoll_pwait2_time64)
diff --git a/sysdeps/unix/sysv/linux/epoll_wait.c b/sysdeps/unix/sysv/linux/epoll_wait.c
index be77ad5385ac..7b340ec33d0f 100644
--- a/sysdeps/unix/sysv/linux/epoll_wait.c
+++ b/sysdeps/unix/sysv/linux/epoll_wait.c
@@ -22,13 +22,10 @@
 #include <sys/epoll.h>
 
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 int
 epoll_wait (int epfd, struct epoll_event *events, int maxevents, int timeout)
 {
-#ifdef __NR_epoll_wait
-  return SYSCALL_CANCEL (epoll_wait, epfd, events, maxevents, timeout);
-#else
-  return epoll_pwait (epfd, events, maxevents, timeout, NULL);
-#endif
+  return zsys_epoll_wait (epfd, events, maxevents, timeout);
 }
diff --git a/sysdeps/unix/sysv/linux/faccessat.c b/sysdeps/unix/sysv/linux/faccessat.c
index 2fa57fd63d37..39d51f48111c 100644
--- a/sysdeps/unix/sysv/linux/faccessat.c
+++ b/sysdeps/unix/sysv/linux/faccessat.c
@@ -21,56 +21,12 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 
 int
 __faccessat (int fd, const char *file, int mode, int flag)
 {
-  int ret = INLINE_SYSCALL_CALL (faccessat2, fd, file, mode, flag);
-#if __ASSUME_FACCESSAT2
-  return ret;
-#else
-  if (ret == 0 || errno != ENOSYS)
-    return ret;
-
-  if (flag & ~(AT_SYMLINK_NOFOLLOW | AT_EACCESS))
-    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);
-
-  if ((flag == 0 || ((flag & ~AT_EACCESS) == 0 && ! __libc_enable_secure)))
-    return INLINE_SYSCALL (faccessat, 3, fd, file, mode);
-
-  struct __stat64_t64 stats;
-  if (__fstatat64_time64 (fd, file, &stats, flag & AT_SYMLINK_NOFOLLOW))
-    return -1;
-
-  mode &= (X_OK | W_OK | R_OK);	/* Clear any bogus bits. */
-# if R_OK != S_IROTH || W_OK != S_IWOTH || X_OK != S_IXOTH
-#  error Oops, portability assumptions incorrect.
-# endif
-
-  if (mode == F_OK)
-    return 0;			/* The file exists. */
-
-  uid_t uid = (flag & AT_EACCESS) ? __geteuid () : __getuid ();
-
-  /* The super-user can read and write any file, and execute any file
-     that anyone can execute. */
-  if (uid == 0 && ((mode & X_OK) == 0
-		   || (stats.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))))
-    return 0;
-
-  int granted = (uid == stats.st_uid
-		 ? (unsigned int) (stats.st_mode & (mode << 6)) >> 6
-		 : (stats.st_gid == ((flag & AT_EACCESS)
-				     ? __getegid () : __getgid ())
-		    || __group_member (stats.st_gid))
-		 ? (unsigned int) (stats.st_mode & (mode << 3)) >> 3
-		 : (stats.st_mode & mode));
-
-  if (granted == mode)
-    return 0;
-
-  return INLINE_SYSCALL_ERROR_RETURN_VALUE (EACCES);
-#endif /* !__ASSUME_FACCESSAT2 */
+  return zsys_faccessat (fd, file, mode, flag);
 }
 weak_alias (__faccessat, faccessat)
diff --git a/sysdeps/unix/sysv/linux/fallocate64.c b/sysdeps/unix/sysv/linux/fallocate64.c
index 3c5436fba0f8..9c19eb184a65 100644
--- a/sysdeps/unix/sysv/linux/fallocate64.c
+++ b/sysdeps/unix/sysv/linux/fallocate64.c
@@ -18,14 +18,14 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 
 /* Reserve storage for the data of the file associated with FD.  */
 int
 fallocate64 (int fd, int mode, __off64_t offset, __off64_t len)
 {
-  return SYSCALL_CANCEL (fallocate, fd, mode,
-			 SYSCALL_LL64 (offset), SYSCALL_LL64 (len));
+  return zsys_fallocate (fd, mode, offset, len);
 }
 
 #ifdef __OFF_T_MATCHES_OFF64_T
diff --git a/sysdeps/unix/sysv/linux/fchmodat.c b/sysdeps/unix/sysv/linux/fchmodat.c
index dad2e1205be8..23f18ced4e53 100644
--- a/sysdeps/unix/sysv/linux/fchmodat.c
+++ b/sysdeps/unix/sysv/linux/fchmodat.c
@@ -25,81 +25,11 @@
 #include <sys/types.h>
 #include <sysdep.h>
 #include <unistd.h>
-
-#if !__ASSUME_FCHMODAT2
-static int
-fchmodat_fallback (int fd, const char *file, mode_t mode, int flag)
-{
-  if (flag != AT_SYMLINK_NOFOLLOW)
-    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);
-
-  /* The kernel system call does not have a mode argument.
-     However, we can create an O_PATH descriptor and change that
-     via /proc (which does not resolve symbolic links).  */
-
-  int pathfd = __openat_nocancel (fd, file,
-				  O_PATH | O_NOFOLLOW | O_CLOEXEC);
-  if (pathfd < 0)
-    /* This may report errors such as ENFILE and EMFILE.  The
-       caller can treat them as temporary if necessary.  */
-    return pathfd;
-
-  /* Use fstatat because fstat does not work on O_PATH descriptors
-     before Linux 3.6.  */
-  struct __stat64_t64 st;
-  if (__fstatat64_time64 (pathfd, "", &st, AT_EMPTY_PATH) != 0)
-    {
-      __close_nocancel (pathfd);
-      return -1;
-    }
-
-  /* Some Linux versions with some file systems can actually
-     change symbolic link permissions via /proc, but this is not
-     intentional, and it gives inconsistent results (e.g., error
-     return despite mode change).  The expected behavior is that
-     symbolic link modes cannot be changed at all, and this check
-     enforces that.  */
-  if (S_ISLNK (st.st_mode))
-    {
-      __close_nocancel (pathfd);
-      __set_errno (EOPNOTSUPP);
-      return -1;
-    }
-
-  /* For most file systems, fchmod does not operate on O_PATH
-     descriptors, so go through /proc.  */
-  struct fd_to_filename filename;
-  int ret = __chmod (__fd_to_filename (pathfd, &filename), mode);
-  if (ret != 0)
-    {
-      if (errno == ENOENT)
-	/* /proc has not been mounted.  Without /proc, there is no
-	   way to upgrade the O_PATH descriptor to a full
-	   descriptor.  It is also not possible to re-open the
-	   file without O_PATH because the file name may refer to
-	   another file, and opening that without O_PATH may have
-	   side effects (such as blocking, device rewinding, or
-	   releasing POSIX locks).  */
-	__set_errno (EOPNOTSUPP);
-    }
-  __close_nocancel (pathfd);
-  return ret;
-}
-#endif
+#include <pizlonated_syscalls.h>
 
 int
 fchmodat (int fd, const char *file, mode_t mode, int flag)
 {
-#if __ASSUME_FCHMODAT2
-  return INLINE_SYSCALL_CALL (fchmodat2, fd, file, mode, flag);
-#else
-  if (flag == 0)
-    return INLINE_SYSCALL_CALL (fchmodat, fd, file, mode);
-
-  int r = INLINE_SYSCALL_CALL (fchmodat2, fd, file, mode, flag);
-  if (r != 0 && errno == ENOSYS)
-    return fchmodat_fallback (fd, file, mode, flag);
-  return r;
-#endif
+  return zsys_fchmodat (fd, file, mode, flag);
 }
 libc_hidden_def (fchmodat)
diff --git a/sysdeps/unix/sysv/linux/fcntl64.c b/sysdeps/unix/sysv/linux/fcntl64.c
index 9c7b0dd3eb10..0b0b975375af 100644
--- a/sysdeps/unix/sysv/linux/fcntl64.c
+++ b/sysdeps/unix/sysv/linux/fcntl64.c
@@ -24,6 +24,7 @@
 #include <stdarg.h>
 #include <errno.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 #ifndef __NR_fcntl64
 # define __NR_fcntl64 __NR_fcntl
@@ -36,19 +37,7 @@
 int
 __libc_fcntl64 (int fd, int cmd, ...)
 {
-  va_list ap;
-  void *arg;
-
-  va_start (ap, cmd);
-  arg = va_arg (ap, void *);
-  va_end (ap);
-
-  cmd = FCNTL_ADJUST_CMD (cmd);
-
-  if (cmd == F_SETLKW || cmd == F_SETLKW64 || cmd == F_OFD_SETLKW)
-    return SYSCALL_CANCEL (fcntl64, fd, cmd, arg);
-
-  return __fcntl64_nocancel_adjusted (fd, cmd, arg);
+  return *(int *) zcall (zsys_fcntl, zargs ());
 }
 libc_hidden_def (__libc_fcntl64)
 weak_alias (__libc_fcntl64, __fcntl64)
diff --git a/sysdeps/unix/sysv/linux/fcntl_nocancel.c b/sysdeps/unix/sysv/linux/fcntl_nocancel.c
index 68483d843e57..cf18c6bda2cf 100644
--- a/sysdeps/unix/sysv/linux/fcntl_nocancel.c
+++ b/sysdeps/unix/sysv/linux/fcntl_nocancel.c
@@ -21,6 +21,7 @@
 #include <errno.h>
 #include <sysdep-cancel.h>
 #include <not-cancel.h>
+#include <pizlonated_syscalls.h>
 
 #ifndef __NR_fcntl64
 # define __NR_fcntl64 __NR_fcntl
@@ -33,16 +34,7 @@
 int
 __fcntl64_nocancel (int fd, int cmd, ...)
 {
-  va_list ap;
-  void *arg;
-
-  va_start (ap, cmd);
-  arg = va_arg (ap, void *);
-  va_end (ap);
-
-  cmd = FCNTL_ADJUST_CMD (cmd);
-
-  return __fcntl64_nocancel_adjusted (fd, cmd, arg);
+  return *(int *) zcall (zsys_fcntl, zargs ());
 }
 hidden_def (__fcntl64_nocancel)
 
@@ -52,13 +44,12 @@ __fcntl64_nocancel_adjusted (int fd, int cmd, void *arg)
   if (cmd == F_GETOWN)
     {
       struct f_owner_ex fex;
-      int res = INTERNAL_SYSCALL_CALL (fcntl64, fd, F_GETOWN_EX, &fex);
-      if (!INTERNAL_SYSCALL_ERROR_P (res))
+      int res = zsys_fcntl (fd, F_GETOWN_EX, &fex);
+      if (!res)
 	return fex.type == F_OWNER_GID ? -fex.pid : fex.pid;
 
-      return INLINE_SYSCALL_ERROR_RETURN_VALUE
-        (INTERNAL_SYSCALL_ERRNO (res));
+      return res;
     }
 
-  return INLINE_SYSCALL_CALL (fcntl64, fd, cmd, (void *) arg);
+  return zsys_fcntl (fd, cmd, arg);
 }
diff --git a/sysdeps/unix/sysv/linux/fdatasync.c b/sysdeps/unix/sysv/linux/fdatasync.c
index b4b009f6efed..e5e6fba6a366 100644
--- a/sysdeps/unix/sysv/linux/fdatasync.c
+++ b/sysdeps/unix/sysv/linux/fdatasync.c
@@ -19,12 +19,13 @@
 
 #include <unistd.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 /* Synchronize at least the data part of a file with the underlying
    media.  */
 int
 fdatasync (int fd)
 {
-  return SYSCALL_CANCEL (fdatasync, fd);
+  return zsys_fdatasync (fd);
 }
 libc_hidden_def (fdatasync)
diff --git a/sysdeps/unix/sysv/linux/fstat64.c b/sysdeps/unix/sysv/linux/fstat64.c
index cc9f695df9c6..708c56481c11 100644
--- a/sysdeps/unix/sysv/linux/fstat64.c
+++ b/sysdeps/unix/sysv/linux/fstat64.c
@@ -24,51 +24,12 @@
 #include <fcntl.h>
 #include <internal-stat.h>
 #include <errno.h>
+#include <pizlonated_syscalls.h>
 
 int
 __fstat64_time64 (int fd, struct __stat64_t64 *buf)
 {
-#if !FSTATAT_USE_STATX
-# if XSTAT_IS_XSTAT64
-  /* The __NR_stat macro is defined for all ABIs that also define 
-     XSTAT_IS_STAT64, so to correctly identify alpha and sparc check
-     __NR_newfstatat (similar to what fstatat64 does).  */
-#  ifdef __NR_newfstatat
-  /* 64-bit kABI, e.g. aarch64, ia64, powerpc64*, s390x, riscv64, and
-     x86_64.  */
-  return INLINE_SYSCALL_CALL (fstat, fd, buf);
-#  elif defined __NR_fstat64
-#   if STAT64_IS_KERNEL_STAT64
-  /* 64-bit kABI outlier, e.g. alpha  */
-  return INLINE_SYSCALL_CALL (fstat64, fd, buf);
-#   else
-  /* 64-bit kABI outlier, e.g. sparc64.  */
-  struct kernel_stat64 kst64;
-  int r = INLINE_SYSCALL_CALL (fstat64, fd, &kst64);
-  if (r == 0)
-    __cp_stat64_kstat64 (buf, &kst64);
-  return r;
-#   endif /* STAT64_IS_KERNEL_STAT64 */
-#  endif
-# else /* XSTAT_IS_XSTAT64 */
-  /* 64-bit kabi outlier, e.g. mips64 and mips64-n32.  */
-  struct kernel_stat kst;
-  int r = INLINE_SYSCALL_CALL (fstat, fd, &kst);
-  if (r == 0)
-    __cp_kstat_stat64_t64 (&kst, buf);
-  return r;
-# endif
-#else /* !FSTATAT_USE_STATX  */
-  /* All kABIs with non-LFS support and with old 32-bit time_t support
-     e.g. arm, csky, i386, hppa, m68k, microblaze, nios2, sh, powerpc32,
-     and sparc32.  */
-  if (fd < 0)
-    {
-      __set_errno (EBADF);
-      return -1;
-    }
-  return __fstatat64_time64 (fd, "", buf, AT_EMPTY_PATH);
-#endif
+  return zsys_fstat (fd, buf);
 }
 #if __TIMESIZE != 64
 hidden_def (__fstat64_time64)
diff --git a/sysdeps/unix/sysv/linux/fstatat64.c b/sysdeps/unix/sysv/linux/fstatat64.c
index da496177c9a2..1059a8750c03 100644
--- a/sysdeps/unix/sysv/linux/fstatat64.c
+++ b/sysdeps/unix/sysv/linux/fstatat64.c
@@ -25,6 +25,7 @@
 #include <time.h>
 #include <sys/sysmacros.h>
 #include <internal-stat.h>
+#include <pizlonated_syscalls.h>
 
 #if __TIMESIZE == 64 \
      && (__WORDSIZE == 32 \
@@ -144,21 +145,7 @@ int
 __fstatat64_time64 (int fd, const char *file, struct __stat64_t64 *buf,
 		    int flag)
 {
-  int r;
-
-#if FSTATAT_USE_STATX
-  r = fstatat64_time64_statx (fd, file, buf, flag);
-# ifndef __ASSUME_STATX
-  if (r == -ENOSYS)
-    r = fstatat64_time64_stat (fd, file, buf, flag);
-# endif
-#else
-  r = fstatat64_time64_stat (fd, file, buf, flag);
-#endif
-
-  return INTERNAL_SYSCALL_ERROR_P (r)
-	 ? INLINE_SYSCALL_ERROR_RETURN_VALUE (-r)
-	 : 0;
+  return zsys_fstatat (fd, file, buf, flag);
 }
 #if __TIMESIZE != 64
 hidden_def (__fstatat64_time64)
diff --git a/sysdeps/unix/sysv/linux/fstatfs64.c b/sysdeps/unix/sysv/linux/fstatfs64.c
index fa5c1ffd2c8f..816d74e74bc1 100644
--- a/sysdeps/unix/sysv/linux/fstatfs64.c
+++ b/sysdeps/unix/sysv/linux/fstatfs64.c
@@ -24,15 +24,13 @@
 #undef __fstatfs
 #undef fstatfs
 
+#include <pizlonated_syscalls.h>
+
 /* Return information about the filesystem on which FD resides.  */
 int
 __fstatfs64 (int fd, struct statfs64 *buf)
 {
-#ifdef __NR_fstatfs64
-  return INLINE_SYSCALL_CALL (fstatfs64, fd, sizeof (*buf), buf);
-#else
-  return INLINE_SYSCALL_CALL (fstatfs, fd, buf);
-#endif
+  return zsys_fstatfs (fd, buf);
 }
 weak_alias (__fstatfs64, fstatfs64)
 
diff --git a/sysdeps/unix/sysv/linux/fsync.c b/sysdeps/unix/sysv/linux/fsync.c
index 20addf6acb33..b364c2fcd4f7 100644
--- a/sysdeps/unix/sysv/linux/fsync.c
+++ b/sysdeps/unix/sysv/linux/fsync.c
@@ -19,11 +19,12 @@
 
 #include <unistd.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 /* Make all changes done to FD actually appear on disk.  */
 int
 fsync (int fd)
 {
-  return SYSCALL_CANCEL (fsync, fd);
+  return zsys_fsync (fd);
 }
 libc_hidden_def (fsync)
diff --git a/sysdeps/unix/sysv/linux/ftruncate64.c b/sysdeps/unix/sysv/linux/ftruncate64.c
index 65deb26bb52e..a0e074c903e9 100644
--- a/sysdeps/unix/sysv/linux/ftruncate64.c
+++ b/sysdeps/unix/sysv/linux/ftruncate64.c
@@ -17,6 +17,7 @@
 
 #include <unistd.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 #ifndef __NR_ftruncate64
 # define __NR_ftruncate64 __NR_ftruncate
@@ -26,8 +27,7 @@
 int
 __ftruncate64 (int fd, off64_t length)
 {
-  return INLINE_SYSCALL_CALL (ftruncate64, fd,
-			      __ALIGNMENT_ARG SYSCALL_LL64 (length));
+  return zsys_ftruncate (fd, length);
 }
 weak_alias (__ftruncate64, ftruncate64)
 
diff --git a/sysdeps/unix/sysv/linux/futimens.c b/sysdeps/unix/sysv/linux/futimens.c
index 040aee97a2d1..e63f3e411eb5 100644
--- a/sysdeps/unix/sysv/linux/futimens.c
+++ b/sysdeps/unix/sysv/linux/futimens.c
@@ -21,6 +21,7 @@
 #include <string.h>
 #include <time.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 
 /* Change the access time of the file associated with FD to TSP[0] and
@@ -31,10 +32,7 @@
 int
 __futimens64 (int fd, const struct __timespec64 tsp64[2])
 {
-  if (fd < 0)
-    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EBADF);
-
-  return __utimensat64_helper (fd, NULL, &tsp64[0], 0);
+  return zsys_futimens (fd, tsp64);
 }
 
 #if __TIMESIZE != 64
diff --git a/sysdeps/unix/sysv/linux/futimes.c b/sysdeps/unix/sysv/linux/futimes.c
index 87e31f2cbf9f..9f0cded51c25 100644
--- a/sysdeps/unix/sysv/linux/futimes.c
+++ b/sysdeps/unix/sysv/linux/futimes.c
@@ -18,21 +18,14 @@
 
 #include <errno.h>
 #include <time.h>
+#include <pizlonated_syscalls.h>
 
 /* Change the access time of the file associated with FD to TVP[0] and
    the modification time of FILE to TVP[1].  */
 int
 __futimes64 (int fd, const struct __timeval64 tvp64[2])
 {
-  /* The utimensat system call expects timespec not timeval.  */
-  struct __timespec64 ts64[2];
-  if (tvp64 != NULL)
-    {
-      ts64[0] = timeval64_to_timespec64 (tvp64[0]);
-      ts64[1] = timeval64_to_timespec64 (tvp64[1]);
-    }
-
-  return __utimensat64_helper (fd, NULL, tvp64 ? &ts64[0] : NULL, 0);
+  return zsys_futimes (fd, tvp64);
 }
 
 #if __TIMESIZE != 64
diff --git a/sysdeps/unix/sysv/linux/getcpu.c b/sysdeps/unix/sysv/linux/getcpu.c
index 0e7c3238c932..e552d4d97b6b 100644
--- a/sysdeps/unix/sysv/linux/getcpu.c
+++ b/sysdeps/unix/sysv/linux/getcpu.c
@@ -19,15 +19,12 @@
 #include <sched.h>
 #include <sysdep.h>
 #include <sysdep-vdso.h>
+#include <pizlonated_syscalls.h>
 
 int
 __getcpu (unsigned int *cpu, unsigned int *node)
 {
-#ifdef HAVE_GETCPU_VSYSCALL
-  return INLINE_VSYSCALL (getcpu, 3, cpu, node, NULL);
-#else
-  return INLINE_SYSCALL_CALL (getcpu, cpu, node, NULL);
-#endif
+  return zsys_getcpu (cpu, node);
 }
 weak_alias (__getcpu, getcpu)
 libc_hidden_def (__getcpu)
diff --git a/sysdeps/unix/sysv/linux/getcwd.c b/sysdeps/unix/sysv/linux/getcwd.c
index d05b83a1f6b5..50c538a2fc3b 100644
--- a/sysdeps/unix/sysv/linux/getcwd.c
+++ b/sysdeps/unix/sysv/linux/getcwd.c
@@ -25,15 +25,12 @@
 
 #include <sysdep.h>
 #include <sys/syscall.h>
+#include <pizlonated_syscalls.h>
 
-
-/* If we compile the file for use in ld.so we don't need the feature
-   that getcwd() allocates the buffers itself.  */
-#if IS_IN (rtld)
-# define NO_ALLOCATION	1
+#ifdef NO_ALLOCATION
+#undef NO_ALLOCATION
 #endif
 
-
 /* The "proc" filesystem provides an easy method to retrieve the value.
    For each process, the corresponding directory contains a symbolic link
    named `cwd'.  Reading the content of this link immediate gives us the
@@ -48,7 +45,6 @@ char *
 __getcwd (char *buf, size_t size)
 {
   char *path;
-  char *result;
 
 #ifndef NO_ALLOCATION
   size_t alloc_size = size;
@@ -77,14 +73,10 @@ __getcwd (char *buf, size_t size)
 
   int retval;
 
-  retval = INLINE_SYSCALL (getcwd, 2, path, alloc_size);
+  retval = zsys_getcwd (path, alloc_size) ? 1 : -1;
   if (retval > 0 && path[0] == '/')
     {
 #ifndef NO_ALLOCATION
-      if (buf == NULL && size == 0)
-	/* Ensure that the buffer is only as large as necessary.  */
-	buf = realloc (path, (size_t) retval);
-
       if (buf == NULL)
 	/* Either buf was NULL all along, or `realloc' failed but
 	   we still have the original string.  */
@@ -99,22 +91,7 @@ __getcwd (char *buf, size_t size)
      generic implementation right away.  */
   if (retval >= 0 || errno == ENAMETOOLONG)
     {
-#ifndef NO_ALLOCATION
-      if (buf == NULL && size == 0)
-	{
-	  free (path);
-	  path = NULL;
-	}
-#endif
-
-      result = __getcwd_generic (path, size);
-
-#ifndef NO_ALLOCATION
-      if (result == NULL && buf == NULL && size != 0)
-	free (path);
-#endif
-
-      return result;
+      ZASSERT (!"Should not get here");
     }
 
   /* It should never happen that the `getcwd' syscall failed because
diff --git a/sysdeps/unix/sysv/linux/getdents64.c b/sysdeps/unix/sysv/linux/getdents64.c
index 227fbf21aef2..138d7a82ff33 100644
--- a/sysdeps/unix/sysv/linux/getdents64.c
+++ b/sysdeps/unix/sysv/linux/getdents64.c
@@ -20,16 +20,13 @@
 #include <dirent.h>
 #include <errno.h>
 #include <limits.h>
+#include <pizlonated_syscalls.h>
 
 /* The kernel struct linux_dirent64 matches the 'struct dirent64' type.  */
 ssize_t
 __getdents64 (int fd, void *buf, size_t nbytes)
 {
-  /* The system call takes an unsigned int argument, and some length
-     checks in the kernel use an int type.  */
-  if (nbytes > INT_MAX)
-    nbytes = INT_MAX;
-  return INLINE_SYSCALL_CALL (getdents64, fd, buf, nbytes);
+  return zsys_getdents (fd, buf, nbytes);
 }
 libc_hidden_def (__getdents64)
 weak_alias (__getdents64, getdents64)
diff --git a/sysdeps/unix/sysv/linux/getentropy.c b/sysdeps/unix/sysv/linux/getentropy.c
index 2d8030acbe2c..1ee834e6b7e1 100644
--- a/sysdeps/unix/sysv/linux/getentropy.c
+++ b/sysdeps/unix/sysv/linux/getentropy.c
@@ -21,6 +21,7 @@
 #include <errno.h>
 #include <unistd.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 /* Write LENGTH bytes of randomness starting at BUFFER.  Return 0 on
    success and -1 on failure.  */
@@ -42,7 +43,7 @@ getentropy (void *buffer, size_t length)
   while (buffer < end)
     {
       /* NB: No cancellation point.  */
-      ssize_t bytes = INLINE_SYSCALL_CALL (getrandom, buffer, end - buffer, 0);
+      ssize_t bytes = zsys_getrandom (buffer, end - buffer, 0);
       if (bytes < 0)
         {
           if (errno == EINTR)
diff --git a/sysdeps/unix/sysv/linux/getitimer.c b/sysdeps/unix/sysv/linux/getitimer.c
index dd1a4b55120e..8774265befcc 100644
--- a/sysdeps/unix/sysv/linux/getitimer.c
+++ b/sysdeps/unix/sysv/linux/getitimer.c
@@ -21,24 +21,12 @@
 #include <sys/types.h>
 #include <sysdep.h>
 #include <tv32-compat.h>
+#include <pizlonated_syscalls.h>
 
 int
 __getitimer64 (__itimer_which_t which, struct __itimerval64 *curr_value)
 {
-#if __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64
-  return INLINE_SYSCALL_CALL (getitimer, which, curr_value);
-#else
-  struct __itimerval32 curr_value_32;
-
-  if (INLINE_SYSCALL_CALL (getitimer, which, &curr_value_32) == -1)
-    return -1;
-
-  curr_value->it_interval
-    = valid_timeval32_to_timeval64 (curr_value_32.it_interval);
-  curr_value->it_value
-    = valid_timeval32_to_timeval64 (curr_value_32.it_value);
-  return 0;
-#endif
+  return zsys_getitimer (which, curr_value);
 }
 
 #if __TIMESIZE != 64
diff --git a/sysdeps/unix/sysv/linux/getpriority.c b/sysdeps/unix/sysv/linux/getpriority.c
index 89d0ee986676..403e87f72fcd 100644
--- a/sysdeps/unix/sysv/linux/getpriority.c
+++ b/sysdeps/unix/sysv/linux/getpriority.c
@@ -21,6 +21,7 @@
 
 #include <sysdep.h>
 #include <sys/syscall.h>
+#include <pizlonated_syscalls.h>
 
 /* The return value of getpriority syscall is biased by this value
    to avoid returning negative values.  */
@@ -34,12 +35,7 @@
 int
 __getpriority (enum __priority_which which, id_t who)
 {
-  int res;
-
-  res = INLINE_SYSCALL (getpriority, 2, (int) which, who);
-  if (res >= 0)
-    res = PZERO - res;
-  return res;
+  return zsys_getpriority (which, who);
 }
 libc_hidden_def (__getpriority)
 weak_alias (__getpriority, getpriority)
diff --git a/sysdeps/unix/sysv/linux/getrandom.c b/sysdeps/unix/sysv/linux/getrandom.c
index 777d1decf0fa..dbe1cb864031 100644
--- a/sysdeps/unix/sysv/linux/getrandom.c
+++ b/sysdeps/unix/sysv/linux/getrandom.c
@@ -20,13 +20,14 @@
 #include <errno.h>
 #include <unistd.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 /* Write up to LENGTH bytes of randomness starting at BUFFER.
    Return the number of bytes written, or -1 on error.  */
 ssize_t
 __getrandom (void *buffer, size_t length, unsigned int flags)
 {
-  return SYSCALL_CANCEL (getrandom, buffer, length, flags);
+  return zsys_getrandom (buffer, length, flags);
 }
 libc_hidden_def (__getrandom)
 weak_alias (__getrandom, getrandom)
diff --git a/sysdeps/unix/sysv/linux/getrlimit64.c b/sysdeps/unix/sysv/linux/getrlimit64.c
index 451cef4cadd8..d96f35065a8c 100644
--- a/sysdeps/unix/sysv/linux/getrlimit64.c
+++ b/sysdeps/unix/sysv/linux/getrlimit64.c
@@ -20,6 +20,7 @@
 #include <sys/types.h>
 #include <sysdep.h>
 #include <shlib-compat.h>
+#include <pizlonated_syscalls.h>
 
 /* Add this redirection so the strong_alias for __RLIM_T_MATCHES_RLIM64_T
    linking getrlimit64 to {__}getrlimit does not throw a type error.  */
@@ -36,7 +37,7 @@
 int
 __getrlimit64 (enum __rlimit_resource resource, struct rlimit64 *rlimits)
 {
-  return INLINE_SYSCALL_CALL (prlimit64, 0, resource, NULL, rlimits);
+  return zsys_getrlimit(resource, rlimits);
 }
 libc_hidden_def (__getrlimit64)
 
diff --git a/sysdeps/unix/sysv/linux/getrusage.c b/sysdeps/unix/sysv/linux/getrusage.c
index 9126e1fa9bca..c44df0932a31 100644
--- a/sysdeps/unix/sysv/linux/getrusage.c
+++ b/sysdeps/unix/sysv/linux/getrusage.c
@@ -21,20 +21,12 @@
 #include <sys/types.h>
 #include <sysdep.h>
 #include <tv32-compat.h>
+#include <pizlonated_syscalls.h>
 
 int
 __getrusage64 (enum __rusage_who who, struct __rusage64 *usage)
 {
-#if __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64
-  return INLINE_SYSCALL_CALL (getrusage, who, usage);
-#else
-  struct __rusage32 usage32;
-  if (INLINE_SYSCALL_CALL (getrusage, who, &usage32) == -1)
-    return -1;
-
-  rusage32_to_rusage64 (&usage32, usage);
-  return 0;
-#endif
+  return zsys_getrusage (who, usage);
 }
 
 #if __TIMESIZE != 64
diff --git a/sysdeps/unix/sysv/linux/getsockopt.c b/sysdeps/unix/sysv/linux/getsockopt.c
index e6aa5e4009c4..9e9051421034 100644
--- a/sysdeps/unix/sysv/linux/getsockopt.c
+++ b/sysdeps/unix/sysv/linux/getsockopt.c
@@ -20,16 +20,13 @@
 #include <sysdep.h>
 #include <socketcall.h>
 #include <socket-constants-time64.h>
+#include <pizlonated_syscalls.h>
 
 static int
 getsockopt_syscall (int fd, int level, int optname, void *optval,
 		    socklen_t *len)
 {
-#ifdef __ASSUME_GETSOCKOPT_SYSCALL
-  return INLINE_SYSCALL (getsockopt, 5, fd, level, optname, optval, len);
-#else
-  return SOCKETCALL (getsockopt, fd, level, optname, optval, len);
-#endif
+  return zsys_getsockopt (fd, level, optname, optval, len);
 }
 
 #ifndef __ASSUME_TIME64_SYSCALLS
diff --git a/sysdeps/unix/sysv/linux/getsysstats.c b/sysdeps/unix/sysv/linux/getsysstats.c
index 1c041b7ebb00..24cca3a4a719 100644
--- a/sysdeps/unix/sysv/linux/getsysstats.c
+++ b/sysdeps/unix/sysv/linux/getsysstats.c
@@ -28,6 +28,7 @@
 #include <sys/mman.h>
 #include <sys/sysinfo.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 static int
 __get_nprocs_sched (void)
@@ -40,8 +41,7 @@ __get_nprocs_sched (void)
 
   /* This cannot use malloc because it is used on malloc initialization.  */
   __cpu_mask cpu_bits[cpu_bits_size / sizeof (__cpu_mask)];
-  int r = INTERNAL_SYSCALL_CALL (sched_getaffinity, 0, cpu_bits_size,
-				 cpu_bits);
+  int r = zsys_sched_getaffinity (0, cpu_bits_size, cpu_bits);
   if (r > 0)
     return CPU_COUNT_S (r, (cpu_set_t*) cpu_bits);
   else if (r == -EINVAL)
diff --git a/sysdeps/unix/sysv/linux/gettimeofday.c b/sysdeps/unix/sysv/linux/gettimeofday.c
index 7ab147c6143a..1d6887810b6c 100644
--- a/sysdeps/unix/sysv/linux/gettimeofday.c
+++ b/sysdeps/unix/sysv/linux/gettimeofday.c
@@ -19,42 +19,6 @@
 #include <time.h>
 #include <string.h>
 
-/* Optimize the function call by setting the PLT directly to vDSO symbol.  */
-#ifdef USE_IFUNC_GETTIMEOFDAY
-# include <sysdep.h>
-# include <sysdep-vdso.h>
-
-# ifdef SHARED
-# include <dl-vdso.h>
-# include <libc-vdso.h>
-
-static int
-__gettimeofday_syscall (struct timeval *restrict tv, void *restrict tz)
-{
-  if (__glibc_unlikely (tz != 0))
-    memset (tz, 0, sizeof *tz);
-  return INLINE_SYSCALL_CALL (gettimeofday, tv, tz);
-}
-
-# undef INIT_ARCH
-# define INIT_ARCH() \
-  void *vdso_gettimeofday = dl_vdso_vsym (HAVE_GETTIMEOFDAY_VSYSCALL)
-libc_ifunc (__gettimeofday,
-	    vdso_gettimeofday ? VDSO_IFUNC_RET (vdso_gettimeofday)
-			      : (void *) __gettimeofday_syscall)
-
-# else
-int
-__gettimeofday (struct timeval *restrict tv, void *restrict tz)
-{
-  if (__glibc_unlikely (tz != 0))
-    memset (tz, 0, sizeof *tz);
-
-  return INLINE_VSYSCALL (gettimeofday, 2, tv, tz);
-}
-# endif
-weak_alias (__gettimeofday, gettimeofday)
-#else /* USE_IFUNC_GETTIMEOFDAY  */
 /* Conversion of gettimeofday function to support 64 bit time on archs
    with __WORDSIZE == 32 and __TIMESIZE == 32/64  */
 #include <errno.h>
@@ -73,7 +37,7 @@ __gettimeofday64 (struct __timeval64 *restrict tv, void *restrict tz)
   return 0;
 }
 
-# if __TIMESIZE != 64
+#if __TIMESIZE != 64
 libc_hidden_def (__gettimeofday64)
 
 int
@@ -92,6 +56,5 @@ __gettimeofday (struct timeval *restrict tv, void *restrict tz)
   *tv = valid_timeval64_to_timeval (tv64);
   return 0;
 }
-# endif
-weak_alias (__gettimeofday, gettimeofday)
 #endif
+weak_alias (__gettimeofday, gettimeofday)
diff --git a/sysdeps/unix/sysv/linux/ifaddrs.c b/sysdeps/unix/sysv/linux/ifaddrs.c
index 10b26d8b3c1c..3b546b70733c 100644
--- a/sysdeps/unix/sysv/linux/ifaddrs.c
+++ b/sysdeps/unix/sysv/linux/ifaddrs.c
@@ -32,6 +32,7 @@
 #include <sysdep.h>
 #include <time.h>
 #include <unistd.h>
+#include <pizlonated_syscalls.h>
 
 #include "netlinkaccess.h"
 
@@ -229,8 +230,9 @@ out_fail:
 void
 __netlink_close (struct netlink_handle *h)
 {
-  /* Don't modify errno.  */
-  INTERNAL_SYSCALL_CALL (close, h->fd);
+  int saved_errno = errno;
+  zsys_close (h->fd);
+  errno = saved_errno;
 }
 
 
diff --git a/sysdeps/unix/sysv/linux/internal-signals.h b/sysdeps/unix/sysv/linux/internal-signals.h
index a6fae59aaa60..bf889a255a84 100644
--- a/sysdeps/unix/sysv/linux/internal-signals.h
+++ b/sysdeps/unix/sysv/linux/internal-signals.h
@@ -26,31 +26,32 @@
 #include <stdbool.h>
 #include <stddef.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 /* The signal used for asynchronous cancelation.  */
 #define SIGCANCEL       __SIGRTMIN
 
 
+/* Signal used to implement the setuid et.al. functions.  */
+#define SIGSETXID       (__SIGRTMIN + 1)
+
+
 /* Signal needed for the kernel-supported POSIX timer implementation.
    We can reuse the cancellation signal since we can distinguish
    cancellation from timer expirations.  */
-#define SIGTIMER        SIGCANCEL
-
-
-/* Signal used to implement the setuid et.al. functions.  */
-#define SIGSETXID       (__SIGRTMIN + 1)
+#define SIGTIMER        (__SIGRTMIN + 2)
 
 
 /* How many signal numbers need to be reserved for libpthread's private uses
    (SIGCANCEL and SIGSETXID).  */
-#define RESERVED_SIGRT  2
+#define RESERVED_SIGRT  3
 
 
 /* Return is sig is used internally.  */
 static inline bool
 is_internal_signal (int sig)
 {
-  return (sig == SIGCANCEL) || (sig == SIGSETXID);
+  return (sig == SIGCANCEL) || (sig == SIGSETXID) || (sig == SIGTIMER);
 }
 
 /* Remove internal glibc signal from the mask.  */
@@ -59,6 +60,7 @@ clear_internal_signals (sigset_t *set)
 {
   __sigdelset (set, SIGCANCEL);
   __sigdelset (set, SIGSETXID);
+  __sigdelset (set, SIGTIMER);
 }
 
 static const internal_sigset_t sigall_set = {
@@ -70,24 +72,21 @@ static inline int
 internal_sigprocmask (int how, const internal_sigset_t *set,
 		      internal_sigset_t *oldset)
 {
-  return INTERNAL_SYSCALL_CALL (rt_sigprocmask, how, set, oldset,
-				__NSIG_BYTES);
+  return zsys_sigprocmask(how, set, oldset);
 }
 
 /* Block all signals, including internal glibc ones.  */
 static inline void
 internal_signal_block_all (internal_sigset_t *oset)
 {
-  INTERNAL_SYSCALL_CALL (rt_sigprocmask, SIG_BLOCK, &sigall_set, oset,
-			 __NSIG_BYTES);
+  zsys_sigprocmask(SIG_BLOCK, &sigall_set, oset);
 }
 
 /* Restore current process signal mask.  */
 static inline void
 internal_signal_restore_set (const internal_sigset_t *set)
 {
-  INTERNAL_SYSCALL_CALL (rt_sigprocmask, SIG_SETMASK, set, NULL,
-			 __NSIG_BYTES);
+  zsys_sigprocmask(SIG_SETMASK, set, NULL);
 }
 
 
@@ -103,8 +102,7 @@ static const sigset_t sigtimer_set = {
 static inline void
 signal_unblock_sigtimer (void)
 {
-  INTERNAL_SYSCALL_CALL (rt_sigprocmask, SIG_UNBLOCK, &sigtimer_set, NULL,
-			 __NSIG_BYTES);
+  zsys_sigprocmask(SIG_UNBLOCK, &sigtimer_set, NULL);
 }
 
 #endif
diff --git a/sysdeps/unix/sysv/linux/ioctl.c b/sysdeps/unix/sysv/linux/ioctl.c
index 230aeda3cf4e..7baf06985942 100644
--- a/sysdeps/unix/sysv/linux/ioctl.c
+++ b/sysdeps/unix/sysv/linux/ioctl.c
@@ -20,26 +20,12 @@
 #include <sys/ioctl.h>
 #include <sysdep.h>
 #include <internal-ioctl.h>
+#include <pizlonated_syscalls.h>
 
 int
 __ioctl (int fd, unsigned long int request, ...)
 {
-  va_list args;
-  va_start (args, request);
-  void *arg = va_arg (args, void *);
-  va_end (args);
-
-  int r;
-  if (!__ioctl_arch (&r, fd, request, arg))
-    {
-      r = INTERNAL_SYSCALL_CALL (ioctl, fd, request, arg);
-      if (__glibc_unlikely (INTERNAL_SYSCALL_ERROR_P (r)))
-	{
-	  __set_errno (-r);
-	  return -1;
-	}
-    }
-  return r;
+  return *(int *) zcall (zsys_ioctl, zargs ());
 }
 libc_hidden_def (__ioctl)
 weak_alias (__ioctl, ioctl)
diff --git a/sysdeps/unix/sysv/linux/kernel-posix-timers.h b/sysdeps/unix/sysv/linux/kernel-posix-timers.h
index d10b0002e298..af95de6c5d58 100644
--- a/sysdeps/unix/sysv/linux/kernel-posix-timers.h
+++ b/sysdeps/unix/sysv/linux/kernel-posix-timers.h
@@ -19,6 +19,7 @@
 #include <setjmp.h>
 #include <signal.h>
 #include <sys/types.h>
+#include <stdfil.h>
 
 
 /* Nonzero if the system calls are not available.  */
@@ -43,6 +44,8 @@ extern struct timer *__timer_active_sigev_thread attribute_hidden;
 /* Lock for __timer_active_sigev_thread.  */
 extern pthread_mutex_t __timer_active_sigev_thread_lock attribute_hidden;
 
+extern zptrtable *__timer_ptrtable attribute_hidden;
+
 extern __typeof (timer_create) __timer_create;
 libc_hidden_proto (__timer_create)
 extern __typeof (timer_delete) __timer_delete;
diff --git a/sysdeps/unix/sysv/linux/libc_fatal.c b/sysdeps/unix/sysv/linux/libc_fatal.c
index 4676757eeb7f..6de398568cad 100644
--- a/sysdeps/unix/sysv/linux/libc_fatal.c
+++ b/sysdeps/unix/sysv/linux/libc_fatal.c
@@ -20,15 +20,15 @@
 #include <sys/uio.h>
 #include <stdbool.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 static bool
 writev_for_fatal (int fd, const struct iovec *iov, size_t niov, size_t total)
 {
   ssize_t cnt;
   do
-    cnt = INTERNAL_SYSCALL_CALL (writev, fd, iov, niov);
-  while (INTERNAL_SYSCALL_ERROR_P (cnt)
-         && INTERNAL_SYSCALL_ERRNO (cnt) == EINTR);
+    cnt = zsys_writev (fd, iov, niov);
+  while (cnt < 0 && errno == EINTR);
   return cnt == total;
 }
 #define WRITEV_FOR_FATAL	writev_for_fatal
diff --git a/sysdeps/unix/sysv/linux/libc_sigaction.c b/sysdeps/unix/sysv/linux/libc_sigaction.c
index 8b894d3dccb9..2275e7fe573a 100644
--- a/sysdeps/unix/sysv/linux/libc_sigaction.c
+++ b/sysdeps/unix/sysv/linux/libc_sigaction.c
@@ -21,52 +21,13 @@
 
 #include <sysdep.h>
 #include <sys/syscall.h>
-
-/* New ports should not define the obsolete SA_RESTORER, however some
-   architecture requires for compat mode and/or due old ABI.  */
-#include <kernel_sigaction.h>
-
-#ifndef SA_RESTORER
-# define SET_SA_RESTORER(kact, act)
-# define RESET_SA_RESTORER(act, kact)
-#endif
-
-/* SPARC passes the restore function as an argument to rt_sigaction.  */
-#ifndef STUB
-# define STUB(act, sigsetsize) (sigsetsize)
-#endif
+#include <pizlonated_syscalls.h>
 
 /* If ACT is not NULL, change the action for SIG to *ACT.
    If OACT is not NULL, put the old action for SIG in *OACT.  */
 int
 __libc_sigaction (int sig, const struct sigaction *act, struct sigaction *oact)
 {
-  int result;
-
-  struct kernel_sigaction kact, koact;
-
-  if (act)
-    {
-      kact.k_sa_handler = act->sa_handler;
-      memcpy (&kact.sa_mask, &act->sa_mask, sizeof (sigset_t));
-      kact.sa_flags = act->sa_flags;
-      SET_SA_RESTORER (&kact, act);
-    }
-
-  /* XXX The size argument hopefully will have to be changed to the
-     real size of the user-level sigset_t.  */
-  result = INLINE_SYSCALL_CALL (rt_sigaction, sig,
-				act ? &kact : NULL,
-				oact ? &koact : NULL, STUB (act,
-							    __NSIG_BYTES));
-
-  if (oact && result >= 0)
-    {
-      oact->sa_handler = koact.k_sa_handler;
-      memcpy (&oact->sa_mask, &koact.sa_mask, sizeof (sigset_t));
-      oact->sa_flags = koact.sa_flags;
-      RESET_SA_RESTORER (oact, &koact);
-    }
-  return result;
+  return zsys_sigaction (sig, act, oact);
 }
 libc_hidden_def (__libc_sigaction)
diff --git a/sysdeps/unix/sysv/linux/link.c b/sysdeps/unix/sysv/linux/link.c
index 3dfc7c867e28..06a15bfef28b 100644
--- a/sysdeps/unix/sysv/linux/link.c
+++ b/sysdeps/unix/sysv/linux/link.c
@@ -19,16 +19,13 @@
 #include <unistd.h>
 #include <fcntl.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 /* Make a link to FROM called TO.  */
 int
 __link (const char *from, const char *to)
 {
-#ifdef __NR_link
-  return INLINE_SYSCALL_CALL (link, from, to);
-#else
-  return INLINE_SYSCALL_CALL (linkat, AT_FDCWD, from, AT_FDCWD, to, 0);
-#endif
+  return zsys_link (from, to);
 }
 
 weak_alias (__link, link)
diff --git a/sysdeps/unix/sysv/linux/lseek64.c b/sysdeps/unix/sysv/linux/lseek64.c
index f7ae01f6fdcd..b87b77b5ba76 100644
--- a/sysdeps/unix/sysv/linux/lseek64.c
+++ b/sysdeps/unix/sysv/linux/lseek64.c
@@ -22,23 +22,12 @@
 #include <sysdep.h>
 #include <errno.h>
 #include <shlib-compat.h>
+#include <pizlonated_syscalls.h>
 
 off64_t
 __lseek64 (int fd, off64_t offset, int whence)
 {
-#ifdef __NR_llseek
-# define __NR__llseek __NR_llseek
-#endif
-
-#ifdef __NR__llseek
-  loff_t res;
-  int rc = INLINE_SYSCALL_CALL (_llseek, fd,
-				(long) (((uint64_t) (offset)) >> 32),
-				(long) offset, &res, whence);
-  return rc ?: res;
-#else
-  return INLINE_SYSCALL_CALL (lseek, fd, offset, whence);
-#endif
+  return zsys_lseek (fd, offset, whence);
 }
 
 #ifdef  __OFF_T_MATCHES_OFF64_T
diff --git a/sysdeps/unix/sysv/linux/mkdir.c b/sysdeps/unix/sysv/linux/mkdir.c
index fbab0a917b91..df4c1a6396ae 100644
--- a/sysdeps/unix/sysv/linux/mkdir.c
+++ b/sysdeps/unix/sysv/linux/mkdir.c
@@ -19,16 +19,13 @@
 #include <fcntl.h>
 #include <sys/stat.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 /* Create a directory named PATH with protections MODE.  */
 int
 __mkdir (const char *path, mode_t mode)
 {
-#ifdef __NR_mkdir
-  return INLINE_SYSCALL_CALL (mkdir,  path, mode);
-#else
-  return INLINE_SYSCALL_CALL (mkdirat, AT_FDCWD, path, mode);
-#endif
+  return zsys_mkdir (path, mode);
 }
 
 libc_hidden_def (__mkdir)
diff --git a/sysdeps/unix/sysv/linux/mknodat.c b/sysdeps/unix/sysv/linux/mknodat.c
index 8e350e2574bd..80244dc17461 100644
--- a/sysdeps/unix/sysv/linux/mknodat.c
+++ b/sysdeps/unix/sysv/linux/mknodat.c
@@ -20,17 +20,12 @@
 #include <sys/stat.h>
 #include <errno.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 int
 __mknodat (int fd, const char *path, mode_t mode, dev_t dev)
 {
-  /* The user-exported dev_t is 64-bit while the kernel interface is
-     32-bit.  */
-  unsigned int k_dev = dev;
-  if (k_dev != dev)
-    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);
-
-  return INLINE_SYSCALL_CALL (mknodat, fd, path, mode, k_dev);
+  return zsys_mknodat (fd, path, mode, dev);
 }
 libc_hidden_def (__mknodat)
 weak_alias (__mknodat, mknodat)
diff --git a/sysdeps/unix/sysv/linux/mmap64.c b/sysdeps/unix/sysv/linux/mmap64.c
index f1869fac0ce9..6fbc0f8a8d97 100644
--- a/sysdeps/unix/sysv/linux/mmap64.c
+++ b/sysdeps/unix/sysv/linux/mmap64.c
@@ -51,12 +51,7 @@ __mmap64 (void *addr, size_t len, int prot, int flags, int fd, off64_t offset)
     return (void *) INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);
 
   MMAP_PREPARE (addr, len, prot, flags, fd, offset);
-#ifdef __NR_mmap2
-  return (void *) MMAP_CALL (mmap2, addr, len, prot, flags, fd,
-			     (off_t) (offset / MMAP2_PAGE_UNIT));
-#else
-  return (void *) MMAP_CALL (mmap, addr, len, prot, flags, fd, offset);
-#endif
+  return zsys_mmap (addr, len, prot, flags, fd, offset);
 }
 weak_alias (__mmap64, mmap64)
 libc_hidden_def (__mmap64)
diff --git a/sysdeps/unix/sysv/linux/mremap.c b/sysdeps/unix/sysv/linux/mremap.c
index 1ada5c1f40de..323512fc7039 100644
--- a/sysdeps/unix/sysv/linux/mremap.c
+++ b/sysdeps/unix/sysv/linux/mremap.c
@@ -21,6 +21,7 @@
 #include <stdarg.h>
 #include <stddef.h>
 #include <errno.h>
+#include <pizlonated_syscalls.h>
 
 #define MREMAP_KNOWN_BITS \
   (MREMAP_MAYMOVE \
@@ -46,8 +47,7 @@ __mremap (void *addr, size_t old_len, size_t new_len, int flags, ...)
       va_end (va);
     }
 
-  return (void *) INLINE_SYSCALL_CALL (mremap, addr, old_len, new_len, flags,
-				       new_addr);
+  return zsys_mremap (addr, old_len, new_len, flags, new_addr);
 }
 libc_hidden_def (__mremap)
 weak_alias (__mremap, mremap)
diff --git a/sysdeps/unix/sysv/linux/msgctl.c b/sysdeps/unix/sysv/linux/msgctl.c
index 3120cae0e218..b422c24df609 100644
--- a/sysdeps/unix/sysv/linux/msgctl.c
+++ b/sysdeps/unix/sysv/linux/msgctl.c
@@ -21,149 +21,17 @@
 #include <shlib-compat.h>
 #include <errno.h>
 #include <linux/posix_types.h>  /* For __kernel_mode_t.  */
+#include <pizlonated_syscalls.h>
 
 /* POSIX states ipc_perm mode should have type of mode_t.  */
 _Static_assert (sizeof ((struct msqid_ds){0}.msg_perm.mode)
 		== sizeof (mode_t),
 		"sizeof (msqid_ds.msg_perm.mode) != sizeof (mode_t)");
 
-#if __IPC_TIME64 == 0
-typedef struct msqid_ds msgctl_arg_t;
-#else
-# include <struct_kernel_msqid64_ds.h>
-
-static void
-msqid64_to_kmsqid64 (const struct __msqid64_ds *msqid64,
-		     struct kernel_msqid64_ds *kmsqid)
-{
-  kmsqid->msg_perm       = msqid64->msg_perm;
-  kmsqid->msg_stime      = msqid64->msg_stime;
-  kmsqid->msg_stime_high = msqid64->msg_stime >> 32;
-  kmsqid->msg_rtime      = msqid64->msg_rtime;
-  kmsqid->msg_rtime_high = msqid64->msg_rtime >> 32;
-  kmsqid->msg_ctime      = msqid64->msg_ctime;
-  kmsqid->msg_ctime_high = msqid64->msg_ctime >> 32;
-  kmsqid->msg_cbytes     = msqid64->msg_cbytes;
-  kmsqid->msg_qnum       = msqid64->msg_qnum;
-  kmsqid->msg_qbytes     = msqid64->msg_qbytes;
-  kmsqid->msg_lspid      = msqid64->msg_lspid;
-  kmsqid->msg_lrpid      = msqid64->msg_lrpid;
-}
-
-static void
-kmsqid64_to_msqid64 (const struct kernel_msqid64_ds *kmsqid,
-		     struct __msqid64_ds *msqid64)
-{
-  msqid64->msg_perm   = kmsqid->msg_perm;
-  msqid64->msg_stime  = kmsqid->msg_stime
-		        | ((__time64_t) kmsqid->msg_stime_high << 32);
-  msqid64->msg_rtime  = kmsqid->msg_rtime
-		        | ((__time64_t) kmsqid->msg_rtime_high << 32);
-  msqid64->msg_ctime  = kmsqid->msg_ctime
-		        | ((__time64_t) kmsqid->msg_ctime_high << 32);
-  msqid64->msg_cbytes = kmsqid->msg_cbytes;
-  msqid64->msg_qnum   = kmsqid->msg_qnum;
-  msqid64->msg_qbytes = kmsqid->msg_qbytes;
-  msqid64->msg_lspid  = kmsqid->msg_lspid;
-  msqid64->msg_lrpid  = kmsqid->msg_lrpid;
-}
-
-typedef struct kernel_msqid64_ds msgctl_arg_t;
-#endif
-
-static int
-msgctl_syscall (int msqid, int cmd, msgctl_arg_t *buf)
-{
-#ifdef __ASSUME_DIRECT_SYSVIPC_SYSCALLS
-  return INLINE_SYSCALL_CALL (msgctl, msqid, cmd | __IPC_64, buf);
-#else
-  return INLINE_SYSCALL_CALL (ipc, IPCOP_msgctl, msqid, cmd | __IPC_64, 0,
-			      buf);
-#endif
-}
-
 int
 __msgctl64 (int msqid, int cmd, struct __msqid64_ds *buf)
 {
-#if IPC_CTL_NEED_TRANSLATION
-# if __IPC_TIME64
-  struct kernel_msqid64_ds ksemid, *arg = NULL;
-# else
-  msgctl_arg_t *arg;
-# endif
-
-  /* Some applications pass the __IPC_64 flag in cmd, to invoke
-     previously unsupported commands back when there was no EINVAL
-     error checking in glibc.  Mask the flag for the switch statements
-     below.  msgctl_syscall adds back the __IPC_64 flag for the actual
-     system call.  */
-  cmd &= ~__IPC_64;
-
-  switch (cmd)
-    {
-    case IPC_RMID:
-      arg = NULL;
-      break;
-
-    case IPC_SET:
-    case IPC_STAT:
-    case MSG_STAT:
-    case MSG_STAT_ANY:
-# if __IPC_TIME64
-      if (buf != NULL)
-	{
-	  msqid64_to_kmsqid64 (buf, &ksemid);
-	  arg = &ksemid;
-	}
-#  ifdef __ASSUME_SYSVIPC_BROKEN_MODE_T
-      if (cmd == IPC_SET)
-	arg->msg_perm.mode *= 0x10000U;
-#  endif
-# else
-      arg = buf;
-# endif
-      break;
-
-    case IPC_INFO:
-    case MSG_INFO:
-      /* This is a Linux extension where kernel returns a 'struct msginfo'
-	 instead.  */
-      arg = (__typeof__ (arg)) buf;
-      break;
-
-    default:
-      __set_errno (EINVAL);
-      return -1;
-    }
-
-  int ret = msgctl_syscall (msqid, cmd, arg);
-  if (ret < 0)
-    return ret;
-
-  switch (cmd)
-    {
-    case IPC_STAT:
-    case MSG_STAT:
-    case MSG_STAT_ANY:
-# ifdef __ASSUME_SYSVIPC_BROKEN_MODE_T
-      arg->msg_perm.mode >>= 16;
-# else
-      /* Old Linux kernel versions might not clear the mode padding.  */
-      if (sizeof ((struct msqid_ds){0}.msg_perm.mode)
-          != sizeof (__kernel_mode_t))
-	arg->msg_perm.mode &= 0xFFFF;
-# endif
-
-# if __IPC_TIME64
-      kmsqid64_to_msqid64 (arg, buf);
-# endif
-    }
-
-  return ret;
-
-#else /* !IPC_CTL_NEED_TRANSLATION */
-  return msgctl_syscall (msqid, cmd, buf);
-#endif
+  return zsys_msgctl (msqid, cmd, buf);
 }
 #if __TIMESIZE != 64
 libc_hidden_def (__msgctl64)
diff --git a/sysdeps/unix/sysv/linux/msgget.c b/sysdeps/unix/sysv/linux/msgget.c
index 71eea731b272..0d3b2df1df62 100644
--- a/sysdeps/unix/sysv/linux/msgget.c
+++ b/sysdeps/unix/sysv/linux/msgget.c
@@ -18,6 +18,7 @@
 #include <ipc_priv.h>
 #include <sysdep.h>
 #include <errno.h>
+#include <pizlonated_syscalls.h>
 
 /* Return descriptor for message queue associated with KEY.  The MSGFLG
    parameter describes how to proceed with clashing of key values.  */
@@ -25,9 +26,5 @@
 int
 msgget (key_t key, int msgflg)
 {
-#ifdef __ASSUME_DIRECT_SYSVIPC_SYSCALLS
-  return INLINE_SYSCALL_CALL (msgget, key, msgflg);
-#else
-  return INLINE_SYSCALL_CALL (ipc, IPCOP_msgget, key, msgflg, 0, NULL);
-#endif
+  return zsys_msgget (key, msgflg);
 }
diff --git a/sysdeps/unix/sysv/linux/msgrcv.c b/sysdeps/unix/sysv/linux/msgrcv.c
index 30519008a698..31deeb5fe447 100644
--- a/sysdeps/unix/sysv/linux/msgrcv.c
+++ b/sysdeps/unix/sysv/linux/msgrcv.c
@@ -17,16 +17,12 @@
 
 #include <ipc_priv.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 ssize_t
 __libc_msgrcv (int msqid, void *msgp, size_t msgsz, long int msgtyp,
 	       int msgflg)
 {
-#ifdef __ASSUME_DIRECT_SYSVIPC_SYSCALLS
-  return SYSCALL_CANCEL (msgrcv, msqid, msgp, msgsz, msgtyp, msgflg);
-#else
-  return SYSCALL_CANCEL (ipc, IPCOP_msgrcv, msqid, msgsz, msgflg,
-			 MSGRCV_ARGS (msgp, msgtyp));
-#endif
+  return zsys_msgrcv (msqid, msgp, msgsz, msgtyp, msgflg);
 }
 weak_alias (__libc_msgrcv, msgrcv)
diff --git a/sysdeps/unix/sysv/linux/msgsnd.c b/sysdeps/unix/sysv/linux/msgsnd.c
index 8af400c31be4..d1efab4dac1a 100644
--- a/sysdeps/unix/sysv/linux/msgsnd.c
+++ b/sysdeps/unix/sysv/linux/msgsnd.c
@@ -17,15 +17,11 @@
 
 #include <ipc_priv.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 int
 __libc_msgsnd (int msqid, const void *msgp, size_t msgsz, int msgflg)
 {
-#ifdef __ASSUME_DIRECT_SYSVIPC_SYSCALLS
-  return SYSCALL_CANCEL (msgsnd, msqid, msgp, msgsz, msgflg);
-#else
-  return SYSCALL_CANCEL (ipc, IPCOP_msgsnd, msqid, msgsz, msgflg,
-			 msgp);
-#endif
+  return zsys_msgsnd (msqid, msgp, msgsz, msgflg);
 }
 weak_alias (__libc_msgsnd, msgsnd)
diff --git a/sysdeps/unix/sysv/linux/msync.c b/sysdeps/unix/sysv/linux/msync.c
index 1d8dd4f59ba1..fc8f060f7c4a 100644
--- a/sysdeps/unix/sysv/linux/msync.c
+++ b/sysdeps/unix/sysv/linux/msync.c
@@ -18,9 +18,10 @@
 
 #include <sys/mman.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 int
 msync (void *addr, size_t length, int flags)
 {
-  return SYSCALL_CANCEL (msync, addr, length, flags);
+  return zsys_msync (addr, length, flags);
 }
diff --git a/sysdeps/unix/sysv/linux/not-cancel.h b/sysdeps/unix/sysv/linux/not-cancel.h
index 2a7585b73f2b..b26af3cd9861 100644
--- a/sysdeps/unix/sysv/linux/not-cancel.h
+++ b/sysdeps/unix/sysv/linux/not-cancel.h
@@ -27,6 +27,7 @@
 #include <sys/syscall.h>
 #include <sys/wait.h>
 #include <time.h>
+#include <pizlonated_syscalls.h>
 
 /* Non cancellable open syscall.  */
 __typeof (open) __open_nocancel;
@@ -80,13 +81,15 @@ __close_nocancel_nostatus (int fd)
 static inline void
 __writev_nocancel_nostatus (int fd, const struct iovec *iov, int iovcnt)
 {
-  INTERNAL_SYSCALL_CALL (writev, fd, iov, iovcnt);
+  int old_errno = errno;
+  zsys_writev (fd, iov, iovcnt);
+  errno = old_errno;
 }
 
 static inline ssize_t
 __getrandom_nocancel (void *buf, size_t buflen, unsigned int flags)
 {
-  return INLINE_SYSCALL_CALL (getrandom, buf, buflen, flags);
+  return zsys_getrandom (buf, buflen, flags);
 }
 
 /* Non cancellable getrandom syscall that does not also set errno in case of
@@ -94,13 +97,16 @@ __getrandom_nocancel (void *buf, size_t buflen, unsigned int flags)
 static inline ssize_t
 __getrandom_nocancel_nostatus (void *buf, size_t buflen, unsigned int flags)
 {
-  return INTERNAL_SYSCALL_CALL (getrandom, buf, buflen, flags);
+  int old_errno = errno;
+  ssize_t result = zsys_getrandom (buf, buflen, flags);
+  errno = old_errno;
+  return result;
 }
 
 static inline int
 __poll_infinity_nocancel (struct pollfd *fds, nfds_t nfds)
 {
-  return INLINE_SYSCALL_CALL (ppoll, fds, nfds, NULL, NULL, 0);
+  return zsys_ppoll (fds, nfds, NULL, NULL);
 }
 
 #endif /* NOT_CANCEL_H  */
diff --git a/sysdeps/unix/sysv/linux/open64.c b/sysdeps/unix/sysv/linux/open64.c
index f15a921001bb..23d0b3396786 100644
--- a/sysdeps/unix/sysv/linux/open64.c
+++ b/sysdeps/unix/sysv/linux/open64.c
@@ -22,24 +22,14 @@
 #include <stdarg.h>
 #include <sysdep-cancel.h>
 #include <shlib-compat.h>
+#include <pizlonated_syscalls.h>
 
 /* Open FILE with access OFLAG.  If O_CREAT or O_TMPFILE is in OFLAG,
    a third argument is the file protection.  */
 int
 __libc_open64 (const char *file, int oflag, ...)
 {
-  int mode = 0;
-
-  if (__OPEN_NEEDS_MODE (oflag))
-    {
-      va_list arg;
-      va_start (arg, oflag);
-      mode = va_arg (arg, int);
-      va_end (arg);
-    }
-
-  return SYSCALL_CANCEL (openat, AT_FDCWD, file, oflag | O_LARGEFILE,
-			 mode);
+  return *(int *) zcall (zsys_open, zargs ());
 }
 
 strong_alias (__libc_open64, __open64)
diff --git a/sysdeps/unix/sysv/linux/open64_nocancel.c b/sysdeps/unix/sysv/linux/open64_nocancel.c
index c6b6845cf0c5..48531ae6e029 100644
--- a/sysdeps/unix/sysv/linux/open64_nocancel.c
+++ b/sysdeps/unix/sysv/linux/open64_nocancel.c
@@ -22,22 +22,12 @@
 #include <stdarg.h>
 
 #include <not-cancel.h>
+#include <pizlonated_syscalls.h>
 
 int
 __open64_nocancel (const char *file, int oflag, ...)
 {
-  int mode = 0;
-
-  if (__OPEN_NEEDS_MODE (oflag))
-    {
-      va_list arg;
-      va_start (arg, oflag);
-      mode = va_arg (arg, int);
-      va_end (arg);
-    }
-
-  return INLINE_SYSCALL_CALL (openat, AT_FDCWD, file, oflag | O_LARGEFILE,
-			      mode);
+  return *(int *) zcall (zsys_open, zargs ());
 }
 
 hidden_def (__open64_nocancel)
diff --git a/sysdeps/unix/sysv/linux/openat64.c b/sysdeps/unix/sysv/linux/openat64.c
index 3bf6730cae8c..6d7a81b2ad78 100644
--- a/sysdeps/unix/sysv/linux/openat64.c
+++ b/sysdeps/unix/sysv/linux/openat64.c
@@ -20,6 +20,7 @@
 #include <stdarg.h>
 
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 /* Open FILE with access OFLAG.  Interpret relative paths relative to
    the directory associated with FD.  If OFLAG includes O_CREAT or
@@ -27,16 +28,7 @@
 int
 __libc_openat64 (int fd, const char *file, int oflag, ...)
 {
-  mode_t mode = 0;
-  if (__OPEN_NEEDS_MODE (oflag))
-    {
-      va_list arg;
-      va_start (arg, oflag);
-      mode = va_arg (arg, mode_t);
-      va_end (arg);
-    }
-
-  return SYSCALL_CANCEL (openat, fd, file, oflag | O_LARGEFILE, mode);
+  return *(int *) zcall (zsys_openat, zargs ());
 }
 
 strong_alias (__libc_openat64, __openat64)
diff --git a/sysdeps/unix/sysv/linux/pause.c b/sysdeps/unix/sysv/linux/pause.c
index a29dac58fc66..0dc2f506bbf3 100644
--- a/sysdeps/unix/sysv/linux/pause.c
+++ b/sysdeps/unix/sysv/linux/pause.c
@@ -19,16 +19,13 @@
 #include <signal.h>
 #include <unistd.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 /* Suspend the process until a signal arrives.
    This always returns -1 and sets errno to EINTR.  */
 int
 __libc_pause (void)
 {
-#ifdef __NR_pause
-  return SYSCALL_CANCEL (pause);
-#else
-  return SYSCALL_CANCEL (ppoll, NULL, 0, NULL, NULL);
-#endif
+  return zsys_pause ();
 }
 weak_alias (__libc_pause, pause)
diff --git a/sysdeps/unix/sysv/linux/pipe.c b/sysdeps/unix/sysv/linux/pipe.c
index e47e3fb8335e..f83810e20ee4 100644
--- a/sysdeps/unix/sysv/linux/pipe.c
+++ b/sysdeps/unix/sysv/linux/pipe.c
@@ -18,6 +18,7 @@
 
 #include <unistd.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 /* Create a one-way communication channel (__pipe).
    If successful, two file descriptors are stored in PIPEDES;
@@ -26,7 +27,7 @@
 int
 __pipe (int __pipedes[2])
 {
-  return INLINE_SYSCALL_CALL (pipe2, (int *) __pipedes, 0);
+  return zsys_pipe (__pipedes);
 }
 libc_hidden_def (__pipe)
 weak_alias (__pipe, pipe)
diff --git a/sysdeps/unix/sysv/linux/poll.c b/sysdeps/unix/sysv/linux/poll.c
index 76c967d1389b..2050f45312bc 100644
--- a/sysdeps/unix/sysv/linux/poll.c
+++ b/sysdeps/unix/sysv/linux/poll.c
@@ -21,25 +21,12 @@
 
 #include <sysdep-cancel.h>
 #include <sys/syscall.h>
+#include <pizlonated_syscalls.h>
 
 int
 __poll (struct pollfd *fds, nfds_t nfds, int timeout)
 {
-#ifdef __NR_poll
-  return SYSCALL_CANCEL (poll, fds, nfds, timeout);
-#else
-  struct timespec timeout_ts;
-  struct timespec *timeout_ts_p = NULL;
-
-  if (timeout >= 0)
-    {
-      timeout_ts.tv_sec = timeout / 1000;
-      timeout_ts.tv_nsec = (timeout % 1000) * 1000000;
-      timeout_ts_p = &timeout_ts;
-    }
-
-  return SYSCALL_CANCEL (ppoll, fds, nfds, timeout_ts_p, NULL, 0);
-#endif
+  return zsys_poll (fds, nfds, timeout);
 }
 libc_hidden_def (__poll)
 weak_alias (__poll, poll)
diff --git a/sysdeps/unix/sysv/linux/posix_fadvise64.c b/sysdeps/unix/sysv/linux/posix_fadvise64.c
index 681bc2024156..d9185acc2af2 100644
--- a/sysdeps/unix/sysv/linux/posix_fadvise64.c
+++ b/sysdeps/unix/sysv/linux/posix_fadvise64.c
@@ -19,6 +19,7 @@
 #include <fcntl.h>
 #include <sysdep.h>
 #include <shlib-compat.h>
+#include <pizlonated_syscalls.h>
 
 int __posix_fadvise64_l64 (int fd, off64_t offset, off64_t len, int advise);
 libc_hidden_proto (__posix_fadvise64_l64)
@@ -41,17 +42,7 @@ libc_hidden_proto (__posix_fadvise64_l64)
 int
 __posix_fadvise64_l64 (int fd, off64_t offset, off64_t len, int advise)
 {
-#ifdef __ASSUME_FADVISE64_64_6ARG
-  int ret = INTERNAL_SYSCALL_CALL (fadvise64_64, fd, advise,
-				   SYSCALL_LL64 (offset), SYSCALL_LL64 (len));
-#else
-  int ret = INTERNAL_SYSCALL_CALL (fadvise64_64, fd,
-				   __ALIGNMENT_ARG SYSCALL_LL64 (offset),
-				   SYSCALL_LL64 (len), advise);
-#endif
-  if (!INTERNAL_SYSCALL_ERROR_P (ret))
-    return 0;
-  return INTERNAL_SYSCALL_ERRNO (ret);
+  return zsys_posix_fadvise (fd, offset, len, advise);
 }
 
 /* The type of the len argument was changed from size_t to off_t in
diff --git a/sysdeps/unix/sysv/linux/posix_fallocate.c b/sysdeps/unix/sysv/linux/posix_fallocate.c
index fff373c12d27..237b5d2b0a1a 100644
--- a/sysdeps/unix/sysv/linux/posix_fallocate.c
+++ b/sysdeps/unix/sysv/linux/posix_fallocate.c
@@ -18,19 +18,11 @@
 #include <fcntl.h>
 #include <sysdep.h>
 
-#define posix_fallocate static internal_fallocate
-#include <sysdeps/posix/posix_fallocate.c>
-#undef posix_fallocate
+#include <pizlonated_syscalls.h>
 
 /* Reserve storage for the data of the file associated with FD.  */
 int
 posix_fallocate (int fd, __off_t offset, __off_t len)
 {
-  int res = INTERNAL_SYSCALL_CALL (fallocate, fd, 0,
-				   SYSCALL_LL (offset), SYSCALL_LL (len));
-  if (! INTERNAL_SYSCALL_ERROR_P (res))
-    return 0;
-  if (INTERNAL_SYSCALL_ERRNO (res) != EOPNOTSUPP)
-    return INTERNAL_SYSCALL_ERRNO (res);
-  return internal_fallocate (fd, offset, len);
+  return zsys_posix_fallocate (fd, offset, len);
 }
diff --git a/sysdeps/unix/sysv/linux/posix_fallocate64.c b/sysdeps/unix/sysv/linux/posix_fallocate64.c
index f9b122b84edd..9cd255466f0e 100644
--- a/sysdeps/unix/sysv/linux/posix_fallocate64.c
+++ b/sysdeps/unix/sysv/linux/posix_fallocate64.c
@@ -17,6 +17,7 @@
 
 #include <fcntl.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 extern int __posix_fallocate64_l64 (int fd, __off64_t offset, __off64_t len);
 libc_hidden_proto (__posix_fallocate64_l64)
@@ -28,12 +29,6 @@ libc_hidden_proto (__posix_fallocate64_l64)
 int
 __posix_fallocate64_l64 (int fd, __off64_t offset, __off64_t len)
 {
-  int res = INTERNAL_SYSCALL_CALL (fallocate, fd, 0,
-				   SYSCALL_LL64 (offset), SYSCALL_LL64 (len));
-  if (! INTERNAL_SYSCALL_ERROR_P (res))
-    return 0;
-  if (INTERNAL_SYSCALL_ERRNO (res) != EOPNOTSUPP)
-    return INTERNAL_SYSCALL_ERRNO (res);
-  return internal_fallocate64 (fd, offset, len);
+  return zsys_posix_fallocate(fd, offset, len);
 }
 libc_hidden_def (__posix_fallocate64_l64)
diff --git a/sysdeps/unix/sysv/linux/ppoll.c b/sysdeps/unix/sysv/linux/ppoll.c
index 39e78008db2a..3fbca18a467b 100644
--- a/sysdeps/unix/sysv/linux/ppoll.c
+++ b/sysdeps/unix/sysv/linux/ppoll.c
@@ -20,47 +20,13 @@
 #include <time.h>
 #include <sys/poll.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 int
 __ppoll64 (struct pollfd *fds, nfds_t nfds, const struct __timespec64 *timeout,
            const sigset_t *sigmask)
 {
-  /* The Linux kernel can in some situations update the timeout value.
-     We do not want that so use a local variable.  */
-  struct __timespec64 tval;
-  if (timeout != NULL)
-    {
-      tval = *timeout;
-      timeout = &tval;
-    }
-
-#ifndef __NR_ppoll_time64
-# define __NR_ppoll_time64 __NR_ppoll
-#endif
-
-#ifdef __ASSUME_TIME64_SYSCALLS
-  return SYSCALL_CANCEL (ppoll_time64, fds, nfds, timeout, sigmask,
-			 __NSIG_BYTES);
-#else
-  int ret;
-  bool need_time64 = timeout != NULL && !in_int32_t_range (timeout->tv_sec);
-  if (need_time64)
-    {
-      ret = SYSCALL_CANCEL (ppoll_time64, fds, nfds, timeout, sigmask,
-			    __NSIG_BYTES);
-      if (ret == 0 || errno != ENOSYS)
-	return ret;
-      __set_errno (EOVERFLOW);
-      return -1;
-    }
-
-  struct timespec ts32;
-  if (timeout != NULL)
-    ts32 = valid_timespec64_to_timespec (*timeout);
-
-  return SYSCALL_CANCEL (ppoll, fds, nfds, timeout ? &ts32 : NULL, sigmask,
-			 __NSIG_BYTES);
-#endif
+  return zsys_ppoll (fds, nfds, timeout, sigmask);
 }
 
 #if __TIMESIZE != 64
diff --git a/sysdeps/unix/sysv/linux/pread64.c b/sysdeps/unix/sysv/linux/pread64.c
index fd55c8b6a9f9..0ba0474bb0b5 100644
--- a/sysdeps/unix/sysv/linux/pread64.c
+++ b/sysdeps/unix/sysv/linux/pread64.c
@@ -18,11 +18,12 @@
 #include <unistd.h>
 #include <sysdep-cancel.h>
 #include <shlib-compat.h>
+#include <pizlonated_syscalls.h>
 
 ssize_t
 __libc_pread64 (int fd, void *buf, size_t count, off64_t offset)
 {
-  return SYSCALL_CANCEL (pread64, fd, buf, count, SYSCALL_LL64_PRW (offset));
+  return zsys_pread (fd, buf, count, offset);
 }
 
 weak_alias (__libc_pread64, __pread64)
diff --git a/sysdeps/unix/sysv/linux/pread64_nocancel.c b/sysdeps/unix/sysv/linux/pread64_nocancel.c
index bb685f268f0a..35fa3ff18355 100644
--- a/sysdeps/unix/sysv/linux/pread64_nocancel.c
+++ b/sysdeps/unix/sysv/linux/pread64_nocancel.c
@@ -19,10 +19,11 @@
 #include <unistd.h>
 #include <sysdep-cancel.h>
 #include <not-cancel.h>
+#include <pizlonated_syscalls.h>
 
 ssize_t
 __pread64_nocancel (int fd, void *buf, size_t count, off64_t offset)
 {
-  return INLINE_SYSCALL_CALL (pread64, fd, buf, count, SYSCALL_LL64_PRW (offset));
+  return zsys_pread (fd, buf, count, offset);
 }
 hidden_def (__pread64_nocancel)
diff --git a/sysdeps/unix/sysv/linux/preadv64.c b/sysdeps/unix/sysv/linux/preadv64.c
index 3386fdbac375..75ca5639b31a 100644
--- a/sysdeps/unix/sysv/linux/preadv64.c
+++ b/sysdeps/unix/sysv/linux/preadv64.c
@@ -17,13 +17,14 @@
 
 #include <sys/uio.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 #ifdef __ASSUME_PREADV
 
 ssize_t
 preadv64 (int fd, const struct iovec *vector, int count, off64_t offset)
 {
-  return SYSCALL_CANCEL (preadv, fd, vector, count, LO_HI_LONG (offset));
+  return zsys_preadv (fd, vector, count, offset);
 }
 #else
 static ssize_t __atomic_preadv64_replacement (int, const struct iovec *,
diff --git a/sysdeps/unix/sysv/linux/pselect.c b/sysdeps/unix/sysv/linux/pselect.c
index f97372616265..dbee211f424e 100644
--- a/sysdeps/unix/sysv/linux/pselect.c
+++ b/sysdeps/unix/sysv/linux/pselect.c
@@ -18,57 +18,11 @@
 #include <sys/select.h>
 #include <sysdep-cancel.h>
 
-static int
-pselect64_syscall (int nfds, fd_set *readfds, fd_set *writefds,
-		   fd_set *exceptfds, const struct __timespec64 *timeout,
-		   const sigset_t *sigmask)
-{
-#ifndef __NR_pselect6_time64
-# define __NR_pselect6_time64 __NR_pselect6
-#endif
-  /* NB: This is required by ARGIFY used in x32 internal_syscallN.  */
-  __syscall_ulong_t data[2] =
-    {
-      (uintptr_t) sigmask, __NSIG_BYTES
-    };
-  return SYSCALL_CANCEL (pselect6_time64, nfds, readfds, writefds, exceptfds,
-			 timeout, data);
-}
-
 int
 __pselect64 (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
 	     const struct __timespec64 *timeout, const sigset_t *sigmask)
 {
-  /* The Linux kernel can in some situations update the timeout value.
-     We do not want that so use a local variable.  */
-  struct __timespec64 tval;
-  if (timeout != NULL)
-    {
-      tval = *timeout;
-      timeout = &tval;
-    }
-
-  /* Note: the system call expects 7 values but on most architectures
-     we can only pass in 6 directly.  If there is an architecture with
-     support for more parameters a new version of this file needs to
-     be created.  */
-#ifdef __ASSUME_TIME64_SYSCALLS
-  return pselect64_syscall (nfds, readfds, writefds, exceptfds, timeout,
-			    sigmask);
-#else
-  bool need_time64 = timeout != NULL && !in_int32_t_range (timeout->tv_sec);
-  if (need_time64)
-    {
-      int r = pselect64_syscall (nfds, readfds, writefds, exceptfds, timeout,
-				 sigmask);
-      if (r == 0 || errno != ENOSYS)
-	return r;
-      __set_errno (EOVERFLOW);
-      return -1;
-    }
-
-  return __pselect32 (nfds, readfds, writefds, exceptfds, timeout, sigmask);
-#endif
+  return zsys_pselect (nfds, readfds, writefds, exceptfds, timeout, sigmask);
 }
 
 #if __TIMESIZE != 64
diff --git a/sysdeps/unix/sysv/linux/pwrite64.c b/sysdeps/unix/sysv/linux/pwrite64.c
index ea83423b9c22..97f68995dd78 100644
--- a/sysdeps/unix/sysv/linux/pwrite64.c
+++ b/sysdeps/unix/sysv/linux/pwrite64.c
@@ -18,11 +18,12 @@
 #include <unistd.h>
 #include <sysdep-cancel.h>
 #include <shlib-compat.h>
+#include <pizlonated_syscalls.h>
 
 ssize_t
 __libc_pwrite64 (int fd, const void *buf, size_t count, off64_t offset)
 {
-  return SYSCALL_CANCEL (pwrite64, fd, buf, count, SYSCALL_LL64_PRW (offset));
+  return zsys_pwrite (fd, buf, count, offset);
 }
 
 weak_alias (__libc_pwrite64, __pwrite64)
diff --git a/sysdeps/unix/sysv/linux/pwritev64.c b/sysdeps/unix/sysv/linux/pwritev64.c
index 465f32904557..6ed993da26ae 100644
--- a/sysdeps/unix/sysv/linux/pwritev64.c
+++ b/sysdeps/unix/sysv/linux/pwritev64.c
@@ -17,13 +17,14 @@
 
 #include <sys/uio.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 #ifdef __ASSUME_PWRITEV
 
 ssize_t
 pwritev64 (int fd, const struct iovec *vector, int count, off64_t offset)
 {
-  return SYSCALL_CANCEL (pwritev, fd, vector, count, LO_HI_LONG (offset));
+  return zsys_pwritev (fd, vector, count, offset);
 }
 #else
 static ssize_t __atomic_pwritev64_replacement (int, const struct iovec *,
diff --git a/sysdeps/unix/sysv/linux/read.c b/sysdeps/unix/sysv/linux/read.c
index b0afd24368b9..4361ffdbddcc 100644
--- a/sysdeps/unix/sysv/linux/read.c
+++ b/sysdeps/unix/sysv/linux/read.c
@@ -18,12 +18,13 @@
 
 #include <unistd.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 /* Read NBYTES into BUF from FD.  Return the number read or -1.  */
 ssize_t
 __libc_read (int fd, void *buf, size_t nbytes)
 {
-  return SYSCALL_CANCEL (read, fd, buf, nbytes);
+  return zsys_read (fd, buf, nbytes);
 }
 libc_hidden_def (__libc_read)
 
diff --git a/sysdeps/unix/sysv/linux/read_nocancel.c b/sysdeps/unix/sysv/linux/read_nocancel.c
index 3e2e4407bff5..47a9de4741cc 100644
--- a/sysdeps/unix/sysv/linux/read_nocancel.c
+++ b/sysdeps/unix/sysv/linux/read_nocancel.c
@@ -19,10 +19,11 @@
 #include <unistd.h>
 #include <sysdep-cancel.h>
 #include <not-cancel.h>
+#include <pizlonated_syscalls.h>
 
 ssize_t
 __read_nocancel (int fd, void *buf, size_t nbytes)
 {
-  return INLINE_SYSCALL_CALL (read, fd, buf, nbytes);
+  return zsys_read (fd, buf, nbytes);
 }
 hidden_def (__read_nocancel)
diff --git a/sysdeps/unix/sysv/linux/readlink.c b/sysdeps/unix/sysv/linux/readlink.c
index bb75d204170f..f17bfdb37e0a 100644
--- a/sysdeps/unix/sysv/linux/readlink.c
+++ b/sysdeps/unix/sysv/linux/readlink.c
@@ -19,6 +19,7 @@
 #include <unistd.h>
 #include <fcntl.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 /* Read the contents of the symbolic link PATH into no more than
    LEN bytes of BUF.  The contents are not null-terminated.
@@ -26,10 +27,6 @@
 ssize_t
 __readlink (const char *path, char *buf, size_t len)
 {
-#ifdef __NR_readlink
-  return INLINE_SYSCALL_CALL (readlink, path, buf, len);
-#else
-  return INLINE_SYSCALL_CALL (readlinkat, AT_FDCWD, path, buf, len);
-#endif
+  return zsys_readlink (path, buf, len);
 }
 weak_alias (__readlink, readlink)
diff --git a/sysdeps/unix/sysv/linux/readv.c b/sysdeps/unix/sysv/linux/readv.c
index 3eae7e864155..b05988aa1cc0 100644
--- a/sysdeps/unix/sysv/linux/readv.c
+++ b/sysdeps/unix/sysv/linux/readv.c
@@ -19,11 +19,12 @@
 #include <unistd.h>
 #include <sys/uio.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 ssize_t
 __readv (int fd, const struct iovec *iov, int iovcnt)
 {
-  return SYSCALL_CANCEL (readv, fd, iov, iovcnt);
+  return zsys_readv (fd, iov, iovcnt);
 }
 libc_hidden_def (__readv)
 weak_alias (__readv, readv)
diff --git a/sysdeps/unix/sysv/linux/reboot.c b/sysdeps/unix/sysv/linux/reboot.c
index 2dbf7238886d..845702aac184 100644
--- a/sysdeps/unix/sysv/linux/reboot.c
+++ b/sysdeps/unix/sysv/linux/reboot.c
@@ -20,10 +20,11 @@
 
 #include <sysdep.h>
 #include <sys/syscall.h>
+#include <pizlonated_syscalls.h>
 
 /* Call kernel with additional two arguments the syscall requires.  */
 int
 reboot (int howto)
 {
-  return INLINE_SYSCALL (reboot, 3, (int) 0xfee1dead, 672274793, howto);
+  return zsys_reboot (howto);
 }
diff --git a/sysdeps/unix/sysv/linux/recv.c b/sysdeps/unix/sysv/linux/recv.c
index 6ff79b198ab5..1d76ef4c6ec3 100644
--- a/sysdeps/unix/sysv/linux/recv.c
+++ b/sysdeps/unix/sysv/linux/recv.c
@@ -18,17 +18,12 @@
 #include <sys/socket.h>
 #include <sysdep-cancel.h>
 #include <socketcall.h>
+#include <pizlonated_syscalls.h>
 
 ssize_t
 __libc_recv (int fd, void *buf, size_t len, int flags)
 {
-#ifdef __ASSUME_RECV_SYSCALL
-  return SYSCALL_CANCEL (recv, fd, buf, len, flags);
-#elif defined __ASSUME_RECVFROM_SYSCALL
-  return SYSCALL_CANCEL (recvfrom, fd, buf, len, flags, NULL, NULL);
-#else
-  return SOCKETCALL_CANCEL (recv, fd, buf, len, flags);
-#endif
+  return zsys_recvfrom (fd, buf, len, flags, NULL, NULL);
 }
 weak_alias (__libc_recv, recv)
 weak_alias (__libc_recv, __recv)
diff --git a/sysdeps/unix/sysv/linux/recvfrom.c b/sysdeps/unix/sysv/linux/recvfrom.c
index a235355d70de..da200358d441 100644
--- a/sysdeps/unix/sysv/linux/recvfrom.c
+++ b/sysdeps/unix/sysv/linux/recvfrom.c
@@ -18,18 +18,13 @@
 #include <sys/socket.h>
 #include <sysdep-cancel.h>
 #include <socketcall.h>
+#include <pizlonated_syscalls.h>
 
 ssize_t
 __libc_recvfrom (int fd, void *buf, size_t len, int flags,
 		 __SOCKADDR_ARG addr, socklen_t *addrlen)
 {
-#ifdef __ASSUME_RECVFROM_SYSCALL
-  return SYSCALL_CANCEL (recvfrom, fd, buf, len, flags, addr.__sockaddr__,
-                         addrlen);
-#else
-  return SOCKETCALL_CANCEL (recvfrom, fd, buf, len, flags, addr.__sockaddr__,
-			    addrlen);
-#endif
+  return zsys_recvfrom (fd, buf, len, flags, addr.__sockaddr__, addrlen);
 }
 weak_alias (__libc_recvfrom, recvfrom)
 weak_alias (__libc_recvfrom, __recvfrom)
diff --git a/sysdeps/unix/sysv/linux/recvmmsg.c b/sysdeps/unix/sysv/linux/recvmmsg.c
index 16136f5739aa..6ddb0856c60b 100644
--- a/sysdeps/unix/sysv/linux/recvmmsg.c
+++ b/sysdeps/unix/sysv/linux/recvmmsg.c
@@ -18,69 +18,16 @@
 #include <sys/socket.h>
 #include <sysdep.h>
 #include <socketcall.h>
-
-static int
-recvmmsg_syscall (int fd, struct mmsghdr *vmessages, unsigned int vlen,
-		  int flags, struct __timespec64 *timeout)
-{
-#ifndef __NR_recvmmsg_time64
-# define __NR_recvmmsg_time64 __NR_recvmmsg
-#endif
-  int r = SYSCALL_CANCEL (recvmmsg_time64, fd, vmessages, vlen, flags,
-			  timeout);
-#ifndef __ASSUME_TIME64_SYSCALLS
-  if (r >= 0 || errno != ENOSYS)
-    return r;
-
-  struct timespec ts32, *pts32 = NULL;
-  if (timeout != NULL)
-    {
-      if (! in_int32_t_range (timeout->tv_sec))
-	{
-	  __set_errno (EINVAL);
-	  return -1;
-	}
-      ts32 = valid_timespec64_to_timespec (*timeout);
-      pts32 = &ts32;
-    }
-
-# ifdef __ASSUME_RECVMMSG_SYSCALL
-  r = SYSCALL_CANCEL (recvmmsg, fd, vmessages, vlen, flags, pts32);
-# else
-  r = SOCKETCALL_CANCEL (recvmmsg, fd, vmessages, vlen, flags, pts32);
-# endif
-  if (r >= 0)
-    {
-      if (timeout != NULL)
-        *timeout = valid_timespec_to_timespec64 (ts32);
-    }
-#endif
-  return r;
-}
+#include <pizlonated_syscalls.h>
 
 int
 __recvmmsg64 (int fd, struct mmsghdr *vmessages, unsigned int vlen, int flags,
 	      struct __timespec64 *timeout)
 {
-#if __TIMESIZE != 64
-  socklen_t csize[IOV_MAX];
-  if (vlen > IOV_MAX)
-    vlen = IOV_MAX;
-  for (int i = 0; i < vlen; i++)
-    csize[i] = vmessages[i].msg_hdr.msg_controllen;
-#endif
-
-  int r = recvmmsg_syscall (fd, vmessages, vlen, flags, timeout);
-#if __TIMESIZE != 64
-  if (r > 0)
-    {
-      for (int i=0; i < r; i++)
-        __convert_scm_timestamps (&vmessages[i].msg_hdr, csize[i]);
-    }
-#endif
-  return r;
+  return zsys_recvmmsg(fd, vmessages, vlen, flags, timeout);
 }
 #if __TIMESIZE != 64
+#error "wtf"
 libc_hidden_def (__recvmmsg64)
 
 int
diff --git a/sysdeps/unix/sysv/linux/recvmsg.c b/sysdeps/unix/sysv/linux/recvmsg.c
index 034526eb3de7..40f33d12be67 100644
--- a/sysdeps/unix/sysv/linux/recvmsg.c
+++ b/sysdeps/unix/sysv/linux/recvmsg.c
@@ -19,15 +19,12 @@
 #include <sys/socket.h>
 #include <sysdep-cancel.h>
 #include <socketcall.h>
+#include <pizlonated_syscalls.h>
 
 static int
 __recvmsg_syscall (int fd, struct msghdr *msg, int flags)
 {
-#ifdef __ASSUME_RECVMSG_SYSCALL
-  return SYSCALL_CANCEL (recvmsg, fd, msg, flags);
-#else
-  return SOCKETCALL_CANCEL (recvmsg, fd, msg, flags);
-#endif
+  return zsys_recvmsg (fd, msg, flags);
 }
 
 ssize_t
diff --git a/sysdeps/unix/sysv/linux/rename.c b/sysdeps/unix/sysv/linux/rename.c
index 583dcd48a317..9af841ce9647 100644
--- a/sysdeps/unix/sysv/linux/rename.c
+++ b/sysdeps/unix/sysv/linux/rename.c
@@ -20,16 +20,11 @@
 #include <fcntl.h>
 #include <sysdep.h>
 #include <errno.h>
+#include <pizlonated_syscalls.h>
 
 /* Rename the file OLD to NEW.  */
 int
 rename (const char *old, const char *new)
 {
-#if defined (__NR_rename)
-  return INLINE_SYSCALL_CALL (rename, old, new);
-#elif defined (__NR_renameat)
-  return INLINE_SYSCALL_CALL (renameat, AT_FDCWD, old, AT_FDCWD, new);
-#else
-  return INLINE_SYSCALL_CALL (renameat2, AT_FDCWD, old, AT_FDCWD, new, 0);
-#endif
+  return zsys_rename (old, new);
 }
diff --git a/sysdeps/unix/sysv/linux/renameat.c b/sysdeps/unix/sysv/linux/renameat.c
index c9a014ddb246..c084b560b1ed 100644
--- a/sysdeps/unix/sysv/linux/renameat.c
+++ b/sysdeps/unix/sysv/linux/renameat.c
@@ -20,15 +20,12 @@
 #include <fcntl.h>
 #include <sysdep.h>
 #include <errno.h>
+#include <pizlonated_syscalls.h>
 
 int
 __renameat (int oldfd, const char *old, int newfd, const char *new)
 {
-#ifdef __NR_renameat
-  return INLINE_SYSCALL_CALL (renameat, oldfd, old, newfd, new);
-#else
-  return INLINE_SYSCALL_CALL (renameat2, oldfd, old, newfd, new, 0);
-#endif
+  return zsys_renameat (oldfd, old, newfd, new);
 }
 libc_hidden_def (__renameat)
 weak_alias (__renameat, renameat)
diff --git a/sysdeps/unix/sysv/linux/renameat2.c b/sysdeps/unix/sysv/linux/renameat2.c
index 0d08eca0aac0..edee3ee65030 100644
--- a/sysdeps/unix/sysv/linux/renameat2.c
+++ b/sysdeps/unix/sysv/linux/renameat2.c
@@ -19,27 +19,13 @@
 #include <errno.h>
 #include <stdio.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 int
 __renameat2 (int oldfd, const char *old, int newfd, const char *new,
            unsigned int flags)
 {
-#if !defined (__NR_renameat) || defined (__ASSUME_RENAMEAT2)
-  return INLINE_SYSCALL_CALL (renameat2, oldfd, old, newfd, new, flags);
-#else
-  if (flags == 0)
-    return __renameat (oldfd, old, newfd, new);
-
-  /* For non-zero flags, try the renameat2 system call.  */
-  int ret = INLINE_SYSCALL_CALL (renameat2, oldfd, old, newfd, new, flags);
-  if (ret != -1 || errno != ENOSYS)
-    /* Preserve non-error/non-ENOSYS return values.  */
-    return ret;
-
-  /* No kernel support for renameat2.  All flags are unknown.  */
-  __set_errno (EINVAL);
-  return -1;
-#endif
+  return zsys_renameat2 (oldfd, old, newfd, new, flags);
 }
 libc_hidden_def (__renameat2)
 weak_alias (__renameat2, renameat2)
diff --git a/sysdeps/unix/sysv/linux/rmdir.c b/sysdeps/unix/sysv/linux/rmdir.c
index fba4bdac29ea..92313ac8442a 100644
--- a/sysdeps/unix/sysv/linux/rmdir.c
+++ b/sysdeps/unix/sysv/linux/rmdir.c
@@ -19,15 +19,12 @@
 #include <unistd.h>
 #include <fcntl.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 /* Remove the directory PATH.  */
 int
 __rmdir (const char *path)
 {
-#ifdef __NR_rmdir
-  return INLINE_SYSCALL_CALL (rmdir, path);
-#else
-  return INLINE_SYSCALL_CALL (unlinkat, AT_FDCWD, path, AT_REMOVEDIR);
-#endif
+  return zsys_rmdir (path);
 }
 weak_alias (__rmdir, rmdir)
diff --git a/sysdeps/unix/sysv/linux/sched_getaffinity.c b/sysdeps/unix/sysv/linux/sched_getaffinity.c
index f4c0e38b9b69..ef35246d2171 100644
--- a/sysdeps/unix/sysv/linux/sched_getaffinity.c
+++ b/sysdeps/unix/sysv/linux/sched_getaffinity.c
@@ -22,6 +22,7 @@
 #include <sys/param.h>
 #include <sys/types.h>
 #include <shlib-compat.h>
+#include <pizlonated_syscalls.h>
 
 
 #if SHLIB_COMPAT (libc, GLIBC_2_3_3, GLIBC_2_3_4)
@@ -32,16 +33,7 @@ libc_hidden_proto (__sched_getaffinity_new)
 int
 __sched_getaffinity_new (pid_t pid, size_t cpusetsize, cpu_set_t *cpuset)
 {
-  int res = INLINE_SYSCALL (sched_getaffinity, 3, pid,
-			    MIN (INT_MAX, cpusetsize), cpuset);
-  if (res != -1)
-    {
-      /* Clean the rest of the memory the kernel didn't do.  */
-      memset ((char *) cpuset + res, '\0', cpusetsize - res);
-
-      res = 0;
-    }
-  return res;
+  return zsys_sched_getaffinity (pid, cpusetsize, cpuset);
 }
 versioned_symbol (libc, __sched_getaffinity_new, sched_getaffinity,
 		  GLIBC_2_3_4);
diff --git a/sysdeps/unix/sysv/linux/sched_getcpu.c b/sysdeps/unix/sysv/linux/sched_getcpu.c
index 72a3360550b8..961395156565 100644
--- a/sysdeps/unix/sysv/linux/sched_getcpu.c
+++ b/sysdeps/unix/sysv/linux/sched_getcpu.c
@@ -19,23 +19,10 @@
 #include <sched.h>
 #include <sysdep.h>
 #include <sysdep-vdso.h>
-
-static int
-vsyscall_sched_getcpu (void)
-{
-  unsigned int cpu;
-  int r = -1;
-#ifdef HAVE_GETCPU_VSYSCALL
-  r = INLINE_VSYSCALL (getcpu, 3, &cpu, NULL, NULL);
-#else
-  r = INLINE_SYSCALL_CALL (getcpu, &cpu, NULL, NULL);
-#endif
-  return r == -1 ? r : cpu;
-}
+#include <pizlonated_syscalls.h>
 
 int
 sched_getcpu (void)
 {
-  int cpu_id = THREAD_GETMEM_VOLATILE (THREAD_SELF, rseq_area.cpu_id);
-  return __glibc_likely (cpu_id >= 0) ? cpu_id : vsyscall_sched_getcpu ();
+  return zsys_sched_getcpu ();
 }
diff --git a/sysdeps/unix/sysv/linux/sched_setaffinity.c b/sysdeps/unix/sysv/linux/sched_setaffinity.c
index 21f66202ea7a..3c60e2ebf7b9 100644
--- a/sysdeps/unix/sysv/linux/sched_setaffinity.c
+++ b/sysdeps/unix/sysv/linux/sched_setaffinity.c
@@ -22,6 +22,7 @@
 #include <unistd.h>
 #include <sys/types.h>
 #include <shlib-compat.h>
+#include <pizlonated_syscalls.h>
 
 
 extern int __sched_setaffinity_new (pid_t, size_t, const cpu_set_t *);
@@ -30,9 +31,7 @@ libc_hidden_proto (__sched_setaffinity_new)
 int
 __sched_setaffinity_new (pid_t pid, size_t cpusetsize, const cpu_set_t *cpuset)
 {
-  int result = INLINE_SYSCALL (sched_setaffinity, 3, pid, cpusetsize, cpuset);
-
-  return result;
+  return zsys_sched_setaffinity (pid, cpusetsize, cpuset);
 }
 libc_hidden_def (__sched_setaffinity_new)
 versioned_symbol (libc, __sched_setaffinity_new, sched_setaffinity,
diff --git a/sysdeps/unix/sysv/linux/select.c b/sysdeps/unix/sysv/linux/select.c
index a75245ca4914..0d8f26282820 100644
--- a/sysdeps/unix/sysv/linux/select.c
+++ b/sysdeps/unix/sysv/linux/select.c
@@ -21,6 +21,7 @@
 #include <sys/select.h>
 #include <errno.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 /* Check the first NFDS descriptors each in READFDS (if not NULL) for read
    readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS
@@ -32,88 +33,7 @@ int
 __select64 (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
 	    struct __timeval64 *timeout)
 {
-  __time64_t s = timeout != NULL ? timeout->tv_sec : 0;
-  int32_t us = timeout != NULL ? timeout->tv_usec : 0;
-  int32_t ns;
-
-  if (s < 0 || us < 0)
-    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);
-
-  /* Normalize the timeout, as legacy Linux __NR_select and __NR__newselect.
-     Different than syscall, it also handle possible overflow.  */
-  if (us / USEC_PER_SEC > INT64_MAX - s)
-    {
-      s = INT64_MAX;
-      ns = NSEC_PER_SEC - 1;
-    }
-  else
-    {
-      s += us / USEC_PER_SEC;
-      us = us % USEC_PER_SEC;
-      ns = us * NSEC_PER_USEC;
-    }
-
-  struct __timespec64 ts64, *pts64 = NULL;
-   if (timeout != NULL)
-     {
-       ts64.tv_sec = s;
-       ts64.tv_nsec = ns;
-       pts64 = &ts64;
-     }
-
-#ifndef __NR_pselect6_time64
-# define __NR_pselect6_time64 __NR_pselect6
-#endif
-
-#ifdef __ASSUME_TIME64_SYSCALLS
-  int r = SYSCALL_CANCEL (pselect6_time64, nfds, readfds, writefds, exceptfds,
-			  pts64, NULL);
-  if (timeout != NULL)
-    TIMESPEC_TO_TIMEVAL (timeout, pts64);
-  return r;
-#else
-  bool need_time64 = timeout != NULL && !in_int32_t_range (timeout->tv_sec);
-  if (need_time64)
-    {
-      int r = SYSCALL_CANCEL (pselect6_time64, nfds, readfds, writefds,
-			      exceptfds, pts64, NULL);
-      if ((r >= 0 || errno != ENOSYS) && timeout != NULL)
-	{
-	  TIMESPEC_TO_TIMEVAL (timeout, &ts64);
-	}
-      else
-	__set_errno (EOVERFLOW);
-      return r;
-    }
-
-# ifdef __ASSUME_PSELECT
-  struct timespec ts32, *pts32 = NULL;
-  if (pts64 != NULL)
-    {
-      ts32.tv_sec = pts64->tv_sec;
-      ts32.tv_nsec = pts64->tv_nsec;
-      pts32 = &ts32;
-    }
-
-  int r = SYSCALL_CANCEL (pselect6, nfds, readfds, writefds, exceptfds, pts32,
-			  NULL);
-  if (timeout != NULL)
-    TIMESPEC_TO_TIMEVAL (timeout, pts32);
-  return r;
-# else
-  struct timeval tv32, *ptv32 = NULL;
-  if (pts64 != NULL)
-    {
-      tv32 = valid_timespec64_to_timeval (*pts64);
-      ptv32 = &tv32;
-    }
-
-  int r = SYSCALL_CANCEL (_newselect, nfds, readfds, writefds, exceptfds, ptv32);
-  if (timeout != NULL)
-    *timeout = valid_timeval_to_timeval64 (tv32);
-  return r;
-# endif /* __ASSUME_PSELECT  */
-#endif
+  return zsys_select (nfds, readfds, writefds, exceptfds, timeout);
 }
 
 #if __TIMESIZE != 64
diff --git a/sysdeps/unix/sysv/linux/semctl.c b/sysdeps/unix/sysv/linux/semctl.c
index c57fceab6bb1..44048fa1084b 100644
--- a/sysdeps/unix/sysv/linux/semctl.c
+++ b/sysdeps/unix/sysv/linux/semctl.c
@@ -21,195 +21,12 @@
 #include <sysdep.h>
 #include <shlib-compat.h>
 #include <linux/posix_types.h>             /* For __kernel_mode_t.  */
-
-/* The struct used to issue the syscall.  For architectures that assume
-   64-bit time as default (!__ASSUME_TIME64_SYSCALLS) the syscall will
-   split the resulting 64-bit sem_{o,c}time in two fields (sem_{o,c}time
-   and __sem_{o,c}time_high).  */
-union semun
-{
-  int val;			/* value for SETVAL */
-  struct semid_ds *buf;		/* buffer for IPC_STAT & IPC_SET */
-  unsigned short int *array;	/* array for GETALL & SETALL */
-  struct seminfo *__buf;	/* buffer for IPC_INFO */
-};
-
-#if __IPC_TIME64 == 0
-# define semun64 semun
-typedef union semun semctl_arg_t;
-#else
-# include <struct_kernel_semid64_ds.h>
-
-union ksemun64
-{
-  int val;
-  struct kernel_semid64_ds *buf;
-  unsigned short int *array;
-  struct seminfo *__buf;
-};
-
-# if __TIMESIZE == 64
-#  define semun64 semun
-# else
-/* The struct used when __semctl64 is called.  */
-union semun64
-{
-  int val;
-  struct __semid64_ds *buf;
-  unsigned short int *array;
-  struct seminfo *__buf;
-};
-# endif
-
-static void
-semid64_to_ksemid64 (const struct __semid64_ds *semid64,
-		     struct kernel_semid64_ds *ksemid)
-{
-  ksemid->sem_perm       = semid64->sem_perm;
-  ksemid->sem_otime      = semid64->sem_otime;
-  ksemid->sem_otime_high = semid64->sem_otime >> 32;
-  ksemid->sem_ctime      = semid64->sem_ctime;
-  ksemid->sem_ctime_high = semid64->sem_ctime >> 32;
-  ksemid->sem_nsems      = semid64->sem_nsems;
-}
-
-static void
-ksemid64_to_semid64 (const struct kernel_semid64_ds *ksemid,
-		     struct __semid64_ds *semid64)
-{
-  semid64->sem_perm  = ksemid->sem_perm;
-  semid64->sem_otime = ksemid->sem_otime
-		       | ((__time64_t) ksemid->sem_otime_high << 32);
-  semid64->sem_ctime = ksemid->sem_ctime
-		       | ((__time64_t) ksemid->sem_ctime_high << 32);
-  semid64->sem_nsems = ksemid->sem_nsems;
-}
-
-static union ksemun64
-semun64_to_ksemun64 (int cmd, union semun64 semun64,
-		     struct kernel_semid64_ds *buf)
-{
-  union ksemun64 r = { 0 };
-  switch (cmd)
-    {
-    case SETVAL:
-      r.val = semun64.val;
-      break;
-    case GETALL:
-    case SETALL:
-      r.array = semun64.array;
-      break;
-    case SEM_STAT:
-    case SEM_STAT_ANY:
-    case IPC_STAT:
-    case IPC_SET:
-      r.buf = buf;
-      semid64_to_ksemid64 (semun64.buf, r.buf);
-      break;
-    case IPC_INFO:
-    case SEM_INFO:
-      r.__buf = semun64.__buf;
-      break;
-    }
-  return r;
-}
-
-typedef union ksemun64 semctl_arg_t;
-#endif
-
-static int
-semctl_syscall (int semid, int semnum, int cmd, semctl_arg_t arg)
-{
-#ifdef __ASSUME_DIRECT_SYSVIPC_SYSCALLS
-  return INLINE_SYSCALL_CALL (semctl, semid, semnum, cmd | __IPC_64,
-			      arg.array);
-#else
-  return INLINE_SYSCALL_CALL (ipc, IPCOP_semctl, semid, semnum, cmd | __IPC_64,
-			      SEMCTL_ARG_ADDRESS (arg));
-#endif
-}
-
-/* POSIX states ipc_perm mode should have type of mode_t.  */
-_Static_assert (sizeof ((struct semid_ds){0}.sem_perm.mode)
-		== sizeof (mode_t),
-		"sizeof (msqid_ds.msg_perm.mode) != sizeof (mode_t)");
+#include <pizlonated_syscalls.h>
 
 int
 __semctl64 (int semid, int semnum, int cmd, ...)
 {
-  union semun64 arg64 = { 0 };
-  va_list ap;
-
-  /* Some applications pass the __IPC_64 flag in cmd, to invoke
-     previously unsupported commands back when there was no EINVAL
-     error checking in glibc.  Mask the flag for the switch statements
-     below.  semctl_syscall adds back the __IPC_64 flag for the actual
-     system call.  */
-  cmd &= ~__IPC_64;
-
-  /* Get the argument only if required.  */
-  switch (cmd)
-    {
-    case SETVAL:        /* arg.val */
-    case GETALL:        /* arg.array */
-    case SETALL:
-    case IPC_STAT:      /* arg.buf */
-    case IPC_SET:
-    case SEM_STAT:
-    case SEM_STAT_ANY:
-    case IPC_INFO:      /* arg.__buf */
-    case SEM_INFO:
-      va_start (ap, cmd);
-      arg64 = va_arg (ap, union semun64);
-      va_end (ap);
-      break;
-    case IPC_RMID:      /* arg ignored.  */
-    case GETNCNT:
-    case GETPID:
-    case GETVAL:
-    case GETZCNT:
-      break;
-    default:
-      __set_errno (EINVAL);
-      return -1;
-    }
-
-#if __IPC_TIME64
-  struct kernel_semid64_ds ksemid;
-  union ksemun64 ksemun = semun64_to_ksemun64 (cmd, arg64, &ksemid);
-# ifdef __ASSUME_SYSVIPC_BROKEN_MODE_T
-  if (cmd == IPC_SET)
-    ksemid.sem_perm.mode *= 0x10000U;
-# endif
-  union ksemun64 arg = ksemun;
-#else
-  union semun arg = arg64;
-#endif
-
-  int ret = semctl_syscall (semid, semnum, cmd, arg);
-  if (ret < 0)
-    return ret;
-
-  switch (cmd)
-    {
-    case IPC_STAT:
-    case SEM_STAT:
-    case SEM_STAT_ANY:
-#ifdef __ASSUME_SYSVIPC_BROKEN_MODE_T
-      arg.buf->sem_perm.mode >>= 16;
-#else
-      /* Old Linux kernel versions might not clear the mode padding.  */
-      if (sizeof ((struct semid_ds){0}.sem_perm.mode)
-	  != sizeof (__kernel_mode_t))
-	arg.buf->sem_perm.mode &= 0xFFFF;
-#endif
-
-#if __IPC_TIME64
-      ksemid64_to_semid64 (arg.buf, arg64.buf);
-#endif
-    }
-
-  return ret;
+  return *(int *) zcall (zsys_semctl, zargs ());
 }
 #if __TIMESIZE != 64
 libc_hidden_def (__semctl64)
diff --git a/sysdeps/unix/sysv/linux/semget.c b/sysdeps/unix/sysv/linux/semget.c
index 26d00467a789..17c82cf15216 100644
--- a/sysdeps/unix/sysv/linux/semget.c
+++ b/sysdeps/unix/sysv/linux/semget.c
@@ -19,6 +19,7 @@
 #include <ipc_priv.h>
 #include <sysdep.h>
 #include <errno.h>
+#include <pizlonated_syscalls.h>
 
 /* Return identifier for array of NSEMS semaphores associated with
    KEY.  */
@@ -26,9 +27,5 @@
 int
 semget (key_t key, int nsems, int semflg)
 {
-#ifdef __ASSUME_DIRECT_SYSVIPC_SYSCALLS
-  return INLINE_SYSCALL_CALL (semget, key, nsems, semflg);
-#else
-  return INLINE_SYSCALL_CALL (ipc, IPCOP_semget, key, nsems, semflg, NULL);
-#endif
+  return zsys_semget (key, nsems, semflg);
 }
diff --git a/sysdeps/unix/sysv/linux/semtimedop.c b/sysdeps/unix/sysv/linux/semtimedop.c
index 181289fa6a69..574d2f49e99f 100644
--- a/sysdeps/unix/sysv/linux/semtimedop.c
+++ b/sysdeps/unix/sysv/linux/semtimedop.c
@@ -19,52 +19,14 @@
 #include <ipc_priv.h>
 #include <sysdep.h>
 #include <errno.h>
-
-static int
-semtimedop_syscall (int semid, struct sembuf *sops, size_t nsops,
-		    const struct __timespec64 *timeout)
-{
-#ifdef __NR_semtimedop_time64
-  return INLINE_SYSCALL_CALL (semtimedop_time64, semid, sops, nsops, timeout);
-#elif defined __ASSUME_DIRECT_SYSVIPC_SYSCALLS && defined __NR_semtimedop
-  return INLINE_SYSCALL_CALL (semtimedop, semid, sops, nsops, timeout);
-#else
-  return INLINE_SYSCALL_CALL (ipc, IPCOP_semtimedop, semid,
-			      SEMTIMEDOP_IPC_ARGS (nsops, sops, timeout));
-#endif
-}
+#include <pizlonated_syscalls.h>
 
 /* Perform user-defined atomic operation of array of semaphores.  */
 int
 __semtimedop64 (int semid, struct sembuf *sops, size_t nsops,
 		const struct __timespec64 *timeout)
 {
-#ifdef __ASSUME_TIME64_SYSCALLS
-  return semtimedop_syscall (semid, sops, nsops, timeout);
-#else
-  bool need_time64 = timeout != NULL && !in_int32_t_range (timeout->tv_sec);
-  if (need_time64)
-    {
-      int r = semtimedop_syscall (semid, sops, nsops, timeout);
-      if (r == 0 || errno != ENOSYS)
-	return r;
-      __set_errno (EOVERFLOW);
-      return -1;
-    }
-
-  struct timespec ts32, *pts32 = NULL;
-  if (timeout != NULL)
-    {
-      ts32 = valid_timespec64_to_timespec (*timeout);
-      pts32 = &ts32;
-    }
-# ifdef __ASSUME_DIRECT_SYSVIPC_SYSCALLS
-  return INLINE_SYSCALL_CALL (semtimedop, semid, sops, nsops, pts32);
-# else
-  return INLINE_SYSCALL_CALL (ipc, IPCOP_semtimedop, semid,
-			      SEMTIMEDOP_IPC_ARGS (nsops, sops, pts32));
-# endif
-#endif
+  return zsys_semtimedop (semid, sops, nsops, timeout);
 }
 #if __TIMESIZE != 64
 libc_hidden_def (__semtimedop64)
diff --git a/sysdeps/unix/sysv/linux/send.c b/sysdeps/unix/sysv/linux/send.c
index 20dc6eae9501..eb4568be373b 100644
--- a/sysdeps/unix/sysv/linux/send.c
+++ b/sysdeps/unix/sysv/linux/send.c
@@ -18,17 +18,12 @@
 #include <sys/socket.h>
 #include <sysdep-cancel.h>
 #include <socketcall.h>
+#include <pizlonated_syscalls.h>
 
 ssize_t
 __libc_send (int fd, const void *buf, size_t len, int flags)
 {
-#ifdef __ASSUME_SEND_SYSCALL
-  return SYSCALL_CANCEL (send, fd, buf, len, flags);
-#elif defined __ASSUME_SENDTO_SYSCALL
-  return SYSCALL_CANCEL (sendto, fd, buf, len, flags, NULL, 0);
-#else
-  return SOCKETCALL_CANCEL (send, fd, buf, len, flags);
-#endif
+  return zsys_sendto (fd, buf, len, flags, NULL, 0);
 }
 weak_alias (__libc_send, send)
 weak_alias (__libc_send, __send)
diff --git a/sysdeps/unix/sysv/linux/sendfile64.c b/sysdeps/unix/sysv/linux/sendfile64.c
index a49aeace8787..17864cca2e01 100644
--- a/sysdeps/unix/sysv/linux/sendfile64.c
+++ b/sysdeps/unix/sysv/linux/sendfile64.c
@@ -20,16 +20,14 @@
 #include <stddef.h>
 #include <errno.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 /* Send COUNT bytes from file associated with IN_FD starting at OFFSET to
    descriptor OUT_FD.  */
 ssize_t
 sendfile64 (int out_fd, int in_fd, off64_t *offset, size_t count)
 {
-#ifndef __NR_sendfile64
-# define __NR_sendfile64 __NR_sendfile
-#endif
-  return INLINE_SYSCALL_CALL (sendfile64, out_fd, in_fd, offset, count);
+  return zsys_sendfile (out_fd, in_fd, offset, count);
 }
 
 #ifdef __OFF_T_MATCHES_OFF64_T
diff --git a/sysdeps/unix/sysv/linux/sendmmsg.c b/sysdeps/unix/sysv/linux/sendmmsg.c
index 50e084dd574e..2c928de0a0a7 100644
--- a/sysdeps/unix/sysv/linux/sendmmsg.c
+++ b/sysdeps/unix/sysv/linux/sendmmsg.c
@@ -22,15 +22,12 @@
 #include <sys/syscall.h>
 #include <socketcall.h>
 #include <kernel-features.h>
+#include <pizlonated_syscalls.h>
 
 int
 __sendmmsg (int fd, struct mmsghdr *vmessages, unsigned int vlen, int flags)
 {
-#ifdef __ASSUME_SENDMMSG_SYSCALL
-  return SYSCALL_CANCEL (sendmmsg, fd, vmessages, vlen, flags);
-#else
-  return SOCKETCALL_CANCEL (sendmmsg, fd, vmessages, vlen, flags);
-#endif
+  return zsys_sendmmsg(fd, vmessages, vlen, flags);
 }
 libc_hidden_def (__sendmmsg)
 weak_alias (__sendmmsg, sendmmsg)
diff --git a/sysdeps/unix/sysv/linux/sendmsg.c b/sysdeps/unix/sysv/linux/sendmsg.c
index 45c59ec98bb7..3f696882501a 100644
--- a/sysdeps/unix/sysv/linux/sendmsg.c
+++ b/sysdeps/unix/sysv/linux/sendmsg.c
@@ -20,15 +20,12 @@
 #include <sysdep-cancel.h>
 #include <socketcall.h>
 #include <shlib-compat.h>
+#include <pizlonated_syscalls.h>
 
 ssize_t
 __libc_sendmsg (int fd, const struct msghdr *msg, int flags)
 {
-# ifdef __ASSUME_SENDMSG_SYSCALL
-  return SYSCALL_CANCEL (sendmsg, fd, msg, flags);
-# else
-  return SOCKETCALL_CANCEL (sendmsg, fd, msg, flags);
-# endif
+  return zsys_sendmsg (fd, msg, flags);
 }
 weak_alias (__libc_sendmsg, sendmsg)
 weak_alias (__libc_sendmsg, __sendmsg)
diff --git a/sysdeps/unix/sysv/linux/sendto.c b/sysdeps/unix/sysv/linux/sendto.c
index 4fb227d1e399..67a1763342ae 100644
--- a/sysdeps/unix/sysv/linux/sendto.c
+++ b/sysdeps/unix/sysv/linux/sendto.c
@@ -18,18 +18,13 @@
 #include <sys/socket.h>
 #include <sysdep-cancel.h>
 #include <socketcall.h>
+#include <pizlonated_syscalls.h>
 
 ssize_t
 __libc_sendto (int fd, const void *buf, size_t len, int flags,
 	       __CONST_SOCKADDR_ARG addr, socklen_t addrlen)
 {
-#ifdef __ASSUME_SENDTO_SYSCALL
-  return SYSCALL_CANCEL (sendto, fd, buf, len, flags, addr.__sockaddr__,
-                         addrlen);
-#else
-  return SOCKETCALL_CANCEL (sendto, fd, buf, len, flags, addr.__sockaddr__,
-			    addrlen);
-#endif
+  return zsys_sendto (fd, buf, len, flags, addr.__sockaddr__, addrlen);
 }
 weak_alias (__libc_sendto, sendto)
 weak_alias (__libc_sendto, __sendto)
diff --git a/sysdeps/unix/sysv/linux/setegid.c b/sysdeps/unix/sysv/linux/setegid.c
index 4a6085321779..b25540c7294c 100644
--- a/sysdeps/unix/sysv/linux/setegid.c
+++ b/sysdeps/unix/sysv/linux/setegid.c
@@ -18,23 +18,13 @@
 #include <errno.h>
 #include <unistd.h>
 #include <setxid.h>
+#include <pizlonated_syscalls.h>
 
 
 int
 setegid (gid_t gid)
 {
-  int result;
-
-  if (gid == (gid_t) ~0)
-    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);
-
-#ifdef __NR_setresgid32
-  result = INLINE_SETXID_SYSCALL (setresgid32, 3, -1, gid, -1);
-#else
-  result = INLINE_SETXID_SYSCALL (setresgid, 3, -1, gid, -1);
-#endif
-
-  return result;
+  return zsys_setegid (gid);
 }
 #ifndef setegid
 libc_hidden_def (setegid)
diff --git a/sysdeps/unix/sysv/linux/seteuid.c b/sysdeps/unix/sysv/linux/seteuid.c
index 64d3c84f7c64..5f706a33e115 100644
--- a/sysdeps/unix/sysv/linux/seteuid.c
+++ b/sysdeps/unix/sysv/linux/seteuid.c
@@ -18,23 +18,13 @@
 #include <errno.h>
 #include <unistd.h>
 #include <setxid.h>
+#include <pizlonated_syscalls.h>
 
 
 int
 seteuid (uid_t uid)
 {
-  int result;
-
-  if (uid == (uid_t) ~0)
-    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);
-
-#ifdef __NR_setresuid32
-  result = INLINE_SETXID_SYSCALL (setresuid32, 3, -1, uid, -1);
-#else
-  result = INLINE_SETXID_SYSCALL (setresuid, 3, -1, uid, -1);
-#endif
-
-  return result;
+  return zsys_seteuid (uid);
 }
 #ifndef seteuid
 libc_hidden_def (seteuid)
diff --git a/sysdeps/unix/sysv/linux/setgid.c b/sysdeps/unix/sysv/linux/setgid.c
index 51d4df8ac015..484981e412d7 100644
--- a/sysdeps/unix/sysv/linux/setgid.c
+++ b/sysdeps/unix/sysv/linux/setgid.c
@@ -18,16 +18,13 @@
 #include <errno.h>
 #include <unistd.h>
 #include <setxid.h>
+#include <pizlonated_syscalls.h>
 
 
 int
 __setgid (gid_t gid)
 {
-#ifdef __NR_setgid32
-  return INLINE_SETXID_SYSCALL (setgid32, 1, gid);
-#else
-  return INLINE_SETXID_SYSCALL (setgid, 1, gid);
-#endif
+  return zsys_setgid (gid);
 }
 #ifndef __setgid
 weak_alias (__setgid, setgid)
diff --git a/sysdeps/unix/sysv/linux/setgroups.c b/sysdeps/unix/sysv/linux/setgroups.c
index be68f0c2e4c3..b78af1064500 100644
--- a/sysdeps/unix/sysv/linux/setgroups.c
+++ b/sysdeps/unix/sysv/linux/setgroups.c
@@ -19,6 +19,7 @@
 #include <grp.h>
 #include <setxid.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 
 /* Set the group set for the current user to GROUPS (N of them).  For
@@ -27,10 +28,6 @@
 int
 setgroups (size_t n, const gid_t *groups)
 {
-#ifdef __NR_setgroups32
-  return INLINE_SETXID_SYSCALL (setgroups32, 2, n, groups);
-#else
-  return INLINE_SETXID_SYSCALL (setgroups, 2, n, groups);
-#endif
+  return zsys_setgroups (n, groups);
 }
 libc_hidden_def (setgroups)
diff --git a/sysdeps/unix/sysv/linux/setitimer.c b/sysdeps/unix/sysv/linux/setitimer.c
index 2a2d59f9026a..51bb1d4a1039 100644
--- a/sysdeps/unix/sysv/linux/setitimer.c
+++ b/sysdeps/unix/sysv/linux/setitimer.c
@@ -21,42 +21,14 @@
 #include <sys/types.h>
 #include <sysdep.h>
 #include <tv32-compat.h>
+#include <pizlonated_syscalls.h>
 
 int
 __setitimer64 (__itimer_which_t which,
                const struct __itimerval64 *restrict new_value,
                struct __itimerval64 *restrict old_value)
 {
-#if __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64
-  return INLINE_SYSCALL_CALL (setitimer, which, new_value, old_value);
-#else
-  struct __itimerval32 new_value_32;
-
-  if (! in_int32_t_range (new_value->it_interval.tv_sec)
-      || ! in_int32_t_range (new_value->it_value.tv_sec))
-    {
-      __set_errno (EOVERFLOW);
-      return -1;
-    }
-  new_value_32.it_interval
-    = valid_timeval64_to_timeval32 (new_value->it_interval);
-  new_value_32.it_value
-    = valid_timeval64_to_timeval32 (new_value->it_value);
-
-  if (old_value == NULL)
-    return INLINE_SYSCALL_CALL (setitimer, which, &new_value_32, NULL);
-
-  struct __itimerval32 old_value_32;
-  if (INLINE_SYSCALL_CALL (setitimer, which, &new_value_32, &old_value_32)
-      == -1)
-    return -1;
-
-  old_value->it_interval
-     = valid_timeval32_to_timeval64 (old_value_32.it_interval);
-  old_value->it_value
-     = valid_timeval32_to_timeval64 (old_value_32.it_value);
-  return 0;
-#endif
+  return zsys_setitimer (which, new_value, old_value);
 }
 
 #if __TIMESIZE != 64
diff --git a/sysdeps/unix/sysv/linux/setregid.c b/sysdeps/unix/sysv/linux/setregid.c
index 2e89677aa328..1f6e8653ad0a 100644
--- a/sysdeps/unix/sysv/linux/setregid.c
+++ b/sysdeps/unix/sysv/linux/setregid.c
@@ -18,16 +18,13 @@
 #include <errno.h>
 #include <unistd.h>
 #include <setxid.h>
+#include <pizlonated_syscalls.h>
 
 
 int
 __setregid (gid_t rgid, gid_t egid)
 {
-#ifdef __NR_setregid32
-  return INLINE_SETXID_SYSCALL (setregid32, 2, rgid, egid);
-#else
-  return INLINE_SETXID_SYSCALL (setregid, 2, rgid, egid);
-#endif
+  return zsys_setregid (rgid, egid);
 }
 #ifndef __setregid
 weak_alias (__setregid, setregid)
diff --git a/sysdeps/unix/sysv/linux/setresgid.c b/sysdeps/unix/sysv/linux/setresgid.c
index 6b44503cb69c..b85ae5c01203 100644
--- a/sysdeps/unix/sysv/linux/setresgid.c
+++ b/sysdeps/unix/sysv/linux/setresgid.c
@@ -18,16 +18,13 @@
 #include <errno.h>
 #include <unistd.h>
 #include <setxid.h>
+#include <pizlonated_syscalls.h>
 
 
 int
 __setresgid (gid_t rgid, gid_t egid, gid_t sgid)
 {
-#ifdef __NR_setresgid32
-  return INLINE_SETXID_SYSCALL (setresgid32, 3, rgid, egid, sgid);
-#else
-  return INLINE_SETXID_SYSCALL (setresgid, 3, rgid, egid, sgid);
-#endif
+  return zsys_setresgid (rgid, egid, sgid);
 }
 libc_hidden_def (__setresgid)
 #ifndef __setresgid
diff --git a/sysdeps/unix/sysv/linux/setresuid.c b/sysdeps/unix/sysv/linux/setresuid.c
index 3339779aeb5d..ad22fb34c6cb 100644
--- a/sysdeps/unix/sysv/linux/setresuid.c
+++ b/sysdeps/unix/sysv/linux/setresuid.c
@@ -18,16 +18,13 @@
 #include <errno.h>
 #include <unistd.h>
 #include <setxid.h>
+#include <pizlonated_syscalls.h>
 
 
 int
 __setresuid (uid_t ruid, uid_t euid, uid_t suid)
 {
-#ifdef __NR_setresuid32
-  return INLINE_SETXID_SYSCALL (setresuid32, 3, ruid, euid, suid);
-#else
-  return INLINE_SETXID_SYSCALL (setresuid, 3, ruid, euid, suid);
-#endif
+  return zsys_setresuid (ruid, euid, suid);
 }
 libc_hidden_def (__setresuid)
 #ifndef __setresuid
diff --git a/sysdeps/unix/sysv/linux/setreuid.c b/sysdeps/unix/sysv/linux/setreuid.c
index a3889b3f1dbc..e39fd5e8229c 100644
--- a/sysdeps/unix/sysv/linux/setreuid.c
+++ b/sysdeps/unix/sysv/linux/setreuid.c
@@ -18,16 +18,13 @@
 #include <errno.h>
 #include <unistd.h>
 #include <setxid.h>
+#include <pizlonated_syscalls.h>
 
 
 int
 __setreuid (uid_t ruid, uid_t euid)
 {
-#ifdef __NR_setreuid32
-  return INLINE_SETXID_SYSCALL (setreuid32, 2, ruid, euid);
-#else
-  return INLINE_SETXID_SYSCALL (setreuid, 2, ruid, euid);
-#endif
+  return zsys_setreuid (ruid, euid);
 }
 #ifndef __setreuid
 weak_alias (__setreuid, setreuid)
diff --git a/sysdeps/unix/sysv/linux/setrlimit.c b/sysdeps/unix/sysv/linux/setrlimit.c
index 3be6f96f045c..21b1c3631bbd 100644
--- a/sysdeps/unix/sysv/linux/setrlimit.c
+++ b/sysdeps/unix/sysv/linux/setrlimit.c
@@ -22,6 +22,8 @@
 
 #if !__RLIM_T_MATCHES_RLIM64_T
 
+#error "Should not get here"
+
 /* The compatibility symbol is meant to match the old __NR_getrlimit syscall
    (with broken RLIM_INFINITY definition).  It should be provided iff
    __NR_getrlimit and __NR_ugetrlimit are both defined.  */
diff --git a/sysdeps/unix/sysv/linux/setrlimit64.c b/sysdeps/unix/sysv/linux/setrlimit64.c
index 084700c335dd..32d9034e152a 100644
--- a/sysdeps/unix/sysv/linux/setrlimit64.c
+++ b/sysdeps/unix/sysv/linux/setrlimit64.c
@@ -20,6 +20,7 @@
 #include <sys/types.h>
 #include <sysdep.h>
 #include <shlib-compat.h>
+#include <pizlonated_syscalls.h>
 
 /* Add this redirection so the strong_alias for __RLIM_T_MATCHES_RLIM64_T
    linking setrlimit64 to {__}setrlimit does not throw a type error.  */
@@ -37,7 +38,7 @@
 int
 __setrlimit64 (enum __rlimit_resource resource, const struct rlimit64 *rlimits)
 {
-  return INLINE_SYSCALL_CALL (prlimit64, 0, resource, rlimits, NULL);
+  return zsys_setrlimit(resource, rlimits);
 }
 /* Alpha defines a versioned setrlimit{64}.  */
 #ifndef USE_VERSIONED_RLIMIT
@@ -50,6 +51,6 @@ strong_alias (__setrlimit64, __setrlimit)
 weak_alias (__setrlimit64, setrlimit)
 # endif
 # ifdef SHARED
-__hidden_ver1 (__setrlimit64, __GI___setrlimit, __setrlimit64);
+__hidden_ver1 (__setrlimit64, __GI___setrlimit, __setrlimit64, "");
 # endif
 #endif
diff --git a/sysdeps/unix/sysv/linux/setsockopt.c b/sysdeps/unix/sysv/linux/setsockopt.c
index e483c13d535a..8d0c8897728a 100644
--- a/sysdeps/unix/sysv/linux/setsockopt.c
+++ b/sysdeps/unix/sysv/linux/setsockopt.c
@@ -20,16 +20,13 @@
 #include <sysdep.h>
 #include <socketcall.h>
 #include <socket-constants-time64.h>
+#include <pizlonated_syscalls.h>
 
 static int
 setsockopt_syscall (int fd, int level, int optname, const void *optval,
 		    socklen_t len)
 {
-#ifdef __ASSUME_SETSOCKOPT_SYSCALL
-  return INLINE_SYSCALL_CALL (setsockopt, fd, level, optname, optval, len);
-#else
-  return SOCKETCALL (setsockopt, fd, level, optname, optval, len);
-#endif
+  return zsys_setsockopt (fd, level, optname, optval, len);
 }
 
 #ifndef __ASSUME_TIME64_SYSCALLS
diff --git a/sysdeps/unix/sysv/linux/setuid.c b/sysdeps/unix/sysv/linux/setuid.c
index 39d5e0cfa19e..3b6ec7a9dbe7 100644
--- a/sysdeps/unix/sysv/linux/setuid.c
+++ b/sysdeps/unix/sysv/linux/setuid.c
@@ -18,15 +18,12 @@
 #include <errno.h>
 #include <unistd.h>
 #include <setxid.h>
+#include <pizlonated_syscalls.h>
 
 int
 __setuid (uid_t uid)
 {
-#ifdef __NR_setuid32
-  return INLINE_SETXID_SYSCALL (setuid32, 1, uid);
-#else
-  return INLINE_SETXID_SYSCALL (setuid, 1, uid);
-#endif
+  return zsys_setuid (uid);
 }
 #ifndef __setuid
 weak_alias (__setuid, setuid)
diff --git a/sysdeps/unix/sysv/linux/shlib-versions b/sysdeps/unix/sysv/linux/shlib-versions
index 916055773340..4afa68f5af83 100644
--- a/sysdeps/unix/sysv/linux/shlib-versions
+++ b/sysdeps/unix/sysv/linux/shlib-versions
@@ -1,2 +1,2 @@
-libm=6
-libc=6
+libm=6666
+libc=6666
diff --git a/sysdeps/unix/sysv/linux/shmat.c b/sysdeps/unix/sysv/linux/shmat.c
index 3f6e0b938ee1..934cc027bc53 100644
--- a/sysdeps/unix/sysv/linux/shmat.c
+++ b/sysdeps/unix/sysv/linux/shmat.c
@@ -18,6 +18,7 @@
 #include <ipc_priv.h>
 #include <sysdep.h>
 #include <errno.h>
+#include <pizlonated_syscalls.h>
 
 /* Attach the shared memory segment associated with SHMID to the data
    segment of the calling process.  SHMADDR and SHMFLG determine how
@@ -26,17 +27,5 @@
 void *
 shmat (int shmid, const void *shmaddr, int shmflg)
 {
-#ifdef __ASSUME_DIRECT_SYSVIPC_SYSCALLS
-  return (void*) INLINE_SYSCALL_CALL (shmat, shmid, shmaddr, shmflg);
-#else
-  unsigned long resultvar;
-  void *raddr;
-
-  resultvar = INTERNAL_SYSCALL_CALL (ipc, IPCOP_shmat, shmid, shmflg,
-				     &raddr, shmaddr);
-  if (INTERNAL_SYSCALL_ERROR_P (resultvar))
-    return (void *) INLINE_SYSCALL_ERROR_RETURN_VALUE (INTERNAL_SYSCALL_ERRNO (resultvar));
-
-  return raddr;
-#endif
+  return zsys_shmat (shmid, shmaddr, shmflg);
 }
diff --git a/sysdeps/unix/sysv/linux/shmctl.c b/sysdeps/unix/sysv/linux/shmctl.c
index 5f13b57d4b6d..0c89f1d33b70 100644
--- a/sysdeps/unix/sysv/linux/shmctl.c
+++ b/sysdeps/unix/sysv/linux/shmctl.c
@@ -22,151 +22,18 @@
 #include <shlib-compat.h>
 #include <errno.h>
 #include <linux/posix_types.h>  /* For __kernel_mode_t.  */
+#include <pizlonated_syscalls.h>
 
 /* POSIX states ipc_perm mode should have type of mode_t.  */
 _Static_assert (sizeof ((struct shmid_ds){0}.shm_perm.mode)
 		== sizeof (mode_t),
 		"sizeof (shmid_ds.shm_perm.mode) != sizeof (mode_t)");
 
-#if __IPC_TIME64 == 0
-typedef struct shmid_ds shmctl_arg_t;
-#else
-# include <struct_kernel_shmid64_ds.h>
-
-static void
-shmid64_to_kshmid64 (const struct __shmid64_ds *shmid64,
-		     struct kernel_shmid64_ds *kshmid)
-{
-  kshmid->shm_perm       = shmid64->shm_perm;
-  kshmid->shm_segsz      = shmid64->shm_segsz;
-  kshmid->shm_atime      = shmid64->shm_atime;
-  kshmid->shm_atime_high = shmid64->shm_atime >> 32;
-  kshmid->shm_dtime      = shmid64->shm_dtime;
-  kshmid->shm_dtime_high = shmid64->shm_dtime >> 32;
-  kshmid->shm_ctime      = shmid64->shm_ctime;
-  kshmid->shm_ctime_high = shmid64->shm_ctime >> 32;
-  kshmid->shm_cpid       = shmid64->shm_cpid;
-  kshmid->shm_lpid       = shmid64->shm_lpid;
-  kshmid->shm_nattch     = shmid64->shm_nattch;
-}
-
-static void
-kshmid64_to_shmid64 (const struct kernel_shmid64_ds *kshmid,
-		     struct __shmid64_ds *shmid64)
-{
-  shmid64->shm_perm   = kshmid->shm_perm;
-  shmid64->shm_segsz  = kshmid->shm_segsz;
-  shmid64->shm_atime  = kshmid->shm_atime
-		        | ((__time64_t) kshmid->shm_atime_high << 32);
-  shmid64->shm_dtime  = kshmid->shm_dtime
-		        | ((__time64_t) kshmid->shm_dtime_high << 32);
-  shmid64->shm_ctime  = kshmid->shm_ctime
-		        | ((__time64_t) kshmid->shm_ctime_high << 32);
-  shmid64->shm_cpid   = kshmid->shm_cpid;
-  shmid64->shm_lpid   = kshmid->shm_lpid;
-  shmid64->shm_nattch = kshmid->shm_nattch;
-}
-
-typedef struct kernel_shmid64_ds shmctl_arg_t;
-#endif
-
-static int
-shmctl_syscall (int shmid, int cmd, shmctl_arg_t *buf)
-{
-#ifdef __ASSUME_DIRECT_SYSVIPC_SYSCALLS
-  return INLINE_SYSCALL_CALL (shmctl, shmid, cmd | __IPC_64, buf);
-#else
-  return INLINE_SYSCALL_CALL (ipc, IPCOP_shmctl, shmid, cmd | __IPC_64, 0,
-			      buf);
-#endif
-}
-
 /* Provide operations to control over shared memory segments.  */
 int
 __shmctl64 (int shmid, int cmd, struct __shmid64_ds *buf)
 {
-#if IPC_CTL_NEED_TRANSLATION
-# if __IPC_TIME64
-  struct kernel_shmid64_ds kshmid, *arg = NULL;
-# else
-  shmctl_arg_t *arg;
-# endif
-
-  /* Some applications pass the __IPC_64 flag in cmd, to invoke
-     previously unsupported commands back when there was no EINVAL
-     error checking in glibc.  Mask the flag for the switch statements
-     below.  shmctl_syscall adds back the __IPC_64 flag for the actual
-     system call.  */
-  cmd &= ~__IPC_64;
-
-  switch (cmd)
-    {
-    case IPC_RMID:
-    case SHM_LOCK:
-    case SHM_UNLOCK:
-      arg = NULL;
-      break;
-
-    case IPC_SET:
-    case IPC_STAT:
-    case SHM_STAT:
-    case SHM_STAT_ANY:
-# if __IPC_TIME64
-      if (buf != NULL)
-	{
-	  shmid64_to_kshmid64 (buf, &kshmid);
-	  arg = &kshmid;
-	}
-#  ifdef __ASSUME_SYSVIPC_BROKEN_MODE_T
-      if (cmd == IPC_SET)
-        arg->shm_perm.mode *= 0x10000U;
-#  endif
-# else
-      arg = buf;
-# endif
-      break;
-
-    case IPC_INFO:
-    case SHM_INFO:
-      /* This is a Linux extension where kernel expects either a
-	 'struct shminfo' (IPC_INFO) or 'struct shm_info' (SHM_INFO).  */
-      arg = (__typeof__ (arg)) buf;
-      break;
-
-    default:
-      __set_errno (EINVAL);
-      return -1;
-    }
-
-
-  int ret = shmctl_syscall (shmid, cmd, arg);
-  if (ret < 0)
-    return ret;
-
-  switch (cmd)
-    {
-      case IPC_STAT:
-      case SHM_STAT:
-      case SHM_STAT_ANY:
-# ifdef __ASSUME_SYSVIPC_BROKEN_MODE_T
-        arg->shm_perm.mode >>= 16;
-# else
-      /* Old Linux kernel versions might not clear the mode padding.  */
-      if (sizeof ((struct shmid_ds){0}.shm_perm.mode)
-	  != sizeof (__kernel_mode_t))
-	arg->shm_perm.mode &= 0xFFFF;
-# endif
-
-# if __IPC_TIME64
-      kshmid64_to_shmid64 (arg, buf);
-# endif
-    }
-
-  return ret;
-
-#else /* !IPC_CTL_NEED_TRANSLATION */
-  return shmctl_syscall (shmid, cmd, buf);
-#endif
+  return zsys_shmctl (shmid, cmd, buf);
 }
 #if __TIMESIZE != 64
 libc_hidden_def (__shmctl64)
diff --git a/sysdeps/unix/sysv/linux/shmdt.c b/sysdeps/unix/sysv/linux/shmdt.c
index 60d54cab126a..773678640ea3 100644
--- a/sysdeps/unix/sysv/linux/shmdt.c
+++ b/sysdeps/unix/sysv/linux/shmdt.c
@@ -18,6 +18,7 @@
 #include <ipc_priv.h>
 #include <sysdep.h>
 #include <errno.h>
+#include <pizlonated_syscalls.h>
 
 /* Detach shared memory segment starting at address specified by SHMADDR
    from the caller's data segment.  */
@@ -25,9 +26,5 @@
 int
 shmdt (const void *shmaddr)
 {
-#ifdef __ASSUME_DIRECT_SYSVIPC_SYSCALLS
-  return INLINE_SYSCALL_CALL (shmdt, shmaddr);
-#else
-  return INLINE_SYSCALL_CALL (ipc, IPCOP_shmdt, 0, 0, 0, shmaddr);
-#endif
+  return zsys_shmdt (shmaddr);
 }
diff --git a/sysdeps/unix/sysv/linux/shmget.c b/sysdeps/unix/sysv/linux/shmget.c
index 8f47aed98fcf..69a35033540f 100644
--- a/sysdeps/unix/sysv/linux/shmget.c
+++ b/sysdeps/unix/sysv/linux/shmget.c
@@ -19,6 +19,7 @@
 #include <stddef.h>
 #include <ipc_priv.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 /* Return an identifier for an shared memory segment of at least size SIZE
    which is associated with KEY.  */
@@ -26,9 +27,5 @@
 int
 shmget (key_t key, size_t size, int shmflg)
 {
-#ifdef __ASSUME_DIRECT_SYSVIPC_SYSCALLS
-  return INLINE_SYSCALL_CALL (shmget, key, size, shmflg, NULL);
-#else
-  return INLINE_SYSCALL_CALL (ipc, IPCOP_shmget, key, size, shmflg, NULL);
-#endif
+  return zsys_shmget (key, size, shmflg);
 }
diff --git a/sysdeps/unix/sysv/linux/signalfd.c b/sysdeps/unix/sysv/linux/signalfd.c
index 55724b817d0c..d65939ec14f9 100644
--- a/sysdeps/unix/sysv/linux/signalfd.c
+++ b/sysdeps/unix/sysv/linux/signalfd.c
@@ -19,10 +19,11 @@
 #include <signal.h>
 #include <sys/signalfd.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 
 int
 signalfd (int fd, const sigset_t *mask, int flags)
 {
-  return INLINE_SYSCALL (signalfd4, 4, fd, mask, __NSIG_BYTES, flags);
+  return zsys_signalfd (fd, mask, flags);
 }
diff --git a/sysdeps/unix/sysv/linux/sigpending.c b/sysdeps/unix/sysv/linux/sigpending.c
index 08e0779fc4f6..2bba80b012fc 100644
--- a/sysdeps/unix/sysv/linux/sigpending.c
+++ b/sysdeps/unix/sysv/linux/sigpending.c
@@ -18,11 +18,12 @@
 #include <signal.h>
 #include <sysdep.h>
 #include <sigsetops.h>
+#include <pizlonated_syscalls.h>
 
 /* Change the set of blocked signals to SET,
    wait until a signal arrives, and restore the set of blocked signals.  */
 int
 sigpending (sigset_t *set)
 {
-  return INLINE_SYSCALL_CALL (rt_sigpending, set, __NSIG_BYTES);
+  return zsys_sigpending (set);
 }
diff --git a/sysdeps/unix/sysv/linux/sigqueue.c b/sysdeps/unix/sysv/linux/sigqueue.c
index 37d910c5ae99..ee74e8a43640 100644
--- a/sysdeps/unix/sysv/linux/sigqueue.c
+++ b/sysdeps/unix/sysv/linux/sigqueue.c
@@ -20,23 +20,12 @@
 #include <string.h>
 #include <unistd.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 /* Return any pending signal or wait for one for the given time.  */
 int
 __sigqueue (pid_t pid, int sig, const union sigval val)
 {
-  siginfo_t info;
-
-  /* First, clear the siginfo_t structure, so that we don't pass our
-     stack content to other tasks.  */
-  memset (&info, 0, sizeof (siginfo_t));
-  /* We must pass the information about the data in a siginfo_t value.  */
-  info.si_signo = sig;
-  info.si_code = SI_QUEUE;
-  info.si_pid = __getpid ();
-  info.si_uid = __getuid ();
-  info.si_value = val;
-
-  return INLINE_SYSCALL_CALL (rt_sigqueueinfo, pid, sig, &info);
+  return zsys_sigqueue (pid, sig, val.sival_ptr);
 }
 weak_alias (__sigqueue, sigqueue)
diff --git a/sysdeps/unix/sysv/linux/sigsetops.h b/sysdeps/unix/sysv/linux/sigsetops.h
index 33db4f77b8f6..8f0c6c65b404 100644
--- a/sysdeps/unix/sysv/linux/sigsetops.h
+++ b/sysdeps/unix/sysv/linux/sigsetops.h
@@ -37,7 +37,7 @@ __sigword (int sig)
 /* Linux sig* functions only handle up to __NSIG_WORDS words instead of
    full _SIGSET_NWORDS sigset size.  The signal numbers are 1-based, and
    bit 0 of a signal mask is for signal 1.  */
-#define __NSIG_WORDS (ALIGN_UP ((_NSIG - 1), ULONG_WIDTH) / ULONG_WIDTH)
+#define __NSIG_WORDS _SIGSET_NWORDS
 _Static_assert (__NSIG_WORDS <= _SIGSET_NWORDS,
 		"__NSIG_WORDS > _SIGSET_WORDS");
 
diff --git a/sysdeps/unix/sysv/linux/sigsuspend.c b/sysdeps/unix/sysv/linux/sigsuspend.c
index 4a5de2b75c0f..470e3c589b21 100644
--- a/sysdeps/unix/sysv/linux/sigsuspend.c
+++ b/sysdeps/unix/sysv/linux/sigsuspend.c
@@ -17,13 +17,14 @@
 
 #include <signal.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 /* Change the set of blocked signals to SET,
    wait until a signal arrives, and restore the set of blocked signals.  */
 int
 __sigsuspend (const sigset_t *set)
 {
-  return SYSCALL_CANCEL (rt_sigsuspend, set, __NSIG_BYTES);
+  return zsys_sigsuspend (set);
 }
 libc_hidden_def (__sigsuspend)
 weak_alias (__sigsuspend, sigsuspend)
diff --git a/sysdeps/unix/sysv/linux/sigtimedwait.c b/sysdeps/unix/sysv/linux/sigtimedwait.c
index 3da4e8ef2834..28145862c414 100644
--- a/sysdeps/unix/sysv/linux/sigtimedwait.c
+++ b/sysdeps/unix/sysv/linux/sigtimedwait.c
@@ -17,51 +17,13 @@
 
 #include <signal.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 int
 __sigtimedwait64 (const sigset_t *set, siginfo_t *info,
 		  const struct __timespec64 *timeout)
 {
-#ifndef __NR_rt_sigtimedwait_time64
-# define __NR_rt_sigtimedwait_time64 __NR_rt_sigtimedwait
-#endif
-
-  int result;
-#ifdef __ASSUME_TIME64_SYSCALLS
-  result = SYSCALL_CANCEL (rt_sigtimedwait_time64, set, info, timeout,
-			   __NSIG_BYTES);
-#else
-  bool need_time64 = timeout != NULL && !in_int32_t_range (timeout->tv_sec);
-  if (need_time64)
-    {
-      result = SYSCALL_CANCEL (rt_sigtimedwait_time64, set, info, timeout,
-			       __NSIG_BYTES);
-      if (result == 0 || errno != ENOSYS)
-	return result;
-      __set_errno (EOVERFLOW);
-      return -1;
-    }
-  else
-    {
-      struct timespec ts32, *pts32 = NULL;
-      if (timeout != NULL)
-	{
-	  ts32 = valid_timespec64_to_timespec (*timeout);
-	  pts32 = &ts32;
-	}
-      result = SYSCALL_CANCEL (rt_sigtimedwait, set, info, pts32,
-			       __NSIG_BYTES);
-    }
-#endif
-
-  /* The kernel generates a SI_TKILL code in si_code in case tkill is
-     used.  tkill is transparently used in raise().  Since having
-     SI_TKILL as a code is useful in general we fold the results
-     here.  */
-  if (result != -1 && info != NULL && info->si_code == SI_TKILL)
-    info->si_code = SI_USER;
-
-  return result;
+  return zsys_sigtimedwait (set, info, timeout);
 }
 #if __TIMESIZE != 64
 libc_hidden_def (__sigtimedwait64)
diff --git a/sysdeps/unix/sysv/linux/spawni.c b/sysdeps/unix/sysv/linux/spawni.c
index f57e92815eaf..07f8c2871d0f 100644
--- a/sysdeps/unix/sysv/linux/spawni.c
+++ b/sysdeps/unix/sysv/linux/spawni.c
@@ -67,8 +67,8 @@ struct posix_spawn_args
   char *const *envp;
   int xflags;
   bool use_clone3;
-  int err;
   int pidfd;
+  int err_pipe[2];
 };
 
 /* Older version requires that shell script without shebang definition
@@ -106,6 +106,8 @@ __spawni_child (void *arguments)
   const posix_spawnattr_t *restrict attr = args->attr;
   const posix_spawn_file_actions_t *file_actions = args->fa;
 
+  ZASSERT (!__close_nocancel (args->err_pipe[0]));
+
   /* The child must ensure that no signal handler is enabled because it
      shares memory with parent, so all signal dispositions must be either
      SIG_DFL or SIG_IGN.  If clone3/CLONE_CLEAR_SIGHAND is used, there is
@@ -265,9 +267,18 @@ __spawni_child (void *arguments)
 	    case spawn_do_closefrom:
 	      {
 		int lowfd = action->action.closefrom_action.from;
-	        int r = INLINE_SYSCALL_CALL (close_range, lowfd, ~0U, 0);
-		if (r != 0 && !__closefrom_fallback (lowfd, false))
-		  goto fail;
+                if (lowfd < args->err_pipe[1])
+                  {
+                    if (zsys_close_range (lowfd, args->err_pipe[1] - 1, 0) != 0)
+                      goto fail;
+                    if (zsys_close_range (args->err_pipe[1] + 1, ~0U, 0) != 0)
+                      goto fail;
+                  }
+                else
+                  {
+                    if (zsys_close_range (lowfd, ~0U, 0) != 0)
+                      goto fail;
+                  }
 	      } break;
 
 	    case spawn_do_tcsetpgrp:
@@ -290,6 +301,8 @@ __spawni_child (void *arguments)
   else
     internal_sigprocmask (SIG_SETMASK, &args->oldmask, NULL);
 
+  ZASSERT (!__fcntl (args->err_pipe[1], F_SETFD, FD_CLOEXEC));
+
   args->exec (args->file, args->argv, args->envp);
 
   /* This is compatibility function required to enable posix_spawn run
@@ -298,12 +311,17 @@ __spawni_child (void *arguments)
   maybe_script_execute (args);
 
 fail:
+  ;
   /* errno should have an appropriate non-zero value; otherwise,
      there's a bug in glibc or the kernel.  For lack of an error code
      (EINTERNALBUG) describing that, use ECHILD.  Another option would
      be to set args->err to some negative sentinel and have the parent
      abort(), but that seems needlessly harsh.  */
-  args->err = errno ? : ECHILD;
+  int errno_to_send = errno;
+  if (!errno_to_send)
+    errno_to_send = ECHILD;
+  ZASSERT (__write (args->err_pipe[1], &errno_to_send, sizeof (errno_to_send))
+           == sizeof(errno_to_send));
   _exit (SPAWN_ERROR);
 }
 
@@ -316,11 +334,12 @@ __spawnix (int *pid, const char *file,
 	   char *const envp[], int xflags,
 	   int (*exec) (const char *, char *const *, char *const *))
 {
-  pid_t new_pid;
+  pid_t new_pid = 0;
   struct posix_spawn_args args;
-  int ec;
+  int ec = 0;
 
   bool use_pidfd = xflags & SPAWN_XFLAGS_RET_PIDFD;
+  ZASSERT (!use_pidfd);
 
   /* For CLONE_PIDFD, older kernels might not fail with unsupported flags or
      some versions might not support waitid (P_PIDFD).  So to avoid the need
@@ -348,31 +367,12 @@ __spawnix (int *pid, const char *file,
 	return errno;
       }
 
-  int prot = (PROT_READ | PROT_WRITE
-	     | ((GL (dl_stack_flags) & PF_X) ? PROT_EXEC : 0));
-
-  /* Add a slack area for child's stack.  */
-  size_t argv_size = (argc * sizeof (void *)) + 512;
-  /* We need at least a few pages in case the compiler's stack checking is
-     enabled.  In some configs, it is known to use at least 24KiB.  We use
-     32KiB to be "safe" from anything the compiler might do.  Besides, the
-     extra pages won't actually be allocated unless they get used.
-     It also acts the slack for spawn_closefrom (including MIPS64 getdents64
-     where it might use about 1k extra stack space).  */
-  argv_size += (32 * 1024);
-  size_t stack_size = ALIGN_UP (argv_size, GLRO(dl_pagesize));
-  void *stack = __mmap (NULL, stack_size, prot,
-			MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);
-  if (__glibc_unlikely (stack == MAP_FAILED))
-    return errno;
-
   /* Disable asynchronous cancellation.  */
   int state;
   __pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &state);
 
   /* Child must set args.err to something non-negative - we rely on
      the parent and child sharing VM.  */
-  args.err = 0;
   args.file = file;
   args.exec = exec;
   args.fa = file_actions;
@@ -382,97 +382,48 @@ __spawnix (int *pid, const char *file,
   args.envp = envp;
   args.pidfd = 0;
   args.xflags = xflags;
+  if (__pipe (args.err_pipe))
+    {
+      ec = errno;
+      __pthread_setcancelstate (state, NULL);
+      return ec;
+    }
 
+  bool set_cgroup = attrp ? (attrp->__flags & POSIX_SPAWN_SETCGROUP) : false;
+  ZASSERT (!set_cgroup);
+  
   internal_signal_block_all (&args.oldmask);
 
-  /* The clone flags used will create a new child that will run in the same
-     memory space (CLONE_VM) and the execution of calling thread will be
-     suspend until the child calls execve or _exit.
-
-     Also since the calling thread execution will be suspend, there is not
-     need for CLONE_SETTLS.  Although parent and child share the same TLS
-     namespace, there will be no concurrent access for TLS variables (errno
-     for instance).  */
-  bool set_cgroup = attrp ? (attrp->__flags & POSIX_SPAWN_SETCGROUP) : false;
-  struct clone_args clone_args =
-    {
-      /* Unsupported flags like CLONE_CLEAR_SIGHAND will be cleared up by
-	 __clone_internal_fallback.  */
-      .flags = (set_cgroup ? CLONE_INTO_CGROUP : 0)
-	       | (use_pidfd ? CLONE_PIDFD : 0)
-	       | CLONE_CLEAR_SIGHAND
-	       | CLONE_VM
-	       | CLONE_VFORK,
-      .exit_signal = SIGCHLD,
-      .stack = (uintptr_t) stack,
-      .stack_size = stack_size,
-      .cgroup = (set_cgroup ? attrp->__cgroup : 0),
-      .pidfd = use_pidfd ? (uintptr_t) &args.pidfd : 0,
-      /* This is require for clone fallback, where pidfd is returned
-	 on parent_tid.  */
-      .parent_tid = use_pidfd ? (uintptr_t) &args.pidfd : 0,
-    };
-#ifdef HAVE_CLONE3_WRAPPER
-  args.use_clone3 = true;
-  new_pid = __clone3 (&clone_args, sizeof (clone_args), __spawni_child,
-		      &args);
-  /* clone3 was added in 5.3 and CLONE_CLEAR_SIGHAND in 5.5.  */
-  if (new_pid == -1 && (errno == ENOSYS || errno == EINVAL))
-#endif
+  int fork_result = zsys_fork ();
+  if (fork_result < 0)
     {
-      args.use_clone3 = false;
-      if (!set_cgroup)
-	new_pid = __clone_internal_fallback (&clone_args, __spawni_child,
-					     &args);
-      else
-	{
-	  /* No fallback for POSIX_SPAWN_SETCGROUP if clone3 is not
-	     supported.  */
-	  new_pid = -1;
-#ifdef HAVE_CLONE3_WRAPPER
-	  if (errno == ENOSYS)
-#endif
-	    errno = ENOTSUP;
-	}
+      ec = errno;
+      __close_nocancel (args.err_pipe[0]);
+      __close_nocancel (args.err_pipe[1]);
     }
-
-  /* It needs to collect the case where the auxiliary process was created
-     but failed to execute the file (due either any preparation step or
-     for execve itself).  */
-  if (new_pid > 0)
+  else if (!fork_result)
     {
-      /* Also, it handles the unlikely case where the auxiliary process was
-	 terminated before calling execve as if it was successfully.  The
-	 args.err is set to 0 as default and changed to a positive value
-	 only in case of failure, so in case of premature termination
-	 due a signal args.err will remain zeroed and it will be up to
-	 caller to actually collect it.  */
-      ec = args.err;
-      if (ec > 0)
-	{
-	  /* There still an unlikely case where the child is cancelled after
-	     setting args.err, due to a positive error value.  Also there is
-	     possible pid reuse race (where the kernel allocated the same pid
-	     to an unrelated process).  Unfortunately due synchronization
-	     issues where the kernel might not have the process collected
-	     the waitpid below can not use WNOHANG.  */
-	  __waitid (use_pidfd ? P_PIDFD : P_PID,
-		    use_pidfd ? args.pidfd : new_pid,
-		    NULL,
-		    WEXITED);
-	  /* For pidfd we need to also close the file descriptor for the case
-	     where execve fails.  */
-	  if (use_pidfd)
-	    __close_nocancel_nostatus (args.pidfd);
-	}
+      __spawni_child (&args);
+      ZASSERT (!"Should not be reached");
     }
   else
-    ec = errno;
+    new_pid = fork_result;
+
+  ZASSERT(!!new_pid == !ec);
+
+  __close_nocancel (args.err_pipe[1]);
+
+  if (new_pid) {
+    ZASSERT (!ec);
+    int read_result = __read(args.err_pipe[0], &ec, sizeof(ec));
+    if (read_result == sizeof(ec))
+      __waitid (P_PID, new_pid, NULL, WEXITED);
+  }
 
-  __munmap (stack, stack_size);
+  __close_nocancel (args.err_pipe[0]);
 
   if ((ec == 0) && (pid != NULL))
-    *pid = use_pidfd ? args.pidfd : new_pid;
+    *pid = new_pid;
 
   internal_signal_restore_set (&args.oldmask);
 
diff --git a/sysdeps/unix/sysv/linux/splice.c b/sysdeps/unix/sysv/linux/splice.c
index ab39620a57b8..53c859d02f20 100644
--- a/sysdeps/unix/sysv/linux/splice.c
+++ b/sysdeps/unix/sysv/linux/splice.c
@@ -18,10 +18,11 @@
 
 #include <fcntl.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 ssize_t
 splice (int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len,
 	unsigned int flags)
 {
-  return SYSCALL_CANCEL (splice, fd_in, off_in, fd_out, off_out, len, flags);
+  return zsys_splice (fd_in, off_in, fd_out, off_out, len, flags);
 }
diff --git a/sysdeps/unix/sysv/linux/statfs64.c b/sysdeps/unix/sysv/linux/statfs64.c
index 477dc12523ae..43fa1770a539 100644
--- a/sysdeps/unix/sysv/linux/statfs64.c
+++ b/sysdeps/unix/sysv/linux/statfs64.c
@@ -24,15 +24,13 @@
 #undef __statfs
 #undef statfs
 
+#include <pizlonated_syscalls.h>
+
 /* Return information about the filesystem on which FILE resides.  */
 int
 __statfs64 (const char *file, struct statfs64 *buf)
 {
-#ifdef __NR_statfs64
-  return INLINE_SYSCALL_CALL (statfs64, file, sizeof (*buf), buf);
-#else
-  return INLINE_SYSCALL_CALL (statfs, file, buf);
-#endif
+  return zsys_statfs (file, buf);
 }
 weak_alias (__statfs64, statfs64)
 
diff --git a/sysdeps/unix/sysv/linux/statx.c b/sysdeps/unix/sysv/linux/statx.c
index a6295a155dff..b93721a95094 100644
--- a/sysdeps/unix/sysv/linux/statx.c
+++ b/sysdeps/unix/sysv/linux/statx.c
@@ -20,19 +20,11 @@
 #include <sys/stat.h>
 #include <sysdep.h>
 #include "statx_generic.c"
+#include <pizlonated_syscalls.h>
 
 int
 statx (int fd, const char *path, int flags,
        unsigned int mask, struct statx *buf)
 {
-  int ret = INLINE_SYSCALL_CALL (statx, fd, path, flags, mask, buf);
-#ifdef __ASSUME_STATX
-  return ret;
-#else
-  if (ret == 0 || errno != ENOSYS)
-    /* Preserve non-error/non-ENOSYS return values.  */
-    return ret;
-  else
-    return statx_generic (fd, path, flags, mask, buf);
-#endif
+  return zsys_statx (fd, path, flags, mask, buf);
 }
diff --git a/sysdeps/unix/sysv/linux/symlink.c b/sysdeps/unix/sysv/linux/symlink.c
index 8fe2c88e2bc1..5dd2437d0660 100644
--- a/sysdeps/unix/sysv/linux/symlink.c
+++ b/sysdeps/unix/sysv/linux/symlink.c
@@ -19,15 +19,12 @@
 #include <unistd.h>
 #include <fcntl.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 /* Make a link to FROM called TO.  */
 int
 __symlink (const char *from, const char *to)
 {
-#ifdef __NR_symlink
-  return INLINE_SYSCALL_CALL (symlink, from, to);
-#else
-  return INLINE_SYSCALL_CALL (symlinkat, from, AT_FDCWD, to);
-#endif
+  return zsys_symlink (from, to);
 }
 weak_alias (__symlink, symlink)
diff --git a/sysdeps/unix/sysv/linux/syscall.c b/sysdeps/unix/sysv/linux/syscall.c
index 3cff1d970a39..e49b59f83d2a 100644
--- a/sysdeps/unix/sysv/linux/syscall.c
+++ b/sysdeps/unix/sysv/linux/syscall.c
@@ -18,26 +18,11 @@
 
 #include <stdarg.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
+#include <stdfil.h>
 
 long int
 syscall (long int number, ...)
 {
-  va_list args;
-
-  va_start (args, number);
-  long int a0 = va_arg (args, long int);
-  long int a1 = va_arg (args, long int);
-  long int a2 = va_arg (args, long int);
-  long int a3 = va_arg (args, long int);
-  long int a4 = va_arg (args, long int);
-  long int a5 = va_arg (args, long int);
-  va_end (args);
-
-  long int r = INTERNAL_SYSCALL_NCS_CALL (number, a0, a1, a2, a3, a4, a5);
-  if (__glibc_unlikely (INTERNAL_SYSCALL_ERROR_P (r)))
-    {
-      __set_errno (-r);
-      return -1;
-    }
-  return r;
+  return *(long int *) zcall (zsys_syscall, zargs ());
 }
diff --git a/sysdeps/unix/sysv/linux/syscalls.list b/sysdeps/unix/sysv/linux/syscalls.list
index 9ac42c3436dd..971788d7d85d 100644
--- a/sysdeps/unix/sysv/linux/syscalls.list
+++ b/sysdeps/unix/sysv/linux/syscalls.list
@@ -8,7 +8,7 @@ create_module	EXTRA	create_module	3	__compat_create_module	create_module@GLIBC_2
 delete_module	EXTRA	delete_module	3	delete_module
 epoll_create1	EXTRA	epoll_create1	i:i	epoll_create1
 epoll_ctl	EXTRA	epoll_ctl	i:iiip	epoll_ctl
-eventfd		EXTRA	eventfd2	i:ii	eventfd
+eventfd		EXTRA	eventfd		i:ii	eventfd
 execve		-	execve		i:spp	__execve	execve
 flock		-	flock		i:ii	__flock		flock
 fsconfig	EXTRA	fsconfig	i:iUsNi	fsconfig
diff --git a/sysdeps/unix/sysv/linux/tcdrain.c b/sysdeps/unix/sysv/linux/tcdrain.c
index 34f8c73aca6a..7449840d3f03 100644
--- a/sysdeps/unix/sysv/linux/tcdrain.c
+++ b/sysdeps/unix/sysv/linux/tcdrain.c
@@ -19,12 +19,13 @@
 #include <termios.h>
 #include <sys/ioctl.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 /* Wait for pending output to be written on FD.  */
 int
 __libc_tcdrain (int fd)
 {
   /* With an argument of 1, TCSBRK for output to be drain.  */
-  return SYSCALL_CANCEL (ioctl, fd, TCSBRK, 1);
+  return zsys_ioctl (fd, TCSBRK, 1);
 }
 weak_alias (__libc_tcdrain, tcdrain)
diff --git a/sysdeps/unix/sysv/linux/tcgetattr.c b/sysdeps/unix/sysv/linux/tcgetattr.c
index 68e0637857b6..994bc330d6d3 100644
--- a/sysdeps/unix/sysv/linux/tcgetattr.c
+++ b/sysdeps/unix/sysv/linux/tcgetattr.c
@@ -35,7 +35,7 @@ __tcgetattr (int fd, struct termios *termios_p)
   struct __kernel_termios k_termios;
   int retval;
 
-  retval = INLINE_SYSCALL (ioctl, 3, fd, TCGETS, &k_termios);
+  retval = zsys_ioctl (fd, TCGETS, &k_termios);
 
   if (__glibc_likely (retval == 0))
     {
diff --git a/sysdeps/unix/sysv/linux/tcsetattr.c b/sysdeps/unix/sysv/linux/tcsetattr.c
index aea74d3e0461..fb411a1cddbd 100644
--- a/sysdeps/unix/sysv/linux/tcsetattr.c
+++ b/sysdeps/unix/sysv/linux/tcsetattr.c
@@ -26,6 +26,7 @@
    kernel is not the same as we use in the libc.  Therefore we must
    translate it here.  */
 #include <kernel_termios.h>
+#include <pizlonated_syscalls.h>
 
 
 /* This is a gross hack around a kernel bug.  If the cfsetispeed functions
@@ -75,7 +76,7 @@ __tcsetattr (int fd, int optional_actions, const struct termios *termios_p)
   memcpy (&k_termios.c_cc[0], &termios_p->c_cc[0],
 	  __KERNEL_NCCS * sizeof (cc_t));
 
-  return INLINE_SYSCALL (ioctl, 3, fd, cmd, &k_termios);
+  return zsys_ioctl (fd, cmd, &k_termios);
 }
 weak_alias (__tcsetattr, tcsetattr)
 libc_hidden_def (tcsetattr)
diff --git a/sysdeps/unix/sysv/linux/tee.c b/sysdeps/unix/sysv/linux/tee.c
index 50f6d0550e61..dac7d3f81564 100644
--- a/sysdeps/unix/sysv/linux/tee.c
+++ b/sysdeps/unix/sysv/linux/tee.c
@@ -18,9 +18,10 @@
 
 #include <fcntl.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 ssize_t
 tee (int src, int dest, size_t len, unsigned int flags)
 {
-  return SYSCALL_CANCEL (tee, src, dest, len, flags);
+  return zsys_tee (src, dest, len, flags);
 }
diff --git a/sysdeps/unix/sysv/linux/time.c b/sysdeps/unix/sysv/linux/time.c
index f8b0cee41cb7..f4b251989eee 100644
--- a/sysdeps/unix/sysv/linux/time.c
+++ b/sysdeps/unix/sysv/linux/time.c
@@ -16,42 +16,7 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-/* Optimize the function call by setting the PLT directly to vDSO symbol.  */
-#ifdef USE_IFUNC_TIME
-# include <time.h>
-# include <sysdep.h>
-# include <sysdep-vdso.h>
-
-#ifdef SHARED
-# include <dl-vdso.h>
-# include <libc-vdso.h>
-
-static time_t
-time_syscall (time_t *t)
-{
-  return INLINE_SYSCALL_CALL (time, t);
-}
-
-# undef INIT_ARCH
-# define INIT_ARCH() \
-  void *vdso_time = dl_vdso_vsym (HAVE_TIME_VSYSCALL);
-libc_ifunc (time,
-	    vdso_time ? VDSO_IFUNC_RET (vdso_time)
-		      : (void *) time_syscall);
-
-# else
-time_t
-time (time_t *t)
-{
-  return INLINE_VSYSCALL (time, 1, t);
-}
-# endif /* !SHARED */
-#else /* USE_IFUNC_TIME  */
-# include <time.h>
-# include <time-clockid.h>
-# include <errno.h>
-
-/* Return the time now, and store it in *TIMER if not NULL.  */
+#include <time.h>
 
 __time64_t
 __time64 (__time64_t *timer)
@@ -64,7 +29,7 @@ __time64 (__time64_t *timer)
   return ts.tv_sec;
 }
 
-# if __TIMESIZE != 64
+#if __TIMESIZE != 64
 libc_hidden_def (__time64)
 
 time_t
@@ -82,6 +47,5 @@ __time (time_t *timer)
     *timer = t;
   return t;
 }
-# endif
-weak_alias (__time, time)
 #endif
+weak_alias (__time, time)
diff --git a/sysdeps/unix/sysv/linux/timer_create.c b/sysdeps/unix/sysv/linux/timer_create.c
index 2c505a52bec2..2edcc900aac0 100644
--- a/sysdeps/unix/sysv/linux/timer_create.c
+++ b/sysdeps/unix/sysv/linux/timer_create.c
@@ -27,6 +27,7 @@
 #include "kernel-posix-timers.h"
 #include "kernel-posix-cpu-timers.h"
 #include <shlib-compat.h>
+#include <pizlonated_syscalls.h>
 
 int
 ___timer_create (clockid_t clock_id, struct sigevent *evp, timer_t *timerid)
@@ -58,8 +59,7 @@ ___timer_create (clockid_t clock_id, struct sigevent *evp, timer_t *timerid)
 	  }
 
 	kernel_timer_t ktimerid;
-	if (INLINE_SYSCALL_CALL (timer_create, syscall_clockid, evp,
-				 &ktimerid) == -1)
+	if (zsys_timer_create (syscall_clockid, evp, &ktimerid) == -1)
 	  return -1;
 
 	*timerid = kernel_timer_to_timerid (ktimerid);
@@ -108,19 +108,15 @@ ___timer_create (clockid_t clock_id, struct sigevent *evp, timer_t *timerid)
 
 	/* Create the event structure for the kernel timer.  */
 	struct sigevent sev =
-	  { .sigev_value.sival_ptr = newp,
+	  { .sigev_value.sival_ptr = (void *) zptrtable_encode(__timer_ptrtable, newp),
 	    .sigev_signo = SIGTIMER,
 	    .sigev_notify = SIGEV_SIGNAL | SIGEV_THREAD_ID,
 	    ._sigev_un = { ._pad = { [0] = __timer_helper_tid } } };
 
 	/* Create the timer.  */
-	int res;
-	res = INTERNAL_SYSCALL_CALL (timer_create, syscall_clockid, &sev,
-				     &newp->ktimerid);
-	if (INTERNAL_SYSCALL_ERROR_P (res))
+        if (zsys_timer_create (syscall_clockid, &sev, &newp->ktimerid) < 0)
 	  {
 	    free (newp);
-	    __set_errno (INTERNAL_SYSCALL_ERRNO (res));
 	    return -1;
 	  }
 
diff --git a/sysdeps/unix/sysv/linux/timer_delete.c b/sysdeps/unix/sysv/linux/timer_delete.c
index ad397e5ce693..0cd214e46fe1 100644
--- a/sysdeps/unix/sysv/linux/timer_delete.c
+++ b/sysdeps/unix/sysv/linux/timer_delete.c
@@ -22,12 +22,13 @@
 #include "kernel-posix-timers.h"
 #include <pthreadP.h>
 #include <shlib-compat.h>
+#include <pizlonated_syscalls.h>
 
 int
 ___timer_delete (timer_t timerid)
 {
   kernel_timer_t ktimerid = timerid_to_kernel_timer (timerid);
-  int res = INLINE_SYSCALL_CALL (timer_delete, ktimerid);
+  int res = zsys_timer_delete (ktimerid);
 
   if (res == 0)
     {
diff --git a/sysdeps/unix/sysv/linux/timer_getoverr.c b/sysdeps/unix/sysv/linux/timer_getoverr.c
index dd7ad4c9d251..cc14051fd1e3 100644
--- a/sysdeps/unix/sysv/linux/timer_getoverr.c
+++ b/sysdeps/unix/sysv/linux/timer_getoverr.c
@@ -20,12 +20,13 @@
 #include <sysdep.h>
 #include "kernel-posix-timers.h"
 #include <shlib-compat.h>
+#include <pizlonated_syscalls.h>
 
 int
 ___timer_getoverrun (timer_t timerid)
 {
   kernel_timer_t ktimerid = timerid_to_kernel_timer (timerid);
-  return INLINE_SYSCALL_CALL (timer_getoverrun, ktimerid);
+  return zsys_timer_getoverrun (ktimerid);
 }
 versioned_symbol (libc, ___timer_getoverrun, timer_getoverrun, GLIBC_2_34);
 libc_hidden_ver (___timer_getoverrun, __timer_getoverrun)
diff --git a/sysdeps/unix/sysv/linux/timer_gettime.c b/sysdeps/unix/sysv/linux/timer_gettime.c
index cc7ddd315f40..e260b0338f54 100644
--- a/sysdeps/unix/sysv/linux/timer_gettime.c
+++ b/sysdeps/unix/sysv/linux/timer_gettime.c
@@ -22,30 +22,14 @@
 #include <kernel-features.h>
 #include "kernel-posix-timers.h"
 #include <shlib-compat.h>
+#include <pizlonated_syscalls.h>
 
 #if !TIMER_T_WAS_INT_COMPAT
 int
 ___timer_gettime64 (timer_t timerid, struct __itimerspec64 *value)
 {
   kernel_timer_t ktimerid = timerid_to_kernel_timer (timerid);
-
-# ifndef __NR_timer_gettime64
-#  define __NR_timer_gettime64 __NR_timer_gettime
-# endif
-  int ret = INLINE_SYSCALL_CALL (timer_gettime64, ktimerid, value);
-# ifndef __ASSUME_TIME64_SYSCALLS
-  if (ret == 0 || errno != ENOSYS)
-    return ret;
-
-  struct itimerspec its32;
-  ret = INLINE_SYSCALL_CALL (timer_gettime, ktimerid, &its32);
-  if (ret == 0)
-    {
-      value->it_interval = valid_timespec_to_timespec64 (its32.it_interval);
-      value->it_value = valid_timespec_to_timespec64 (its32.it_value);
-    }
-# endif
-  return ret;
+  return zsys_timer_gettime (ktimerid, value);
 }
 
 # if __TIMESIZE == 64
@@ -88,7 +72,7 @@ ___timer_gettime_new (timer_t timerid, struct itimerspec *value)
 {
   kernel_timer_t ktimerid = timerid_to_kernel_timer (timerid);
 
-  return INLINE_SYSCALL_CALL (timer_gettime, ktimerid, value);
+  return zsys_timer_gettime (ktimerid, value);
 }
 versioned_symbol (libc, ___timer_gettime_new, timer_gettime, GLIBC_2_34);
 libc_hidden_ver (___timer_gettime_new, __timer_gettime_new)
diff --git a/sysdeps/unix/sysv/linux/timer_routines.c b/sysdeps/unix/sysv/linux/timer_routines.c
index 344033d0fd45..60685cf6c5c8 100644
--- a/sysdeps/unix/sysv/linux/timer_routines.c
+++ b/sysdeps/unix/sysv/linux/timer_routines.c
@@ -30,6 +30,8 @@ struct timer *__timer_active_sigev_thread;
 /* Lock for _timer_active_sigev_thread.  */
 pthread_mutex_t __timer_active_sigev_thread_lock = PTHREAD_MUTEX_INITIALIZER;
 
+zptrtable *__timer_ptrtable;
+
 struct thread_start_data
 {
   void (*thrfunc) (sigval_t);
@@ -70,7 +72,8 @@ timer_helper_thread (void *arg)
       while (__sigwaitinfo (&sigtimer_set, &si) < 0);
       if (si.si_code == SI_TIMER)
 	{
-	  struct timer *tk = (struct timer *) si.si_ptr;
+	  struct timer *tk = (struct timer *)
+            zptrtable_decode(__timer_ptrtable, (uintptr_t) si.si_ptr);
 
 	  /* Check the timer is still used and will not go away
 	     while we are reading the values here.  */
@@ -125,6 +128,8 @@ __timer_fork_subprocess (void)
 void
 __timer_start_helper_thread (void)
 {
+  __timer_ptrtable = zptrtable_new();
+  
   /* The helper thread needs only very little resources
      and should go away automatically when canceled.  */
   pthread_attr_t attr;
diff --git a/sysdeps/unix/sysv/linux/timer_settime.c b/sysdeps/unix/sysv/linux/timer_settime.c
index 8986462d8e8e..1403955d0d0f 100644
--- a/sysdeps/unix/sysv/linux/timer_settime.c
+++ b/sysdeps/unix/sysv/linux/timer_settime.c
@@ -22,6 +22,7 @@
 #include <kernel-features.h>
 #include "kernel-posix-timers.h"
 #include <shlib-compat.h>
+#include <pizlonated_syscalls.h>
 
 #if !TIMER_T_WAS_INT_COMPAT
 int
@@ -30,42 +31,7 @@ ___timer_settime64 (timer_t timerid, int flags,
                    struct __itimerspec64 *ovalue)
 {
   kernel_timer_t ktimerid = timerid_to_kernel_timer (timerid);
-
-# ifdef __ASSUME_TIME64_SYSCALLS
-#  ifndef __NR_timer_settime64
-#   define __NR_timer_settime64 __NR_timer_settime
-#  endif
-  return INLINE_SYSCALL_CALL (timer_settime64, ktimerid, flags, value,
-                              ovalue);
-# else
-#  ifdef __NR_timer_settime64
-  int ret = INLINE_SYSCALL_CALL (timer_settime64, ktimerid, flags, value,
-                                 ovalue);
-  if (ret == 0 || errno != ENOSYS)
-    return ret;
-#  endif
-  struct itimerspec its32, oits32;
-
-  if (! in_int32_t_range ((value->it_value).tv_sec)
-      || ! in_int32_t_range ((value->it_interval).tv_sec))
-    {
-      __set_errno (EOVERFLOW);
-      return -1;
-    }
-
-  its32.it_interval = valid_timespec64_to_timespec (value->it_interval);
-  its32.it_value = valid_timespec64_to_timespec (value->it_value);
-
-  int retval = INLINE_SYSCALL_CALL (timer_settime, ktimerid, flags,
-                                    &its32, ovalue ? &oits32 : NULL);
-  if (retval == 0 && ovalue)
-    {
-      ovalue->it_interval = valid_timespec_to_timespec64 (oits32.it_interval);
-      ovalue->it_value = valid_timespec_to_timespec64 (oits32.it_value);
-    }
-
-  return retval;
-# endif
+  return zsys_timer_settime (ktimerid, flags, value, ovalue);
 }
 
 # if __TIMESIZE == 64
@@ -116,7 +82,7 @@ ___timer_settime_new (timer_t timerid, int flags,
 {
   kernel_timer_t ktimerid = timerid_to_kernel_timer (timerid);
 
-  return INLINE_SYSCALL_CALL (timer_settime, ktimerid, flags, value, ovalue);
+  return zsys_timer_settime (ktimerid, flags, value, ovalue);
 }
 versioned_symbol (libc, ___timer_settime_new, timer_settime, GLIBC_2_34);
 libc_hidden_ver (___timer_settime_new, __timer_settime_new)
diff --git a/sysdeps/unix/sysv/linux/timerfd_settime.c b/sysdeps/unix/sysv/linux/timerfd_settime.c
index 86c49d423866..87220a01f27d 100644
--- a/sysdeps/unix/sysv/linux/timerfd_settime.c
+++ b/sysdeps/unix/sysv/linux/timerfd_settime.c
@@ -21,42 +21,13 @@
 #include <time.h>
 #include <sysdep.h>
 #include <kernel-features.h>
+#include <pizlonated_syscalls.h>
 
 int
 __timerfd_settime64 (int fd, int flags, const struct __itimerspec64 *value,
                      struct __itimerspec64 *ovalue)
 {
-#ifndef __NR_timerfd_settime64
-# define __NR_timerfd_settime64 __NR_timerfd_settime
-#endif
-
-#ifdef __ASSUME_TIME64_SYSCALLS
-  return INLINE_SYSCALL_CALL (timerfd_settime64, fd, flags, value, ovalue);
-#else
-  bool need_time64 = !in_int32_t_range (value->it_value.tv_sec)
-		     || !in_int32_t_range (value->it_interval.tv_sec);
-  if (need_time64)
-    {
-      int r = INLINE_SYSCALL_CALL (timerfd_settime64, fd, flags, value,
-				   ovalue);
-      if (r == 0 || errno != ENOSYS)
-	return r;
-      __set_errno (EOVERFLOW);
-      return r;
-    }
-
-  struct itimerspec its32, oits32;
-  its32.it_interval = valid_timespec64_to_timespec (value->it_interval);
-  its32.it_value = valid_timespec64_to_timespec (value->it_value);
-  int ret = INLINE_SYSCALL_CALL (timerfd_settime, fd, flags,
-				 &its32, ovalue != NULL ? &oits32 : NULL);
-  if (ret == 0 && ovalue != NULL)
-    {
-      ovalue->it_interval = valid_timespec_to_timespec64 (oits32.it_interval);
-      ovalue->it_value = valid_timespec_to_timespec64 (oits32.it_value);
-    }
-  return ret;
-#endif
+  return zsys_timerfd_settime (fd, flags, value, ovalue);
 }
 
 #if __TIMESIZE != 64
diff --git a/sysdeps/unix/sysv/linux/times.c b/sysdeps/unix/sysv/linux/times.c
index 96860658a9cb..823dcd364c48 100644
--- a/sysdeps/unix/sysv/linux/times.c
+++ b/sysdeps/unix/sysv/linux/times.c
@@ -18,49 +18,12 @@
 #include <errno.h>
 #include <sys/times.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 
 clock_t
 __times (struct tms *buf)
 {
-  clock_t ret = INTERNAL_SYSCALL_CALL (times, buf);
-  if (INTERNAL_SYSCALL_ERROR_P (ret)
-      && __glibc_unlikely (INTERNAL_SYSCALL_ERRNO (ret) == EFAULT)
-      && buf)
-    {
-      /* This might be an error or not.  For architectures which have no
-	 separate return value and error indicators we cannot
-	 distinguish a return value of e.g. (clock_t) -14 from -EFAULT.
-	 Therefore the only course of action is to dereference the user
-	 -supplied structure on a return of (clock_t) -14.  This will crash
-	 applications which pass in an invalid non-NULL BUF pointer.
-	 Note that Linux allows BUF to be NULL in which case we skip this.  */
-#define touch(v) \
-      do {								      \
-	clock_t temp = v;						      \
-	asm volatile ("" : "+r" (temp));				      \
-	v = temp;							      \
-      } while (0)
-      touch (buf->tms_utime);
-      touch (buf->tms_stime);
-      touch (buf->tms_cutime);
-      touch (buf->tms_cstime);
-
-      /* If we come here the memory is valid and the kernel did not
-	 return an EFAULT error, but rather e.g. (clock_t) -14.
-	 Return the value given by the kernel.  */
-    }
-
-  /* On Linux this function never fails except with EFAULT.
-     POSIX says that returning a value (clock_t) -1 indicates an error,
-     but on Linux this is simply one of the valid clock values after
-     clock_t wraps.  Therefore when we would return (clock_t) -1, we
-     instead return (clock_t) 0, and loose a tick of accuracy (having
-     returned 0 for two consecutive calls even though the clock
-     advanced).  */
-  if (ret == (clock_t) -1)
-    return (clock_t) 0;
-
-  return ret;
+  return zsys_times (buf);
 }
 weak_alias (__times, times)
diff --git a/sysdeps/unix/sysv/linux/umount2.c b/sysdeps/unix/sysv/linux/umount2.c
index 2b37c158d6d1..21cc3b425629 100644
--- a/sysdeps/unix/sysv/linux/umount2.c
+++ b/sysdeps/unix/sysv/linux/umount2.c
@@ -18,11 +18,12 @@
 
 #include <sys/mount.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 int
 __umount2 (const char *special_file, int flags)
 {
-  return INLINE_SYSCALL_CALL (umount2, special_file, flags);
+  return zsys_umount2 (special_file, flags);
 }
 libc_hidden_def (__umount2)
 
diff --git a/sysdeps/unix/sysv/linux/unlink.c b/sysdeps/unix/sysv/linux/unlink.c
index 932cfcfbd6dd..41678e3fce12 100644
--- a/sysdeps/unix/sysv/linux/unlink.c
+++ b/sysdeps/unix/sysv/linux/unlink.c
@@ -19,15 +19,12 @@
 #include <unistd.h>
 #include <fcntl.h>
 #include <sysdep.h>
+#include <pizlonated_syscalls.h>
 
 /* Remove the link named NAME.  */
 int
 __unlink (const char *name)
 {
-#ifdef __NR_unlink
-  return INLINE_SYSCALL_CALL (unlink, name);
-#else
-  return INLINE_SYSCALL_CALL (unlinkat, AT_FDCWD, name, 0);
-#endif
+  return zsys_unlink (name);
 }
 weak_alias (__unlink, unlink)
diff --git a/sysdeps/unix/sysv/linux/utimensat.c b/sysdeps/unix/sysv/linux/utimensat.c
index 991897f50d14..d882bf9f91d3 100644
--- a/sysdeps/unix/sysv/linux/utimensat.c
+++ b/sysdeps/unix/sysv/linux/utimensat.c
@@ -21,6 +21,7 @@
 #include <sysdep.h>
 #include <time.h>
 #include <kernel-features.h>
+#include <pizlonated_syscalls.h>
 
 /* Helper function defined for easy reusage of the code which calls utimensat
    and utimensat_time64 syscall.  */
@@ -28,42 +29,7 @@ int
 __utimensat64_helper (int fd, const char *file,
                       const struct __timespec64 tsp64[2], int flags)
 {
-#ifndef __NR_utimensat_time64
-# define __NR_utimensat_time64 __NR_utimensat
-#endif
-
-#ifdef __ASSUME_TIME64_SYSCALLS
-  return INLINE_SYSCALL_CALL (utimensat_time64, fd, file, &tsp64[0], flags);
-#else
-  /* For UTIME_NOW and UTIME_OMIT the value of tv_sec field is ignored.  */
-# define TS_SPECIAL(ts) \
-  ((ts).tv_nsec == UTIME_NOW || (ts).tv_nsec == UTIME_OMIT)
-
-  bool need_time64 = tsp64 != NULL
-		     && ((!TS_SPECIAL (tsp64[0])
-			  && !in_int32_t_range (tsp64[0].tv_sec))
-			 || (!TS_SPECIAL (tsp64[1])
-			     && !in_int32_t_range (tsp64[1].tv_sec)));
-  if (need_time64)
-    {
-      int r = INLINE_SYSCALL_CALL (utimensat_time64, fd, file, &tsp64[0],
-				   flags);
-      if (r == 0 || errno != ENOSYS)
-	return r;
-      __set_errno (EOVERFLOW);
-      return -1;
-    }
-
-  struct timespec tsp32[2], *ptsp32 = NULL;
-  if (tsp64)
-    {
-      tsp32[0] = valid_timespec64_to_timespec (tsp64[0]);
-      tsp32[1] = valid_timespec64_to_timespec (tsp64[1]);
-      ptsp32 = tsp32;
-    }
-
-  return INLINE_SYSCALL_CALL (utimensat, fd, file, ptsp32, flags);
-#endif
+  return zsys_utimensat (fd, file, tsp64, flags);
 }
 libc_hidden_def (__utimensat64_helper)
 
diff --git a/sysdeps/unix/sysv/linux/wait4.c b/sysdeps/unix/sysv/linux/wait4.c
index 5dd0d3e2b9d0..6361958ccce9 100644
--- a/sysdeps/unix/sysv/linux/wait4.c
+++ b/sysdeps/unix/sysv/linux/wait4.c
@@ -21,91 +21,12 @@
 #include <sys/types.h>
 #include <sysdep-cancel.h>
 #include <tv32-compat.h>
+#include <pizlonated_syscalls.h>
 
 pid_t
 __wait4_time64 (pid_t pid, int *stat_loc, int options, struct __rusage64 *usage)
 {
-#ifdef __NR_wait4
-# if __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64
-  return SYSCALL_CANCEL (wait4, pid, stat_loc, options, usage);
-# else
-  pid_t ret;
-  struct __rusage32 usage32;
-
-  ret = SYSCALL_CANCEL (wait4, pid, stat_loc, options,
-                        usage != NULL ? &usage32 : NULL);
-
-  if (ret > 0 && usage != NULL)
-    rusage32_to_rusage64 (&usage32, usage);
-
-  return ret;
-# endif
-#elif defined (__ASSUME_WAITID_PID0_P_PGID)
-  idtype_t idtype = P_PID;
-
-  if (pid < -1)
-    {
-      idtype = P_PGID;
-      pid *= -1;
-    }
-  else if (pid == -1)
-    idtype = P_ALL;
-  else if (pid == 0)
-    idtype = P_PGID;
-
-  options |= WEXITED;
-
-  siginfo_t infop;
-
-# if __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64
-  if (SYSCALL_CANCEL (waitid, idtype, pid, &infop, options, usage) < 0)
-    return -1;
-# else
-  {
-    struct __rusage32 usage32;
-    if (SYSCALL_CANCEL (waitid, idtype, pid, &infop, options, &usage32) < 0)
-      return -1;
-    if (usage != NULL)
-      rusage32_to_rusage64 (&usage32, usage);
-  }
-# endif
-
-  if (stat_loc)
-    {
-      switch (infop.si_code)
-        {
-        case CLD_EXITED:
-          *stat_loc = W_EXITCODE (infop.si_status, 0);
-          break;
-        case CLD_DUMPED:
-          *stat_loc = WCOREFLAG | infop.si_status;
-	  break;
-        case CLD_KILLED:
-          *stat_loc = infop.si_status;
-          break;
-        case CLD_TRAPPED:
-        case CLD_STOPPED:
-          *stat_loc = W_STOPCODE (infop.si_status);
-          break;
-        case CLD_CONTINUED:
-          *stat_loc = __W_CONTINUED;
-          break;
-	default:
-	  *stat_loc = 0;
-	  break;
-        }
-    }
-
-  return infop.si_pid;
-#else
-/* Linux waitid prior kernel 5.4 does not support waiting for the current
-   process.  It is possible to emulate wait4 it by calling getpgid for
-   PID 0, however, it would require an additional syscall and it is inherent
-   racy: after the current process group is received and before it is passed
-   to waitid a signal could arrive causing the current process group to
-   change.  */
-# error "The kernel ABI does not provide a way to implement wait4"
-#endif
+  return zsys_wait4 (pid, stat_loc, options, usage);
 }
 
 #if __TIMESIZE != 64
diff --git a/sysdeps/unix/sysv/linux/waitid.c b/sysdeps/unix/sysv/linux/waitid.c
index 13fed92fdadd..27c29f85f0b5 100644
--- a/sysdeps/unix/sysv/linux/waitid.c
+++ b/sysdeps/unix/sysv/linux/waitid.c
@@ -20,13 +20,14 @@
 #include <errno.h>
 #include <sys/wait.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 int
 __waitid (idtype_t idtype, id_t id, siginfo_t *infop, int options)
 {
   /* The unused fifth argument is a `struct rusage *' that we could
      pass if we were using waitid to simulate wait3/wait4.  */
-  return SYSCALL_CANCEL (waitid, idtype, id, infop, options, NULL);
+  return zsys_waitid (idtype, id, infop, options);
 }
 weak_alias (__waitid, waitid)
 strong_alias (__waitid, __libc_waitid)
diff --git a/sysdeps/unix/sysv/linux/write.c b/sysdeps/unix/sysv/linux/write.c
index b689a9f48c94..3e76cc795425 100644
--- a/sysdeps/unix/sysv/linux/write.c
+++ b/sysdeps/unix/sysv/linux/write.c
@@ -18,12 +18,13 @@
 
 #include <unistd.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 /* Write NBYTES of BUF to FD.  Return the number written, or -1.  */
 ssize_t
 __libc_write (int fd, const void *buf, size_t nbytes)
 {
-  return SYSCALL_CANCEL (write, fd, buf, nbytes);
+  return zsys_write (fd, buf, nbytes);
 }
 libc_hidden_def (__libc_write)
 
diff --git a/sysdeps/unix/sysv/linux/write_nocancel.c b/sysdeps/unix/sysv/linux/write_nocancel.c
index d16fda94710f..a17fa788c8ea 100644
--- a/sysdeps/unix/sysv/linux/write_nocancel.c
+++ b/sysdeps/unix/sysv/linux/write_nocancel.c
@@ -19,10 +19,11 @@
 #include <unistd.h>
 #include <sysdep-cancel.h>
 #include <not-cancel.h>
+#include <pizlonated_syscalls.h>
 
 ssize_t
 __write_nocancel (int fd, const void *buf, size_t nbytes)
 {
-  return INLINE_SYSCALL_CALL (write, fd, buf, nbytes);
+  return zsys_write (fd, buf, nbytes);
 }
 hidden_def (__write_nocancel)
diff --git a/sysdeps/unix/sysv/linux/writev.c b/sysdeps/unix/sysv/linux/writev.c
index f06bcd54945a..9095fc15a812 100644
--- a/sysdeps/unix/sysv/linux/writev.c
+++ b/sysdeps/unix/sysv/linux/writev.c
@@ -19,11 +19,12 @@
 #include <unistd.h>
 #include <sys/uio.h>
 #include <sysdep-cancel.h>
+#include <pizlonated_syscalls.h>
 
 ssize_t
 __writev (int fd, const struct iovec *iov, int iovcnt)
 {
-  return SYSCALL_CANCEL (writev, fd, iov, iovcnt);
+  return zsys_writev (fd, iov, iovcnt);
 }
 libc_hidden_def (__writev)
 weak_alias (__writev, writev)
diff --git a/sysdeps/unix/sysv/linux/x86/bits/epoll.h b/sysdeps/unix/sysv/linux/x86/bits/epoll.h
index a0279fc8cc06..15f42c0c9fe5 100644
--- a/sysdeps/unix/sysv/linux/x86/bits/epoll.h
+++ b/sysdeps/unix/sysv/linux/x86/bits/epoll.h
@@ -26,4 +26,4 @@ enum
 #define EPOLL_CLOEXEC EPOLL_CLOEXEC
   };
 
-#define __EPOLL_PACKED __attribute__ ((__packed__))
+
diff --git a/sysdeps/unix/sysv/linux/x86/jmp_buf-ssp.sym b/sysdeps/unix/sysv/linux/x86/jmp_buf-ssp.sym
index 9416ca23dfe6..edb5180b667b 100644
--- a/sysdeps/unix/sysv/linux/x86/jmp_buf-ssp.sym
+++ b/sysdeps/unix/sysv/linux/x86/jmp_buf-ssp.sym
@@ -1,6 +1,3 @@
-#include <setjmpP.h>
 #include <stddef.h>
-#undef __saved_mask
 
 --
-SHADOW_STACK_POINTER_OFFSET offsetof(struct __jmp_buf_tag, __saved_mask.__saved.__shadow_stack_pointer)
diff --git a/sysdeps/unix/sysv/linux/x86/longjmp.c b/sysdeps/unix/sysv/linux/x86/longjmp.c
index 0f045e3ffc18..7d56bfcd9e53 100644
--- a/sysdeps/unix/sysv/linux/x86/longjmp.c
+++ b/sysdeps/unix/sysv/linux/x86/longjmp.c
@@ -18,22 +18,3 @@
 
 #include <sysdeps/x86/longjmp.c>
 
-#include <pthreadP.h>
-#include <jmp_buf-ssp.h>
-
-#ifdef __x86_64__
-# define SHADOW_STACK_POINTER_SIZE 8
-#else
-# define SHADOW_STACK_POINTER_SIZE 4
-#endif
-
-/* Assert that the priv field in struct pthread_unwind_buf has space
-   to store shadow stack pointer.  */
-_Static_assert ((offsetof (struct pthread_unwind_buf, priv)
-                <= SHADOW_STACK_POINTER_OFFSET)
-               && ((offsetof (struct pthread_unwind_buf, priv)
-                    + sizeof (((struct pthread_unwind_buf *) 0)->priv))
-                   >= (SHADOW_STACK_POINTER_OFFSET
-                       + SHADOW_STACK_POINTER_SIZE)),
-               "Shadow stack pointer is not within private storage "
-               "of pthread_unwind_buf.");
diff --git a/sysdeps/unix/sysv/linux/x86_64/Makefile b/sysdeps/unix/sysv/linux/x86_64/Makefile
index fcbffd81cbaa..2e4fc2d9d98c 100644
--- a/sysdeps/unix/sysv/linux/x86_64/Makefile
+++ b/sysdeps/unix/sysv/linux/x86_64/Makefile
@@ -3,7 +3,7 @@ sysdep_routines += ioperm iopl
 endif
 
 ifeq ($(subdir),stdlib)
-sysdep_routines += __start_context allocate-shadow-stack
+sysdep_routines += allocate-shadow-stack
 endif
 
 ifeq ($(subdir),csu)
diff --git a/sysdeps/unix/sysv/linux/x86_64/clone.S b/sysdeps/unix/sysv/linux/x86_64/clone.S
deleted file mode 100644
index d0adc21c8506..000000000000
--- a/sysdeps/unix/sysv/linux/x86_64/clone.S
+++ /dev/null
@@ -1,111 +0,0 @@
-/* Copyright (C) 2001-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-/* clone() is even more special than fork() as it mucks with stacks
-   and invokes a function in the right context after its all over.  */
-
-#include <sysdep.h>
-#define _ERRNO_H	1
-#include <bits/errno.h>
-#include <asm-syntax.h>
-
-/* The userland implementation is:
-   int clone (int (*fn)(void *arg), void *child_stack, int flags,
-	      void *arg, pid_t *parent_tid, void *tls, pid_t *child_tid);
-   the kernel entry is:
-   int clone (long flags, void *child_stack, pid_t *parent_tid,
-	      pid_t *child_tid, void *tls);
-
-   The parameters are passed in register and on the stack from userland:
-   rdi: fn
-   rsi: child_stack
-   rdx:	flags
-   rcx: arg
-    r8:	TID field in parent
-    r9: thread pointer
-%rsp+8:	TID field in child
-
-   The kernel expects:
-   rax: system call number
-   rdi: flags
-   rsi: child_stack
-   rdx: TID field in parent
-   r10: TID field in child
-   r8:	thread pointer  */
-
-
-        .text
-ENTRY (__clone)
-	/* Sanity check arguments.  */
-	movq	$-EINVAL,%rax
-	testq	%rdi,%rdi		/* no NULL function pointers */
-	jz	SYSCALL_ERROR_LABEL
-
-	/* Align stack to 16 bytes per the x86-64 psABI.  */
-	andq	$-16, %rsi
-	jz	SYSCALL_ERROR_LABEL	/* no NULL stack pointers */
-
-	/* Insert the argument onto the new stack.  */
-	movq	%rcx,-8(%rsi)
-
-	subq	$16,%rsi
-
-	/* Save the function pointer.  It will be popped off in the
-	   child.  */
-	movq	%rdi,0(%rsi)
-
-	/* Do the system call.  */
-	movq	%rdx, %rdi
-	movq	%r8, %rdx
-	movq	%r9, %r8
-	mov	8(%rsp), %R10_LP
-	movl	$SYS_ify(clone),%eax
-
-	/* End FDE now, because in the child the unwind info will be
-	   wrong.  */
-	cfi_endproc;
-	syscall
-
-	testq	%rax,%rax
-	jl	SYSCALL_ERROR_LABEL
-	jz	L(thread_start)
-
-	ret
-
-L(thread_start):
-	cfi_startproc;
-	/* Clearing frame pointer is insufficient, use CFI.  */
-	cfi_undefined (rip);
-	/* Clear the frame pointer.  The ABI suggests this be done, to mark
-	   the outermost frame obviously.  */
-	xorl	%ebp, %ebp
-
-	/* Set up arguments for the function call.  */
-	popq	%rax		/* Function to call.  */
-	popq	%rdi		/* Argument.  */
-	call	*%rax
-	/* Call exit with return value from function call. */
-	movq	%rax, %rdi
-	movl	$SYS_ify(exit), %eax
-	syscall
-	cfi_endproc;
-
-	cfi_startproc;
-PSEUDO_END (__clone)
-
-libc_hidden_def (__clone)
-weak_alias (__clone, clone)
diff --git a/sysdeps/unix/sysv/linux/x86_64/clone3.S b/sysdeps/unix/sysv/linux/x86_64/clone3.S
deleted file mode 100644
index 4cc19e066ccc..000000000000
--- a/sysdeps/unix/sysv/linux/x86_64/clone3.S
+++ /dev/null
@@ -1,88 +0,0 @@
-/* The clone3 syscall wrapper.  Linux/x86-64 version.
-   Copyright (C) 2021-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-/* clone3() is even more special than fork() as it mucks with stacks
-   and invokes a function in the right context after its all over.  */
-
-#include <sysdep.h>
-
-/* The userland implementation is:
-   int clone3 (struct clone_args *cl_args, size_t size,
-	       int (*func)(void *arg), void *arg);
-   the kernel entry is:
-   int clone3 (struct clone_args *cl_args, size_t size);
-
-   The parameters are passed in registers from userland:
-   rdi: cl_args
-   rsi: size
-   rdx: func
-   rcx: arg
-
-   The kernel expects:
-   rax: system call number
-   rdi: cl_args
-   rsi: size  */
-
-        .text
-ENTRY (__clone3)
-	/* Sanity check arguments.  */
-	movl	$-EINVAL, %eax
-	test	%RDI_LP, %RDI_LP	/* No NULL cl_args pointer.  */
-	jz	SYSCALL_ERROR_LABEL
-	test	%RDX_LP, %RDX_LP	/* No NULL function pointer.  */
-	jz	SYSCALL_ERROR_LABEL
-
-	/* Save the cl_args pointer in R8 which is preserved by the
-	   syscall.  */
-	mov	%RCX_LP, %R8_LP
-
-	/* Do the system call.  */
-	movl	$SYS_ify(clone3), %eax
-
-	/* End FDE now, because in the child the unwind info will be
-	   wrong.  */
-	cfi_endproc
-	syscall
-
-	test	%RAX_LP, %RAX_LP
-	jl	SYSCALL_ERROR_LABEL
-	jz	L(thread_start)
-
-	ret
-
-L(thread_start):
-	cfi_startproc
-	/* Clearing frame pointer is insufficient, use CFI.  */
-	cfi_undefined (rip)
-	/* Clear the frame pointer.  The ABI suggests this be done, to mark
-	   the outermost frame obviously.  */
-	xorl	%ebp, %ebp
-
-	/* Set up arguments for the function call.  */
-	mov	%R8_LP, %RDI_LP	/* Argument.  */
-	call	*%rdx		/* Call function.  */
-	/* Call exit with return value from function call. */
-	movq	%rax, %rdi
-	movl	$SYS_ify(exit), %eax
-	syscall
-	cfi_endproc
-
-	cfi_startproc
-PSEUDO_END (__clone3)
-
-libc_hidden_def (__clone3)
diff --git a/sysdeps/unix/sysv/linux/x86_64/get-cpuid-feature-leaf.c b/sysdeps/unix/sysv/linux/x86_64/get-cpuid-feature-leaf.c
index 39b342463cf9..fb61c0ad8fda 100644
--- a/sysdeps/unix/sysv/linux/x86_64/get-cpuid-feature-leaf.c
+++ b/sysdeps/unix/sysv/linux/x86_64/get-cpuid-feature-leaf.c
@@ -17,8 +17,3 @@
 
 #include <sysdeps/x86/get-cpuid-feature-leaf.c>
 
-#ifdef __LP64__
-_Static_assert (FEATURE_1_OFFSET == 72, "FEATURE_1_OFFSET != 72");
-#else
-_Static_assert (FEATURE_1_OFFSET == 40, "FEATURE_1_OFFSET != 40");
-#endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/getcontext.S b/sysdeps/unix/sysv/linux/x86_64/getcontext.S
deleted file mode 100644
index e588a8cc0764..000000000000
--- a/sysdeps/unix/sysv/linux/x86_64/getcontext.S
+++ /dev/null
@@ -1,116 +0,0 @@
-/* Save current context.
-   Copyright (C) 2002-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <asm/prctl.h>
-
-#include "ucontext_i.h"
-
-/*  int __getcontext (ucontext_t *ucp)
-
-  Saves the machine context in UCP such that when it is activated,
-  it appears as if __getcontext() returned again.
-
-  This implementation is intended to be used for *synchronous* context
-  switches only.  Therefore, it does not have to save anything
-  other than the PRESERVED state.  */
-
-
-ENTRY(__getcontext)
-	/* Save the preserved registers, the registers used for passing
-	   args, and the return address.  */
-	movq	%rbx, oRBX(%rdi)
-	movq	%rbp, oRBP(%rdi)
-	movq	%r12, oR12(%rdi)
-	movq	%r13, oR13(%rdi)
-	movq	%r14, oR14(%rdi)
-	movq	%r15, oR15(%rdi)
-
-	movq	%rdi, oRDI(%rdi)
-	movq	%rsi, oRSI(%rdi)
-	movq	%rdx, oRDX(%rdi)
-	movq	%rcx, oRCX(%rdi)
-	movq	%r8, oR8(%rdi)
-	movq	%r9, oR9(%rdi)
-
-	movq	(%rsp), %rcx
-	movq	%rcx, oRIP(%rdi)
-	leaq	8(%rsp), %rcx		/* Exclude the return address.  */
-	movq	%rcx, oRSP(%rdi)
-
-#if SHSTK_ENABLED
-	/* Check if shadow stack is enabled.  */
-	testl	$X86_FEATURE_1_SHSTK, %fs:FEATURE_1_OFFSET
-	jz	L(no_shstk)
-
-	xorl	%eax, %eax
-	cmpq	%fs:SSP_BASE_OFFSET, %rax
-	jnz	L(shadow_stack_bound_recorded)
-
-	/* When the shadow stack base is unset, the default shadow
-	   stack is in use.  Use the current shadow stack pointer
-	   as the marker for the default shadow stack.  */
-	rdsspq	%rax
-	movq	%rax, %fs:SSP_BASE_OFFSET
-
-L(shadow_stack_bound_recorded):
-	/* Get the current shadow stack pointer.  */
-	rdsspq	%rax
-	/* NB: Save the caller's shadow stack so that we can jump back
-	   to the caller directly.  */
-	addq	$8, %rax
-	movq	%rax, oSSP(%rdi)
-
-	/* Save the current shadow stack base in ucontext.  */
-	movq	%fs:SSP_BASE_OFFSET, %rax
-	movq	%rax, (oSSP + 8)(%rdi)
-
-L(no_shstk):
-#endif
-	/* We have separate floating-point register content memory on the
-	   stack.  We use the __fpregs_mem block in the context.  Set the
-	   links up correctly.  */
-
-	leaq	oFPREGSMEM(%rdi), %rcx
-	movq	%rcx, oFPREGS(%rdi)
-	/* Save the floating-point environment.  */
-	fnstenv	(%rcx)
-	fldenv	(%rcx)
-	stmxcsr oMXCSR(%rdi)
-
-	/* Save the current signal mask with
-	   rt_sigprocmask (SIG_BLOCK, NULL, set,_NSIG/8).  */
-	leaq	oSIGMASK(%rdi), %rdx
-	xorl	%esi,%esi
-#if SIG_BLOCK == 0
-	xorl	%edi, %edi
-#else
-	movl	$SIG_BLOCK, %edi
-#endif
-	movl	$_NSIG8,%r10d
-	movl	$__NR_rt_sigprocmask, %eax
-	syscall
-	cmpq	$-4095, %rax		/* Check %rax for error.  */
-	jae	SYSCALL_ERROR_LABEL	/* Jump to error handler if error.  */
-
-	/* All done, return 0 for success.  */
-	xorl	%eax, %eax
-	ret
-PSEUDO_END(__getcontext)
-
-weak_alias (__getcontext, getcontext)
diff --git a/sysdeps/unix/sysv/linux/x86_64/libc_sigaction.c b/sysdeps/unix/sysv/linux/x86_64/libc_sigaction.c
index b39812f81d17..fa40d1d87bde 100644
--- a/sysdeps/unix/sysv/linux/x86_64/libc_sigaction.c
+++ b/sysdeps/unix/sysv/linux/x86_64/libc_sigaction.c
@@ -17,118 +17,6 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include <signal.h>
-#define SA_RESTORER 0x04000000
-
-extern void restore_rt (void) asm ("__restore_rt") attribute_hidden;
-
-#define SET_SA_RESTORER(kact, act)			\
-  (kact)->sa_flags = (act)->sa_flags | SA_RESTORER;	\
-  (kact)->sa_restorer = &restore_rt
-
-#define RESET_SA_RESTORER(act, kact) 			\
-  (act)->sa_restorer = (kact)->sa_restorer
-
 #include <kernel_sigaction.h>
 
 #include <sysdeps/unix/sysv/linux/libc_sigaction.c>
-
-/* NOTE: Please think twice before making any changes to the bits of
-   code below.  GDB needs some intimate knowledge about it to
-   recognize them as signal trampolines, and make backtraces through
-   signal handlers work right.  Important are both the names
-   (__restore_rt) and the exact instruction sequence.
-   If you ever feel the need to make any changes, please notify the
-   appropriate GDB maintainer.
-
-   The unwind information starts a byte before __restore_rt, so that
-   it is found when unwinding, to get an address the unwinder assumes
-   will be in the middle of a call instruction.  See the Linux kernel
-   (the i386 vsyscall, in particular) for an explanation of the complex
-   unwind information used here in order to get the traditional CFA.
-   We do not restore cs - it's only stored as two bytes here so that's
-   a bit tricky.  We don't use the gas cfi directives, so that we can
-   reliably add .cfi_signal_frame.  */
-
-#include "ucontext_i.h"
-
-#define do_cfa_expr						\
-  "	.byte 0x0f\n"		/* DW_CFA_def_cfa_expression */	\
-  "	.uleb128 2f-1f\n"	/* length */			\
-  "1:	.byte 0x77\n"		/* DW_OP_breg7 */		\
-  "	.sleb128 " CFI_STRINGIFY (oRSP) "\n"			\
-  "	.byte 0x06\n"		/* DW_OP_deref */		\
-  "2:"
-
-#define do_expr(regno, offset)					\
-  "	.byte 0x10\n"		/* DW_CFA_expression */		\
-  "	.uleb128 " CFI_STRINGIFY (regno) "\n"			\
-  "	.uleb128 2f-1f\n"	/* length */			\
-  "1:	.byte 0x77\n"		/* DW_OP_breg7 */		\
-  "	.sleb128 " CFI_STRINGIFY (offset) "\n"			\
-  "2:"
-
-#define RESTORE(name, syscall) RESTORE2 (name, syscall)
-# define RESTORE2(name, syscall) \
-asm									\
-  (									\
-   /* `nop' for debuggers assuming `call' should not disalign the code.  */ \
-   "	nop\n"								\
-   ".align 16\n"							\
-   ".LSTART_" #name ":\n"						\
-   "	.type __" #name ",@function\n"					\
-   "__" #name ":\n"							\
-   "	movq $" #syscall ", %rax\n"					\
-   "	syscall\n"							\
-   ".LEND_" #name ":\n"							\
-   ".section .eh_frame,\"a\",@progbits\n"				\
-   ".LSTARTFRAME_" #name ":\n"						\
-   "	.long .LENDCIE_" #name "-.LSTARTCIE_" #name "\n"		\
-   ".LSTARTCIE_" #name ":\n"						\
-   "	.long 0\n"	/* CIE ID */					\
-   "	.byte 1\n"	/* Version number */				\
-   "	.string \"zRS\"\n" /* NUL-terminated augmentation string */	\
-   "	.uleb128 1\n"	/* Code alignment factor */			\
-   "	.sleb128 -8\n"	/* Data alignment factor */			\
-   "	.uleb128 16\n"	/* Return address register column (rip) */	\
-   /* Augmentation value length */					\
-   "	.uleb128 .LENDAUGMNT_" #name "-.LSTARTAUGMNT_" #name "\n"	\
-   ".LSTARTAUGMNT_" #name ":\n"						\
-   "	.byte 0x1b\n"	/* DW_EH_PE_pcrel|DW_EH_PE_sdata4. */		\
-   ".LENDAUGMNT_" #name ":\n"						\
-   "	.align " LP_SIZE "\n"						\
-   ".LENDCIE_" #name ":\n"						\
-   "	.long .LENDFDE_" #name "-.LSTARTFDE_" #name "\n" /* FDE len */	\
-   ".LSTARTFDE_" #name ":\n"						\
-   "	.long .LSTARTFDE_" #name "-.LSTARTFRAME_" #name "\n" /* CIE */	\
-   /* `LSTART_' is subtracted 1 as debuggers assume a `call' here.  */	\
-   "	.long (.LSTART_" #name "-1)-.\n" /* PC-relative start addr.  */	\
-   "	.long .LEND_" #name "-(.LSTART_" #name "-1)\n"			\
-   "	.uleb128 0\n"			/* FDE augmentation length */	\
-   do_cfa_expr								\
-   do_expr (8 /* r8 */, oR8)						\
-   do_expr (9 /* r9 */, oR9)						\
-   do_expr (10 /* r10 */, oR10)						\
-   do_expr (11 /* r11 */, oR11)						\
-   do_expr (12 /* r12 */, oR12)						\
-   do_expr (13 /* r13 */, oR13)						\
-   do_expr (14 /* r14 */, oR14)						\
-   do_expr (15 /* r15 */, oR15)						\
-   do_expr (5 /* rdi */, oRDI)						\
-   do_expr (4 /* rsi */, oRSI)						\
-   do_expr (6 /* rbp */, oRBP)						\
-   do_expr (3 /* rbx */, oRBX)						\
-   do_expr (1 /* rdx */, oRDX)						\
-   do_expr (0 /* rax */, oRAX)						\
-   do_expr (2 /* rcx */, oRCX)						\
-   do_expr (7 /* rsp */, oRSP)						\
-   do_expr (16 /* rip */, oRIP)						\
-   /* libgcc-4.1.1 has only `DWARF_FRAME_REGISTERS == 17'.  */		\
-   /* do_expr (49 |* rflags *|, oEFL) */				\
-   /* `cs'/`ds'/`fs' are unaligned and a different size.  */		\
-   /* gas: Error: register save offset not a multiple of 8  */		\
-   "	.align " LP_SIZE "\n"						\
-   ".LENDFDE_" #name ":\n"						\
-   "	.previous\n"							\
-   );
-/* The return code for realtime-signals.  */
-RESTORE (restore_rt, __NR_rt_sigreturn)
diff --git a/sysdeps/unix/sysv/linux/x86_64/makecontext.c b/sysdeps/unix/sysv/linux/x86_64/makecontext.c
deleted file mode 100644
index 8602a51ff225..000000000000
--- a/sysdeps/unix/sysv/linux/x86_64/makecontext.c
+++ /dev/null
@@ -1,158 +0,0 @@
-/* Create new context.
-   Copyright (C) 2002-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <stdarg.h>
-#include <stdint.h>
-#include <ucontext.h>
-#if SHSTK_ENABLED
-# include <pthread.h>
-# include <libc-pointer-arith.h>
-# include <sys/prctl.h>
-# include <allocate-shadow-stack.h>
-#endif
-
-#include "ucontext_i.h"
-
-/* This implementation can handle any ARGC value but only
-   normal integer parameters.
-   makecontext sets up a stack and the registers for the
-   user context. The stack looks like this:
-               +-----------------------+
-               | next context          |
-               +-----------------------+
-               | parameter 7-n         |
-	       +-----------------------+
-	       | trampoline address    |
-    %rsp ->    +-----------------------+
-
-   The registers are set up like this:
-     %rdi,%rsi,%rdx,%rcx,%r8,%r9: parameter 1 to 6
-     %rbx   : address of next context
-     %rsp   : stack pointer.
-*/
-
-/* XXX: This implementation currently only handles integer arguments.
-   To handle long int and pointer arguments the va_arg arguments needs
-   to be changed to long and also the stdlib/tst-setcontext.c file needs
-   to be changed to pass long arguments to makecontext.  */
-
-
-void
-__makecontext (ucontext_t *ucp, void (*func) (void), int argc, ...)
-{
-  extern void __start_context (void) attribute_hidden;
-  extern void __push___start_context (ucontext_t *)
-    attribute_hidden;
-  greg_t *sp;
-  unsigned int idx_uc_link;
-  va_list ap;
-  int i;
-
-  /* Generate room on stack for parameter if needed and uc_link.  */
-  sp = (greg_t *) ((uintptr_t) ucp->uc_stack.ss_sp
-		   + ucp->uc_stack.ss_size);
-  sp -= (argc > 6 ? argc - 6 : 0) + 1;
-  /* Align stack and make space for trampoline address.  */
-  sp = (greg_t *) ((((uintptr_t) sp) & -16L) - 8);
-
-  idx_uc_link = (argc > 6 ? argc - 6 : 0) + 1;
-
-  /* Setup context ucp.  */
-  /* Address to jump to.  */
-  ucp->uc_mcontext.gregs[REG_RIP] = (uintptr_t) func;
-  /* Setup rbx.*/
-  ucp->uc_mcontext.gregs[REG_RBX] = (uintptr_t) &sp[idx_uc_link];
-  ucp->uc_mcontext.gregs[REG_RSP] = (uintptr_t) sp;
-
-  /* Setup stack.  */
-#if SHSTK_ENABLED
-  struct pthread *self = THREAD_SELF;
-  unsigned int feature_1 = THREAD_GETMEM (self, header.feature_1);
-  /* NB: We must check feature_1 before accessing __ssp since caller
-	 may be compiled against ucontext_t without __ssp.  */
-  if ((feature_1 & X86_FEATURE_1_SHSTK) != 0)
-    {
-      /* Shadow stack is enabled.  We need to allocate a new shadow
-         stack.  NB:
-	   ucp->__ssp[0]: The new shadow stack pointer.
-	   ucp->__ssp[1]: The base address of the new shadow stack.
-	   ucp->__ssp[2]: The size of the new shadow stack.
-       */
-      long int ret
-	= __allocate_shadow_stack (((uintptr_t) sp
-				    - (uintptr_t) ucp->uc_stack.ss_sp),
-				   &ucp->__ssp[1]);
-      if (ret != 0)
-	{
-	  /* FIXME: What should we do?  */
-	  abort ();
-	}
-
-      ucp->__ssp[0] = ucp->__ssp[1] + ucp->__ssp[2] - 8;
-      /* Call __push___start_context to push __start_context onto the new
-	 stack as well as the new shadow stack.  */
-      __push___start_context (ucp);
-    }
-  else
-#endif
-    sp[0] = (uintptr_t) &__start_context;
-  sp[idx_uc_link] = (uintptr_t) ucp->uc_link;
-
-  va_start (ap, argc);
-  /* Handle arguments.
-
-     The standard says the parameters must all be int values.  This is
-     an historic accident and would be done differently today.  For
-     x86-64 all integer values are passed as 64-bit values and
-     therefore extending the API to copy 64-bit values instead of
-     32-bit ints makes sense.  It does not break existing
-     functionality and it does not violate the standard which says
-     that passing non-int values means undefined behavior.  */
-  for (i = 0; i < argc; ++i)
-    switch (i)
-      {
-      case 0:
-	ucp->uc_mcontext.gregs[REG_RDI] = va_arg (ap, greg_t);
-	break;
-      case 1:
-	ucp->uc_mcontext.gregs[REG_RSI] = va_arg (ap, greg_t);
-	break;
-      case 2:
-	ucp->uc_mcontext.gregs[REG_RDX] = va_arg (ap, greg_t);
-	break;
-      case 3:
-	ucp->uc_mcontext.gregs[REG_RCX] = va_arg (ap, greg_t);
-	break;
-      case 4:
-	ucp->uc_mcontext.gregs[REG_R8] = va_arg (ap, greg_t);
-	break;
-      case 5:
-	ucp->uc_mcontext.gregs[REG_R9] = va_arg (ap, greg_t);
-	break;
-      default:
-	/* Put value on stack.  */
-	sp[i - 5] = va_arg (ap, greg_t);
-	break;
-      }
-  va_end (ap);
-
-}
-
-
-weak_alias (__makecontext, makecontext)
diff --git a/sysdeps/unix/sysv/linux/x86_64/pointer_guard.h b/sysdeps/unix/sysv/linux/x86_64/pointer_guard.h
deleted file mode 100644
index bc02c0ab7cad..000000000000
--- a/sysdeps/unix/sysv/linux/x86_64/pointer_guard.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/* Pointer obfuscation implenentation.  x86-64 version.
-   Copyright (C) 2005-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#ifndef POINTER_GUARD_H
-#define POINTER_GUARD_H
-
-#include <x86-lp_size.h>
-#include <tcb-offsets.h>
-
-#if IS_IN (rtld)
-/* We cannot use the thread descriptor because in ld.so we use setjmp
-   earlier than the descriptor is initialized.  */
-# ifdef __ASSEMBLER__
-#  define PTR_MANGLE(reg)       xor __pointer_chk_guard_local(%rip), reg;    \
-                                rol $2*LP_SIZE+1, reg
-#  define PTR_DEMANGLE(reg)     ror $2*LP_SIZE+1, reg;                       \
-                                xor __pointer_chk_guard_local(%rip), reg
-# else
-#  define PTR_MANGLE(reg)       asm ("xor __pointer_chk_guard_local(%%rip), %0\n" \
-                                     "rol $2*" LP_SIZE "+1, %0"                   \
-                                     : "=r" (reg) : "0" (reg))
-#  define PTR_DEMANGLE(reg)     asm ("ror $2*" LP_SIZE "+1, %0\n"                 \
-                                     "xor __pointer_chk_guard_local(%%rip), %0"   \
-                                     : "=r" (reg) : "0" (reg))
-# endif
-#else
-# ifdef __ASSEMBLER__
-#  define PTR_MANGLE(reg)       xor %fs:POINTER_GUARD, reg;                   \
-                                rol $2*LP_SIZE+1, reg
-#  define PTR_DEMANGLE(reg)     ror $2*LP_SIZE+1, reg;                        \
-                                xor %fs:POINTER_GUARD, reg
-# else
-#  define PTR_MANGLE(var)       asm ("xor %%fs:%c2, %0\n"                     \
-                                     "rol $2*" LP_SIZE "+1, %0"               \
-                                     : "=r" (var)                             \
-                                     : "0" (var),                             \
-                                       "i" (POINTER_GUARD))
-#  define PTR_DEMANGLE(var)     asm ("ror $2*" LP_SIZE "+1, %0\n"             \
-                                     "xor %%fs:%c2, %0"                       \
-                                     : "=r" (var)                             \
-                                     : "0" (var),                             \
-                                       "i" (POINTER_GUARD))
-# endif
-#endif
-
-#endif /* POINTER_GUARD_H */
diff --git a/sysdeps/unix/sysv/linux/x86_64/setcontext.S b/sysdeps/unix/sysv/linux/x86_64/setcontext.S
deleted file mode 100644
index d0bcd794e89e..000000000000
--- a/sysdeps/unix/sysv/linux/x86_64/setcontext.S
+++ /dev/null
@@ -1,196 +0,0 @@
-/* Install given context.
-   Copyright (C) 2002-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <asm/prctl.h>
-
-#include "ucontext_i.h"
-
-
-/*  int __setcontext (const ucontext_t *ucp)
-
-  Restores the machine context in UCP and thereby resumes execution
-  in that context.
-
-  This implementation is intended to be used for *synchronous* context
-  switches only.  Therefore, it does not have to restore anything
-  other than the PRESERVED state.  */
-
-ENTRY(__setcontext)
-	/* Save argument since syscall will destroy it.  */
-	pushq	%rdi
-	cfi_adjust_cfa_offset(8)
-
-	/* Set the signal mask with
-	   rt_sigprocmask (SIG_SETMASK, mask, NULL, _NSIG/8).  */
-	leaq	oSIGMASK(%rdi), %rsi
-	xorl	%edx, %edx
-	movl	$SIG_SETMASK, %edi
-	movl	$_NSIG8,%r10d
-	movl	$__NR_rt_sigprocmask, %eax
-	syscall
-	/* Pop the pointer into RDX. The choice is arbitrary, but
-	   leaving RDI and RSI available for use later can avoid
-	   shuffling values.  */
-	popq	%rdx
-	cfi_adjust_cfa_offset(-8)
-	cmpq	$-4095, %rax		/* Check %rax for error.  */
-	jae	SYSCALL_ERROR_LABEL	/* Jump to error handler if error.  */
-
-	/* Restore the floating-point context.  Not the registers, only the
-	   rest.  */
-	movq	oFPREGS(%rdx), %rcx
-	fldenv	(%rcx)
-	ldmxcsr oMXCSR(%rdx)
-
-
-	/* Load the new stack pointer, the preserved registers and
-	   registers used for passing args.  */
-	cfi_def_cfa(%rdx, 0)
-	cfi_offset(%rbx,oRBX)
-	cfi_offset(%rbp,oRBP)
-	cfi_offset(%r12,oR12)
-	cfi_offset(%r13,oR13)
-	cfi_offset(%r14,oR14)
-	cfi_offset(%r15,oR15)
-	cfi_offset(%rsp,oRSP)
-	cfi_offset(%rip,oRIP)
-
-	movq	oRSP(%rdx), %rsp
-	movq	oRBX(%rdx), %rbx
-	movq	oRBP(%rdx), %rbp
-	movq	oR12(%rdx), %r12
-	movq	oR13(%rdx), %r13
-	movq	oR14(%rdx), %r14
-	movq	oR15(%rdx), %r15
-
-#if SHSTK_ENABLED
-	/* Check if shadow stack is enabled.  */
-	testl	$X86_FEATURE_1_SHSTK, %fs:FEATURE_1_OFFSET
-	jz	L(no_shstk)
-
-	/* If the base of the target shadow stack is the same as the
-	   base of the current shadow stack, we unwind the shadow
-	   stack.  Otherwise it is a stack switch and we look for a
-	   restore token.  */
-	movq	oSSP(%rdx), %rsi
-	movq	%rsi, %rdi
-
-	/* Get the base of the target shadow stack.  */
-	movq	(oSSP + 8)(%rdx), %rcx
-	cmpq	%fs:SSP_BASE_OFFSET, %rcx
-	je	L(unwind_shadow_stack)
-
-L(find_restore_token_loop):
-	/* Look for a restore token.  */
-	movq	-8(%rsi), %rax
-	andq	$-8, %rax
-	cmpq	%rsi, %rax
-	je	L(restore_shadow_stack)
-
-	/* Try the next slot.  */
-	subq	$8, %rsi
-	jmp	L(find_restore_token_loop)
-
-L(restore_shadow_stack):
-	/* Pop return address from the shadow stack since setcontext
-	   will not return.  */
-	movq	$1, %rax
-	incsspq	%rax
-
-	/* Use the restore stoken to restore the target shadow stack.  */
-	rstorssp -8(%rsi)
-
-	/* Save the restore token on the old shadow stack.  NB: This
-	   restore token may be checked by setcontext or swapcontext
-	   later.  */
-	saveprevssp
-
-	/* Record the new shadow stack base that was switched to.  */
-	movq	(oSSP + 8)(%rdx), %rax
-	movq	%rax, %fs:SSP_BASE_OFFSET
-
-L(unwind_shadow_stack):
-	rdsspq	%rcx
-	subq	%rdi, %rcx
-	je	L(skip_unwind_shadow_stack)
-	negq	%rcx
-	shrq	$3, %rcx
-	movl	$255, %esi
-L(loop):
-	cmpq	%rsi, %rcx
-	cmovb	%rcx, %rsi
-	incsspq	%rsi
-	subq	%rsi, %rcx
-	ja	L(loop)
-
-L(skip_unwind_shadow_stack):
-	movq	oRSI(%rdx), %rsi
-	movq	oRDI(%rdx), %rdi
-	movq	oRCX(%rdx), %rcx
-	movq	oR8(%rdx), %r8
-	movq	oR9(%rdx), %r9
-
-	/* Get the return address set with getcontext.  */
-	movq	oRIP(%rdx), %r10
-
-	/* Setup finally %rdx.  */
-	movq	oRDX(%rdx), %rdx
-
-	/* Check if return address is valid for the case when setcontext
-	   is invoked from __start_context with linked context.  */
-	rdsspq	%rax
-	cmpq	(%rax), %r10
-	/* Clear RAX to indicate success.  NB: Don't use xorl to keep
-	   EFLAGS for jne.  */
-	movl	$0, %eax
-	jne	L(jmp)
-	/* Return to the new context if return address valid.  */
-	pushq	%r10
-	ret
-
-L(jmp):
-	/* Jump to the new context directly.  */
-	jmp	*%r10
-
-L(no_shstk):
-#endif
-	/* The following ret should return to the address set with
-	getcontext.  Therefore push the address on the stack.  */
-	movq	oRIP(%rdx), %rcx
-	pushq	%rcx
-
-	movq	oRSI(%rdx), %rsi
-	movq	oRDI(%rdx), %rdi
-	movq	oRCX(%rdx), %rcx
-	movq	oR8(%rdx), %r8
-	movq	oR9(%rdx), %r9
-
-	/* Setup finally %rdx.  */
-	movq	oRDX(%rdx), %rdx
-
-	/* End FDE here, we fall into another context.  */
-	cfi_endproc
-	cfi_startproc
-
-	/* Clear rax to indicate success.  */
-	xorl	%eax, %eax
-	ret
-PSEUDO_END(__setcontext)
-
-weak_alias (__setcontext, setcontext)
diff --git a/sysdeps/unix/sysv/linux/x86_64/swapcontext.S b/sysdeps/unix/sysv/linux/x86_64/swapcontext.S
deleted file mode 100644
index b2e0f19a9d57..000000000000
--- a/sysdeps/unix/sysv/linux/x86_64/swapcontext.S
+++ /dev/null
@@ -1,236 +0,0 @@
-/* Save current context and install the given one.
-   Copyright (C) 2002-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <asm/prctl.h>
-
-#include "ucontext_i.h"
-
-
-/* int __swapcontext (ucontext_t *oucp, const ucontext_t *ucp);
-
-  Saves the machine context in oucp such that when it is activated,
-  it appears as if __swapcontextt() returned again, restores the
-  machine context in ucp and thereby resumes execution in that
-  context.
-
-  This implementation is intended to be used for *synchronous* context
-  switches only.  Therefore, it does not have to save anything
-  other than the PRESERVED state.  */
-
-ENTRY(__swapcontext)
-	/* Save the preserved registers, the registers used for passing args,
-	   and the return address.  */
-	movq	%rbx, oRBX(%rdi)
-	movq	%rbp, oRBP(%rdi)
-	movq	%r12, oR12(%rdi)
-	movq	%r13, oR13(%rdi)
-	movq	%r14, oR14(%rdi)
-	movq	%r15, oR15(%rdi)
-
-	movq	%rdi, oRDI(%rdi)
-	movq	%rsi, oRSI(%rdi)
-	movq	%rdx, oRDX(%rdi)
-	movq	%rcx, oRCX(%rdi)
-	movq	%r8, oR8(%rdi)
-	movq	%r9, oR9(%rdi)
-
-	movq	(%rsp), %rcx
-	movq	%rcx, oRIP(%rdi)
-	leaq	8(%rsp), %rcx		/* Exclude the return address.  */
-	movq	%rcx, oRSP(%rdi)
-
-	/* We have separate floating-point register content memory on the
-	   stack.  We use the __fpregs_mem block in the context.  Set the
-	   links up correctly.  */
-	leaq	oFPREGSMEM(%rdi), %rcx
-	movq	%rcx, oFPREGS(%rdi)
-	/* Save the floating-point environment.  */
-	fnstenv	(%rcx)
-	stmxcsr oMXCSR(%rdi)
-
-
-	/* The syscall destroys some registers, save them.  */
-	movq	%rsi, %r12
-	movq	%rdi, %r9
-
-	/* Save the current signal mask and install the new one with
-	   rt_sigprocmask (SIG_BLOCK, newset, oldset,_NSIG/8).  */
-	leaq	oSIGMASK(%rdi), %rdx
-	leaq	oSIGMASK(%rsi), %rsi
-	movl	$SIG_SETMASK, %edi
-	movl	$_NSIG8,%r10d
-	movl	$__NR_rt_sigprocmask, %eax
-	syscall
-	cmpq	$-4095, %rax		/* Check %rax for error.  */
-	jae	SYSCALL_ERROR_LABEL	/* Jump to error handler if error.  */
-
-	/* Restore destroyed register into RDX. The choice is arbitrary,
-	   but leaving RDI and RSI available for use later can avoid
-	   shuffling values.  */
-	movq	%r12, %rdx
-
-	/* Restore the floating-point context.  Not the registers, only the
-	   rest.  */
-	movq	oFPREGS(%rdx), %rcx
-	fldenv	(%rcx)
-	ldmxcsr oMXCSR(%rdx)
-
-	/* Load the new stack pointer and the preserved registers.  */
-	movq	oRSP(%rdx), %rsp
-	movq	oRBX(%rdx), %rbx
-	movq	oRBP(%rdx), %rbp
-	movq	oR12(%rdx), %r12
-	movq	oR13(%rdx), %r13
-	movq	oR14(%rdx), %r14
-	movq	oR15(%rdx), %r15
-
-#if SHSTK_ENABLED
-	/* Check if shadow stack is enabled.  */
-	testl	$X86_FEATURE_1_SHSTK, %fs:FEATURE_1_OFFSET
-	jz	L(no_shstk)
-
-	xorl	%eax, %eax
-	cmpq	%fs:SSP_BASE_OFFSET, %rax
-	jnz	L(shadow_stack_bound_recorded)
-
-	/* When the shadow stack base is unset, the default shadow
-	   stack is in use.  Use the current shadow stack pointer
-	   as the marker for the default shadow stack.  */
-	rdsspq	%rax
-	movq	%rax, %fs:SSP_BASE_OFFSET
-
-L(shadow_stack_bound_recorded):
-        /* If we unwind the stack, we can't undo stack unwinding.  Just
-	   save the target shadow stack pointer as the current shadow
-	   stack pointer.   */
-	movq	oSSP(%rdx), %rcx
-	movq	%rcx, oSSP(%r9)
-
-	/* Save the base of the current shadow stack.  */
-	movq	%fs:SSP_BASE_OFFSET, %rax
-	movq	%rax, (oSSP + 8)(%r9)
-
-	/* If the base of the target shadow stack is the same as the
-	   base of the current shadow stack, we unwind the shadow
-	   stack.  Otherwise it is a stack switch and we look for a
-	   restore token.  */
-	movq	oSSP(%rdx), %rsi
-	movq	%rsi, %rdi
-
-	/* Get the base of the target shadow stack.  */
-	movq	(oSSP + 8)(%rdx), %rcx
-	cmpq	%fs:SSP_BASE_OFFSET, %rcx
-	je	L(unwind_shadow_stack)
-
-L(find_restore_token_loop):
-	/* Look for a restore token.  */
-	movq	-8(%rsi), %rax
-	andq	$-8, %rax
-	cmpq	%rsi, %rax
-	je	L(restore_shadow_stack)
-
-	/* Try the next slot.  */
-	subq	$8, %rsi
-	jmp	L(find_restore_token_loop)
-
-L(restore_shadow_stack):
-        /* The target shadow stack will be restored.  Save the current
-	   shadow stack pointer.  */
-	rdsspq	%rcx
-	movq	%rcx, oSSP(%r9)
-
-	/* Restore the target shadow stack.  */
-	rstorssp -8(%rsi)
-
-	/* Save the restore token on the old shadow stack.  NB: This
-	   restore token may be checked by setcontext or swapcontext
-	   later.  */
-	saveprevssp
-
-	/* Record the new shadow stack base that was switched to.   */
-	movq	(oSSP + 8)(%rdx), %rax
-	movq	%rax, %fs:SSP_BASE_OFFSET
-
-L(unwind_shadow_stack):
-	rdsspq	%rcx
-	subq	%rdi, %rcx
-	je	L(skip_unwind_shadow_stack)
-	negq	%rcx
-	shrq	$3, %rcx
-	movl	$255, %esi
-L(loop):
-	cmpq	%rsi, %rcx
-	cmovb	%rcx, %rsi
-	incsspq	%rsi
-	subq	%rsi, %rcx
-	ja	L(loop)
-
-L(skip_unwind_shadow_stack):
-	/* Setup registers used for passing args.  */
-	movq	oRDI(%rdx), %rdi
-	movq	oRSI(%rdx), %rsi
-	movq	oRCX(%rdx), %rcx
-	movq	oR8(%rdx), %r8
-	movq	oR9(%rdx), %r9
-
-	/* Get the return address set with getcontext.  */
-	movq	oRIP(%rdx), %r10
-
-	/* Setup finally %rdx.  */
-	movq	oRDX(%rdx), %rdx
-
-	/* Check if return address is valid for the case when setcontext
-	   is invoked from __start_context with linked context.  */
-	rdsspq	%rax
-	cmpq	(%rax), %r10
-	/* Clear rax to indicate success.  NB: Don't use xorl to keep
-	   EFLAGS for jne.  */
-	movl	$0, %eax
-	jne	L(jmp)
-	/* Return to the new context if return address valid.  */
-	pushq	%r10
-	ret
-
-L(jmp):
-	/* Jump to the new context directly.  */
-	jmp	*%r10
-
-L(no_shstk):
-#endif
-	/* The following ret should return to the address set with
-	getcontext.  Therefore push the address on the stack.  */
-	movq	oRIP(%rdx), %rcx
-	pushq	%rcx
-
-	/* Setup registers used for passing args.  */
-	movq	oRDI(%rdx), %rdi
-	movq	oRSI(%rdx), %rsi
-	movq	oRCX(%rdx), %rcx
-	movq	oR8(%rdx), %r8
-	movq	oR9(%rdx), %r9
-
-	/* Setup finally %rdx.  */
-	movq	oRDX(%rdx), %rdx
-
-	/* Clear rax to indicate success.  */
-	xorl	%eax, %eax
-	ret
-PSEUDO_END(__swapcontext)
-
-weak_alias (__swapcontext, swapcontext)
diff --git a/sysdeps/unix/sysv/linux/x86_64/syscall.S b/sysdeps/unix/sysv/linux/x86_64/syscall.S
deleted file mode 100644
index 43af8087b657..000000000000
--- a/sysdeps/unix/sysv/linux/x86_64/syscall.S
+++ /dev/null
@@ -1,42 +0,0 @@
-/* Copyright (C) 2001-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-
-/* Please consult the file sysdeps/unix/sysv/linux/x86-64/sysdep.h for
-   more information about the value -4095 used below.  */
-
-/* Usage: long syscall (syscall_number, arg1, arg2, arg3, arg4, arg5, arg6)
-   We need to do some arg shifting, the syscall_number will be in
-   rax.  */
-
-
-	.text
-ENTRY (syscall)
-	movq %rdi, %rax		/* Syscall number -> rax.  */
-	movq %rsi, %rdi		/* shift arg1 - arg5.  */
-	movq %rdx, %rsi
-	movq %rcx, %rdx
-	movq %r8, %r10
-	movq %r9, %r8
-	movq 8(%rsp),%r9	/* arg6 is on the stack.  */
-	syscall			/* Do the system call.  */
-	cmpq $-4095, %rax	/* Check %rax for error.  */
-	jae SYSCALL_ERROR_LABEL	/* Jump to error handler if error.  */
-	ret			/* Return to caller.  */
-
-PSEUDO_END (syscall)
diff --git a/sysdeps/unix/sysv/linux/x86_64/vfork.S b/sysdeps/unix/sysv/linux/x86_64/vfork.S
deleted file mode 100644
index 0d8732e37421..000000000000
--- a/sysdeps/unix/sysv/linux/x86_64/vfork.S
+++ /dev/null
@@ -1,77 +0,0 @@
-/* Copyright (C) 2001-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#define _ERRNO_H	1
-#include <bits/errno.h>
-#include <tcb-offsets.h>
-
-/* Clone the calling process, but without copying the whole address space.
-   The calling process is suspended until the new process exits or is
-   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
-   and the process ID of the new process to the old process.  */
-
-ENTRY (__vfork)
-
-	/* Pop the return PC value into RDI.  We need a register that
-	   is preserved by the syscall and that we're allowed to destroy. */
-	popq	%rdi
-	cfi_adjust_cfa_offset(-8)
-	cfi_register(%rip, %rdi)
-
-	/* Stuff the syscall number in RAX and enter into the kernel.  */
-	movl	$SYS_ify (vfork), %eax
-	syscall
-
-	/* Push back the return PC.  */
-	pushq	%rdi
-	cfi_adjust_cfa_offset(8)
-
-	cmpl	$-4095, %eax
-	jae SYSCALL_ERROR_LABEL		/* Branch forward if it failed.  */
-
-#if SHSTK_ENABLED
-	/* Check if shadow stack is in use.  */
-	xorl	%esi, %esi
-	rdsspq	%rsi
-	testq	%rsi, %rsi
-	/* Normal return if shadow stack isn't in use.  */
-	je	L(no_shstk)
-
-	testl	%eax, %eax
-	/* In parent, normal return.  */
-	jnz	L(no_shstk)
-
-	/* NB: In child, jump back to caller via indirect branch without
-	   popping shadow stack which is shared with parent.  Keep shadow
-	   stack mismatched so that child returns in the vfork-calling
-	   function will trigger SIGSEGV.  */
-	popq	%rdi
-	cfi_adjust_cfa_offset(-8)
-	jmp	*%rdi
-
-L(no_shstk):
-#endif
-
-	/* Normal return.  */
-	ret
-
-PSEUDO_END (__vfork)
-libc_hidden_def (__vfork)
-
-weak_alias (__vfork, vfork)
-strong_alias (__vfork, __libc_vfork)
diff --git a/sysdeps/x86/Makefile b/sysdeps/x86/Makefile
index 5311b594aff6..449cafc98f83 100644
--- a/sysdeps/x86/Makefile
+++ b/sysdeps/x86/Makefile
@@ -101,7 +101,6 @@ endif # $(subdir) == math
 
 ifeq ($(subdir),setjmp)
 gen-as-const-headers += jmp_buf-ssp.sym
-sysdep_routines += __longjmp_cancel
 endif
 
 ifeq ($(subdir),string)
diff --git a/sysdeps/x86/cacheinfo.c b/sysdeps/x86/cacheinfo.c
index 02c453220326..00dd47a6f2f9 100644
--- a/sysdeps/x86/cacheinfo.c
+++ b/sysdeps/x86/cacheinfo.c
@@ -71,18 +71,4 @@ __cache_sysconf (int name)
   return -1;
 }
 
-# ifdef SHARED
-/* NB: In libc.a, cacheinfo.h is included in libc-start.c.  In libc.so,
-   cacheinfo.h is included here and call init_cacheinfo by initializing
-   a dummy function pointer via IFUNC relocation after CPU features in
-   ld.so have been initialized by DL_PLATFORM_INIT or IFUNC relocation.  */
-# include <cacheinfo.h>
-# include <ifunc-init.h>
-
-extern void __x86_cacheinfo (void) attribute_hidden;
-void (*const __x86_cacheinfo_p) (void) attribute_hidden
-  = __x86_cacheinfo;
-
-__ifunc (__x86_cacheinfo, __x86_cacheinfo, NULL, void, init_cacheinfo);
-# endif
 #endif
diff --git a/sysdeps/x86/configure.ac b/sysdeps/x86/configure.ac
index 8a259d397148..7a5e610bd213 100644
--- a/sysdeps/x86/configure.ac
+++ b/sysdeps/x86/configure.ac
@@ -58,7 +58,7 @@ libc_cv_include_x86_isa_level=no
 if AC_TRY_COMMAND(${CC-cc} $CFLAGS $CPPFLAGS -nostartfiles -nostdlib -r -o conftest conftest1.S conftest2.S); then
   count=`LC_ALL=C $READELF -n conftest | grep NT_GNU_PROPERTY_TYPE_0 | wc -l`
   if test "$count" = 1; then
-    libc_cv_include_x86_isa_level=yes
+    libc_cv_include_x86_isa_level=no
   fi
 fi
 rm -f conftest*])
diff --git a/sysdeps/x86/cpu-features.c b/sysdeps/x86/cpu-features.c
index c096dd390ab3..3981550bdc50 100644
--- a/sysdeps/x86/cpu-features.c
+++ b/sysdeps/x86/cpu-features.c
@@ -24,15 +24,12 @@
 #include <dl-cacheinfo.h>
 #include <dl-minsigstacksize.h>
 #include <dl-hwcap2.h>
+#include <stdfil.h>
 
 extern void TUNABLE_CALLBACK (set_hwcaps) (tunable_val_t *)
   attribute_hidden;
 
 #if defined SHARED
-extern void _dl_tlsdesc_dynamic_fxsave (void) attribute_hidden;
-extern void _dl_tlsdesc_dynamic_xsave (void) attribute_hidden;
-extern void _dl_tlsdesc_dynamic_xsavec (void) attribute_hidden;
-
 # ifdef __x86_64__
 #  include <dl-plt-rewrite.h>
 
@@ -53,17 +50,9 @@ TUNABLE_CALLBACK (set_plt_rewrite) (tunable_val_t *valp)
 		 : plt_rewrite_jmp);
     }
 }
-# else
-extern void _dl_tlsdesc_dynamic_fnsave (void) attribute_hidden;
 # endif
 #endif
 
-#ifdef __x86_64__
-extern void _dl_runtime_resolve_fxsave (void) attribute_hidden;
-extern void _dl_runtime_resolve_xsave (void) attribute_hidden;
-extern void _dl_runtime_resolve_xsavec (void) attribute_hidden;
-#endif
-
 #ifdef __LP64__
 static void
 TUNABLE_CALLBACK (set_prefer_map_32bit_exec) (tunable_val_t *valp)
@@ -162,9 +151,8 @@ update_active (struct cpu_features *cpu_features)
   if (CPU_FEATURES_CPU_P (cpu_features, OSXSAVE))
     {
       unsigned int xcrlow;
-      unsigned int xcrhigh;
       CPU_FEATURE_SET_ACTIVE (cpu_features, AVX10);
-      asm ("xgetbv" : "=a" (xcrlow), "=d" (xcrhigh) : "c" (0));
+      xcrlow = (unsigned)zxgetbv();
       /* Is YMM and XMM state usable?  */
       if ((xcrlow & (bit_YMM_state | bit_XMM_state))
 	  == (bit_YMM_state | bit_XMM_state))
@@ -1226,52 +1214,12 @@ no_cpuid:
 	       TUNABLE_CALLBACK (set_x86_shstk));
 #endif
 
-  if (MINIMUM_X86_ISA_LEVEL >= AVX_X86_ISA_LEVEL
-      || (GLRO(dl_x86_cpu_features).xsave_state_size != 0))
-    {
-      if (CPU_FEATURE_USABLE_P (cpu_features, XSAVEC))
-	{
-#ifdef __x86_64__
-	  GLRO(dl_x86_64_runtime_resolve) = _dl_runtime_resolve_xsavec;
-#endif
-#ifdef SHARED
-	  GLRO(dl_x86_tlsdesc_dynamic) = _dl_tlsdesc_dynamic_xsavec;
-#endif
-	}
-      else
-	{
-#ifdef __x86_64__
-	  GLRO(dl_x86_64_runtime_resolve) = _dl_runtime_resolve_xsave;
-#endif
-#ifdef SHARED
-	  GLRO(dl_x86_tlsdesc_dynamic) = _dl_tlsdesc_dynamic_xsave;
-#endif
-	}
-    }
-  else
-    {
-#ifdef __x86_64__
-      GLRO(dl_x86_64_runtime_resolve) = _dl_runtime_resolve_fxsave;
-# ifdef SHARED
-      GLRO(dl_x86_tlsdesc_dynamic) = _dl_tlsdesc_dynamic_fxsave;
-# endif
-#else
-# ifdef SHARED
-      if (CPU_FEATURE_USABLE_P (cpu_features, FXSR))
-	GLRO(dl_x86_tlsdesc_dynamic) = _dl_tlsdesc_dynamic_fxsave;
-      else
-	GLRO(dl_x86_tlsdesc_dynamic) = _dl_tlsdesc_dynamic_fnsave;
-# endif
-#endif
-    }
-
 #ifdef SHARED
 # ifdef __x86_64__
   TUNABLE_GET (plt_rewrite, tunable_val_t *,
 	       TUNABLE_CALLBACK (set_plt_rewrite));
 # endif
-#else
+#endif
   /* NB: In libc.a, call init_cacheinfo.  */
   init_cacheinfo ();
-#endif
 }
diff --git a/sysdeps/x86/dl-cacheinfo.h b/sysdeps/x86/dl-cacheinfo.h
index ac97414b5bff..9e1c97800319 100644
--- a/sysdeps/x86/dl-cacheinfo.h
+++ b/sysdeps/x86/dl-cacheinfo.h
@@ -698,8 +698,7 @@ get_common_cache_info (long int *shared_ptr, long int * shared_per_thread_ptr, u
                           int count_mask;
 
                           /* Compute count mask.  */
-                          asm ("bsr %1, %0"
-                               : "=r" (count_mask) : "g" (threads_l2));
+                          count_mask = __builtin_clz(threads_l2) ^ 31;
                           count_mask = ~(-1 << (count_mask + 1));
                           threads_l2 = (shipped - 1) & count_mask;
                           count &= ~0x1;
@@ -715,8 +714,7 @@ get_common_cache_info (long int *shared_ptr, long int * shared_per_thread_ptr, u
                             = (level == 2 ? threads_l2 : threads_l3);
 
                           /* Compute count mask.  */
-                          asm ("bsr %1, %0"
-                               : "=r" (count_mask) : "g" (threads_core));
+                          count_mask = __builtin_clz(threads_core) ^ 31;
                           count_mask = ~(-1 << (count_mask + 1));
                           threads_core = (shipped - 1) & count_mask;
                           if (level == 2)
diff --git a/sysdeps/x86/dl-get-cpu-features.c b/sysdeps/x86/dl-get-cpu-features.c
index 579d02d63821..a0f1de37c0d2 100644
--- a/sysdeps/x86/dl-get-cpu-features.c
+++ b/sysdeps/x86/dl-get-cpu-features.c
@@ -18,65 +18,6 @@
 
 #include <ldsodefs.h>
 
-#ifdef SHARED
-# include <cpu-features.c>
-# include <gcc-macros.h>
-
-/* NB: Normally, DL_PLATFORM_INIT calls init_cpu_features to initialize
-   CPU features in dynamic executable.  But when loading ld.so inside of
-   static executable, DL_PLATFORM_INIT isn't called and IFUNC relocation
-   is used to call init_cpu_features.  In static executable, it is called
-   once by IFUNC relocation.  In dynamic executable, it is called twice
-   by DL_PLATFORM_INIT and by IFUNC relocation.  */
-extern void __x86_cpu_features (void) attribute_hidden;
-void (*const __x86_cpu_features_p) (void) attribute_hidden
-  = __x86_cpu_features;
-
-void
-_dl_x86_init_cpu_features (void)
-{
-  struct cpu_features *cpu_features = __get_cpu_features ();
-  if (cpu_features->basic.kind == arch_kind_unknown)
-    {
-      init_cpu_features (cpu_features);
-
-# if IS_IN (rtld)
-      /* See isa-level.c.  */
-#  if defined GCCMACRO__GCC_HAVE_SYNC_COMPARE_AND_SWAP_16		\
-  && defined HAVE_X86_LAHF_SAHF && defined GCCMACRO__POPCNT__		\
-  && defined GCCMACRO__SSE3__ && defined GCCMACRO__SSSE3__		\
-  && defined GCCMACRO__SSE4_1__ && defined GCCMACRO__SSE4_2__
-      if (!(cpu_features->isa_1 & GNU_PROPERTY_X86_ISA_1_V2))
-	_dl_fatal_printf ("\
-Fatal glibc error: CPU does not support x86-64-v%d\n", 2);
-#   if defined GCCMACRO__AVX__ && defined GCCMACRO__AVX2__ \
-  && defined GCCMACRO__F16C__ && defined GCCMACRO__FMA__   \
-  && defined GCCMACRO__LZCNT__ && defined HAVE_X86_MOVBE
-      if (!(cpu_features->isa_1 & GNU_PROPERTY_X86_ISA_1_V3))
-	_dl_fatal_printf ("\
-Fatal glibc error: CPU does not support x86-64-v%d\n", 3);
-#    if defined GCCMACRO__AVX512F__ && defined GCCMACRO__AVX512BW__ \
-     && defined GCCMACRO__AVX512CD__ && defined GCCMACRO__AVX512DQ__ \
-     && defined GCCMACRO__AVX512VL__
-      if (!(cpu_features->isa_1 & GNU_PROPERTY_X86_ISA_1_V4))
-	_dl_fatal_printf ("\
-Fatal glibc error: CPU does not support x86-64-v%d\n", 4);
-#    endif /* ISA level 4 */
-#   endif /* ISA level 3 */
-#  endif /* ISA level 2 */
-# ifdef GCCMACRO__APX_F__
-      if (!CPU_FEATURE_USABLE_P (cpu_features, APX_F))
-	_dl_fatal_printf ("\
-Fatal glibc error: CPU does not support APX\n");
-# endif
-# endif /* IS_IN (rtld) */
-    }
-}
-
-__ifunc (__x86_cpu_features, __x86_cpu_features, NULL, void,
-	 _dl_x86_init_cpu_features);
-#endif
-
 #undef _dl_x86_get_cpu_features
 
 const struct cpu_features *
diff --git a/sysdeps/x86/dl-procinfo.c b/sysdeps/x86/dl-procinfo.c
index b791fd3e92ba..036d04ad1d19 100644
--- a/sysdeps/x86/dl-procinfo.c
+++ b/sysdeps/x86/dl-procinfo.c
@@ -39,49 +39,18 @@
   */
 
 #if !IS_IN (ldconfig)
-# if !defined PROCINFO_DECL && defined SHARED
-  ._dl_x86_cpu_features
-# else
 PROCINFO_CLASS struct cpu_features _dl_x86_cpu_features
-# endif
 # ifndef PROCINFO_DECL
 = { }
 # endif
-# if !defined SHARED || defined PROCINFO_DECL
 ;
-# else
-,
-# endif
 #endif
 
-#if !defined PROCINFO_DECL && defined SHARED
-  ._dl_x86_hwcap_flags
-#else
 PROCINFO_CLASS const char _dl_x86_hwcap_flags[3][9]
-#endif
 #ifndef PROCINFO_DECL
 = {
     "sse2", "x86_64", "avx512_1"
   }
 #endif
-#if !defined SHARED || defined PROCINFO_DECL
 ;
-#else
-,
-#endif
 
-#if defined SHARED && !IS_IN (ldconfig)
-# if !defined PROCINFO_DECL
-  ._dl_x86_tlsdesc_dynamic
-# else
-PROCINFO_CLASS void * _dl_x86_tlsdesc_dynamic
-# endif
-# ifndef PROCINFO_DECL
-= NULL
-# endif
-# ifdef PROCINFO_DECL
-;
-# else
-,
-# endif
-#endif
diff --git a/sysdeps/x86/features-offsets.sym b/sysdeps/x86/features-offsets.sym
index 77e990c7053a..3472f07a4cc9 100644
--- a/sysdeps/x86/features-offsets.sym
+++ b/sysdeps/x86/features-offsets.sym
@@ -2,7 +2,3 @@
 
 #include <ldsodefs.h>
 
-RTLD_GLOBAL_RO_DL_X86_CPU_FEATURES_OFFSET offsetof (struct rtld_global_ro, _dl_x86_cpu_features)
-#ifdef __x86_64__
-RTLD_GLOBAL_DL_X86_FEATURE_1_OFFSET offsetof (struct rtld_global, _dl_x86_feature_1)
-#endif
diff --git a/sysdeps/x86/fpu/fenv_private.h b/sysdeps/x86/fpu/fenv_private.h
index 4b081e015b9c..d737931db896 100644
--- a/sysdeps/x86/fpu/fenv_private.h
+++ b/sysdeps/x86/fpu/fenv_private.h
@@ -19,21 +19,16 @@
    actually using.  */
 
 #if defined __AVX__ || defined SSE2AVX
-# define STMXCSR "vstmxcsr"
-# define LDMXCSR "vldmxcsr"
-#else
-# define STMXCSR "stmxcsr"
-# define LDMXCSR "ldmxcsr"
+# error "Should not be here"
 #endif
 
 static __always_inline void
 libc_feholdexcept_sse (fenv_t *e)
 {
-  unsigned int mxcsr;
-  asm (STMXCSR " %0" : "=m" (*&mxcsr));
+  unsigned int mxcsr = __builtin_ia32_stmxcsr ();
   e->__mxcsr = mxcsr;
   mxcsr = (mxcsr | 0x1f80) & ~0x3f;
-  asm volatile (LDMXCSR " %0" : : "m" (*&mxcsr));
+  __builtin_ia32_ldmxcsr (mxcsr);
 }
 
 static __always_inline void
@@ -50,10 +45,9 @@ libc_feholdexcept_387 (fenv_t *e)
 static __always_inline void
 libc_fesetround_sse (int r)
 {
-  unsigned int mxcsr;
-  asm (STMXCSR " %0" : "=m" (*&mxcsr));
+  unsigned int mxcsr = __builtin_ia32_stmxcsr ();
   mxcsr = (mxcsr & ~0x6000) | (r << 3);
-  asm volatile (LDMXCSR " %0" : : "m" (*&mxcsr));
+  __builtin_ia32_ldmxcsr (mxcsr);
 }
 
 static __always_inline void
@@ -68,11 +62,10 @@ libc_fesetround_387 (int r)
 static __always_inline void
 libc_feholdexcept_setround_sse (fenv_t *e, int r)
 {
-  unsigned int mxcsr;
-  asm (STMXCSR " %0" : "=m" (*&mxcsr));
+  unsigned int mxcsr = __builtin_ia32_stmxcsr ();
   e->__mxcsr = mxcsr;
   mxcsr = ((mxcsr | 0x1f80) & ~0x603f) | (r << 3);
-  asm volatile (LDMXCSR " %0" : : "m" (*&mxcsr));
+  __builtin_ia32_ldmxcsr (mxcsr);
 }
 
 /* Set both rounding mode and precision.  A convenience function for use
@@ -103,8 +96,7 @@ libc_feholdexcept_setround_387_53bit (fenv_t *e, int r)
 static __always_inline int
 libc_fetestexcept_sse (int e)
 {
-  unsigned int mxcsr;
-  asm volatile (STMXCSR " %0" : "=m" (*&mxcsr));
+  unsigned int mxcsr = __builtin_ia32_stmxcsr ();
   return mxcsr & e & FE_ALL_EXCEPT;
 }
 
@@ -119,7 +111,7 @@ libc_fetestexcept_387 (int ex)
 static __always_inline void
 libc_fesetenv_sse (fenv_t *e)
 {
-  asm volatile (LDMXCSR " %0" : : "m" (e->__mxcsr));
+  __builtin_ia32_ldmxcsr (e->__mxcsr);
 }
 
 static __always_inline void
@@ -137,13 +129,13 @@ static __always_inline int
 libc_feupdateenv_test_sse (fenv_t *e, int ex)
 {
   unsigned int mxcsr, old_mxcsr, cur_ex;
-  asm volatile (STMXCSR " %0" : "=m" (*&mxcsr));
+  mxcsr = __builtin_ia32_stmxcsr ();
   cur_ex = mxcsr & FE_ALL_EXCEPT;
 
   /* Merge current exceptions with the old environment.  */
   old_mxcsr = e->__mxcsr;
   mxcsr = old_mxcsr | cur_ex;
-  asm volatile (LDMXCSR " %0" : : "m" (*&mxcsr));
+  __builtin_ia32_ldmxcsr (mxcsr);
 
   /* Raise SIGFPE for any new exceptions since the hold.  Expect that
      the normal environment has all exceptions masked.  */
@@ -188,11 +180,10 @@ libc_feupdateenv_387 (fenv_t *e)
 static __always_inline void
 libc_feholdsetround_sse (fenv_t *e, int r)
 {
-  unsigned int mxcsr;
-  asm (STMXCSR " %0" : "=m" (*&mxcsr));
+  unsigned int mxcsr = __builtin_ia32_stmxcsr ();
   e->__mxcsr = mxcsr;
   mxcsr = (mxcsr & ~0x6000) | (r << 3);
-  asm volatile (LDMXCSR " %0" : : "m" (*&mxcsr));
+  __builtin_ia32_ldmxcsr (mxcsr);
 }
 
 static __always_inline void
@@ -222,10 +213,9 @@ libc_feholdsetround_387_53bit (fenv_t *e, int r)
 static __always_inline void
 libc_feresetround_sse (fenv_t *e)
 {
-  unsigned int mxcsr;
-  asm (STMXCSR " %0" : "=m" (*&mxcsr));
+  unsigned int mxcsr = __builtin_ia32_stmxcsr ();
   mxcsr = (mxcsr & ~0x6000) | (e->__mxcsr & 0x6000);
-  asm volatile (LDMXCSR " %0" : : "m" (*&mxcsr));
+  __builtin_ia32_ldmxcsr (mxcsr);
 }
 
 static __always_inline void
@@ -315,13 +305,13 @@ static __always_inline void
 libc_feholdexcept_setround_sse_ctx (struct rm_ctx *ctx, int r)
 {
   unsigned int mxcsr, new_mxcsr;
-  asm (STMXCSR " %0" : "=m" (*&mxcsr));
+  mxcsr = __builtin_ia32_stmxcsr ();
   new_mxcsr = ((mxcsr | 0x1f80) & ~0x603f) | (r << 3);
 
   ctx->env.__mxcsr = mxcsr;
   if (__glibc_unlikely (mxcsr != new_mxcsr))
     {
-      asm volatile (LDMXCSR " %0" : : "m" (*&new_mxcsr));
+      __builtin_ia32_ldmxcsr (new_mxcsr);
       ctx->updated_status = true;
     }
   else
@@ -412,13 +402,13 @@ libc_feholdsetround_sse_ctx (struct rm_ctx *ctx, int r)
 {
   unsigned int mxcsr, new_mxcsr;
 
-  asm (STMXCSR " %0" : "=m" (*&mxcsr));
+  mxcsr = __builtin_ia32_stmxcsr ();
   new_mxcsr = (mxcsr & ~0x6000) | (r << 3);
 
   ctx->env.__mxcsr = mxcsr;
   if (__glibc_unlikely (new_mxcsr != mxcsr))
     {
-      asm volatile (LDMXCSR " %0" : : "m" (*&new_mxcsr));
+      __builtin_ia32_ldmxcsr (new_mxcsr);
       ctx->updated_status = true;
     }
   else
diff --git a/sysdeps/x86/fpu/math-barriers.h b/sysdeps/x86/fpu/math-barriers.h
index 6fdcdac28024..9d7d45136456 100644
--- a/sysdeps/x86/fpu/math-barriers.h
+++ b/sysdeps/x86/fpu/math-barriers.h
@@ -22,16 +22,14 @@
 #ifdef __SSE2_MATH__
 # define math_opt_barrier(x)						\
   ({ __typeof(x) __x;							\
-     if (sizeof (x) <= sizeof (double)					\
-	|| __builtin_types_compatible_p (__typeof (x), _Float128))	\
+     if (sizeof (x) <= sizeof (double))					\
        __asm ("" : "=x" (__x) : "0" (x));				\
      else								\
        __asm ("" : "=t" (__x) : "0" (x));				\
      __x; })
 # define math_force_eval(x)						\
   do {									\
-    if (sizeof (x) <= sizeof (double)					\
-	|| __builtin_types_compatible_p (__typeof (x), _Float128))	\
+    if (sizeof (x) <= sizeof (double))					\
       __asm __volatile ("" : : "x" (x));				\
     else								\
       __asm __volatile ("" : : "f" (x));				\
diff --git a/sysdeps/x86/fpu_control.h b/sysdeps/x86/fpu_control.h
index cccc25e50dcd..67a33f0a5317 100644
--- a/sysdeps/x86/fpu_control.h
+++ b/sysdeps/x86/fpu_control.h
@@ -55,6 +55,7 @@
  */
 
 #include <features.h>
+#include <pizlonated_math.h>
 
 /* masking of interrupts */
 #define _FPU_MASK_IM  0x01
@@ -89,18 +90,8 @@
 /* Type of the control word.  */
 typedef unsigned int fpu_control_t __attribute__ ((__mode__ (__HI__)));
 
-/* Macros for accessing the hardware control word.  "*&" is used to
-   work around a bug in older versions of GCC.  __volatile__ is used
-   to support combination of writing the control register and reading
-   it back.  Without __volatile__, the old value may be used for reading
-   back under compiler optimization.
-
-   Note that the use of these macros is not sufficient anymore with
-   recent hardware nor on x86-64.  Some floating point operations are
-   executed in the SSE/SSE2 engines which have their own control and
-   status register.  */
-#define _FPU_GETCW(cw) __asm__ __volatile__ ("fnstcw %0" : "=m" (*&cw))
-#define _FPU_SETCW(cw) __asm__ __volatile__ ("fldcw %0" : : "m" (*&cw))
+#define _FPU_GETCW(cw) (cw = zmath_getcw ())
+#define _FPU_SETCW(cw) zmath_setcw (cw)
 
 /* Default control word set at startup.  */
 extern fpu_control_t __fpu_control;
diff --git a/sysdeps/x86/libc-start.c b/sysdeps/x86/libc-start.c
index 070b068149c4..55f1d1137b8c 100644
--- a/sysdeps/x86/libc-start.c
+++ b/sysdeps/x86/libc-start.c
@@ -15,8 +15,6 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#ifndef SHARED
-
 /* Mark symbols hidden in static PIE for early self relocation to work.  */
 # if BUILD_PIE_DEFAULT
 #  pragma GCC visibility push(hidden)
@@ -27,9 +25,6 @@
 # include <ldsodefs.h>
 # include <cpu-features.c>
 
-extern struct cpu_features _dl_x86_cpu_features;
-
-# define ARCH_INIT_CPU_FEATURES() init_cpu_features (&_dl_x86_cpu_features)
+# define ARCH_INIT_CPU_FEATURES() init_cpu_features (&GLRO(dl_x86_cpu_features))
 
-#endif /* !SHARED */
 #include <csu/libc-start.c>
diff --git a/sysdeps/x86/longjmp.c b/sysdeps/x86/longjmp.c
index b72a76f5f429..23794b6faeee 100644
--- a/sysdeps/x86/longjmp.c
+++ b/sysdeps/x86/longjmp.c
@@ -16,30 +16,4 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#define __libc_longjmp __redirect___libc_longjmp
 #include <setjmp/longjmp.c>
-#undef __libc_longjmp
-
-extern void __longjmp_cancel (__jmp_buf __env, int __val)
-     __attribute__ ((__noreturn__)) attribute_hidden;
-
-/* Since __libc_longjmp is a private interface for cancellation
-   implementation in libpthread, there is no need to restore shadow
-   stack register.  */
-
-void
-__libc_longjmp (sigjmp_buf env, int val)
-{
-  /* Perform any cleanups needed by the frames being unwound.  */
-  _longjmp_unwind (env, val);
-
-  if (env[0].__mask_was_saved)
-    /* Restore the saved signal mask.  */
-    (void) __sigprocmask (SIG_SETMASK,
-			  (sigset_t *) &env[0].__saved_mask,
-			  (sigset_t *) NULL);
-
-  /* Call the machine-dependent function to restore machine state
-     without shadow stack.  */
-  __longjmp_cancel (env[0].__jmpbuf, val ?: 1);
-}
diff --git a/sysdeps/x86_64/Implies b/sysdeps/x86_64/Implies
index c458625d727b..67a9ea92a5fd 100644
--- a/sysdeps/x86_64/Implies
+++ b/sysdeps/x86_64/Implies
@@ -1,5 +1,4 @@
 x86
-ieee754/float128
 ieee754/ldbl-96
 ieee754/dbl-64
 ieee754/flt-32
diff --git a/sysdeps/x86_64/Makefile b/sysdeps/x86_64/Makefile
index ce949dba27ee..44da450d45ad 100644
--- a/sysdeps/x86_64/Makefile
+++ b/sysdeps/x86_64/Makefile
@@ -13,14 +13,6 @@ ifeq ($(subdir),csu)
 gen-as-const-headers += link-defines.sym
 endif
 
-ifeq ($(subdir),gmon)
-sysdep_routines += _mcount
-# We cannot compile _mcount.S with -pg because that would create
-# recursive calls when ENTRY is used.  Just copy the normal static
-# object.
-sysdep_noprof += _mcount
-endif
-
 ifeq ($(subdir),string)
 sysdep_routines += \
   strcasecmp_l-nonascii \
@@ -219,18 +211,6 @@ gen-as-const-headers += tlsdesc.sym rtld-offsets.sym
 endif
 
 ifeq ($(subdir),wcsmbs)
-
-sysdep_routines += \
-  wcpcpy-generic \
-  wcpncpy-generic \
-  wcscat-generic \
-  wcscpy-generic \
-  wcsncat-generic \
-  wcsncmp-generic \
-  wcsncpy-generic \
-  wcsnlen-generic \
-# sysdep_routines
-
 tests += \
   tst-rsi-wcslen \
 # tests
diff --git a/sysdeps/x86_64/add_n.S b/sysdeps/x86_64/add_n.S
deleted file mode 100644
index fc85a15ecc03..000000000000
--- a/sysdeps/x86_64/add_n.S
+++ /dev/null
@@ -1,100 +0,0 @@
-/* x86-64 __mpn_add_n -- Add two limb vectors of the same length > 0 and store
-   sum in a third limb vector.
-   Copyright (C) 2006-2024 Free Software Foundation, Inc.
-   This file is part of the GNU MP Library.
-
-   The GNU MP Library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU Lesser General Public License as published by
-   the Free Software Foundation; either version 2.1 of the License, or (at your
-   option) any later version.
-
-   The GNU MP Library is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
-   License for more details.
-
-   You should have received a copy of the GNU Lesser General Public License
-   along with the GNU MP Library; see the file COPYING.LIB.  If not,
-   see <https://www.gnu.org/licenses/>.  */
-
-#include "sysdep.h"
-#include "asm-syntax.h"
-
-#define rp	%rdi
-#define up	%rsi
-#define vp	%rdx
-#define n	%rcx
-#define cy	%r8
-
-#ifndef func
-# define func __mpn_add_n
-# define ADCSBB adc
-#endif
-
-	.text
-ENTRY (func)
-	xor	%r8, %r8
-	mov	(up), %r10
-	mov	(vp), %r11
-
-	lea	-8(up,n,8), up
-	lea	-8(vp,n,8), vp
-	lea	-16(rp,n,8), rp
-	mov	%ecx, %eax
-	neg	n
-	and	$3, %eax
-	je	L(b00)
-	add	%rax, n		/* clear low rcx bits for jrcxz */
-	cmp	$2, %eax
-	jl	L(b01)
-	je	L(b10)
-
-L(b11):	shr	%r8		/* set cy */
-	jmp	L(e11)
-
-L(b00):	shr	%r8		/* set cy */
-	mov	%r10, %r8
-	mov	%r11, %r9
-	lea	4(n), n
-	jmp	L(e00)
-
-L(b01):	shr	%r8		/* set cy */
-	jmp	L(e01)
-
-L(b10):	shr	%r8		/* set cy */
-	mov	%r10, %r8
-	mov	%r11, %r9
-	jmp	L(e10)
-
-L(end):	ADCSBB	%r11, %r10
-	mov	%r10, 8(rp)
-	mov	%ecx, %eax	/* clear eax, ecx contains 0 */
-	adc	%eax, %eax
-	ret
-
-	.p2align 4
-L(top):
-	mov	-24(up,n,8), %r8
-	mov	-24(vp,n,8), %r9
-	ADCSBB	%r11, %r10
-	mov	%r10, -24(rp,n,8)
-L(e00):
-	mov	-16(up,n,8), %r10
-	mov	-16(vp,n,8), %r11
-	ADCSBB	%r9, %r8
-	mov	%r8, -16(rp,n,8)
-L(e11):
-	mov	-8(up,n,8), %r8
-	mov	-8(vp,n,8), %r9
-	ADCSBB	%r11, %r10
-	mov	%r10, -8(rp,n,8)
-L(e10):
-	mov	(up,n,8), %r10
-	mov	(vp,n,8), %r11
-	ADCSBB	%r9, %r8
-	mov	%r8, (rp,n,8)
-L(e01):
-	jrcxz	L(end)
-	lea	4(n), n
-	jmp	L(top)
-END (func)
diff --git a/sysdeps/x86_64/addmul_1.S b/sysdeps/x86_64/addmul_1.S
deleted file mode 100644
index b0c489b15028..000000000000
--- a/sysdeps/x86_64/addmul_1.S
+++ /dev/null
@@ -1,114 +0,0 @@
-/* x86-64 __mpn_addmul_1 -- Multiply a limb vector with a limb and add
-   the result to a second limb vector.
-   Copyright (C) 2003-2024 Free Software Foundation, Inc.
-   This file is part of the GNU MP Library.
-
-   The GNU MP Library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU Lesser General Public License as published by
-   the Free Software Foundation; either version 2.1 of the License, or (at your
-   option) any later version.
-
-   The GNU MP Library is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
-   License for more details.
-
-   You should have received a copy of the GNU Lesser General Public License
-   along with the GNU MP Library; see the file COPYING.LIB.  If not,
-   see <https://www.gnu.org/licenses/>.  */
-
-#include "sysdep.h"
-#include "asm-syntax.h"
-
-#define rp	%rdi
-#define up	%rsi
-#define n	%rdx
-#define v0	%rcx
-
-#ifndef func
-# define func __mpn_addmul_1
-# define ADDSUB add
-#endif
-
-	.text
-ENTRY (func)
-	push	%rbx
-	push	%rbp
-	lea	(%rdx), %rbx
-	neg	%rbx
-
-	mov	(up), %rax
-	mov	(rp), %r10
-
-	lea	-16(rp,%rdx,8), rp
-	lea	(up,%rdx,8), up
-	mul	%rcx
-
-	bt	$0, %ebx
-	jc	L(odd)
-
-	lea	(%rax), %r11
-	mov	8(up,%rbx,8), %rax
-	lea	(%rdx), %rbp
-	mul	%rcx
-	add	$2, %rbx
-	jns	L(n2)
-
-	lea	(%rax), %r8
-	mov	(up,%rbx,8), %rax
-	lea	(%rdx), %r9
-	jmp	L(mid)
-
-L(odd):	add	$1, %rbx
-	jns	L(n1)
-
-	lea	(%rax), %r8
-	mov	(up,%rbx,8), %rax
-	lea	(%rdx), %r9
-	mul	%rcx
-	lea	(%rax), %r11
-	mov	8(up,%rbx,8), %rax
-	lea	(%rdx), %rbp
-	jmp	L(e)
-
-	.p2align 4
-L(top):	mul	%rcx
-	ADDSUB	%r8, %r10
-	lea	(%rax), %r8
-	mov	(up,%rbx,8), %rax
-	adc	%r9, %r11
-	mov	%r10, -8(rp,%rbx,8)
-	mov	(rp,%rbx,8), %r10
-	lea	(%rdx), %r9
-	adc	$0, %rbp
-L(mid):	mul	%rcx
-	ADDSUB	%r11, %r10
-	lea	(%rax), %r11
-	mov	8(up,%rbx,8), %rax
-	adc	%rbp, %r8
-	mov	%r10, (rp,%rbx,8)
-	mov	8(rp,%rbx,8), %r10
-	lea	(%rdx), %rbp
-	adc	$0, %r9
-L(e):	add	$2, %rbx
-	js	L(top)
-
-	mul	%rcx
-	ADDSUB	%r8, %r10
-	adc	%r9, %r11
-	mov	%r10, -8(rp)
-	adc	$0, %rbp
-L(n2):	mov	(rp), %r10
-	ADDSUB	%r11, %r10
-	adc	%rbp, %rax
-	mov	%r10, (rp)
-	adc	$0, %rdx
-L(n1):	mov	8(rp), %r10
-	ADDSUB	%rax, %r10
-	mov	%r10, 8(rp)
-	mov	%ebx, %eax	/* zero rax */
-	adc	%rdx, %rax
-	pop	%rbp
-	pop	%rbx
-	ret
-END (func)
diff --git a/sysdeps/x86_64/dl-procinfo.c b/sysdeps/x86_64/dl-procinfo.c
index 06637a8154d8..ca00dbbca2ea 100644
--- a/sysdeps/x86_64/dl-procinfo.c
+++ b/sysdeps/x86_64/dl-procinfo.c
@@ -42,19 +42,11 @@
 #include <sysdeps/x86/dl-procinfo.c>
 
 #if !IS_IN (ldconfig)
-# if !defined PROCINFO_DECL && defined SHARED
-  ._dl_x86_64_runtime_resolve
-# else
 PROCINFO_CLASS void * _dl_x86_64_runtime_resolve
-# endif
 # ifndef PROCINFO_DECL
 = NULL
 # endif
-# if !defined SHARED || defined PROCINFO_DECL
 ;
-# else
-,
-# endif
 #endif
 
 #undef PROCINFO_DECL
diff --git a/sysdeps/x86_64/dl-procruntime.c b/sysdeps/x86_64/dl-procruntime.c
index 0859438ed08f..3f3a2c3fd2f0 100644
--- a/sysdeps/x86_64/dl-procruntime.c
+++ b/sysdeps/x86_64/dl-procruntime.c
@@ -43,25 +43,13 @@
 #endif
 
 #if !IS_IN (ldconfig)
-# if !defined PROCINFO_DECL && defined SHARED
-  ._dl_x86_feature_1
-# else
 PROCINFO_CLASS unsigned int _dl_x86_feature_1
-# endif
 # ifndef PROCINFO_DECL
 = 0
 # endif
-# if !defined SHARED || defined PROCINFO_DECL
 ;
-# else
-,
-# endif
 
-# if !defined PROCINFO_DECL && defined SHARED
-  ._dl_x86_feature_control
-# else
 PROCINFO_CLASS struct dl_x86_feature_control _dl_x86_feature_control
-# endif
 # ifndef PROCINFO_DECL
 = {
     .ibt = DEFAULT_DL_X86_CET_CONTROL,
@@ -69,9 +57,5 @@ PROCINFO_CLASS struct dl_x86_feature_control _dl_x86_feature_control
     .plt_rewrite = plt_rewrite_none,
   }
 # endif
-# if !defined SHARED || defined PROCINFO_DECL
 ;
-# else
-,
-# endif
 #endif
diff --git a/sysdeps/x86_64/fpu/e_exp10l.S b/sysdeps/x86_64/fpu/e_exp10l.S
deleted file mode 100644
index d843e2b5e849..000000000000
--- a/sysdeps/x86_64/fpu/e_exp10l.S
+++ /dev/null
@@ -1,2 +0,0 @@
-#define USE_AS_EXP10L
-#include <e_expl.S>
diff --git a/sysdeps/x86_64/fpu/e_exp2l.S b/sysdeps/x86_64/fpu/e_exp2l.S
deleted file mode 100644
index 1b664473d8fa..000000000000
--- a/sysdeps/x86_64/fpu/e_exp2l.S
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Public domain.
- */
-
-#include <machine/asm.h>
-#include <x86_64-math-asm.h>
-#include <libm-alias-finite.h>
-
-DEFINE_LDBL_MIN
-
-#ifdef PIC
-# define MO(op) op##(%rip)
-#else
-# define MO(op) op
-#endif
-
-	.text
-ENTRY(__ieee754_exp2l)
-	fldt	8(%rsp)
-/* I added the following ugly construct because exp(+-Inf) resulted
-   in NaN.  The ugliness results from the bright minds at Intel.
-   For the i686 the code can be written better.
-   -- drepper@cygnus.com.  */
-	fxam				/* Is NaN or +-Inf?  */
-	fstsw	%ax
-	movb	$0x45, %dh
-	andb	%ah, %dh
-	cmpb	$0x05, %dh
-	je	1f			/* Is +-Inf, jump.  */
-	movzwl	8+8(%rsp), %eax
-	andl	$0x7fff, %eax
-	cmpl	$0x3fbe, %eax
-	jge	3f
-	/* Argument's exponent below -65, result rounds to 1.  */
-	fld1
-	faddp
-	ret
-3:	fld	%st
-	frndint				/* int(x) */
-	fsubr	%st,%st(1)		/* fract(x) */
-	fxch
-	f2xm1				/* 2^(fract(x)) - 1 */
-	fld1
-	faddp				/* 2^(fract(x)) */
-	fscale				/* e^x */
-	fstp	%st(1)
-	LDBL_CHECK_FORCE_UFLOW_NONNEG_NAN
-	ret
-
-1:	testl	$0x200, %eax		/* Test sign.  */
-	jz	2f			/* If positive, jump.  */
-	fstp	%st
-	fldz				/* Set result to 0.  */
-2:	ret
-END (__ieee754_exp2l)
-libm_alias_finite (__ieee754_exp2l, __exp2l)
diff --git a/sysdeps/x86_64/fpu/e_expl.S b/sysdeps/x86_64/fpu/e_expl.S
deleted file mode 100644
index 203b1ed2c5d7..000000000000
--- a/sysdeps/x86_64/fpu/e_expl.S
+++ /dev/null
@@ -1,222 +0,0 @@
-/*
- * Public domain.
- *
- */
-
-/*
- * The 8087 method for the exponential function is to calculate
- *   exp(x) = 2^(x log2(e))
- * after separating integer and fractional parts
- *   x log2(e) = i + f, |f| <= .5
- * 2^i is immediate but f needs to be precise for long double accuracy.
- * Suppress range reduction error in computing f by the following.
- * Separate x into integer and fractional parts
- *   x = xi + xf, |xf| <= .5
- * Separate log2(e) into the sum of an exact number c0 and small part c1.
- *   c0 + c1 = log2(e) to extra precision
- * Then
- *   f = (c0 xi - i) + c0 xf + c1 x
- * where c0 xi is exact and so also is (c0 xi - i).
- * -- moshier@na-net.ornl.gov
- */
-
-#include <libm-alias-ldouble.h>
-#include <machine/asm.h>
-#include <x86_64-math-asm.h>
-#include <libm-alias-finite.h>
-
-#ifdef USE_AS_EXP10L
-# define IEEE754_EXPL __ieee754_exp10l
-# define EXPL_FINITE __exp10l_finite
-# define FLDLOG fldl2t
-#elif defined USE_AS_EXPM1L
-# define IEEE754_EXPL __expm1l
-# undef EXPL_FINITE
-# define FLDLOG fldl2e
-#else
-# define IEEE754_EXPL __ieee754_expl
-# define EXPL_FINITE __expl_finite
-# define FLDLOG fldl2e
-#endif
-
-	.section .rodata.cst16,"aM",@progbits,16
-
-	.p2align 4
-#ifdef USE_AS_EXP10L
-	.type c0,@object
-c0:	.byte 0, 0, 0, 0, 0, 0, 0x9a, 0xd4, 0x00, 0x40
-	.byte 0, 0, 0, 0, 0, 0
-	ASM_SIZE_DIRECTIVE(c0)
-	.type c1,@object
-c1:	.byte 0x58, 0x92, 0xfc, 0x15, 0x37, 0x9a, 0x97, 0xf0, 0xef, 0x3f
-	.byte 0, 0, 0, 0, 0, 0
-	ASM_SIZE_DIRECTIVE(c1)
-#else
-	.type c0,@object
-c0:	.byte 0, 0, 0, 0, 0, 0, 0xaa, 0xb8, 0xff, 0x3f
-	.byte 0, 0, 0, 0, 0, 0
-	ASM_SIZE_DIRECTIVE(c0)
-	.type c1,@object
-c1:	.byte 0x20, 0xfa, 0xee, 0xc2, 0x5f, 0x70, 0xa5, 0xec, 0xed, 0x3f
-	.byte 0, 0, 0, 0, 0, 0
-	ASM_SIZE_DIRECTIVE(c1)
-#endif
-#ifndef USE_AS_EXPM1L
-	.type csat,@object
-csat:	.byte 0, 0, 0, 0, 0, 0, 0, 0x80, 0x0e, 0x40
-	.byte 0, 0, 0, 0, 0, 0
-	ASM_SIZE_DIRECTIVE(csat)
-DEFINE_LDBL_MIN
-#endif
-
-#ifdef PIC
-# define MO(op) op##(%rip)
-#else
-# define MO(op) op
-#endif
-
-	.text
-ENTRY(IEEE754_EXPL)
-#ifdef USE_AS_EXPM1L
-	movzwl	8+8(%rsp), %eax
-	xorb	$0x80, %ah	// invert sign bit (now 1 is "positive")
-	cmpl	$0xc006, %eax	// is num positive and exp >= 6 (number is >= 128.0)?
-	jae	HIDDEN_JUMPTARGET (__expl) // (if num is denormal, it is at least >= 64.0)
-#endif
-	fldt	8(%rsp)
-/* I added the following ugly construct because expl(+-Inf) resulted
-   in NaN.  The ugliness results from the bright minds at Intel.
-   For the i686 the code can be written better.
-   -- drepper@cygnus.com.  */
-	fxam			/* Is NaN or +-Inf?  */
-#ifdef USE_AS_EXPM1L
-	xorb	$0x80, %ah
-	cmpl	$0xc006, %eax
-	fstsw	%ax
-	movb	$0x45, %dh
-	jb	4f
-
-	/* Below -64.0 (may be -NaN or -Inf). */
-	andb	%ah, %dh
-	cmpb	$0x01, %dh
-	je	6f		/* Is +-NaN, jump.  */
-	jmp	1f		/* -large, possibly -Inf.  */
-
-4:	/* In range -64.0 to 64.0 (may be +-0 but not NaN or +-Inf).  */
-	/* Test for +-0 as argument.  */
-	andb	%ah, %dh
-	cmpb	$0x40, %dh
-	je	2f
-
-	/* Test for arguments that are small but not subnormal.  */
-	movzwl	8+8(%rsp), %eax
-	andl	$0x7fff, %eax
-	cmpl	$0x3fbf, %eax
-	jge	3f
-	/* Argument's exponent below -64; avoid spurious underflow if
-	   normal.  */
-	cmpl	$0x0001, %eax
-	jge	2f
-	/* Force underflow and return the argument, to avoid wrong signs
-	   of zero results from the code below in some rounding modes.  */
-	fld	%st
-	fmul	%st
-	fstp	%st
-	jmp	2f
-#else
-	movzwl	8+8(%rsp), %eax
-	andl	$0x7fff, %eax
-	cmpl	$0x400d, %eax
-	jg	5f
-	cmpl	$0x3fbc, %eax
-	jge	3f
-	/* Argument's exponent below -67, result rounds to 1.  */
-	fld1
-	faddp
-	jmp	2f
-5:	/* Overflow, underflow or infinity or NaN as argument.  */
-	fstsw	%ax
-	movb	$0x45, %dh
-	andb	%ah, %dh
-	cmpb	$0x05, %dh
-	je	1f		/* Is +-Inf, jump.    */
-	cmpb	$0x01, %dh
-	je	6f		/* Is +-NaN, jump.    */
-	/* Overflow or underflow; saturate.  */
-	fstp	%st
-	fldt	MO(csat)
-	andb	$2, %ah
-	jz	3f
-	fchs
-#endif
-3:	FLDLOG			/* 1  log2(base)      */
-	fmul	%st(1), %st	/* 1  x log2(base)    */
-	/* Set round-to-nearest temporarily.  */
-	fstcw	-4(%rsp)
-	movl	$0xf3ff, %edx
-	andl	-4(%rsp), %edx
-	movl	%edx, -8(%rsp)
-	fldcw	-8(%rsp)
-	frndint			/* 1  i               */
-	fld	%st(1)		/* 2  x               */
-	frndint			/* 2  xi              */
-	fldcw	-4(%rsp)
-	fld	%st(1)		/* 3  i               */
-	fldt	MO(c0)		/* 4  c0              */
-	fld	%st(2)		/* 5  xi              */
-	fmul	%st(1), %st	/* 5  c0 xi           */
-	fsubp	%st, %st(2)	/* 4  f = c0 xi  - i  */
-	fld	%st(4)		/* 5  x               */
-	fsub	%st(3), %st	/* 5  xf = x - xi     */
-	fmulp	%st, %st(1)	/* 4  c0 xf           */
-	faddp	%st, %st(1)	/* 3  f = f + c0 xf   */
-	fldt	MO(c1)		/* 4                  */
-	fmul	%st(4), %st	/* 4  c1 * x          */
-	faddp	%st, %st(1)	/* 3  f = f + c1 * x  */
-	f2xm1			/* 3 2^(fract(x * log2(base))) - 1 */
-#ifdef USE_AS_EXPM1L
-	fstp	%st(1)		/* 2                  */
-	fscale			/* 2 scale factor is st(1); base^x - 2^i */
-	fxch			/* 2 i                */
-	fld1			/* 3 1.0              */
-	fscale			/* 3 2^i              */
-	fld1			/* 4 1.0              */
-	fsubrp	%st, %st(1)	/* 3 2^i - 1.0        */
-	fstp	%st(1)		/* 2                  */
-	faddp	%st, %st(1)	/* 1 base^x - 1.0     */
-#else
-	fld1			/* 4 1.0              */
-	faddp			/* 3 2^(fract(x * log2(base))) */
-	fstp	%st(1)		/* 2  */
-	fscale			/* 2 scale factor is st(1); base^x */
-	fstp	%st(1)		/* 1  */
-	LDBL_CHECK_FORCE_UFLOW_NONNEG
-#endif
-	fstp	%st(1)		/* 0  */
-	jmp	2f
-1:
-#ifdef USE_AS_EXPM1L
-	/* For expm1l, only negative sign gets here.  */
-	fstp	%st
-	fld1
-	fchs
-#else
-	testl	$0x200, %eax	/* Test sign.  */
-	jz	2f		/* If positive, jump.  */
-	fstp	%st
-	fldz			/* Set result to 0.  */
-#endif
-2:	ret
-6:	/* NaN argument.  */
-	fadd	%st
-	ret
-END(IEEE754_EXPL)
-
-#ifdef USE_AS_EXPM1L
-libm_hidden_def (__expm1l)
-libm_alias_ldouble (__expm1, expm1)
-#elif defined USE_AS_EXP10L
-libm_alias_finite (__ieee754_exp10l, __exp10l)
-#else
-libm_alias_finite (__ieee754_expl, __expl)
-#endif
diff --git a/sysdeps/x86_64/fpu/e_fmodl.S b/sysdeps/x86_64/fpu/e_fmodl.S
deleted file mode 100644
index d754668bce59..000000000000
--- a/sysdeps/x86_64/fpu/e_fmodl.S
+++ /dev/null
@@ -1,21 +0,0 @@
-/*
- * Public domain.
- *
- */
-
-#include <machine/asm.h>
-#include <libm-alias-finite.h>
-
-RCSID("$NetBSD: $")
-
-ENTRY(__ieee754_fmodl)
-	fldt	24(%rsp)
-	fldt	8(%rsp)
-1:	fprem
-	fstsw	%ax
-	and	$04,%ah
-	jnz	1b
-	fstp	%st(1)
-	ret
-END (__ieee754_fmodl)
-libm_alias_finite (__ieee754_fmodl, __fmodl)
diff --git a/sysdeps/x86_64/fpu/e_ilogbl.S b/sysdeps/x86_64/fpu/e_ilogbl.S
deleted file mode 100644
index 174647344dd4..000000000000
--- a/sysdeps/x86_64/fpu/e_ilogbl.S
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Public domain.
- */
-
-#include <machine/asm.h>
-
-ENTRY(__ieee754_ilogbl)
-	fldt	8(%rsp)
-/* I added the following ugly construct because ilogb(+-Inf) is
-   required to return INT_MAX in ISO C99.
-   -- jakub@redhat.com.  */
-	fxam			/* Is NaN or +-Inf?  */
-	fstsw   %ax
-	movb    $0x45, %dh
-	andb    %ah, %dh
-	cmpb    $0x05, %dh
-	je      1f		/* Is +-Inf, jump.  */
-	cmpb    $0x40, %dh
-	je      2f		/* Is +-Inf, jump.  */
-
-	fxtract
-	fstp	%st
-
-	fistpl	-4(%rsp)
-	fwait
-	movl	-4(%rsp),%eax
-
-	ret
-
-1:	fstp	%st
-	movl	$0x7fffffff, %eax
-	ret
-2:	fstp	%st
-	movl	$0x80000000, %eax	/* FP_ILOGB0  */
-	ret
-END (__ieee754_ilogbl)
diff --git a/sysdeps/x86_64/fpu/e_log10l.S b/sysdeps/x86_64/fpu/e_log10l.S
deleted file mode 100644
index cebde8271502..000000000000
--- a/sysdeps/x86_64/fpu/e_log10l.S
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Public domain.
- *
- */
-
-#include <machine/asm.h>
-#include <libm-alias-finite.h>
-
-	.section .rodata.cst8,"aM",@progbits,8
-
-	.p2align 3
-	.type one,@object
-one:	.double 1.0
-	ASM_SIZE_DIRECTIVE(one)
-	/* It is not important that this constant is precise.  It is only
-	   a value which is known to be on the safe side for using the
-	   fyl2xp1 instruction.  */
-	.type limit,@object
-limit:	.double 0.29
-	ASM_SIZE_DIRECTIVE(limit)
-
-
-#ifdef PIC
-# define MO(op) op##(%rip)
-#else
-# define MO(op) op
-#endif
-
-	.text
-ENTRY(__ieee754_log10l)
-	fldlg2			// log10(2)
-	fldt	8(%rsp)		// x : log10(2)
-	fxam
-	fnstsw
-	fld	%st		// x : x : log10(2)
-	testb	$1, %ah
-	jnz	3f		// in case x is NaN or Inf
-4:	fsubl	MO(one)		// x-1 : x : log10(2)
-	fld	%st		// x-1 : x-1 : x : log10(2)
-	fabs			// |x-1| : x-1 : x : log10(2)
-	fcompl	MO(limit)	// x-1 : x : log10(2)
-	fnstsw			// x-1 : x : log10(2)
-	andb	$0x45, %ah
-	jz	2f
-	fxam
-	fnstsw
-	andb	$0x45, %ah
-	cmpb	$0x40, %ah
-	jne	5f
-	fabs			// log10(1) is +0 in all rounding modes.
-5:	fstp	%st(1)		// x-1 : log10(2)
-	fyl2xp1			// log10(x)
-	ret
-
-2:	fstp	%st(0)		// x : log10(2)
-	fyl2x			// log10(x)
-	ret
-
-3:	testb	$4, %ah
-	jnz	4b		// in case x is Inf
-	fstp	%st(1)
-	fstp	%st(1)
-	fadd	%st(0)
-	ret
-END(__ieee754_log10l)
-
-
-ENTRY(__log10l_finite)
-	fldlg2			// log10(2)
-	fldt	8(%rsp)		// x : log10(2)
-	fld	%st		// x : x : log10(2)
-4:	fsubl	MO(one)		// x-1 : x : log10(2)
-	fld	%st		// x-1 : x-1 : x : log10(2)
-	fabs			// |x-1| : x-1 : x : log10(2)
-	fcompl	MO(limit)	// x-1 : x : log10(2)
-	fnstsw			// x-1 : x : log10(2)
-	andb	$0x45, %ah
-	jz	2b
-	fxam
-	fnstsw
-	andb	$0x45, %ah
-	cmpb	$0x40, %ah
-	jne	6f
-	fabs			// log10(1) is +0 in all rounding modes.
-6:	fstp	%st(1)		// x-1 : log10(2)
-	fyl2xp1			// log10(x)
-	ret
-END(__log10l_finite)
-libm_alias_finite (__log10l_finite, __log10l)
diff --git a/sysdeps/x86_64/fpu/e_log2l.S b/sysdeps/x86_64/fpu/e_log2l.S
deleted file mode 100644
index dd3d9cb86aa2..000000000000
--- a/sysdeps/x86_64/fpu/e_log2l.S
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Public domain.
- *
- */
-
-#include <machine/asm.h>
-#include <libm-alias-finite.h>
-
-	.section .rodata.cst8,"aM",@progbits,8
-
-	.p2align 3
-	.type one,@object
-one:	.double 1.0
-	ASM_SIZE_DIRECTIVE(one)
-	/* It is not important that this constant is precise.  It is only
-	   a value which is known to be on the safe side for using the
-	   fyl2xp1 instruction.  */
-	.type limit,@object
-limit:	.double 0.29
-	ASM_SIZE_DIRECTIVE(limit)
-
-
-#ifdef PIC
-# define MO(op) op##(%rip)
-#else
-# define MO(op) op
-#endif
-
-	.text
-ENTRY(__ieee754_log2l)
-	fldl	MO(one)
-	fldt	8(%rsp)		// x : 1
-	fxam
-	fnstsw
-	fld	%st		// x : x : 1
-	testb	$1, %ah
-	jnz	3f		// in case x is NaN or Inf
-4:	fsub	%st(2), %st	// x-1 : x : 1
-	fld	%st		// x-1 : x-1 : x : 1
-	fabs			// |x-1| : x-1 : x : 1
-	fcompl	MO(limit)	// x-1 : x : 1
-	fnstsw			// x-1 : x : 1
-	andb	$0x45, %ah
-	jz	2f
-	fxam
-	fnstsw
-	andb	$0x45, %ah
-	cmpb	$0x40, %ah
-	jne	5f
-	fabs			// log2(1) is +0 in all rounding modes.
-5:	fstp	%st(1)		// x-1 : 1
-	fyl2xp1			// log(x)
-	ret
-
-2:	fstp	%st(0)		// x : 1
-	fyl2x			// log(x)
-	ret
-
-3:	testb	$4, %ah
-	jnz	4b		// in case x is Inf
-	fstp	%st(1)
-	fstp	%st(1)
-	fadd	%st(0)
-	ret
-END (__ieee754_log2l)
-
-
-ENTRY(__log2l_finite)
-	fldl	MO(one)
-	fldt	8(%rsp)		// x : 1
-	fld	%st		// x : x : 1
-	fsub	%st(2), %st	// x-1 : x : 1
-	fld	%st		// x-1 : x-1 : x : 1
-	fabs			// |x-1| : x-1 : x : 1
-	fcompl	MO(limit)	// x-1 : x : 1
-	fnstsw			// x-1 : x : 1
-	andb	$0x45, %ah
-	jz	2b
-	fxam
-	fnstsw
-	andb	$0x45, %ah
-	cmpb	$0x40, %ah
-	jne	6f
-	fabs			// log2(1) is +0 in all rounding modes.
-6:	fstp	%st(1)		// x-1 : 1
-	fyl2xp1			// log(x)
-	ret
-END (__log2l_finite)
-libm_alias_finite (__log2l_finite, __log2l)
diff --git a/sysdeps/x86_64/fpu/e_logl.S b/sysdeps/x86_64/fpu/e_logl.S
deleted file mode 100644
index 126f6c533252..000000000000
--- a/sysdeps/x86_64/fpu/e_logl.S
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Public domain.
- *
- */
-
-#include <machine/asm.h>
-#include <libm-alias-finite.h>
-
-	.section .rodata.cst8,"aM",@progbits,8
-
-	.p2align 3
-	.type one,@object
-one:	.double 1.0
-	ASM_SIZE_DIRECTIVE(one)
-	/* It is not important that this constant is precise.  It is only
-	   a value which is known to be on the safe side for using the
-	   fyl2xp1 instruction.  */
-	.type limit,@object
-limit:	.double 0.29
-	ASM_SIZE_DIRECTIVE(limit)
-
-
-#ifdef PIC
-# define MO(op) op##(%rip)
-#else
-# define MO(op) op
-#endif
-
-	.text
-ENTRY(__ieee754_logl)
-	fldln2			// log(2)
-	fldt	8(%rsp)		// x : log(2)
-	fxam
-	fnstsw
-	fld	%st		// x : x : log(2)
-	testb	$1, %ah
-	jnz	3f		// in case x is NaN or +-Inf
-	movzwl	8+8(%rsp), %eax
-	cmpl	$0xc000, %eax
-	jae	6f		// x <= -2, avoid overflow from -LDBL_MAX - 1.
-4:	fsubl	MO(one)		// x-1 : x : log(2)
-6:	fld	%st		// x-1 : x-1 : x : log(2)
-	fabs			// |x-1| : x-1 : x : log(2)
-	fcompl	MO(limit)	// x-1 : x : log(2)
-	fnstsw			// x-1 : x : log(2)
-	andb	$0x45, %ah
-	jz	2f
-	fxam
-	fnstsw
-	andb	$0x45, %ah
-	cmpb	$0x40, %ah
-	jne	5f
-	fabs			// log(1) is +0 in all rounding modes.
-5:	fstp	%st(1)		// x-1 : log(2)
-	fyl2xp1			// log(x)
-	ret
-
-2:	fstp	%st(0)		// x : log(2)
-	fyl2x			// log(x)
-	ret
-
-3:	testb	$4, %ah
-	jnz	4b		// in case x is +-Inf
-	fstp	%st(1)
-	fstp	%st(1)
-	fadd	%st(0)
-	ret
-END (__ieee754_logl)
-
-
-ENTRY(__logl_finite)
-	fldln2			// log(2)
-	fldt	8(%rsp)		// x : log(2)
-	fld	%st		// x : x : log(2)
-	fsubl	MO(one)		// x-1 : x : log(2)
-	fld	%st		// x-1 : x-1 : x : log(2)
-	fabs			// |x-1| : x-1 : x : log(2)
-	fcompl	MO(limit)	// x-1 : x : log(2)
-	fnstsw			// x-1 : x : log(2)
-	andb	$0x45, %ah
-	jz	2b
-	fxam
-	fnstsw
-	andb	$0x45, %ah
-	cmpb	$0x40, %ah
-	jne	7f
-	fabs			// log(1) is +0 in all rounding modes.
-7:	fstp	%st(1)		// x-1 : log(2)
-	fyl2xp1			// log(x)
-	ret
-END (__logl_finite)
-libm_alias_finite (__logl_finite, __logl)
diff --git a/sysdeps/x86_64/fpu/e_powl.S b/sysdeps/x86_64/fpu/e_powl.S
deleted file mode 100644
index 1ab2f776e080..000000000000
--- a/sysdeps/x86_64/fpu/e_powl.S
+++ /dev/null
@@ -1,433 +0,0 @@
-/* ix87 specific implementation of pow function.
-   Copyright (C) 1996-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <machine/asm.h>
-#include <x86_64-math-asm.h>
-#include <libm-alias-finite.h>
-
-	.section .rodata.cst8,"aM",@progbits,8
-
-	.p2align 3
-	.type one,@object
-one:	.double 1.0
-	ASM_SIZE_DIRECTIVE(one)
-	.type p2,@object
-p2:	.byte 0, 0, 0, 0, 0, 0, 0x10, 0x40
-	ASM_SIZE_DIRECTIVE(p2)
-	.type p63,@object
-p63:	.byte 0, 0, 0, 0, 0, 0, 0xe0, 0x43
-	ASM_SIZE_DIRECTIVE(p63)
-	.type p64,@object
-p64:	.byte 0, 0, 0, 0, 0, 0, 0xf0, 0x43
-	ASM_SIZE_DIRECTIVE(p64)
-	.type p78,@object
-p78:	.byte 0, 0, 0, 0, 0, 0, 0xd0, 0x44
-	ASM_SIZE_DIRECTIVE(p78)
-	.type pm79,@object
-pm79:	.byte 0, 0, 0, 0, 0, 0, 0, 0x3b
-	ASM_SIZE_DIRECTIVE(pm79)
-
-	.section .rodata.cst16,"aM",@progbits,16
-
-	.p2align 3
-	.type infinity,@object
-inf_zero:
-infinity:
-	.byte 0, 0, 0, 0, 0, 0, 0xf0, 0x7f
-	ASM_SIZE_DIRECTIVE(infinity)
-	.type zero,@object
-zero:	.double 0.0
-	ASM_SIZE_DIRECTIVE(zero)
-	.type minf_mzero,@object
-minf_mzero:
-minfinity:
-	.byte 0, 0, 0, 0, 0, 0, 0xf0, 0xff
-mzero:
-	.byte 0, 0, 0, 0, 0, 0, 0, 0x80
-	ASM_SIZE_DIRECTIVE(minf_mzero)
-DEFINE_LDBL_MIN
-
-#ifdef PIC
-# define MO(op) op##(%rip)
-#else
-# define MO(op) op
-#endif
-
-	.text
-ENTRY(__ieee754_powl)
-	fldt	24(%rsp)	// y
-	fxam
-
-
-	fnstsw
-	movb	%ah, %dl
-	andb	$0x45, %ah
-	cmpb	$0x40, %ah	// is y == 0 ?
-	je	11f
-
-	cmpb	$0x05, %ah	// is y == inf ?
-	je	12f
-
-	cmpb	$0x01, %ah	// is y == NaN ?
-	je	30f
-
-	fldt	8(%rsp)		// x : y
-
-	fxam
-	fnstsw
-	movb	%ah, %dh
-	andb	$0x45, %ah
-	cmpb	$0x40, %ah
-	je	20f		// x is 0
-
-	cmpb	$0x05, %ah
-	je	15f		// x is inf
-
-	cmpb	$0x01, %ah
-	je	31f		// x is NaN
-
-	fxch			// y : x
-
-	/* fistpll raises invalid exception for |y| >= 1L<<63.  */
-	fldl	MO(p63)		// 1L<<63 : y : x
-	fld	%st(1)		// y : 1L<<63 : y : x
-	fabs			// |y| : 1L<<63 : y : x
-	fcomip	%st(1), %st	// 1L<<63 : y : x
-	fstp	%st(0)		// y : x
-	jnc	2f
-
-	/* First see whether `y' is a natural number.  In this case we
-	   can use a more precise algorithm.  */
-	fld	%st		// y : y : x
-	fistpll	-8(%rsp)	// y : x
-	fildll	-8(%rsp)	// int(y) : y : x
-	fucomip	%st(1),%st	// y : x
-	je	9f
-
-	// If y has absolute value at most 0x1p-79, then any finite
-	// nonzero x will result in 1.  Saturate y to those bounds to
-	// avoid underflow in the calculation of y*log2(x).
-	fldl	MO(pm79)	// 0x1p-79 : y : x
-	fld	%st(1)		// y : 0x1p-79 : y : x
-	fabs			// |y| : 0x1p-79 : y : x
-	fcomip	%st(1), %st	// 0x1p-79 : y : x
-	fstp	%st(0)		// y : x
-	jnc	3f
-	fstp	%st(0)		// pop y
-	fldl	MO(pm79)	// 0x1p-79 : x
-	testb	$2, %dl
-	jnz	3f		// y > 0
-	fchs			// -0x1p-79 : x
-	jmp	3f
-
-9:	/* OK, we have an integer value for y.  Unless very small
-	   (we use < 4), use the algorithm for real exponent to avoid
-	   accumulation of errors.  */
-	fldl	MO(p2)		// 4 : y : x
-	fld	%st(1)		// y : 4 : y : x
-	fabs			// |y| : 4 : y : x
-	fcomip	%st(1), %st	// 4 : y : x
-	fstp	%st(0)		// y : x
-	jnc	3f
-	mov	-8(%rsp),%eax
-	mov	-4(%rsp),%edx
-	orl	$0, %edx
-	fstp	%st(0)		// x
-	jns	4f		// y >= 0, jump
-	fdivrl	MO(one)		// 1/x		(now referred to as x)
-	negl	%eax
-	adcl	$0, %edx
-	negl	%edx
-4:	fldl	MO(one)		// 1 : x
-	fxch
-
-	/* If y is even, take the absolute value of x.  Otherwise,
-	   ensure all intermediate values that might overflow have the
-	   sign of x.  */
-	testb	$1, %al
-	jnz	6f
-	fabs
-
-6:	shrdl	$1, %edx, %eax
-	jnc	5f
-	fxch
-	fabs
-	fmul	%st(1)		// x : ST*x
-	fxch
-5:	fld	%st		// x : x : ST*x
-	fabs			// |x| : x : ST*x
-	fmulp			// |x|*x : ST*x
-	shrl	$1, %edx
-	movl	%eax, %ecx
-	orl	%edx, %ecx
-	jnz	6b
-	fstp	%st(0)		// ST*x
-	LDBL_CHECK_FORCE_UFLOW_NONNAN
-	ret
-
-	/* y is NAN */
-30:	fldt	8(%rsp)		// x : y
-	fldl	MO(one)		// 1.0 : x : y
-	fucomip	%st(1),%st	// x : y
-	je	32f
-31:	/* At least one argument NaN, and result should be NaN.  */
-	faddp
-	ret
-32:	jc	31b
-	/* pow (1, NaN); check if the NaN signaling.  */
-	testb	$0x40, 31(%rsp)
-	jz	31b
-	fstp	%st(1)
-	ret
-
-	.align ALIGNARG(4)
-2:	// y is a large integer (absolute value at least 1L<<63).
-	// If y has absolute value at least 1L<<78, then any finite
-	// nonzero x will result in 0 (underflow), 1 or infinity (overflow).
-	// Saturate y to those bounds to avoid overflow in the calculation
-	// of y*log2(x).
-	fldl	MO(p78)		// 1L<<78 : y : x
-	fld	%st(1)		// y : 1L<<78 : y : x
-	fabs			// |y| : 1L<<78 : y : x
-	fcomip	%st(1), %st	// 1L<<78 : y : x
-	fstp	%st(0)		// y : x
-	jc	3f
-	fstp	%st(0)		// pop y
-	fldl	MO(p78)		// 1L<<78 : x
-	testb	$2, %dl
-	jz	3f		// y > 0
-	fchs			// -(1L<<78) : x
-	.align ALIGNARG(4)
-3:	/* y is a real number.  */
-	subq	$40, %rsp
-	cfi_adjust_cfa_offset (40)
-	fstpt	16(%rsp)	// x
-	fstpt	(%rsp)		// <empty>
-	call	HIDDEN_JUMPTARGET (__powl_helper)	// <result>
-	addq	$40, %rsp
-	cfi_adjust_cfa_offset (-40)
-	ret
-
-	// pow(x,0) = 1, unless x is sNaN
-	.align ALIGNARG(4)
-11:	fstp	%st(0)		// pop y
-	fldt	8(%rsp)		// x
-	fxam
-	fnstsw
-	andb	$0x45, %ah
-	cmpb	$0x01, %ah
-	je	112f		// x is NaN
-111:	fstp	%st(0)
-	fldl	MO(one)
-	ret
-
-112:	testb	$0x40, 15(%rsp)
-	jnz	111b
-	fadd	%st(0)
-	ret
-
-	// y == inf
-	.align ALIGNARG(4)
-12:	fstp	%st(0)		// pop y
-	fldl	MO(one)		// 1
-	fldt	8(%rsp)		// x : 1
-	fabs			// abs(x) : 1
-	fucompp			// < 1, == 1, or > 1
-	fnstsw
-	andb	$0x45, %ah
-	cmpb	$0x45, %ah
-	je	13f		// jump if x is NaN
-
-	cmpb	$0x40, %ah
-	je	14f		// jump if |x| == 1
-
-	shlb	$1, %ah
-	xorb	%ah, %dl
-	andl	$2, %edx
-#ifdef PIC
-	lea	inf_zero(%rip),%rcx
-	fldl	(%rcx, %rdx, 4)
-#else
-	fldl	inf_zero(,%rdx, 4)
-#endif
-	ret
-
-	.align ALIGNARG(4)
-14:	fldl	MO(one)
-	ret
-
-	.align ALIGNARG(4)
-13:	fldt	8(%rsp)		// load x == NaN
-	fadd	%st(0)
-	ret
-
-	.align ALIGNARG(4)
-	// x is inf
-15:	fstp	%st(0)		// y
-	testb	$2, %dh
-	jz	16f		// jump if x == +inf
-
-	// fistpll raises invalid exception for |y| >= 1L<<63, but y
-	// may be odd unless we know |y| >= 1L<<64.
-	fldl	MO(p64)		// 1L<<64 : y
-	fld	%st(1)		// y : 1L<<64 : y
-	fabs			// |y| : 1L<<64 : y
-	fcomip	%st(1), %st	// 1L<<64 : y
-	fstp	%st(0)		// y
-	jnc	16f
-	fldl	MO(p63)		// p63 : y
-	fxch			// y : p63
-	fprem			// y%p63 : p63
-	fstp	%st(1)		// y%p63
-
-	// We must find out whether y is an odd integer.
-	fld	%st		// y : y
-	fistpll	-8(%rsp)	// y
-	fildll	-8(%rsp)	// int(y) : y
-	fucomip %st(1),%st
-	ffreep	%st		// <empty>
-	jne	17f
-
-	// OK, the value is an integer, but is it odd?
-	mov	-8(%rsp), %eax
-	mov	-4(%rsp), %edx
-	andb	$1, %al
-	jz	18f		// jump if not odd
-	// It's an odd integer.
-	shrl	$31, %edx
-#ifdef PIC
-	lea	minf_mzero(%rip),%rcx
-	fldl	(%rcx, %rdx, 8)
-#else
-	fldl	minf_mzero(,%rdx, 8)
-#endif
-	ret
-
-	.align ALIGNARG(4)
-16:	fcompl	MO(zero)
-	fnstsw
-	shrl	$5, %eax
-	andl	$8, %eax
-#ifdef PIC
-	lea	inf_zero(%rip),%rcx
-	fldl	(%rcx, %rax, 1)
-#else
-	fldl	inf_zero(,%rax, 1)
-#endif
-	ret
-
-	.align ALIGNARG(4)
-17:	shll	$30, %edx	// sign bit for y in right position
-18:	shrl	$31, %edx
-#ifdef PIC
-	lea	inf_zero(%rip),%rcx
-	fldl	(%rcx, %rdx, 8)
-#else
-	fldl	inf_zero(,%rdx, 8)
-#endif
-	ret
-
-	.align ALIGNARG(4)
-	// x is 0
-20:	fstp	%st(0)		// y
-	testb	$2, %dl
-	jz	21f		// y > 0
-
-	// x is 0 and y is < 0.  We must find out whether y is an odd integer.
-	testb	$2, %dh
-	jz	25f
-
-	// fistpll raises invalid exception for |y| >= 1L<<63, but y
-	// may be odd unless we know |y| >= 1L<<64.
-	fldl	MO(p64)		// 1L<<64 : y
-	fld	%st(1)		// y : 1L<<64 : y
-	fabs			// |y| : 1L<<64 : y
-	fcomip	%st(1), %st	// 1L<<64 : y
-	fstp	%st(0)		// y
-	jnc	25f
-	fldl	MO(p63)		// p63 : y
-	fxch			// y : p63
-	fprem			// y%p63 : p63
-	fstp	%st(1)		// y%p63
-
-	fld	%st		// y : y
-	fistpll	-8(%rsp)	// y
-	fildll	-8(%rsp)	// int(y) : y
-	fucomip	%st(1),%st
-	ffreep	%st		// <empty>
-	jne	26f
-
-	// OK, the value is an integer, but is it odd?
-	mov	-8(%rsp),%eax
-	mov	-4(%rsp),%edx
-	andb	$1, %al
-	jz	27f		// jump if not odd
-	// It's an odd integer.
-	// Raise divide-by-zero exception and get minus infinity value.
-	fldl	MO(one)
-	fdivl	MO(zero)
-	fchs
-	ret
-
-25:	fstp	%st(0)
-26:
-27:	// Raise divide-by-zero exception and get infinity value.
-	fldl	MO(one)
-	fdivl	MO(zero)
-	ret
-
-	.align ALIGNARG(4)
-	// x is 0 and y is > 0.  We must find out whether y is an odd integer.
-21:	testb	$2, %dh
-	jz	22f
-
-	// fistpll raises invalid exception for |y| >= 1L<<63, but y
-	// may be odd unless we know |y| >= 1L<<64.
-	fldl	MO(p64)		// 1L<<64 : y
-	fxch			// y : 1L<<64
-	fcomi	%st(1), %st	// y : 1L<<64
-	fstp	%st(1)		// y
-	jnc	22f
-	fldl	MO(p63)		// p63 : y
-	fxch			// y : p63
-	fprem			// y%p63 : p63
-	fstp	%st(1)		// y%p63
-
-	fld	%st		// y : y
-	fistpll	-8(%rsp)	// y
-	fildll	-8(%rsp)	// int(y) : y
-	fucomip %st(1),%st
-	ffreep	%st		// <empty>
-	jne	23f
-
-	// OK, the value is an integer, but is it odd?
-	mov	-8(%rsp),%eax
-	mov	-4(%rsp),%edx
-	andb	$1, %al
-	jz	24f		// jump if not odd
-	// It's an odd integer.
-	fldl	MO(mzero)
-	ret
-
-22:	fstp	%st(0)
-23:
-24:	fldl	MO(zero)
-	ret
-
-END(__ieee754_powl)
-libm_alias_finite (__ieee754_powl, __powl)
diff --git a/sysdeps/x86_64/fpu/e_remainderl.S b/sysdeps/x86_64/fpu/e_remainderl.S
deleted file mode 100644
index c957f9889779..000000000000
--- a/sysdeps/x86_64/fpu/e_remainderl.S
+++ /dev/null
@@ -1,19 +0,0 @@
-/*
- * Public domain.
- *
- */
-
-#include <machine/asm.h>
-#include <libm-alias-finite.h>
-
-ENTRY(__ieee754_remainderl)
-	fldt	24(%rsp)
-	fldt	8(%rsp)
-1:	fprem1
-	fstsw	%ax
-	testl	$0x400,%eax
-	jnz	1b
-	fstp	%st(1)
-	ret
-END (__ieee754_remainderl)
-libm_alias_finite (__ieee754_remainderl, __remainderl)
diff --git a/sysdeps/x86_64/fpu/e_scalbl.S b/sysdeps/x86_64/fpu/e_scalbl.S
deleted file mode 100644
index 1b1b5cca266b..000000000000
--- a/sysdeps/x86_64/fpu/e_scalbl.S
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Public domain.
- */
-
-#include <machine/asm.h>
-#include <libm-alias-finite.h>
-
-	.section .rodata
-
-	.align ALIGNARG(4)
-	.type zero_nan,@object
-zero_nan:
-	.double 0.0
-nan:	.byte 0, 0, 0, 0, 0, 0, 0xff, 0x7f
-	.byte 0, 0, 0, 0, 0, 0, 0, 0x80
-	.byte 0, 0, 0, 0, 0, 0, 0xff, 0x7f
-	ASM_SIZE_DIRECTIVE(zero_nan)
-
-
-#ifdef PIC
-# define MO(op) op##(%rip)
-#else
-# define MO(op) op
-#endif
-
-	.text
-ENTRY(__ieee754_scalbl)
-	fldt	24(%rsp)
-	fxam
-	fnstsw
-	fldt	8(%rsp)
-	andl	$0x4700, %eax
-	cmpl	$0x0700, %eax
-	je	1f
-	andl	$0x4500, %eax
-	cmpl	$0x0100, %eax
-	je	2f
-	fxam
-	fnstsw
-	andl	$0x4500, %eax
-	cmpl	$0x0100, %eax
-	je	2f
-	fld	%st(1)
-	frndint
-	fcomip	%st(2), %st
-	jne	4f
-	fscale
-	fstp	%st(1)
-	ret
-
-	/* y is -inf */
-1:	fxam
-	fnstsw
-	movl	16(%rsp), %edx
-	shrl	$5, %eax
-	fstp	%st
-	fstp	%st
-	andl	$0x8000, %edx
-	andl	$0x0228, %eax
-	cmpl	$0x0028, %eax
-	je	4f
-	andl	$8, %eax
-	shrl	$11, %edx
-	addl	%edx, %eax
-#ifdef PIC
-	lea	zero_nan(%rip),%rdx
-	fldl	(%rdx,%rax,1)
-#else
-	fldl	zero_nan(%rax, 1)
-#endif
-	ret
-
-	/* The result is NaN; raise an exception for sNaN arguments.  */
-2:	faddp
-	ret
-
-	/* Return NaN and raise the invalid exception.  */
-4:	fstp	%st
-	fstp	%st
-	fldz
-	fdiv	%st
-	ret
-END(__ieee754_scalbl)
-libm_alias_finite (__ieee754_scalbl, __scalbl)
diff --git a/sysdeps/x86_64/fpu/s_expm1l.S b/sysdeps/x86_64/fpu/s_expm1l.S
deleted file mode 100644
index 7fbd99b0db5a..000000000000
--- a/sysdeps/x86_64/fpu/s_expm1l.S
+++ /dev/null
@@ -1,2 +0,0 @@
-#define USE_AS_EXPM1L
-#include <e_expl.S>
diff --git a/sysdeps/x86_64/fpu/s_finitel.S b/sysdeps/x86_64/fpu/s_finitel.S
deleted file mode 100644
index 12b31043744b..000000000000
--- a/sysdeps/x86_64/fpu/s_finitel.S
+++ /dev/null
@@ -1,12 +0,0 @@
-
-#include <machine/asm.h>
-
-ENTRY(__finitel)
-	movl	16(%rsp),%eax
-	orl	$0xffff8000, %eax
-	incl	%eax
-	shrl	$31, %eax
-	ret
-END (__finitel)
-weak_alias (__finitel, finitel)
-hidden_def (__finitel)
diff --git a/sysdeps/x86_64/fpu/s_fmax.S b/sysdeps/x86_64/fpu/s_fmax.S
deleted file mode 100644
index ac362e9cb7c5..000000000000
--- a/sysdeps/x86_64/fpu/s_fmax.S
+++ /dev/null
@@ -1,52 +0,0 @@
-/* Compute maximum of two numbers, regarding NaN as missing argument.
-   Copyright (C) 2002-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <libm-alias-double.h>
-
-	.text
-ENTRY(__fmax)
-	ucomisd	%xmm0, %xmm1
-	jp	1f		// jump if unordered
-	maxsd	%xmm1, %xmm0
-	jmp	2f
-
-1:	ucomisd	%xmm1, %xmm1	// Is xmm1 a NaN?
-	jp	3f
-	// xmm0 is a NaN; xmm1 is not.  Test if xmm0 is signaling.
-	movsd	%xmm0, -8(%rsp)
-	testb	$0x8, -2(%rsp)
-	jz	4f
-	movsd	%xmm1, %xmm0	// otherwise return xmm1
-	ret
-
-3:	// xmm1 is a NaN; xmm0 may or may not be.
-	ucomisd	%xmm0, %xmm0
-	jp	4f
-	// xmm1 is a NaN; xmm0 is not.  Test if xmm1 is signaling.
-	movsd	%xmm1, -8(%rsp)
-	testb	$0x8, -2(%rsp)
-	jz	4f
-	ret
-
-4:	// Both arguments are NaNs, or one is a signaling NaN.
-	addsd	%xmm1, %xmm0
-
-2:	ret
-END(__fmax)
-libm_alias_double (__fmax, fmax)
diff --git a/sysdeps/x86_64/fpu/s_fmaxf.S b/sysdeps/x86_64/fpu/s_fmaxf.S
deleted file mode 100644
index 7c9e10055510..000000000000
--- a/sysdeps/x86_64/fpu/s_fmaxf.S
+++ /dev/null
@@ -1,52 +0,0 @@
-/* Compute maximum of two numbers, regarding NaN as missing argument.
-   Copyright (C) 2002-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <libm-alias-float.h>
-
-	.text
-ENTRY(__fmaxf)
-	ucomiss	%xmm0, %xmm1
-	jp	1f		// jump if unordered
-	maxss	%xmm1, %xmm0
-	jmp	2f
-
-1:	ucomiss	%xmm1, %xmm1	// Is xmm1 a NaN?
-	jp	3f
-	// xmm0 is a NaN; xmm1 is not.  Test if xmm0 is signaling.
-	movss	%xmm0, -4(%rsp)
-	testb	$0x40, -2(%rsp)
-	jz	4f
-	movss	%xmm1, %xmm0	// otherwise return xmm1
-	ret
-
-3:	// xmm1 is a NaN; xmm0 may or may not be.
-	ucomiss	%xmm0, %xmm0
-	jp	4f
-	// xmm1 is a NaN; xmm0 is not.  Test if xmm1 is signaling.
-	movss	%xmm1, -4(%rsp)
-	testb	$0x40, -2(%rsp)
-	jz	4f
-	ret
-
-4:	// Both arguments are NaNs, or one is a signaling NaN.
-	addss	%xmm1, %xmm0
-
-2:	ret
-END(__fmaxf)
-libm_alias_float (__fmax, fmax)
diff --git a/sysdeps/x86_64/fpu/s_fmaxl.S b/sysdeps/x86_64/fpu/s_fmaxl.S
deleted file mode 100644
index 1505d35ccc3f..000000000000
--- a/sysdeps/x86_64/fpu/s_fmaxl.S
+++ /dev/null
@@ -1,58 +0,0 @@
-/* Compute maximum of two numbers, regarding NaN as missing argument.
-   Copyright (C) 1997-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <libm-alias-ldouble.h>
-
-	.text
-ENTRY(__fmaxl)
-	fldt	8(%rsp)		// x
-	fldt	24(%rsp)	// x : y
-
-	fucomi	%st(1), %st
-	jp	2f
-	fcmovb	%st(1), %st
-
-	fstp	%st(1)
-
-	ret
-
-2:	// Unordered.
-	fucomi	%st(0), %st
-	jp	3f
-	// st(1) is a NaN; st(0) is not.  Test if st(1) is signaling.
-	testb	$0x40, 15(%rsp)
-	jz	4f
-	fstp	%st(1)
-	ret
-
-3:	// st(0) is a NaN; st(1) may or may not be.
-	fxch
-	fucomi	%st(0), %st
-	jp	4f
-	// st(1) is a NaN; st(0) is not.  Test if st(1) is signaling.
-	testb	$0x40, 31(%rsp)
-	jz	4f
-	fstp	%st(1)
-	ret
-
-4:	// Both arguments are NaNs, or one is a signaling NaN.
-	faddp
-	ret
-END(__fmaxl)
-libm_alias_ldouble (__fmax, fmax)
diff --git a/sysdeps/x86_64/fpu/s_fmin.S b/sysdeps/x86_64/fpu/s_fmin.S
deleted file mode 100644
index 2f50c0b7c083..000000000000
--- a/sysdeps/x86_64/fpu/s_fmin.S
+++ /dev/null
@@ -1,52 +0,0 @@
-/* Compute minimum of two numbers, regarding NaN as missing argument.
-   Copyright (C) 2002-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <libm-alias-double.h>
-
-	.text
-ENTRY(__fmin)
-	ucomisd	%xmm0, %xmm1
-	jp	1f		// jump if unordered
-	minsd	%xmm1, %xmm0
-	jmp	2f
-
-1:	ucomisd	%xmm1, %xmm1	// Is xmm1 a NaN?
-	jp	3f
-	// xmm0 is a NaN; xmm1 is not.  Test if xmm0 is signaling.
-	movsd	%xmm0, -8(%rsp)
-	testb	$0x8, -2(%rsp)
-	jz	4f
-	movsd	%xmm1, %xmm0	// otherwise return xmm1
-	ret
-
-3:	// xmm1 is a NaN; xmm0 may or may not be.
-	ucomisd	%xmm0, %xmm0
-	jp	4f
-	// xmm1 is a NaN; xmm0 is not.  Test if xmm1 is signaling.
-	movsd	%xmm1, -8(%rsp)
-	testb	$0x8, -2(%rsp)
-	jz	4f
-	ret
-
-4:	// Both arguments are NaNs, or one is a signaling NaN.
-	addsd	%xmm1, %xmm0
-
-2:	ret
-END(__fmin)
-libm_alias_double (__fmin, fmin)
diff --git a/sysdeps/x86_64/fpu/s_fminf.S b/sysdeps/x86_64/fpu/s_fminf.S
deleted file mode 100644
index cf584b6e9867..000000000000
--- a/sysdeps/x86_64/fpu/s_fminf.S
+++ /dev/null
@@ -1,52 +0,0 @@
-/* Compute minimum of two numbers, regarding NaN as missing argument.
-   Copyright (C) 2002-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <libm-alias-float.h>
-
-	.text
-ENTRY(__fminf)
-	ucomiss	%xmm0, %xmm1
-	jp	1f		// jump if unordered
-	minss	%xmm1, %xmm0
-	jmp	2f
-
-1:	ucomiss	%xmm1, %xmm1	// Is xmm1 a NaN?
-	jp	3f
-	// xmm0 is a NaN; xmm1 is not.  Test if xmm0 is signaling.
-	movss	%xmm0, -4(%rsp)
-	testb	$0x40, -2(%rsp)
-	jz	4f
-	movss	%xmm1, %xmm0	// otherwise return xmm1
-	ret
-
-3:	// xmm1 is a NaN; xmm0 may or may not be.
-	ucomiss	%xmm0, %xmm0
-	jp	4f
-	// xmm1 is a NaN; xmm0 is not.  Test if xmm1 is signaling.
-	movss	%xmm1, -4(%rsp)
-	testb	$0x40, -2(%rsp)
-	jz	4f
-	ret
-
-4:	// Both arguments are NaNs, or one is a signaling NaN.
-	addss	%xmm1, %xmm0
-
-2:	ret
-END(__fminf)
-libm_alias_float (__fmin, fmin)
diff --git a/sysdeps/x86_64/fpu/s_fminl.S b/sysdeps/x86_64/fpu/s_fminl.S
deleted file mode 100644
index 280341ed7bbc..000000000000
--- a/sysdeps/x86_64/fpu/s_fminl.S
+++ /dev/null
@@ -1,58 +0,0 @@
-/* Compute minimum of two numbers, regarding NaN as missing argument.
-   Copyright (C) 1997-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <libm-alias-ldouble.h>
-
-	.text
-ENTRY(__fminl)
-	fldt	8(%rsp)		// x
-	fldt	24(%rsp)	// x : y
-
-	fucomi	%st(1), %st
-	jp	2f
-	fcmovnb	%st(1), %st
-
-	fstp	%st(1)
-
-	ret
-
-2:	// Unordered.
-	fucomi	%st(0), %st
-	jp	3f
-	// st(1) is a NaN; st(0) is not.  Test if st(1) is signaling.
-	testb	$0x40, 15(%rsp)
-	jz	4f
-	fstp	%st(1)
-	ret
-
-3:	// st(0) is a NaN; st(1) may or may not be.
-	fxch
-	fucomi	%st(0), %st
-	jp	4f
-	// st(1) is a NaN; st(0) is not.  Test if st(1) is signaling.
-	testb	$0x40, 31(%rsp)
-	jz	4f
-	fstp	%st(1)
-	ret
-
-4:	// Both arguments are NaNs, or one is a signaling NaN.
-	faddp
-	ret
-END(__fminl)
-libm_alias_ldouble (__fmin, fmin)
diff --git a/sysdeps/x86_64/fpu/s_llrint.S b/sysdeps/x86_64/fpu/s_llrint.S
deleted file mode 100644
index 9188b24b1f69..000000000000
--- a/sysdeps/x86_64/fpu/s_llrint.S
+++ /dev/null
@@ -1,32 +0,0 @@
-/* Round argument to nearest integral value according to current rounding
-   direction.
-   Copyright (C) 2002-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <libm-alias-double.h>
-
-	.text
-ENTRY(__llrint)
-	cvtsd2si %xmm0,%rax
-	ret
-END(__llrint)
-libm_alias_double (__llrint, llrint)
-#ifndef __ILP32__
-strong_alias (__llrint, __lrint)
-libm_alias_double (__llrint, lrint)
-#endif
diff --git a/sysdeps/x86_64/fpu/s_llrintf.S b/sysdeps/x86_64/fpu/s_llrintf.S
deleted file mode 100644
index 8748895f7058..000000000000
--- a/sysdeps/x86_64/fpu/s_llrintf.S
+++ /dev/null
@@ -1,32 +0,0 @@
-/* Round argument to nearest integral value according to current rounding
-   direction.
-   Copyright (C) 2002-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <libm-alias-float.h>
-
-	.text
-ENTRY(__llrintf)
-	cvtss2si %xmm0,%rax
-	ret
-END(__llrintf)
-libm_alias_float (__llrint, llrint)
-#ifndef __ILP32__
-strong_alias (__llrintf, __lrintf)
-libm_alias_float (__llrint, lrint)
-#endif
diff --git a/sysdeps/x86_64/fpu/s_llrintl.S b/sysdeps/x86_64/fpu/s_llrintl.S
deleted file mode 100644
index 8b5a8de05f90..000000000000
--- a/sysdeps/x86_64/fpu/s_llrintl.S
+++ /dev/null
@@ -1,35 +0,0 @@
-/* Round argument to nearest integral value according to current rounding
-   direction.
-   Copyright (C) 1997-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <libm-alias-ldouble.h>
-
-	.text
-ENTRY(__llrintl)
-	fldt	8(%rsp)
-	fistpll	-8(%rsp)
-	fwait
-	movq	-8(%rsp),%rax
-	ret
-END(__llrintl)
-libm_alias_ldouble (__llrint, llrint)
-#ifndef __ILP32__
-strong_alias (__llrintl, __lrintl)
-libm_alias_ldouble (__llrint, lrint)
-#endif
diff --git a/sysdeps/x86_64/fpu/s_log1pl.S b/sysdeps/x86_64/fpu/s_log1pl.S
deleted file mode 100644
index 187c65e668a5..000000000000
--- a/sysdeps/x86_64/fpu/s_log1pl.S
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Public domain.
- *
- */
-
-#include <machine/asm.h>
-
-RCSID("$NetBSD: s_log1p.S,v 1.7 1995/05/09 00:10:58 jtc Exp $")
-
-	.section .rodata
-
-	.align ALIGNARG(4)
-	/* The fyl2xp1 can only be used for values in
-		-1 + sqrt(2) / 2 <= x <= 1 - sqrt(2) / 2
-	   0.29 is a safe value.
-	*/
-limit:	.quad   0x947ae147ae147ae1	/* 0.29  */
-	.short	0x3ffd
-	/* Please note:	 we use a double value here.  Since 1.0 has
-	   an exact representation this does not effect the accuracy
-	   but it helps to optimize the code.  */
-one:	.double 1.0
-
-/*
- * Use the fyl2xp1 function when the argument is in the range -0.29 to 0.29,
- * otherwise fyl2x with the needed extra computation.
- */
-#ifdef PIC
-#define MO(op) op##(%rip)
-#else
-#define MO(op) op
-#endif
-
-	.text
-ENTRY(__log1pl)
-	fldln2
-
-	fldt	8(%rsp)
-
-	fxam
-	fnstsw
-	fld	%st
-	testb	$1, %ah
-	jnz	3f		// in case x is NaN or Inf
-4:
-	fabs
-	fldt	MO(limit)
-	fcompp
-	fnstsw
-	andb	$1,%ah
-	jz	2f
-
-	movzwl	8+8(%rsp), %eax
-	xorb	$0x80, %ah
-	cmpl	$0xc040, %eax
-	jae	5f
-
-	faddl	MO(one)
-5:	fyl2x
-	ret
-
-2:	fyl2xp1
-	ret
-
-3:	testb	$4, %ah
-	jnz	4b		// in case x is Inf
-	fstp	%st(1)
-	fstp	%st(1)
-	fadd	%st(0)
-	ret
-
-END (__log1pl)
diff --git a/sysdeps/x86_64/fpu/s_lrint.S b/sysdeps/x86_64/fpu/s_lrint.S
deleted file mode 100644
index dfc31359a090..000000000000
--- a/sysdeps/x86_64/fpu/s_lrint.S
+++ /dev/null
@@ -1 +0,0 @@
-/* Not needed, see s_llrint.S.  */
diff --git a/sysdeps/x86_64/fpu/s_lrintf.S b/sysdeps/x86_64/fpu/s_lrintf.S
deleted file mode 100644
index fcdc4dca9a5e..000000000000
--- a/sysdeps/x86_64/fpu/s_lrintf.S
+++ /dev/null
@@ -1 +0,0 @@
-/* Not needed, see s_llrintf.S.  */
diff --git a/sysdeps/x86_64/fpu/s_lrintl.S b/sysdeps/x86_64/fpu/s_lrintl.S
deleted file mode 100644
index ef9c45d00d03..000000000000
--- a/sysdeps/x86_64/fpu/s_lrintl.S
+++ /dev/null
@@ -1 +0,0 @@
-/* Not needed, see s_llrintl.S.  */
diff --git a/sysdeps/x86_64/fpu/s_nearbyintl.S b/sysdeps/x86_64/fpu/s_nearbyintl.S
deleted file mode 100644
index fae4dac3e5f3..000000000000
--- a/sysdeps/x86_64/fpu/s_nearbyintl.S
+++ /dev/null
@@ -1,18 +0,0 @@
-/*
- * Public domain.
- */
-
-#include <libm-alias-ldouble.h>
-#include <machine/asm.h>
-
-ENTRY(__nearbyintl)
-	fldt	8(%rsp)
-	fnstenv	-28(%rsp)
-	frndint
-	fnstsw
-	andl	$0x1, %eax
-	orl	%eax, -24(%rsp)
-	fldenv	-28(%rsp)
-	ret
-END (__nearbyintl)
-libm_alias_ldouble (__nearbyint, nearbyint)
diff --git a/sysdeps/x86_64/fpu/s_scalbnl.S b/sysdeps/x86_64/fpu/s_scalbnl.S
deleted file mode 100644
index cfb58cfb92a3..000000000000
--- a/sysdeps/x86_64/fpu/s_scalbnl.S
+++ /dev/null
@@ -1,14 +0,0 @@
-/*
- * Public domain.
- */
-
-#include <machine/asm.h>
-
-ENTRY(__scalbnl)
-	movl	%edi,-4(%rsp)
-	fildl	-4(%rsp)
-	fldt	8(%rsp)
-	fscale
-	fstp	%st(1)
-	ret
-END (__scalbnl)
diff --git a/sysdeps/x86_64/fpu/s_signbit.S b/sysdeps/x86_64/fpu/s_signbit.S
deleted file mode 100644
index 0c76d9a20b48..000000000000
--- a/sysdeps/x86_64/fpu/s_signbit.S
+++ /dev/null
@@ -1,25 +0,0 @@
-/* Return nonzero value if number is negative.
-   Copyright (C) 2009-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-
-ENTRY(__signbit)
-	pmovmskb %xmm0, %eax
-	andl	$0x80, %eax
-	ret
-END(__signbit)
diff --git a/sysdeps/x86_64/fpu/s_signbitf.S b/sysdeps/x86_64/fpu/s_signbitf.S
deleted file mode 100644
index a5651b6b75a6..000000000000
--- a/sysdeps/x86_64/fpu/s_signbitf.S
+++ /dev/null
@@ -1,25 +0,0 @@
-/* Return nonzero value if number is negative.
-   Copyright (C) 2009-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-
-ENTRY(__signbitf)
-	pmovmskb %xmm0, %eax
-	andl	$0x8, %eax
-	ret
-END(__signbitf)
diff --git a/sysdeps/x86_64/jmpbuf-unwind.h b/sysdeps/x86_64/jmpbuf-unwind.h
index a5f3194068bd..cc9471adc12d 100644
--- a/sysdeps/x86_64/jmpbuf-unwind.h
+++ b/sysdeps/x86_64/jmpbuf-unwind.h
@@ -21,11 +21,24 @@
 #include <unwind.h>
 #include <sysdep.h>
 #include <pointer_guard.h>
+#include <stdfil.h>
+#include <stdbool.h>
+
+static inline bool __attribute__ ((unused))
+_jmpbuf_unwinds (void)
+{
+  zerror("cannot do _JMPBUF_UNWINDS");
+  return false;
+}
 
 /* Test if longjmp to JMPBUF would unwind the frame
    containing a local variable at ADDRESS.  */
-#define _JMPBUF_UNWINDS(jmpbuf, address, demangle) \
-  ((void *) (address) < (void *) demangle ((jmpbuf)[JB_RSP]))
+#define _JMPBUF_UNWINDS(jmpbuf, address, demangle) ({    \
+      (void) (address);                                  \
+      (void) (demangle);                                 \
+      (void) (jmpbuf);                                   \
+      _jmpbuf_unwinds ();                                \
+    })
 
 #define _JMPBUF_CFA_UNWINDS_ADJ(_jmpbuf, _context, _adj) \
   _JMPBUF_UNWINDS_ADJ (_jmpbuf, \
@@ -35,9 +48,9 @@
 static inline uintptr_t __attribute__ ((unused))
 _jmpbuf_sp (__jmp_buf regs)
 {
-  uintptr_t sp = regs[JB_RSP];
-  PTR_DEMANGLE (sp);
-  return sp;
+  /* It's weird but true that zget_jmp_buf_frame works on regs, since regs is also an array, and
+     is guaranteed to be the first thing in the jmp_buf. */
+  return (uintptr_t) zget_jmp_buf_frame (regs);
 }
 
 #define _JMPBUF_UNWINDS_ADJ(_jmpbuf, _address, _adj) \
diff --git a/sysdeps/x86_64/libc-start.h b/sysdeps/x86_64/libc-start.h
index 63fef17029a9..66350a585714 100644
--- a/sysdeps/x86_64/libc-start.h
+++ b/sysdeps/x86_64/libc-start.h
@@ -16,7 +16,6 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#ifndef SHARED
 # define ARCH_SETUP_IREL() apply_irel ()
 # define ARCH_APPLY_IREL()
 # ifdef __CET__
@@ -71,4 +70,3 @@ get_cet_feature (void)
 # else
 #  define ARCH_SETUP_TLS()	__libc_setup_tls ()
 # endif
-#endif /* !SHARED */
diff --git a/sysdeps/x86_64/lshift.S b/sysdeps/x86_64/lshift.S
deleted file mode 100644
index 5509aa96b2ed..000000000000
--- a/sysdeps/x86_64/lshift.S
+++ /dev/null
@@ -1,116 +0,0 @@
-/* x86-64 __mpn_lshift --
-   Copyright (C) 2007-2024 Free Software Foundation, Inc.
-   This file is part of the GNU MP Library.
-
-   The GNU MP Library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU Lesser General Public License as published by
-   the Free Software Foundation; either version 2.1 of the License, or (at your
-   option) any later version.
-
-   The GNU MP Library is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
-   License for more details.
-
-   You should have received a copy of the GNU Lesser General Public License
-   along with the GNU MP Library; see the file COPYING.LIB.  If not,
-   see <https://www.gnu.org/licenses/>.  */
-
-#include "sysdep.h"
-#include "asm-syntax.h"
-
-#define rp	%rdi
-#define up	%rsi
-#define n	%rdx
-#define cnt	%cl
-
-	.text
-ENTRY (__mpn_lshift)
-	lea	-8(rp,n,8), rp
-	lea	-8(up,n,8), up
-
-	mov	%edx, %eax
-	and	$3, %eax
-	jne	L(nb00)
-L(b00):	/* n = 4, 8, 12, ... */
-	mov	(up), %r10
-	mov	-8(up), %r11
-	xor	%eax, %eax
-	shld	%cl, %r10, %rax
-	mov	-16(up), %r8
-	lea	24(rp), rp
-	sub	$4, n
-	jmp	L(00)
-
-L(nb00):/* n = 1, 5, 9, ... */
-	cmp	$2, %eax
-	jae	L(nb01)
-L(b01):	mov	(up), %r9
-	xor	%eax, %eax
-	shld	%cl, %r9, %rax
-	sub	$2, n
-	jb	L(le1)
-	mov	-8(up), %r10
-	mov	-16(up), %r11
-	lea	-8(up), up
-	lea	16(rp), rp
-	jmp	L(01)
-L(le1):	shl	%cl, %r9
-	mov	%r9, (rp)
-	ret
-
-L(nb01):/* n = 2, 6, 10, ... */
-	jne	L(b11)
-L(b10):	mov	(up), %r8
-	mov	-8(up), %r9
-	xor	%eax, %eax
-	shld	%cl, %r8, %rax
-	sub	$3, n
-	jb	L(le2)
-	mov	-16(up), %r10
-	lea	-16(up), up
-	lea	8(rp), rp
-	jmp	L(10)
-L(le2):	shld	%cl, %r9, %r8
-	mov	%r8, (rp)
-	shl	%cl, %r9
-	mov	%r9, -8(rp)
-	ret
-
-	.p2align 4		/* performance critical! */
-L(b11):	/* n = 3, 7, 11, ... */
-	mov	(up), %r11
-	mov	-8(up), %r8
-	xor	%eax, %eax
-	shld	%cl, %r11, %rax
-	mov	-16(up), %r9
-	lea	-24(up), up
-	sub	$4, n
-	jb	L(end)
-
-	.p2align 4
-L(top):	shld	%cl, %r8, %r11
-	mov	(up), %r10
-	mov	%r11, (rp)
-L(10):	shld	%cl, %r9, %r8
-	mov	-8(up), %r11
-	mov	%r8, -8(rp)
-L(01):	shld	%cl, %r10, %r9
-	mov	-16(up), %r8
-	mov	%r9, -16(rp)
-L(00):	shld	%cl, %r11, %r10
-	mov	-24(up), %r9
-	mov	%r10, -24(rp)
-	add	$-32, up
-	lea	-32(rp), rp
-	sub	$4, n
-	jnc	L(top)
-
-L(end):	shld	%cl, %r8, %r11
-	mov	%r11, (rp)
-	shld	%cl, %r9, %r8
-	mov	%r8, -8(rp)
-	shl	%cl, %r9
-	mov	%r9, -16(rp)
-	ret
-END (__mpn_lshift)
diff --git a/sysdeps/x86_64/memchr.S b/sysdeps/x86_64/memchr.S
deleted file mode 100644
index 2d6176fe9bbe..000000000000
--- a/sysdeps/x86_64/memchr.S
+++ /dev/null
@@ -1,27 +0,0 @@
-/* Copyright (C) 2011-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#define MEMCHR	__memchr
-
-#define DEFAULT_IMPL_V1	"multiarch/memchr-sse2.S"
-#define DEFAULT_IMPL_V3	"multiarch/memchr-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/memchr-evex.S"
-
-#include "isa-default-impl.h"
-
-weak_alias (__memchr, memchr)
-libc_hidden_builtin_def(memchr)
diff --git a/sysdeps/x86_64/memcmp.S b/sysdeps/x86_64/memcmp.S
deleted file mode 100644
index 59cb2478a18f..000000000000
--- a/sysdeps/x86_64/memcmp.S
+++ /dev/null
@@ -1,28 +0,0 @@
-/* memcmp hook for non-multiarch and RTLD build.
-   Copyright (C) 2009-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#define MEMCMP	memcmp
-
-#define DEFAULT_IMPL_V1	"multiarch/memcmp-sse2.S"
-#define DEFAULT_IMPL_V3	"multiarch/memcmp-avx2-movbe.S"
-#define DEFAULT_IMPL_V4	"multiarch/memcmp-evex-movbe.S"
-
-#include "isa-default-impl.h"
-
-libc_hidden_builtin_def(memcmp)
-weak_alias (memcmp, bcmp)
diff --git a/sysdeps/x86_64/memcpy.S b/sysdeps/x86_64/memcpy.S
deleted file mode 100644
index 4922cba6576b..000000000000
--- a/sysdeps/x86_64/memcpy.S
+++ /dev/null
@@ -1 +0,0 @@
-/* Implemented in memmove.S.  */
diff --git a/sysdeps/x86_64/memmove.S b/sysdeps/x86_64/memmove.S
deleted file mode 100644
index 66e04d408f24..000000000000
--- a/sysdeps/x86_64/memmove.S
+++ /dev/null
@@ -1,66 +0,0 @@
-/* Optimized memmove for x86-64.
-   Copyright (C) 2016-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-
-#ifdef USE_MULTIARCH
-# if !IS_IN (libc)
-#  define MEMCPY_SYMBOL(p,s)		memcpy
-# endif
-#else
-# if defined SHARED && IS_IN (libc)
-#  define MEMCPY_SYMBOL(p,s)		__memcpy
-# else
-#  define MEMCPY_SYMBOL(p,s)		memcpy
-# endif
-#endif
-#if !defined USE_MULTIARCH || !IS_IN (libc)
-# define MEMPCPY_SYMBOL(p,s)		__mempcpy
-#endif
-
-#define MEMMOVE_CHK_SYMBOL(p,s)	p
-#define MEMMOVE_SYMBOL(p,s)	memmove
-
-
-#define DEFAULT_IMPL_V1	"multiarch/memmove-sse2-unaligned-erms.S"
-#define DEFAULT_IMPL_V3	"multiarch/memmove-avx-unaligned-erms.S"
-#define DEFAULT_IMPL_V4	"multiarch/memmove-evex-unaligned-erms.S"
-
-#include "isa-default-impl.h"
-
-weak_alias (__mempcpy, mempcpy)
-
-#ifndef USE_MULTIARCH
-libc_hidden_builtin_def (memmove)
-libc_hidden_builtin_def (__memmove_chk)
-libc_hidden_builtin_def (__memcpy_chk)
-libc_hidden_builtin_def (__mempcpy_chk)
-# if defined SHARED && IS_IN (libc)
-strong_alias (memmove, __memcpy)
-libc_hidden_ver (memmove, memcpy)
-# endif
-libc_hidden_def (__mempcpy)
-weak_alias (__mempcpy, mempcpy)
-libc_hidden_builtin_def (mempcpy)
-
-
-# if defined SHARED && IS_IN (libc)
-#  undef memcpy
-#  include <shlib-compat.h>
-versioned_symbol (libc, __memcpy, memcpy, GLIBC_2_14);
-# endif
-#endif
diff --git a/sysdeps/x86_64/mempcpy.S b/sysdeps/x86_64/mempcpy.S
deleted file mode 100644
index d98500a78a37..000000000000
--- a/sysdeps/x86_64/mempcpy.S
+++ /dev/null
@@ -1 +0,0 @@
-/* Implemented in memcpy.S.  */
diff --git a/sysdeps/x86_64/memrchr.S b/sysdeps/x86_64/memrchr.S
deleted file mode 100644
index ec5f511a4f31..000000000000
--- a/sysdeps/x86_64/memrchr.S
+++ /dev/null
@@ -1,29 +0,0 @@
-/* memrchr dispatch for RTLD and non-multiarch build
-
-   Copyright (C) 2011-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#define MEMRCHR	__memrchr
-
-#define DEFAULT_IMPL_V1	"multiarch/memrchr-sse2.S"
-#define DEFAULT_IMPL_V3	"multiarch/memrchr-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/memrchr-evex.S"
-
-#include "isa-default-impl.h"
-
-libc_hidden_def (__memrchr)
-weak_alias (__memrchr, memrchr)
diff --git a/sysdeps/x86_64/memset.S b/sysdeps/x86_64/memset.S
deleted file mode 100644
index f627bb941b08..000000000000
--- a/sysdeps/x86_64/memset.S
+++ /dev/null
@@ -1,41 +0,0 @@
-/* memset -- set memory area to CH/0
-   Optimized version for x86-64.
-   Copyright (C) 2002-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-
-#define MEMSET_SYMBOL(p,s)	memset
-#define MEMSET_CHK_SYMBOL(p,s)	p
-
-#define WMEMSET_SYMBOL(p,s)	__wmemset
-#define WMEMSET_CHK_SYMBOL(p,s) p
-
-#define DEFAULT_IMPL_V1	"multiarch/memset-sse2-unaligned-erms.S"
-#define DEFAULT_IMPL_V3	"multiarch/memset-avx2-unaligned-erms.S"
-#define DEFAULT_IMPL_V4	"multiarch/memset-evex-unaligned-erms.S"
-
-#include "isa-default-impl.h"
-
-libc_hidden_builtin_def (memset)
-libc_hidden_builtin_def (__memset_chk)
-
-#if IS_IN (libc)
-libc_hidden_def (__wmemset)
-weak_alias (__wmemset, wmemset)
-libc_hidden_weak (wmemset)
-#endif
diff --git a/sysdeps/x86_64/mp_clz_tab.c b/sysdeps/x86_64/mp_clz_tab.c
deleted file mode 100644
index 7b13a394da86..000000000000
--- a/sysdeps/x86_64/mp_clz_tab.c
+++ /dev/null
@@ -1 +0,0 @@
-/* __clz_tab not needed on x86-64.  */
diff --git a/sysdeps/x86_64/mul_1.S b/sysdeps/x86_64/mul_1.S
deleted file mode 100644
index 3a493e09997e..000000000000
--- a/sysdeps/x86_64/mul_1.S
+++ /dev/null
@@ -1,128 +0,0 @@
-/* AMD64 __mpn_mul_1 -- Multiply a limb vector with a limb and store
-   the result in a second limb vector.
-   Copyright (C) 2003-2024 Free Software Foundation, Inc.
-   This file is part of the GNU MP Library.
-
-   The GNU MP Library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU Lesser General Public License as published by
-   the Free Software Foundation; either version 2.1 of the License, or (at your
-   option) any later version.
-
-   The GNU MP Library is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
-   License for more details.
-
-   You should have received a copy of the GNU Lesser General Public License
-   along with the GNU MP Library; see the file COPYING.LIB.  If not,
-   see <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include "asm-syntax.h"
-
-#define rp	%rdi
-#define up	%rsi
-#define n_param	%rdx
-#define vl	%rcx
-
-#define n	%r11
-
-	.text
-ENTRY (__mpn_mul_1)
-	push	%rbx
-	cfi_adjust_cfa_offset (8)
-	cfi_rel_offset (%rbx, 0)
-	xor	%r10, %r10
-	mov	(up), %rax		/* read first u limb early */
-	mov	n_param, %rbx		/* move away n from rdx, mul uses it */
-	mul	vl
-	mov	%rbx, %r11
-
-	add	%r10, %rax
-	adc	$0, %rdx
-
-	and	$3, %ebx
-	jz	L(b0)
-	cmp	$2, %ebx
-	jz	L(b2)
-	jg	L(b3)
-
-L(b1):	dec	n
-	jne	L(gt1)
-	mov	%rax, (rp)
-	jmp	L(ret)
-L(gt1):	lea	8(up,n,8), up
-	lea	-8(rp,n,8), rp
-	neg	n
-	xor	%r10, %r10
-	xor	%ebx, %ebx
-	mov	%rax, %r9
-	mov	(up,n,8), %rax
-	mov	%rdx, %r8
-	jmp	L(L1)
-
-L(b0):	lea	(up,n,8), up
-	lea	-16(rp,n,8), rp
-	neg	n
-	xor	%r10, %r10
-	mov	%rax, %r8
-	mov	%rdx, %rbx
-	jmp	L(L0)
-
-L(b3):	lea	-8(up,n,8), up
-	lea	-24(rp,n,8), rp
-	neg	n
-	mov	%rax, %rbx
-	mov	%rdx, %r10
-	jmp	L(L3)
-
-L(b2):	lea	-16(up,n,8), up
-	lea	-32(rp,n,8), rp
-	neg	n
-	xor	%r8, %r8
-	xor	%ebx, %ebx
-	mov	%rax, %r10
-	mov	24(up,n,8), %rax
-	mov	%rdx, %r9
-	jmp	L(L2)
-
-	.p2align 4
-L(top): mov	%r10, (rp,n,8)
-	add	%rax, %r9
-	mov	(up,n,8), %rax
-	adc	%rdx, %r8
-	mov	$0, %r10d
-L(L1):	mul	vl
-	mov	%r9, 8(rp,n,8)
-	add	%rax, %r8
-	adc	%rdx, %rbx
-L(L0):	mov	8(up,n,8), %rax
-	mul	vl
-	mov	%r8, 16(rp,n,8)
-	add	%rax, %rbx
-	adc	%rdx, %r10
-L(L3):	mov	16(up,n,8), %rax
-	mul	vl
-	mov	%rbx, 24(rp,n,8)
-	mov	$0, %r8d                # zero
-	mov	%r8, %rbx               # zero
-	add	%rax, %r10
-	mov	24(up,n,8), %rax
-	mov	%r8, %r9                # zero
-	adc	%rdx, %r9
-L(L2):	mul	vl
-	add	$4, n
-	js	L(top)
-
-	mov	%r10, (rp,n,8)
-	add	%rax, %r9
-	adc	%r8, %rdx
-	mov	%r9, 8(rp,n,8)
-	add	%r8, %rdx
-L(ret):	mov	%rdx, %rax
-
-	pop	%rbx
-	cfi_adjust_cfa_offset (-8)
-	cfi_restore (%rbx)
-	ret
-END (__mpn_mul_1)
diff --git a/sysdeps/x86_64/nptl/pthread_spin_lock.S b/sysdeps/x86_64/nptl/pthread_spin_lock.S
deleted file mode 100644
index 86b8ab1119b2..000000000000
--- a/sysdeps/x86_64/nptl/pthread_spin_lock.S
+++ /dev/null
@@ -1,48 +0,0 @@
-/* Copyright (C) 2012-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <shlib-compat.h>
-
-ENTRY(__pthread_spin_lock)
-	/* Always return zero.  */
-	xor	%eax, %eax
-	LOCK
-	decl	0(%rdi)
-	jne	1f
-	ret
-
-	.align	16
-1:
-	/* `rep nop` == `pause`.  */
-	rep
-	nop
-	cmpl	%eax, 0(%rdi)
-	jle	1b
-	/* Just repeat the `lock decl` logic here.  The code size save
-	   of jumping back to entry doesn't change how many 16-byte
-	   chunks (default function alignment) that the code fits in.  */
-	LOCK
-	decl	0(%rdi)
-	jne	1b
-	ret
-END(__pthread_spin_lock)
-versioned_symbol (libc, __pthread_spin_lock, pthread_spin_lock, GLIBC_2_34)
-
-#if OTHER_SHLIB_COMPAT (libpthread, GLIBC_2_2, GLIBC_2_34)
-compat_symbol (libpthread, __pthread_spin_lock, pthread_spin_lock, GLIBC_2_2)
-#endif
diff --git a/sysdeps/x86_64/nptl/pthread_spin_trylock.S b/sysdeps/x86_64/nptl/pthread_spin_trylock.S
deleted file mode 100644
index 6ce68959c69e..000000000000
--- a/sysdeps/x86_64/nptl/pthread_spin_trylock.S
+++ /dev/null
@@ -1,45 +0,0 @@
-/* Copyright (C) 2002-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <errno.h>
-#include <shlib-compat.h>
-
-ENTRY(__pthread_spin_trylock)
-	xorl	%ecx, %ecx
-	/* xchg has implicit LOCK prefix.  */
-	xchgl	%ecx, (%rdi)
-
-	/* Branch on result.  Expectation is the use of trylock will be
-	   branching on success/failure so this branch can be used to
-	   to predict the coming branch.  It has the benefit of
-	   breaking the likely expensive memory dependency on (%rdi).  */
-	cmpl	$1, %ecx
-	jnz	1f
-	xorl	%eax, %eax
-	ret
-1:
-	movl	$EBUSY, %eax
-	ret
-END(__pthread_spin_trylock)
-versioned_symbol (libc, __pthread_spin_trylock, pthread_spin_trylock,
-		  GLIBC_2_34)
-
-#if OTHER_SHLIB_COMPAT (libpthread, GLIBC_2_2, GLIBC_2_34)
-compat_symbol (libpthread, __pthread_spin_trylock, pthread_spin_trylock,
-	       GLIBC_2_2)
-#endif
diff --git a/sysdeps/x86_64/nptl/pthread_spin_unlock.S b/sysdeps/x86_64/nptl/pthread_spin_unlock.S
deleted file mode 100644
index 1791ee9f522b..000000000000
--- a/sysdeps/x86_64/nptl/pthread_spin_unlock.S
+++ /dev/null
@@ -1,34 +0,0 @@
-/* Copyright (C) 2002-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <shlib-compat.h>
-
-ENTRY(__pthread_spin_unlock)
-	movl	$1, (%rdi)
-	xorl	%eax, %eax
-	retq
-END(__pthread_spin_unlock)
-versioned_symbol (libc, __pthread_spin_unlock, pthread_spin_unlock, GLIBC_2_34)
-/* The implementation of pthread_spin_init is identical.  */
-versioned_symbol (libc, __pthread_spin_unlock, pthread_spin_init, GLIBC_2_34)
-
-#if OTHER_SHLIB_COMPAT (libpthread, GLIBC_2_2, GLIBC_2_34)
-compat_symbol (libpthread, __pthread_spin_unlock, pthread_spin_unlock,
-	       GLIBC_2_2)
-compat_symbol (libpthread, __pthread_spin_unlock, pthread_spin_init, GLIBC_2_2)
-#endif
diff --git a/sysdeps/x86_64/nptl/tcb-access.h b/sysdeps/x86_64/nptl/tcb-access.h
deleted file mode 100644
index d35948f111dc..000000000000
--- a/sysdeps/x86_64/nptl/tcb-access.h
+++ /dev/null
@@ -1,132 +0,0 @@
-/* THREAD_* accessors.  x86_64 version.
-   Copyright (C) 2002-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-/* Read member of the thread descriptor directly.  */
-# define THREAD_GETMEM(descr, member) \
-  ({ __typeof (descr->member) __value;					      \
-     _Static_assert (sizeof (__value) == 1				      \
-		     || sizeof (__value) == 4				      \
-		     || sizeof (__value) == 8,				      \
-		     "size of per-thread data");			      \
-     if (sizeof (__value) == 1)						      \
-       asm volatile ("movb %%fs:%P2,%b0"				      \
-		     : "=q" (__value)					      \
-		     : "0" (0), "i" (offsetof (struct pthread, member)));     \
-     else if (sizeof (__value) == 4)					      \
-       asm volatile ("movl %%fs:%P1,%0"					      \
-		     : "=r" (__value)					      \
-		     : "i" (offsetof (struct pthread, member)));	      \
-     else /* 8 */								      \
-       {								      \
-	 asm volatile ("movq %%fs:%P1,%q0"				      \
-		       : "=r" (__value)					      \
-		       : "i" (offsetof (struct pthread, member)));	      \
-       }								      \
-     __value; })
-
-/* THREAD_GETMEM already forces a read.  */
-#define THREAD_GETMEM_VOLATILE(descr, member) THREAD_GETMEM (descr, member)
-
-/* Same as THREAD_GETMEM, but the member offset can be non-constant.  */
-# define THREAD_GETMEM_NC(descr, member, idx) \
-  ({ __typeof (descr->member[0]) __value;				      \
-     _Static_assert (sizeof (__value) == 1				      \
-		     || sizeof (__value) == 4				      \
-		     || sizeof (__value) == 8,				      \
-		     "size of per-thread data");			      \
-     if (sizeof (__value) == 1)						      \
-       asm volatile ("movb %%fs:%P2(%q3),%b0"				      \
-		     : "=q" (__value)					      \
-		     : "0" (0), "i" (offsetof (struct pthread, member[0])),   \
-		       "r" (idx));					      \
-     else if (sizeof (__value) == 4)					      \
-       asm volatile ("movl %%fs:%P1(,%q2,4),%0"				      \
-		     : "=r" (__value)					      \
-		     : "i" (offsetof (struct pthread, member[0])), "r" (idx));\
-     else /* 8 */							      \
-       {								      \
-	 asm volatile ("movq %%fs:%P1(,%q2,8),%q0"			      \
-		       : "=r" (__value)					      \
-		       : "i" (offsetof (struct pthread, member[0])),	      \
-			 "r" (idx));					      \
-       }								      \
-     __value; })
-
-
-/* Loading addresses of objects on x86-64 needs to be treated special
-   when generating PIC code.  */
-#ifdef __pic__
-# define IMM_MODE "nr"
-#else
-# define IMM_MODE "ir"
-#endif
-
-
-/* Set member of the thread descriptor directly.  */
-# define THREAD_SETMEM(descr, member, value) \
-  ({									      \
-     _Static_assert (sizeof (descr->member) == 1			      \
-		     || sizeof (descr->member) == 4			      \
-		     || sizeof (descr->member) == 8,			      \
-		     "size of per-thread data");			      \
-     if (sizeof (descr->member) == 1)					      \
-       asm volatile ("movb %b0,%%fs:%P1" :				      \
-		     : "iq" (value),					      \
-		       "i" (offsetof (struct pthread, member)));	      \
-     else if (sizeof (descr->member) == 4)				      \
-       asm volatile ("movl %0,%%fs:%P1" :				      \
-		     : IMM_MODE (value),				      \
-		       "i" (offsetof (struct pthread, member)));	      \
-     else /* 8 */							      \
-       {								      \
-	 /* Since movq takes a signed 32-bit immediate or a register source   \
-	    operand, use "er" constraint for 32-bit signed integer constant   \
-	    or register.  */						      \
-	 asm volatile ("movq %q0,%%fs:%P1" :				      \
-		       : "er" ((uint64_t) cast_to_integer (value)),	      \
-			 "i" (offsetof (struct pthread, member)));	      \
-       }})
-
-
-/* Same as THREAD_SETMEM, but the member offset can be non-constant.  */
-# define THREAD_SETMEM_NC(descr, member, idx, value) \
-  ({									      \
-     _Static_assert (sizeof (descr->member[0]) == 1			      \
-		     || sizeof (descr->member[0]) == 4			      \
-		     || sizeof (descr->member[0]) == 8,			      \
-		     "size of per-thread data");			      \
-     if (sizeof (descr->member[0]) == 1)				      \
-       asm volatile ("movb %b0,%%fs:%P1(%q2)" :				      \
-		     : "iq" (value),					      \
-		       "i" (offsetof (struct pthread, member[0])),	      \
-		       "r" (idx));					      \
-     else if (sizeof (descr->member[0]) == 4)				      \
-       asm volatile ("movl %0,%%fs:%P1(,%q2,4)" :			      \
-		     : IMM_MODE (value),				      \
-		       "i" (offsetof (struct pthread, member[0])),	      \
-		       "r" (idx));					      \
-     else /* 8 */							      \
-       {								      \
-	 /* Since movq takes a signed 32-bit immediate or a register source   \
-	    operand, use "er" constraint for 32-bit signed integer constant   \
-	    or register.  */						      \
-	 asm volatile ("movq %q0,%%fs:%P1(,%q2,8)" :			      \
-		       : "er" ((uint64_t) cast_to_integer (value)),	      \
-			 "i" (offsetof (struct pthread, member[0])),	      \
-			 "r" (idx));					      \
-       }})
diff --git a/sysdeps/x86_64/nptl/tls.h b/sysdeps/x86_64/nptl/tls.h
index 876889bed4bf..3599d92c6208 100644
--- a/sysdeps/x86_64/nptl/tls.h
+++ b/sysdeps/x86_64/nptl/tls.h
@@ -29,6 +29,7 @@
 # include <libc-pointer-arith.h> /* For cast_to_integer.  */
 # include <kernel-features.h>
 # include <dl-dtv.h>
+# include <pizlonated_runtime.h>
 
 /* Replacement type for __m128 since this file is included by ld.so,
    which is compiled with -mno-sse.  It must not change the alignment
@@ -142,21 +143,14 @@ _Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x80,
 # define TLS_INIT_TP(thrdescr) \
   ({ void *_thrdescr = (thrdescr);					      \
      tcbhead_t *_head = _thrdescr;					      \
-     int _result;							      \
 									      \
      _head->tcb = _thrdescr;						      \
      /* For now the thread descriptor is at the same address.  */	      \
      _head->self = _thrdescr;						      \
 									      \
      /* It is a simple syscall to set the %fs value for the thread.  */	      \
-     asm volatile ("syscall"						      \
-		   : "=a" (_result)					      \
-		   : "0" ((unsigned long int) __NR_arch_prctl),		      \
-		     "D" ((unsigned long int) ARCH_SET_FS),		      \
-		     "S" (_thrdescr)					      \
-		   : "memory", "cc", "r11", "cx");			      \
-									      \
-    _result == 0;							      \
+     zthread_set_self_cookie (_thrdescr);                                     \
+     true;                                                                    \
   })
 
 # define TLS_DEFINE_INIT_TP(tp, pd) void *tp = (pd)
@@ -174,16 +168,7 @@ _Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x80,
    assignments like
 	pthread_descr self = thread_self();
    do not get optimized away.  */
-# if __GNUC_PREREQ (6, 0)
-#  define THREAD_SELF \
-  (*(struct pthread *__seg_fs *) offsetof (struct pthread, header.self))
-# else
-#  define THREAD_SELF \
-  ({ struct pthread *__self;						      \
-     asm ("mov %%fs:%c1,%0" : "=r" (__self)				      \
-	  : "i" (offsetof (struct pthread, header.self)));	 	      \
-     __self;})
-# endif
+# define THREAD_SELF ((struct pthread *) zthread_self_cookie ())
 
 /* Magic for libthread_db to know how to do THREAD_SELF.  */
 # define DB_THREAD_SELF_INCLUDE  <sys/reg.h> /* For the FS constant.  */
@@ -206,25 +191,6 @@ _Static_assert (offsetof (tcbhead_t, __glibc_unused2) == 0x80,
   ((descr)->header.pointer_guard					      \
    = THREAD_GETMEM (THREAD_SELF, header.pointer_guard))
 
-
-/* Get and set the global scope generation counter in the TCB head.  */
-# define THREAD_GSCOPE_FLAG_UNUSED 0
-# define THREAD_GSCOPE_FLAG_USED   1
-# define THREAD_GSCOPE_FLAG_WAIT   2
-# define THREAD_GSCOPE_RESET_FLAG() \
-  do									      \
-    { int __res;							      \
-      asm volatile ("xchgl %0, %%fs:%P1"				      \
-		    : "=r" (__res)					      \
-		    : "i" (offsetof (struct pthread, header.gscope_flag)),    \
-		      "0" (THREAD_GSCOPE_FLAG_UNUSED));			      \
-      if (__res == THREAD_GSCOPE_FLAG_WAIT)				      \
-	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1, LLL_PRIVATE);    \
-    }									      \
-  while (0)
-# define THREAD_GSCOPE_SET_FLAG() \
-  THREAD_SETMEM (THREAD_SELF, header.gscope_flag, THREAD_GSCOPE_FLAG_USED)
-
 #endif /* __ASSEMBLER__ */
 
 #endif	/* tls.h */
diff --git a/sysdeps/x86_64/rawmemchr.S b/sysdeps/x86_64/rawmemchr.S
deleted file mode 100644
index 2810ee715dde..000000000000
--- a/sysdeps/x86_64/rawmemchr.S
+++ /dev/null
@@ -1,29 +0,0 @@
-/* fast SSE2 memchr with 64 byte loop and pmaxub instruction using
-
-   Copyright (C) 2011-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#define RAWMEMCHR	__rawmemchr
-
-#define DEFAULT_IMPL_V1	"multiarch/rawmemchr-sse2.S"
-#define DEFAULT_IMPL_V3	"multiarch/rawmemchr-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/rawmemchr-evex.S"
-
-#include "isa-default-impl.h"
-
-weak_alias (__rawmemchr, rawmemchr)
-libc_hidden_def (__rawmemchr)
diff --git a/sysdeps/x86_64/rshift.S b/sysdeps/x86_64/rshift.S
deleted file mode 100644
index feab128da968..000000000000
--- a/sysdeps/x86_64/rshift.S
+++ /dev/null
@@ -1,114 +0,0 @@
-/* x86-64 __mpn_rshift --
-   Copyright (C) 2007-2024 Free Software Foundation, Inc.
-   This file is part of the GNU MP Library.
-
-   The GNU MP Library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU Lesser General Public License as published by
-   the Free Software Foundation; either version 2.1 of the License, or (at your
-   option) any later version.
-
-   The GNU MP Library is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
-   License for more details.
-
-   You should have received a copy of the GNU Lesser General Public License
-   along with the GNU MP Library; see the file COPYING.LIB.  If not,
-   see <https://www.gnu.org/licenses/>.  */
-
-#include "sysdep.h"
-#include "asm-syntax.h"
-
-#define rp	%rdi
-#define up	%rsi
-#define n	%rdx
-#define cnt	%cl
-
-	.text
-ENTRY (__mpn_rshift)
-	mov	%edx, %eax
-	and	$3, %eax
-	jne	L(nb00)
-L(b00):	/* n = 4, 8, 12, ... */
-	mov	(up), %r10
-	mov	8(up), %r11
-	xor	%eax, %eax
-	shrd	%cl, %r10, %rax
-	mov	16(up), %r8
-	lea	8(up), up
-	lea	-24(rp), rp
-	sub	$4, n
-	jmp	L(00)
-
-L(nb00):/* n = 1, 5, 9, ... */
-	cmp	$2, %eax
-	jae	L(nb01)
-L(b01):	mov	(up), %r9
-	xor	%eax, %eax
-	shrd	%cl, %r9, %rax
-	sub	$2, n
-	jb	L(le1)
-	mov	8(up), %r10
-	mov	16(up), %r11
-	lea	16(up), up
-	lea	-16(rp), rp
-	jmp	L(01)
-L(le1): shr	%cl, %r9
-	mov	%r9, (rp)
-	ret
-
-L(nb01):/* n = 2, 6, 10, ... */
-	jne	L(b11)
-L(b10):	mov	(up), %r8
-	mov	8(up), %r9
-	xor	%eax, %eax
-	shrd	%cl, %r8, %rax
-	sub	$3, n
-	jb	L(le2)
-	mov	16(up), %r10
-	lea	24(up), up
-	lea	-8(rp), rp
-	jmp	L(10)
-L(le2): shrd	%cl, %r9, %r8
-	mov	%r8, (rp)
-	shr	%cl, %r9
-	mov	%r9, 8(rp)
-	ret
-
-	.p2align 4
-L(b11):	/* n = 3, 7, 11, ... */
-	mov	(up), %r11
-	mov	8(up), %r8
-	xor	%eax, %eax
-	shrd	%cl, %r11, %rax
-	mov	16(up), %r9
-	lea	32(up), up
-	sub	$4, n
-	jb	L(end)
-
-	.p2align 4
-L(top):	shrd	%cl, %r8, %r11
-	mov	-8(up), %r10
-	mov	%r11, (rp)
-L(10):	shrd	%cl, %r9, %r8
-	mov	(up), %r11
-	mov	%r8, 8(rp)
-L(01):	shrd	%cl, %r10, %r9
-	mov	8(up), %r8
-	mov	%r9, 16(rp)
-L(00):	shrd	%cl, %r11, %r10
-	mov	16(up), %r9
-	mov	%r10, 24(rp)
-	add	$32, up
-	lea	32(rp), rp
-	sub	$4, n
-	jnc	L(top)
-
-L(end):	shrd	%cl, %r8, %r11
-	mov	%r11, (rp)
-	shrd	%cl, %r9, %r8
-	mov	%r8, 8(rp)
-	shr	%cl, %r9
-	mov	%r9, 16(rp)
-	ret
-END (__mpn_rshift)
diff --git a/sysdeps/x86_64/rtld-offsets.sym b/sysdeps/x86_64/rtld-offsets.sym
index fd41b51521ac..6be959c02f9a 100644
--- a/sysdeps/x86_64/rtld-offsets.sym
+++ b/sysdeps/x86_64/rtld-offsets.sym
@@ -1,6 +1,4 @@
-#define SHARED
 #include <ldsodefs.h>
 
 --
 
-GL_TLS_GENERATION_OFFSET        offsetof (struct rtld_global, _dl_tls_generation)
diff --git a/sysdeps/x86_64/stackinfo.h b/sysdeps/x86_64/stackinfo.h
index 2cb24a74bb0e..1bde5ff850f5 100644
--- a/sysdeps/x86_64/stackinfo.h
+++ b/sysdeps/x86_64/stackinfo.h
@@ -36,16 +36,4 @@
  * present, but it is presumed absent.  */
 #define DEFAULT_STACK_PERMS (PF_R|PF_W|PF_X)
 
-/* Access to the stack pointer.  The macros are used in alloca_account
-   for which they need to act as barriers as well, hence the additional
-   (unnecessary) parameters.  */
-#define stackinfo_get_sp() \
-  ({ register void * p__ __asm__(RSP_REG); \
-     asm volatile("" : "=r" (p__)); \
-     p__; })
-#define stackinfo_sub_sp(ptr) \
-  ({ ptrdiff_t d__;						\
-     asm volatile ("sub %%" RSP_REG " , %0" : "=r" (d__) : "0" (ptr));	\
-     d__; })
-
 #endif	/* stackinfo.h */
diff --git a/sysdeps/x86_64/stpcpy.S b/sysdeps/x86_64/stpcpy.S
deleted file mode 100644
index d3117c8cebd6..000000000000
--- a/sysdeps/x86_64/stpcpy.S
+++ /dev/null
@@ -1,29 +0,0 @@
-/* stpcpy dispatch for RTLD and non-multiarch build
-   Copyright (C) 2022-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#define STPCPY	__stpcpy
-
-#define DEFAULT_IMPL_V1	"multiarch/stpcpy-sse2-unaligned.S"
-#define DEFAULT_IMPL_V3	"multiarch/stpcpy-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/stpcpy-evex.S"
-
-#include "isa-default-impl.h"
-
-weak_alias (__stpcpy, stpcpy)
-libc_hidden_def (__stpcpy)
-libc_hidden_builtin_def (stpcpy)
diff --git a/sysdeps/x86_64/stpncpy.S b/sysdeps/x86_64/stpncpy.S
deleted file mode 100644
index 5e0b14764a77..000000000000
--- a/sysdeps/x86_64/stpncpy.S
+++ /dev/null
@@ -1,28 +0,0 @@
-/* stpncpy dispatch for RTLD and non-multiarch build
-   Copyright (C) 2022-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#define STPNCPY	__stpncpy
-
-#define DEFAULT_IMPL_V1	"multiarch/stpncpy-sse2-unaligned.S"
-#define DEFAULT_IMPL_V3	"multiarch/stpncpy-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/stpncpy-evex.S"
-
-#include "isa-default-impl.h"
-
-weak_alias (__stpncpy, stpncpy)
-libc_hidden_def (__stpncpy)
diff --git a/sysdeps/x86_64/strcasecmp.S b/sysdeps/x86_64/strcasecmp.S
deleted file mode 100644
index fe49e820f279..000000000000
--- a/sysdeps/x86_64/strcasecmp.S
+++ /dev/null
@@ -1 +0,0 @@
-/* In strcasecmp_l.S.  */
diff --git a/sysdeps/x86_64/strcasecmp_l.S b/sysdeps/x86_64/strcasecmp_l.S
deleted file mode 100644
index e8c36c04368d..000000000000
--- a/sysdeps/x86_64/strcasecmp_l.S
+++ /dev/null
@@ -1,35 +0,0 @@
-/* strcasecmp_l dispatch for RTLD and non-multiarch build
-   Copyright (C) 2022-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-/* Symbols = __strcasecmp_l and __strcasecmp.  */
-
-#define DEFAULT_IMPL_V1	"multiarch/strcasecmp_l-sse2.S"
-/* This may cause regressions on some processors that heavily prefer
-   aligned loads or have slow a implementation of the `pcmpstri`
-   instruction.  */
-#define DEFAULT_IMPL_V2	"multiarch/strcasecmp_l-sse4_2.S"
-#define DEFAULT_IMPL_V3	"multiarch/strcasecmp_l-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/strcasecmp_l-evex.S"
-
-#include "isa-default-impl.h"
-
-libc_hidden_def (__strcasecmp_l)
-weak_alias (__strcasecmp_l, strcasecmp_l)
-
-libc_hidden_def (__strcasecmp)
-weak_alias (__strcasecmp, strcasecmp)
diff --git a/sysdeps/x86_64/strcat.S b/sysdeps/x86_64/strcat.S
deleted file mode 100644
index 7c7c178dec69..000000000000
--- a/sysdeps/x86_64/strcat.S
+++ /dev/null
@@ -1,27 +0,0 @@
-/* strcat dispatch for RTLD and non-multiarch build
-   Copyright (C) 2022-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#define STRCAT	strcat
-
-#define DEFAULT_IMPL_V1	"multiarch/strcat-sse2-unaligned.S"
-#define DEFAULT_IMPL_V3	"multiarch/strcat-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/strcat-evex.S"
-
-#include "isa-default-impl.h"
-
-libc_hidden_builtin_def (strcat)
diff --git a/sysdeps/x86_64/strchr.S b/sysdeps/x86_64/strchr.S
deleted file mode 100644
index a8346aee8f05..000000000000
--- a/sysdeps/x86_64/strchr.S
+++ /dev/null
@@ -1,28 +0,0 @@
-/* strchr dispatch for RTLD and non-multiarch build
-   Copyright (C) 2009-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#define STRCHR	strchr
-
-#define DEFAULT_IMPL_V1	"multiarch/strchr-sse2.S"
-#define DEFAULT_IMPL_V3	"multiarch/strchr-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/strchr-evex.S"
-
-#include "isa-default-impl.h"
-
-weak_alias (strchr, index)
-libc_hidden_builtin_def (strchr)
diff --git a/sysdeps/x86_64/strchrnul.S b/sysdeps/x86_64/strchrnul.S
deleted file mode 100644
index 7e715dc5c74e..000000000000
--- a/sysdeps/x86_64/strchrnul.S
+++ /dev/null
@@ -1,28 +0,0 @@
-/* strchrnul dispatch for RTLD and non-multiarch build
-   Copyright (C) 2009-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#define STRCHRNUL	__strchrnul
-
-#define DEFAULT_IMPL_V1	"multiarch/strchrnul-sse2.S"
-#define DEFAULT_IMPL_V3	"multiarch/strchrnul-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/strchrnul-evex.S"
-
-#include "isa-default-impl.h"
-
-libc_hidden_def (__strchrnul)
-weak_alias (__strchrnul, strchrnul)
diff --git a/sysdeps/x86_64/strcmp.S b/sysdeps/x86_64/strcmp.S
deleted file mode 100644
index 1ab3f2848079..000000000000
--- a/sysdeps/x86_64/strcmp.S
+++ /dev/null
@@ -1,31 +0,0 @@
-/* strcmp dispatch for RTLD and non-multiarch build
-   Copyright (C) 1999-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-/* Symbol = strcmp.  */
-
-#define DEFAULT_IMPL_V1	"multiarch/strcmp-sse2.S"
-/* strcmp-sse2-unaligned.S is often faster than strcmp-sse42.S and
-   doesn't have the drawback of using the `pcmpstri` instruction
-   which can be very slow on some CPUs.  */
-#define DEFAULT_IMPL_V2	"multiarch/strcmp-sse2-unaligned.S"
-#define DEFAULT_IMPL_V3	"multiarch/strcmp-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/strcmp-evex.S"
-
-#include "isa-default-impl.h"
-
-libc_hidden_builtin_def (strcmp)
diff --git a/sysdeps/x86_64/strcpy.S b/sysdeps/x86_64/strcpy.S
deleted file mode 100644
index e37c7ce495bb..000000000000
--- a/sysdeps/x86_64/strcpy.S
+++ /dev/null
@@ -1,27 +0,0 @@
-/* strcpy dispatch for RTLD and non-multiarch build
-   Copyright (C) 2022-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#define STRCPY	strcpy
-
-#define DEFAULT_IMPL_V1	"multiarch/strcpy-sse2-unaligned.S"
-#define DEFAULT_IMPL_V3	"multiarch/strcpy-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/strcpy-evex.S"
-
-#include "isa-default-impl.h"
-
-libc_hidden_builtin_def (strcpy)
diff --git a/sysdeps/x86_64/strlen.S b/sysdeps/x86_64/strlen.S
deleted file mode 100644
index cea7acea753a..000000000000
--- a/sysdeps/x86_64/strlen.S
+++ /dev/null
@@ -1,27 +0,0 @@
-/* strlen dispatch for RTLD and non-multiarch build
-   Copyright (C) 2021-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#define STRLEN	strlen
-
-#define DEFAULT_IMPL_V1	"multiarch/strlen-sse2.S"
-#define DEFAULT_IMPL_V3	"multiarch/strlen-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/strlen-evex.S"
-
-#include "isa-default-impl.h"
-
-libc_hidden_builtin_def (strlen)
diff --git a/sysdeps/x86_64/strncase.S b/sysdeps/x86_64/strncase.S
deleted file mode 100644
index 2de2ce4b96b0..000000000000
--- a/sysdeps/x86_64/strncase.S
+++ /dev/null
@@ -1 +0,0 @@
-/* In strncase_l.S.  */
diff --git a/sysdeps/x86_64/strncase_l.S b/sysdeps/x86_64/strncase_l.S
deleted file mode 100644
index 6b04c9fbf1e6..000000000000
--- a/sysdeps/x86_64/strncase_l.S
+++ /dev/null
@@ -1,35 +0,0 @@
-/* strcasecmp_l dispatch for RTLD and non-multiarch build
-   Copyright (C) 2022-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-/* Symbols = __strncasecmp_l and __strncasecmp.  */
-
-#define DEFAULT_IMPL_V1	"multiarch/strncase_l-sse2.S"
-/* This may cause regressions on some processors that heavily prefer
-   aligned loads or have slow a implementation of the `pcmpstri`
-   instruction.  */
-#define DEFAULT_IMPL_V2	"multiarch/strncase_l-sse4_2.S"
-#define DEFAULT_IMPL_V3	"multiarch/strncase_l-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/strncase_l-evex.S"
-
-#include "isa-default-impl.h"
-
-libc_hidden_def (__strncasecmp_l)
-weak_alias (__strncasecmp_l, strncasecmp_l)
-
-libc_hidden_def (__strncasecmp)
-weak_alias (__strncasecmp, strncasecmp)
diff --git a/sysdeps/x86_64/strncat.S b/sysdeps/x86_64/strncat.S
deleted file mode 100644
index c0524a0c985f..000000000000
--- a/sysdeps/x86_64/strncat.S
+++ /dev/null
@@ -1,28 +0,0 @@
-/* strncat dispatch for RTLD and non-multiarch build
-   Copyright (C) 2022-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#define STRNCAT	strncat
-
-#define DEFAULT_IMPL_V1	"multiarch/strncat-sse2-unaligned.S"
-#define DEFAULT_IMPL_V3	"multiarch/strncat-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/strncat-evex.S"
-
-#include "isa-default-impl.h"
-
-strong_alias (strncat, __strncat)
-libc_hidden_def (__strncat)
diff --git a/sysdeps/x86_64/strncmp.S b/sysdeps/x86_64/strncmp.S
deleted file mode 100644
index 07f09d6c7470..000000000000
--- a/sysdeps/x86_64/strncmp.S
+++ /dev/null
@@ -1,31 +0,0 @@
-/* strncmp dispatch for RTLD and non-multiarch build
-   Copyright (C) 1999-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-/* Symbol = strncmp.  */
-
-#define DEFAULT_IMPL_V1	"multiarch/strncmp-sse2.S"
-/* This may cause regressions on some processors that heavily prefer
-   aligned loads or have slow a implementation of the `pcmpstri`
-   instruction.  */
-#define DEFAULT_IMPL_V2	"multiarch/strncmp-sse4_2.S"
-#define DEFAULT_IMPL_V3	"multiarch/strncmp-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/strncmp-evex.S"
-
-#include "isa-default-impl.h"
-
-libc_hidden_builtin_def (strncmp)
diff --git a/sysdeps/x86_64/strncpy.S b/sysdeps/x86_64/strncpy.S
deleted file mode 100644
index 28ad0d714b73..000000000000
--- a/sysdeps/x86_64/strncpy.S
+++ /dev/null
@@ -1,27 +0,0 @@
-/* strncpy dispatch for RTLD and non-multiarch build
-   Copyright (C) 2022-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#define STRNCPY	strncpy
-
-#define DEFAULT_IMPL_V1	"multiarch/strncpy-sse2-unaligned.S"
-#define DEFAULT_IMPL_V3	"multiarch/strncpy-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/strncpy-evex.S"
-
-#include "isa-default-impl.h"
-
-libc_hidden_builtin_def (strncpy)
diff --git a/sysdeps/x86_64/strnlen.S b/sysdeps/x86_64/strnlen.S
deleted file mode 100644
index fb0f56072f37..000000000000
--- a/sysdeps/x86_64/strnlen.S
+++ /dev/null
@@ -1,29 +0,0 @@
-/* strnlen dispatch for RTLD and non-multiarch build
-   Copyright (C) 2022-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#define STRNLEN	__strnlen
-
-#define DEFAULT_IMPL_V1	"multiarch/strnlen-sse2.S"
-#define DEFAULT_IMPL_V3	"multiarch/strnlen-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/strnlen-evex.S"
-
-#include "isa-default-impl.h"
-
-weak_alias (__strnlen, strnlen)
-libc_hidden_def (__strnlen)
-libc_hidden_def (strnlen)
diff --git a/sysdeps/x86_64/strrchr.S b/sysdeps/x86_64/strrchr.S
deleted file mode 100644
index 00a2cac8f617..000000000000
--- a/sysdeps/x86_64/strrchr.S
+++ /dev/null
@@ -1,28 +0,0 @@
-/* strrchr dispatch for RTLD and non-multiarch build
-   Copyright (C) 2013-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#define STRRCHR	strrchr
-
-#define DEFAULT_IMPL_V1	"multiarch/strrchr-sse2.S"
-#define DEFAULT_IMPL_V3	"multiarch/strrchr-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/strrchr-evex.S"
-
-#include "isa-default-impl.h"
-
-weak_alias (strrchr, rindex)
-libc_hidden_builtin_def (strrchr)
diff --git a/sysdeps/x86_64/sub_n.S b/sysdeps/x86_64/sub_n.S
deleted file mode 100644
index f43efc8e3c07..000000000000
--- a/sysdeps/x86_64/sub_n.S
+++ /dev/null
@@ -1,23 +0,0 @@
-/* x86-64 __mpn_sub_n -- Add two limb vectors of the same length > 0 and store
-   sum in a third limb vector.
-   Copyright (C) 2006-2024 Free Software Foundation, Inc.
-   This file is part of the GNU MP Library.
-
-   The GNU MP Library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU Lesser General Public License as published by
-   the Free Software Foundation; either version 2.1 of the License, or (at your
-   option) any later version.
-
-   The GNU MP Library is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
-   License for more details.
-
-   You should have received a copy of the GNU Lesser General Public License
-   along with the GNU MP Library; see the file COPYING.LIB.  If not,
-   see <https://www.gnu.org/licenses/>.  */
-
-#define func __mpn_sub_n
-#define ADCSBB sbb
-
-#include "add_n.S"
diff --git a/sysdeps/x86_64/submul_1.S b/sysdeps/x86_64/submul_1.S
deleted file mode 100644
index 7ba095f5f6e6..000000000000
--- a/sysdeps/x86_64/submul_1.S
+++ /dev/null
@@ -1,23 +0,0 @@
-/* x86-64 __mpn_submul_1 -- Multiply a limb vector with a limb and subtract
-   the result from a second limb vector.
-   Copyright (C) 2003-2024 Free Software Foundation, Inc.
-   This file is part of the GNU MP Library.
-
-   The GNU MP Library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU Lesser General Public License as published by
-   the Free Software Foundation; either version 2.1 of the License, or (at your
-   option) any later version.
-
-   The GNU MP Library is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
-   License for more details.
-
-   You should have received a copy of the GNU Lesser General Public License
-   along with the GNU MP Library; see the file COPYING.LIB.  If not,
-   see <https://www.gnu.org/licenses/>.  */
-
-#define func __mpn_submul_1
-#define ADDSUB sub
-
-#include "addmul_1.S"
diff --git a/sysdeps/x86_64/wcpcpy.S b/sysdeps/x86_64/wcpcpy.S
deleted file mode 100644
index dcc93610a4e1..000000000000
--- a/sysdeps/x86_64/wcpcpy.S
+++ /dev/null
@@ -1,41 +0,0 @@
-/* ISA level static dispatch for wcpcpy .S files.
-   Copyright (C) 2022-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-/* wcpcpy non-multiarch build is split into two files,
-   wcpcpy-generic.c and wcpcpy.S. The wcpcpy-generic.c build is
-   for ISA level <= 1 and just uses multiarch/wcpcpy-generic.c.
-   This must be split into two files because we cannot include C
-   code from assembly or vice versa.  */
-
-#include <isa-level.h>
-
-#if MINIMUM_X86_ISA_LEVEL >= 3
-
-# define WCPCPY	__wcpcpy
-
-# define DEFAULT_IMPL_V4	"multiarch/wcpcpy-evex.S"
-# define DEFAULT_IMPL_V3	"multiarch/wcpcpy-avx2.S"
-/* isa-default-impl.h expects DEFAULT_IMPL_V1 to be defined but it
-   should never be used from here.  */
-# define DEFAULT_IMPL_V1	"ERROR -- Invalid ISA IMPL"
-
-# include "isa-default-impl.h"
-
-weak_alias (__wcpcpy, wcpcpy)
-libc_hidden_def (__wcpcpy)
-#endif
diff --git a/sysdeps/x86_64/wcpncpy.S b/sysdeps/x86_64/wcpncpy.S
deleted file mode 100644
index fcc728eb5c6f..000000000000
--- a/sysdeps/x86_64/wcpncpy.S
+++ /dev/null
@@ -1,41 +0,0 @@
-/* ISA level static dispatch for wcpcpy .S files.
-   Copyright (C) 2022-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-/* wcpncpy non-multiarch build is split into two files,
-   wcpncpy-generic.c and wcpncpy.S. The wcpncpy-generic.c build is
-   for ISA level <= 1 and just uses multiarch/wcpncpy-generic.c.
-   This must be split into two files because we cannot include C
-   code from assembly or vice versa.  */
-
-#include <isa-level.h>
-
-#if MINIMUM_X86_ISA_LEVEL >= 3
-
-# define WCPNCPY	__wcpncpy
-
-# define DEFAULT_IMPL_V4	"multiarch/wcpncpy-evex.S"
-# define DEFAULT_IMPL_V3	"multiarch/wcpncpy-avx2.S"
-/* isa-default-impl.h expects DEFAULT_IMPL_V1 to be defined but it
-   should never be used from here.  */
-# define DEFAULT_IMPL_V1	"ERROR -- Invalid ISA IMPL"
-
-# include "isa-default-impl.h"
-
-weak_alias (__wcpncpy, wcpncpy)
-libc_hidden_def (__wcpncpy)
-#endif
diff --git a/sysdeps/x86_64/wcscat.S b/sysdeps/x86_64/wcscat.S
deleted file mode 100644
index f920e881e430..000000000000
--- a/sysdeps/x86_64/wcscat.S
+++ /dev/null
@@ -1,41 +0,0 @@
-/* ISA level static dispatch for wcscat .S files.
-   Copyright (C) 2022-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-/* wcscat non-multiarch build is split into two files,
-   wcscat-generic.c and wcscat.S. The wcscat-generic.c build is
-   for ISA level <= 1 and just uses multiarch/wcscat-generic.c.
-   This must be split into two files because we cannot include C
-   code from assembly or vice versa.  */
-
-#include <isa-level.h>
-
-#if MINIMUM_X86_ISA_LEVEL >= 3
-
-# define WCSCAT	__wcscat
-
-# define DEFAULT_IMPL_V4	"multiarch/wcscat-evex.S"
-# define DEFAULT_IMPL_V3	"multiarch/wcscat-avx2.S"
-/* isa-default-impl.h expects DEFAULT_IMPL_V1 to be defined but it
-   should never be used from here.  */
-# define DEFAULT_IMPL_V1	"ERROR -- Invalid ISA IMPL"
-
-# include "isa-default-impl.h"
-
-weak_alias (__wcscat, wcscat)
-libc_hidden_def (__wcscat)
-#endif
diff --git a/sysdeps/x86_64/wcschr.S b/sysdeps/x86_64/wcschr.S
deleted file mode 100644
index abc32ef4437f..000000000000
--- a/sysdeps/x86_64/wcschr.S
+++ /dev/null
@@ -1,29 +0,0 @@
-/* wcschr dispatch for RTLD and non-multiarch build
-   Copyright (C) 2011-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#define WCSCHR	__wcschr
-
-#define DEFAULT_IMPL_V1	"multiarch/wcschr-sse2.S"
-#define DEFAULT_IMPL_V3	"multiarch/wcschr-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/wcschr-evex.S"
-
-#include "isa-default-impl.h"
-
-libc_hidden_def (__wcschr)
-weak_alias (__wcschr, wcschr)
-libc_hidden_weak (wcschr)
diff --git a/sysdeps/x86_64/wcscmp.S b/sysdeps/x86_64/wcscmp.S
deleted file mode 100644
index 74244c4805b8..000000000000
--- a/sysdeps/x86_64/wcscmp.S
+++ /dev/null
@@ -1,28 +0,0 @@
-/* strlen dispatch for RTLD and non-multiarch build
-   Copyright (C) 2011-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-/* Symbol = __wcscmp.  */
-
-#define DEFAULT_IMPL_V1	"multiarch/wcscmp-sse2.S"
-#define DEFAULT_IMPL_V3	"multiarch/wcscmp-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/wcscmp-evex.S"
-
-#include "isa-default-impl.h"
-
-libc_hidden_def (__wcscmp)
-weak_alias (__wcscmp, wcscmp)
diff --git a/sysdeps/x86_64/wcscpy.S b/sysdeps/x86_64/wcscpy.S
deleted file mode 100644
index c8f3ca1bd6ef..000000000000
--- a/sysdeps/x86_64/wcscpy.S
+++ /dev/null
@@ -1,42 +0,0 @@
-/* ISA level static dispatch for wcscpy .S files.
-   Copyright (C) 2022-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-/* wcscpy non-multiarch build is split into two files,
-   wcscpy-generic.c and wcscpy.S. The wcscpy.S build is for
-   ISA level >= 2 uses the optimized assembly implementations in
-   multiarch/wcscpy*.S.  This must be split into two files because
-   we cannot include C code from assembly or vice versa.  */
-
-#include <isa-level.h>
-
-#if MINIMUM_X86_ISA_LEVEL >= 2
-
-# define WCSCPY	__wcscpy
-
-# define DEFAULT_IMPL_V4	"multiarch/wcscpy-evex.S"
-# define DEFAULT_IMPL_V3	"multiarch/wcscpy-avx2.S"
-# define DEFAULT_IMPL_V2	"multiarch/wcscpy-ssse3.S"
-/* isa-default-impl.h expects DEFAULT_IMPL_V1 to be defined but it
-   should never be used from here.  */
-# define DEFAULT_IMPL_V1	"ERROR -- Invalid ISA IMPL"
-
-# include "isa-default-impl.h"
-
-weak_alias (__wcscpy, wcscpy)
-libc_hidden_def (__wcscpy)
-#endif
diff --git a/sysdeps/x86_64/wcslen.S b/sysdeps/x86_64/wcslen.S
deleted file mode 100644
index b83c423be2d8..000000000000
--- a/sysdeps/x86_64/wcslen.S
+++ /dev/null
@@ -1,34 +0,0 @@
-/* wcslen dispatch for RTLD and non-multiarch build
-   Copyright (C) 2011-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#define WCSLEN	__wcslen
-
-#define DEFAULT_IMPL_V1	"multiarch/wcslen-sse2.S"
-#define DEFAULT_IMPL_V2	"multiarch/wcslen-sse4_1.S"
-#define DEFAULT_IMPL_V3	"multiarch/wcslen-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/wcslen-evex.S"
-
-#include "isa-default-impl.h"
-
-weak_alias (__wcslen, wcslen)
-
-#if MINIMUM_X86_ISA_LEVEL == 2 && !IS_IN (rtld)
-/* Hidden def so it can be used as overflow fallback in
-   wcsnlen-sse4_1.S.  */
-libc_hidden_def (__wcslen)
-#endif
diff --git a/sysdeps/x86_64/wcsncat.S b/sysdeps/x86_64/wcsncat.S
deleted file mode 100644
index 382e62b2ebe2..000000000000
--- a/sysdeps/x86_64/wcsncat.S
+++ /dev/null
@@ -1,39 +0,0 @@
-/* ISA level static dispatch for wcsncat .S files.
-   Copyright (C) 2022-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-/* wcsncat non-multiarch build is split into two files,
-   wcsncat-generic.c and wcsncat.S. The wcsncat-generic.c build is
-   for ISA level <= 1 and just uses multiarch/wcsncat-generic.c.
-   This must be split into two files because we cannot include C
-   code from assembly or vice versa.  */
-
-#include <isa-level.h>
-
-#if MINIMUM_X86_ISA_LEVEL >= 3
-
-# define WCSNCAT	wcsncat
-
-# define DEFAULT_IMPL_V4	"multiarch/wcsncat-evex.S"
-# define DEFAULT_IMPL_V3	"multiarch/wcsncat-avx2.S"
-/* isa-default-impl.h expects DEFAULT_IMPL_V1 to be defined but it
-   should never be used from here.  */
-# define DEFAULT_IMPL_V1	"ERROR -- Invalid ISA IMPL"
-
-# include "isa-default-impl.h"
-
-#endif
diff --git a/sysdeps/x86_64/wcsncmp.S b/sysdeps/x86_64/wcsncmp.S
deleted file mode 100644
index 19182c4c06a8..000000000000
--- a/sysdeps/x86_64/wcsncmp.S
+++ /dev/null
@@ -1,40 +0,0 @@
-/* wcsncmp dispatch for RTLD and non-multiarch .c files
-   Copyright (C) 2022-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-/* wcsncmp non-multiarch build is split into two files,
-   wcsncmp-generic.c and wcsncmp.S. The wcsncmp.S build is for
-   ISA level >= 3 uses the optimized assembly implementations in
-   multiarch/wcsncmp*.S.  This must be split into two files because
-   we cannot include C code from assembly or vice versa.  */
-
-#include <isa-level.h>
-
-#if MINIMUM_X86_ISA_LEVEL >= 3
-
-/* Symbol = wcsncmp.  */
-
-# define DEFAULT_IMPL_V3	"multiarch/wcsncmp-avx2.S"
-# define DEFAULT_IMPL_V4	"multiarch/wcsncmp-evex.S"
-
-/* isa-default-impl.h expects DEFAULT_IMPL_V1 to be defined but it
-   should never be used from here.  */
-# define DEFAULT_IMPL_V1	"ERROR -- Invalid ISA IMPL"
-
-# include "isa-default-impl.h"
-
-#endif
diff --git a/sysdeps/x86_64/wcsncpy.S b/sysdeps/x86_64/wcsncpy.S
deleted file mode 100644
index a7545264aabc..000000000000
--- a/sysdeps/x86_64/wcsncpy.S
+++ /dev/null
@@ -1,41 +0,0 @@
-/* ISA level static dispatch for wcsncpy .S files.
-   Copyright (C) 2022-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-/* wcsncpy non-multiarch build is split into two files,
-   wcsncpy-generic.c and wcsncpy.S. The wcsncpy-generic.c build is
-   for ISA level <= 1 and just uses multiarch/wcsncpy-generic.c.
-   This must be split into two files because we cannot include C
-   code from assembly or vice versa.  */
-
-#include <isa-level.h>
-
-#if MINIMUM_X86_ISA_LEVEL >= 3
-
-# define WCSNCPY	__wcsncpy
-
-# define DEFAULT_IMPL_V4	"multiarch/wcsncpy-evex.S"
-# define DEFAULT_IMPL_V3	"multiarch/wcsncpy-avx2.S"
-/* isa-default-impl.h expects DEFAULT_IMPL_V1 to be defined but it
-   should never be used from here.  */
-# define DEFAULT_IMPL_V1	"ERROR -- Invalid ISA IMPL"
-
-# include "isa-default-impl.h"
-
-weak_alias (__wcsncpy, wcsncpy)
-libc_hidden_def (__wcsncpy)
-#endif
diff --git a/sysdeps/x86_64/wcsnlen.S b/sysdeps/x86_64/wcsnlen.S
deleted file mode 100644
index a4c81232c4d2..000000000000
--- a/sysdeps/x86_64/wcsnlen.S
+++ /dev/null
@@ -1,49 +0,0 @@
-/* wcsnlen dispatch for RTLD and non-multiarch .c files
-   Copyright (C) 2022-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-/* wcsnlen non-multiarch build is split into two files,
-   wcsnlen-generic.c and wcsnlen.S. The wcsnlen.S build is for
-   ISA level >= 2 uses the optimized assembly implementations in
-   multiarch/wcsnlen*.S.  This must be split into two files because
-   we cannot include C code from assembly or vice versa.  */
-
-#include <isa-level.h>
-
-#if MINIMUM_X86_ISA_LEVEL >= 2
-
-# define WCSNLEN	__wcsnlen
-/* This symbol must stay linked to the name in wcslen.S.  */
-#if IS_IN (rtld)
-# define OVERFLOW_STRLEN	__wcslen
-#else
-# define OVERFLOW_STRLEN	HIDDEN_JUMPTARGET (__wcslen)
-#endif
-
-# define DEFAULT_IMPL_V2	"multiarch/wcsnlen-sse4_1.S"
-# define DEFAULT_IMPL_V3	"multiarch/wcsnlen-avx2.S"
-# define DEFAULT_IMPL_V4	"multiarch/wcsnlen-evex.S"
-
-/* isa-default-impl.h expects DEFAULT_IMPL_V1 to be defined but it
-   should never be used from here.  */
-# define DEFAULT_IMPL_V1	"ERROR -- Invalid ISA IMPL"
-
-# include "isa-default-impl.h"
-
-weak_alias (__wcsnlen, wcsnlen)
-libc_hidden_def (__wcsnlen)
-#endif
diff --git a/sysdeps/x86_64/wcsrchr.S b/sysdeps/x86_64/wcsrchr.S
deleted file mode 100644
index a8150caa2bc7..000000000000
--- a/sysdeps/x86_64/wcsrchr.S
+++ /dev/null
@@ -1,25 +0,0 @@
-/* wcsrchr dispatch for RTLD and non-multiarch build
-   Copyright (C) 2011-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#define WCSRCHR	wcsrchr
-
-#define DEFAULT_IMPL_V1	"multiarch/wcsrchr-sse2.S"
-#define DEFAULT_IMPL_V3	"multiarch/wcsrchr-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/wcsrchr-evex.S"
-
-#include "isa-default-impl.h"
diff --git a/sysdeps/x86_64/wmemchr.S b/sysdeps/x86_64/wmemchr.S
deleted file mode 100644
index 5ac503c337e6..000000000000
--- a/sysdeps/x86_64/wmemchr.S
+++ /dev/null
@@ -1,28 +0,0 @@
-/* Copyright (C) 2022-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#define WMEMCHR	__wmemchr
-
-#define DEFAULT_IMPL_V1	"multiarch/wmemchr-sse2.S"
-#define DEFAULT_IMPL_V3	"multiarch/wmemchr-avx2.S"
-#define DEFAULT_IMPL_V4	"multiarch/wmemchr-evex.S"
-
-#include "isa-default-impl.h"
-
-libc_hidden_def (__wmemchr)
-weak_alias (__wmemchr, wmemchr)
-libc_hidden_weak (wmemchr)
diff --git a/sysdeps/x86_64/wmemcmp.S b/sysdeps/x86_64/wmemcmp.S
deleted file mode 100644
index 273e02606126..000000000000
--- a/sysdeps/x86_64/wmemcmp.S
+++ /dev/null
@@ -1,27 +0,0 @@
-/* wmemcmp hook for non-multiarch and RTLD build.
-   Copyright (C) 2022-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#define WMEMCMP	__wmemcmp
-
-#define DEFAULT_IMPL_V1	"multiarch/wmemcmp-sse2.S"
-#define DEFAULT_IMPL_V3	"multiarch/wmemcmp-avx2-movbe.S"
-#define DEFAULT_IMPL_V4	"multiarch/wmemcmp-evex-movbe.S"
-
-#include "isa-default-impl.h"
-
-weak_alias (__wmemcmp, wmemcmp)
diff --git a/sysdeps/x86_64/wmemset.S b/sysdeps/x86_64/wmemset.S
deleted file mode 100644
index f96d567fd876..000000000000
--- a/sysdeps/x86_64/wmemset.S
+++ /dev/null
@@ -1 +0,0 @@
-/* Implemented in memset.S.  */
diff --git a/sysdeps/x86_64/wordcopy.c b/sysdeps/x86_64/wordcopy.c
deleted file mode 100644
index 590b6cb16b8f..000000000000
--- a/sysdeps/x86_64/wordcopy.c
+++ /dev/null
@@ -1 +0,0 @@
-/* X86-64 doesn't use memory copy functions.  */
diff --git a/timezone/Makefile b/timezone/Makefile
index cf4ef3bf7e31..80e17e0f7247 100644
--- a/timezone/Makefile
+++ b/timezone/Makefile
@@ -68,7 +68,7 @@ tz-cflags = -DTZDIR='"$(zonedir)"' \
 	    -DTZDEFRULES='"$(posixrules-file)"' \
 	    -DTM_GMTOFF=tm_gmtoff -DTM_ZONE=tm_zone \
 	    -DHAVE_GETTEXT -DUSE_LTZ=0 -D_ISOMAC -DTZ_DOMAIN='"libc"' \
-	    -include $(common-objpfx)config.h -Wno-maybe-uninitialized
+	    -include $(common-objpfx)config.h
 
 # The -Wno-unused-variable flag is used to prevent GCC 6
 # from warning about time_t_min and time_t_max which are
diff --git a/wctype/bits/wctype-wchar.h b/wctype/bits/wctype-wchar.h
index 829fddab2d1b..f82643093b68 100644
--- a/wctype/bits/wctype-wchar.h
+++ b/wctype/bits/wctype-wchar.h
@@ -35,7 +35,8 @@
 
 /* Scalar type that can hold values which represent locale-specific
    character classifications.  */
-typedef unsigned long int wctype_t;
+struct __wctype_opaque_struct;
+typedef struct __wctype_opaque_struct *wctype_t;
 
 # ifndef _ISwbit
 /* The characteristics are stored always in network byte order (big
